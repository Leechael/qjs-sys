use ::libc;
use ::c2rust_bitfields;
extern "C" {
    pub type OPCodeEnum_0;
    fn strstart(
        str: *const libc::c_char,
        val: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
    fn dbuf_init2(
        s: *mut DynBuf,
        opaque: *mut libc::c_void,
        realloc_func: Option::<DynBufReallocFunc>,
    );
    fn dbuf_realloc(s: *mut DynBuf, new_size: size_t) -> libc::c_int;
    fn dbuf_put(s: *mut DynBuf, data: *const uint8_t, len: size_t) -> libc::c_int;
    fn dbuf_putc(s: *mut DynBuf, c: uint8_t) -> libc::c_int;
    fn dbuf_printf(s: *mut DynBuf, fmt: *const libc::c_char, _: ...) -> libc::c_int;
    fn dbuf_free(s: *mut DynBuf);
    fn unicode_to_utf8(buf: *mut uint8_t, c: libc::c_uint) -> libc::c_int;
    fn unicode_from_utf8(
        p: *const uint8_t,
        max_len: libc::c_int,
        pp: *mut *const uint8_t,
    ) -> libc::c_int;
    fn rqsort(
        base: *mut libc::c_void,
        nmemb: size_t,
        size: size_t,
        cmp: Option::<
            unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
    );
    fn lre_case_conv(
        res: *mut uint32_t,
        c: uint32_t,
        conv_type: libc::c_int,
    ) -> libc::c_int;
    fn lre_is_cased(c: uint32_t) -> libc::c_int;
    fn lre_is_case_ignorable(c: uint32_t) -> libc::c_int;
    fn lre_is_id_start(c: uint32_t) -> libc::c_int;
    fn lre_parse_escape(
        pp: *mut *const uint8_t,
        allow_utf16: libc::c_int,
    ) -> libc::c_int;
    fn lre_is_id_continue(c: uint32_t) -> libc::c_int;
    fn lre_compile(
        plen: *mut libc::c_int,
        error_msg: *mut libc::c_char,
        error_msg_size: libc::c_int,
        buf: *const libc::c_char,
        buf_len: size_t,
        re_flags: libc::c_int,
        opaque: *mut libc::c_void,
    ) -> *mut uint8_t;
    fn lre_get_flags(bc_buf: *const uint8_t) -> libc::c_int;
    fn lre_get_capture_count(bc_buf: *const uint8_t) -> libc::c_int;
    fn lre_exec(
        capture: *mut *mut uint8_t,
        bc_buf: *const uint8_t,
        cbuf: *const uint8_t,
        cindex: libc::c_int,
        clen: libc::c_int,
        cbuf_type: libc::c_int,
        opaque: *mut libc::c_void,
    ) -> libc::c_int;
    fn lre_get_groupnames(bc_buf: *const uint8_t) -> *const libc::c_char;
    fn unicode_normalize(
        pdst: *mut *mut uint32_t,
        src: *const uint32_t,
        src_len: libc::c_int,
        n_type: UnicodeNormalizationEnum,
        opaque: *mut libc::c_void,
        realloc_func: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                *mut libc::c_void,
                size_t,
            ) -> *mut libc::c_void,
        >,
    ) -> libc::c_int;
    fn lre_is_space(c: libc::c_int) -> libc::c_int;
    static lre_id_start_table_ascii: [uint32_t; 4];
    static lre_id_continue_table_ascii: [uint32_t; 4];
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn abort() -> !;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn alloca(_: libc::c_ulong) -> *mut libc::c_void;
    fn round(_: libc::c_double) -> libc::c_double;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: __builtin_va_list,
    ) -> libc::c_int;
    fn pow(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn trunc(_: libc::c_double) -> libc::c_double;
    fn lrint(_: libc::c_double) -> libc::c_long;
    fn floor(_: libc::c_double) -> libc::c_double;
    fn fabs(_: libc::c_double) -> libc::c_double;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fmod(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn fmin(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn fmax(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn hypot(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn ceil(_: libc::c_double) -> libc::c_double;
    fn sqrt(_: libc::c_double) -> libc::c_double;
    fn acos(_: libc::c_double) -> libc::c_double;
    fn asin(_: libc::c_double) -> libc::c_double;
    fn atan(_: libc::c_double) -> libc::c_double;
    fn atan2(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn cos(_: libc::c_double) -> libc::c_double;
    fn exp(_: libc::c_double) -> libc::c_double;
    fn log(_: libc::c_double) -> libc::c_double;
    fn sin(_: libc::c_double) -> libc::c_double;
    fn tan(_: libc::c_double) -> libc::c_double;
    fn cosh(_: libc::c_double) -> libc::c_double;
    fn sinh(_: libc::c_double) -> libc::c_double;
    fn tanh(_: libc::c_double) -> libc::c_double;
    fn acosh(_: libc::c_double) -> libc::c_double;
    fn asinh(_: libc::c_double) -> libc::c_double;
    fn atanh(_: libc::c_double) -> libc::c_double;
    fn expm1(_: libc::c_double) -> libc::c_double;
    fn log1p(_: libc::c_double) -> libc::c_double;
    fn log2(_: libc::c_double) -> libc::c_double;
    fn log10(_: libc::c_double) -> libc::c_double;
    fn cbrt(_: libc::c_double) -> libc::c_double;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
}
pub type __builtin_va_list = *mut libc::c_void;
pub type size_t = libc::c_ulong;
pub type va_list = __builtin_va_list;
pub type uintptr_t = libc::c_uint;
pub type intptr_t = libc::c_int;
pub type time_t = libc::c_longlong;
pub type suseconds_t = libc::c_longlong;
pub type int8_t = libc::c_schar;
pub type int16_t = libc::c_short;
pub type int32_t = libc::c_int;
pub type int64_t = libc::c_longlong;
pub type uint8_t = libc::c_uchar;
pub type uint16_t = libc::c_ushort;
pub type uint32_t = libc::c_uint;
pub type uint64_t = libc::c_ulonglong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
pub type BOOL = libc::c_int;
pub type C2RustUnnamed = libc::c_uint;
pub const TRUE: C2RustUnnamed = 1;
pub const FALSE: C2RustUnnamed = 0;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct packed_u64 {
    pub v: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct packed_u32 {
    pub v: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct packed_u16 {
    pub v: uint16_t,
}
pub type DynBufReallocFunc = unsafe extern "C" fn(
    *mut libc::c_void,
    *mut libc::c_void,
    size_t,
) -> *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DynBuf {
    pub buf: *mut uint8_t,
    pub size: size_t,
    pub allocated_size: size_t,
    pub error: BOOL,
    pub realloc_func: Option::<DynBufReallocFunc>,
    pub opaque: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct list_head {
    pub prev: *mut list_head,
    pub next: *mut list_head,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSRuntime {
    pub mf: JSMallocFunctions,
    pub malloc_state: JSMallocState,
    pub rt_info: *const libc::c_char,
    pub atom_hash_size: libc::c_int,
    pub atom_count: libc::c_int,
    pub atom_size: libc::c_int,
    pub atom_count_resize: libc::c_int,
    pub atom_hash: *mut uint32_t,
    pub atom_array: *mut *mut JSAtomStruct,
    pub atom_free_index: libc::c_int,
    pub class_count: libc::c_int,
    pub class_array: *mut JSClass,
    pub context_list: list_head,
    pub gc_obj_list: list_head,
    pub gc_zero_ref_count_list: list_head,
    pub tmp_obj_list: list_head,
    #[bitfield(name = "gc_phase", ty = "JSGCPhaseEnum", bits = "0..=7")]
    pub gc_phase: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub malloc_gc_threshold: size_t,
    pub stack_size: uintptr_t,
    pub stack_top: uintptr_t,
    pub stack_limit: uintptr_t,
    pub current_exception: JSValue,
    #[bitfield(name = "in_out_of_memory", ty = "BOOL", bits = "0..=7")]
    pub in_out_of_memory: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding_0: [u8; 3],
    pub current_stack_frame: *mut JSStackFrame,
    pub interrupt_handler: Option::<JSInterruptHandler>,
    pub interrupt_opaque: *mut libc::c_void,
    pub host_promise_rejection_tracker: Option::<JSHostPromiseRejectionTracker>,
    pub host_promise_rejection_tracker_opaque: *mut libc::c_void,
    pub job_list: list_head,
    pub module_normalize_func: Option::<JSModuleNormalizeFunc>,
    pub module_loader_func: Option::<JSModuleLoaderFunc>,
    pub module_loader_opaque: *mut libc::c_void,
    #[bitfield(name = "can_block", ty = "BOOL", bits = "0..=7")]
    pub can_block: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding_1: [u8; 3],
    pub sab_funcs: JSSharedArrayBufferFunctions,
    pub shape_hash_bits: libc::c_int,
    pub shape_hash_size: libc::c_int,
    pub shape_hash_count: libc::c_int,
    pub shape_hash: *mut *mut JSShape,
    pub user_opaque: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSShape {
    pub header: JSGCObjectHeader,
    pub is_hashed: uint8_t,
    pub has_small_array_index: uint8_t,
    pub hash: uint32_t,
    pub prop_hash_mask: uint32_t,
    pub prop_size: libc::c_int,
    pub prop_count: libc::c_int,
    pub deleted_prop_count: libc::c_int,
    pub shape_hash_next: *mut JSShape,
    pub proto: *mut JSObject,
    pub prop: [JSShapeProperty; 0],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSShapeProperty {
    #[bitfield(name = "hash_next", ty = "uint32_t", bits = "0..=25")]
    #[bitfield(name = "flags", ty = "uint32_t", bits = "26..=31")]
    pub hash_next_flags: [u8; 4],
    pub atom: JSAtom,
}
pub type JSAtom = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSObject {
    pub c2rust_unnamed: C2RustUnnamed_13,
    pub shape: *mut JSShape,
    pub prop: *mut JSProperty,
    pub first_weak_ref: *mut JSMapRecord,
    pub u: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub opaque: *mut libc::c_void,
    pub bound_function: *mut JSBoundFunction,
    pub c_function_data_record: *mut JSCFunctionDataRecord,
    pub for_in_iterator: *mut JSForInIterator,
    pub array_buffer: *mut JSArrayBuffer,
    pub typed_array: *mut JSTypedArray,
    pub map_state: *mut JSMapState,
    pub map_iterator_data: *mut JSMapIteratorData,
    pub array_iterator_data: *mut JSArrayIteratorData,
    pub regexp_string_iterator_data: *mut JSRegExpStringIteratorData,
    pub generator_data: *mut JSGeneratorData,
    pub proxy_data: *mut JSProxyData,
    pub promise_data: *mut JSPromiseData,
    pub promise_function_data: *mut JSPromiseFunctionData,
    pub async_function_data: *mut JSAsyncFunctionData,
    pub async_from_sync_iterator_data: *mut JSAsyncFromSyncIteratorData,
    pub async_generator_data: *mut JSAsyncGeneratorData,
    pub func: C2RustUnnamed_6,
    pub cfunc: C2RustUnnamed_5,
    pub array: C2RustUnnamed_2,
    pub regexp: JSRegExp,
    pub object_data: JSValue,
}
pub type JSValue = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSRegExp {
    pub pattern: *mut JSString,
    pub bytecode: *mut JSString,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSString {
    pub header: JSRefCountHeader,
    #[bitfield(name = "len", ty = "uint32_t", bits = "0..=30")]
    #[bitfield(name = "is_wide_char", ty = "uint8_t", bits = "31..=31")]
    #[bitfield(name = "hash", ty = "uint32_t", bits = "32..=61")]
    #[bitfield(name = "atom_type", ty = "uint8_t", bits = "62..=63")]
    pub len_is_wide_char_hash_atom_type: [u8; 8],
    pub hash_next: uint32_t,
    pub u: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub str8: [uint8_t; 0],
    pub str16: [uint16_t; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSRefCountHeader {
    pub ref_count: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub u1: C2RustUnnamed_4,
    pub u: C2RustUnnamed_3,
    pub count: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub values: *mut JSValue,
    pub ptr: *mut libc::c_void,
    pub int8_ptr: *mut int8_t,
    pub uint8_ptr: *mut uint8_t,
    pub int16_ptr: *mut int16_t,
    pub uint16_ptr: *mut uint16_t,
    pub int32_ptr: *mut int32_t,
    pub uint32_ptr: *mut uint32_t,
    pub int64_ptr: *mut int64_t,
    pub uint64_ptr: *mut uint64_t,
    pub float_ptr: *mut libc::c_float,
    pub double_ptr: *mut libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub size: uint32_t,
    pub typed_array: *mut JSTypedArray,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSTypedArray {
    pub link: list_head,
    pub obj: *mut JSObject,
    pub buffer: *mut JSObject,
    pub offset: uint32_t,
    pub length: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub realm: *mut JSContext,
    pub c_function: JSCFunctionType,
    pub length: uint8_t,
    pub cproto: uint8_t,
    pub magic: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union JSCFunctionType {
    pub generic: Option::<JSCFunction>,
    pub generic_magic: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            libc::c_int,
            *mut JSValue,
            libc::c_int,
        ) -> JSValue,
    >,
    pub constructor: Option::<JSCFunction>,
    pub constructor_magic: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            libc::c_int,
            *mut JSValue,
            libc::c_int,
        ) -> JSValue,
    >,
    pub constructor_or_func: Option::<JSCFunction>,
    pub f_f: Option::<unsafe extern "C" fn(libc::c_double) -> libc::c_double>,
    pub f_f_f: Option::<
        unsafe extern "C" fn(libc::c_double, libc::c_double) -> libc::c_double,
    >,
    pub getter: Option::<unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue>,
    pub setter: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSValue) -> JSValue,
    >,
    pub getter_magic: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, libc::c_int) -> JSValue,
    >,
    pub setter_magic: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSValue, libc::c_int) -> JSValue,
    >,
    pub iterator_next: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            libc::c_int,
            *mut JSValue,
            *mut libc::c_int,
            libc::c_int,
        ) -> JSValue,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSContext {
    pub header: JSGCObjectHeader,
    pub rt: *mut JSRuntime,
    pub link: list_head,
    pub binary_object_count: uint16_t,
    pub binary_object_size: libc::c_int,
    pub array_shape: *mut JSShape,
    pub class_proto: *mut JSValue,
    pub function_proto: JSValue,
    pub function_ctor: JSValue,
    pub array_ctor: JSValue,
    pub regexp_ctor: JSValue,
    pub promise_ctor: JSValue,
    pub native_error_proto: [JSValue; 8],
    pub iterator_proto: JSValue,
    pub async_iterator_proto: JSValue,
    pub array_proto_values: JSValue,
    pub throw_type_error: JSValue,
    pub eval_obj: JSValue,
    pub global_obj: JSValue,
    pub global_var_obj: JSValue,
    pub random_state: uint64_t,
    pub interrupt_counter: libc::c_int,
    pub is_error_property_enabled: BOOL,
    pub loaded_modules: list_head,
    pub compile_regexp: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSValue) -> JSValue,
    >,
    pub eval_internal: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            *const libc::c_char,
            size_t,
            *const libc::c_char,
            libc::c_int,
            libc::c_int,
        ) -> JSValue,
    >,
    pub user_opaque: *mut libc::c_void,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSGCObjectHeader {
    pub ref_count: libc::c_int,
    #[bitfield(name = "gc_obj_type", ty = "JSGCObjectTypeEnum", bits = "0..=3")]
    #[bitfield(name = "mark", ty = "uint8_t", bits = "4..=7")]
    pub gc_obj_type_mark: [u8; 1],
    pub dummy1: uint8_t,
    pub dummy2: uint16_t,
    pub link: list_head,
}
pub type JSGCObjectTypeEnum = libc::c_uint;
pub const JS_GC_OBJ_TYPE_JS_CONTEXT: JSGCObjectTypeEnum = 5;
pub const JS_GC_OBJ_TYPE_ASYNC_FUNCTION: JSGCObjectTypeEnum = 4;
pub const JS_GC_OBJ_TYPE_VAR_REF: JSGCObjectTypeEnum = 3;
pub const JS_GC_OBJ_TYPE_SHAPE: JSGCObjectTypeEnum = 2;
pub const JS_GC_OBJ_TYPE_FUNCTION_BYTECODE: JSGCObjectTypeEnum = 1;
pub const JS_GC_OBJ_TYPE_JS_OBJECT: JSGCObjectTypeEnum = 0;
pub type JSCFunction = unsafe extern "C" fn(
    *mut JSContext,
    JSValue,
    libc::c_int,
    *mut JSValue,
) -> JSValue;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub function_bytecode: *mut JSFunctionBytecode,
    pub var_refs: *mut *mut JSVarRef,
    pub home_object: *mut JSObject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSVarRef {
    pub c2rust_unnamed: C2RustUnnamed_7,
    pub pvalue: *mut JSValue,
    pub value: JSValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub header: JSGCObjectHeader,
    pub c2rust_unnamed: C2RustUnnamed_8,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub __gc_ref_count: libc::c_int,
    pub __gc_mark: uint8_t,
    #[bitfield(name = "is_detached", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "is_arg", ty = "uint8_t", bits = "1..=1")]
    pub is_detached_is_arg: [u8; 1],
    pub var_idx: uint16_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSFunctionBytecode {
    pub header: JSGCObjectHeader,
    pub js_mode: uint8_t,
    #[bitfield(name = "has_prototype", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "has_simple_parameter_list", ty = "uint8_t", bits = "1..=1")]
    #[bitfield(name = "is_derived_class_constructor", ty = "uint8_t", bits = "2..=2")]
    #[bitfield(name = "need_home_object", ty = "uint8_t", bits = "3..=3")]
    #[bitfield(name = "func_kind", ty = "uint8_t", bits = "4..=5")]
    #[bitfield(name = "new_target_allowed", ty = "uint8_t", bits = "6..=6")]
    #[bitfield(name = "super_call_allowed", ty = "uint8_t", bits = "7..=7")]
    #[bitfield(name = "super_allowed", ty = "uint8_t", bits = "8..=8")]
    #[bitfield(name = "arguments_allowed", ty = "uint8_t", bits = "9..=9")]
    #[bitfield(name = "has_debug", ty = "uint8_t", bits = "10..=10")]
    #[bitfield(name = "backtrace_barrier", ty = "uint8_t", bits = "11..=11")]
    #[bitfield(name = "read_only_bytecode", ty = "uint8_t", bits = "12..=12")]
    pub has_prototype_has_simple_parameter_list_is_derived_class_constructor_need_home_object_func_kind_new_target_allowed_super_call_allowed_super_allowed_arguments_allowed_has_debug_backtrace_barrier_read_only_bytecode: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub byte_code_buf: *mut uint8_t,
    pub byte_code_len: libc::c_int,
    pub func_name: JSAtom,
    pub vardefs: *mut JSVarDef,
    pub closure_var: *mut JSClosureVar,
    pub arg_count: uint16_t,
    pub var_count: uint16_t,
    pub defined_arg_count: uint16_t,
    pub stack_size: uint16_t,
    pub realm: *mut JSContext,
    pub cpool: *mut JSValue,
    pub cpool_count: libc::c_int,
    pub closure_var_count: libc::c_int,
    pub debug: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub filename: JSAtom,
    pub line_num: libc::c_int,
    pub source_len: libc::c_int,
    pub pc2line_len: libc::c_int,
    pub pc2line_buf: *mut uint8_t,
    pub source: *mut libc::c_char,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSClosureVar {
    #[bitfield(name = "is_local", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "is_arg", ty = "uint8_t", bits = "1..=1")]
    #[bitfield(name = "is_const", ty = "uint8_t", bits = "2..=2")]
    #[bitfield(name = "is_lexical", ty = "uint8_t", bits = "3..=3")]
    #[bitfield(name = "var_kind", ty = "uint8_t", bits = "4..=7")]
    pub is_local_is_arg_is_const_is_lexical_var_kind: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub var_idx: uint16_t,
    pub var_name: JSAtom,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSVarDef {
    pub var_name: JSAtom,
    pub scope_level: libc::c_int,
    pub scope_next: libc::c_int,
    #[bitfield(name = "is_const", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "is_lexical", ty = "uint8_t", bits = "1..=1")]
    #[bitfield(name = "is_captured", ty = "uint8_t", bits = "2..=2")]
    #[bitfield(name = "var_kind", ty = "uint8_t", bits = "3..=6")]
    #[bitfield(name = "func_pool_idx", ty = "libc::c_int", bits = "7..=30")]
    pub is_const_is_lexical_is_captured_var_kind_func_pool_idx: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSAsyncGeneratorData {
    pub generator: *mut JSObject,
    pub state: JSAsyncGeneratorStateEnum,
    pub func_state: JSAsyncFunctionState,
    pub queue: list_head,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSAsyncFunctionState {
    pub this_val: JSValue,
    pub argc: libc::c_int,
    pub throw_flag: BOOL,
    pub frame: JSStackFrame,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSStackFrame {
    pub prev_frame: *mut JSStackFrame,
    pub cur_func: JSValue,
    pub arg_buf: *mut JSValue,
    pub var_buf: *mut JSValue,
    pub var_ref_list: list_head,
    pub cur_pc: *const uint8_t,
    pub arg_count: libc::c_int,
    pub js_mode: libc::c_int,
    pub cur_sp: *mut JSValue,
}
pub type JSAsyncGeneratorStateEnum = libc::c_uint;
pub const JS_ASYNC_GENERATOR_STATE_COMPLETED: JSAsyncGeneratorStateEnum = 5;
pub const JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN: JSAsyncGeneratorStateEnum = 4;
pub const JS_ASYNC_GENERATOR_STATE_EXECUTING: JSAsyncGeneratorStateEnum = 3;
pub const JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR: JSAsyncGeneratorStateEnum = 2;
pub const JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD: JSAsyncGeneratorStateEnum = 1;
pub const JS_ASYNC_GENERATOR_STATE_SUSPENDED_START: JSAsyncGeneratorStateEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSAsyncFromSyncIteratorData {
    pub sync_iter: JSValue,
    pub next_method: JSValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSAsyncFunctionData {
    pub header: JSGCObjectHeader,
    pub resolving_funcs: [JSValue; 2],
    pub is_active: BOOL,
    pub func_state: JSAsyncFunctionState,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPromiseFunctionData {
    pub promise: JSValue,
    pub presolved: *mut JSPromiseFunctionDataResolved,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPromiseFunctionDataResolved {
    pub ref_count: libc::c_int,
    pub already_resolved: BOOL,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPromiseData {
    pub promise_state: JSPromiseStateEnum,
    pub promise_reactions: [list_head; 2],
    pub is_handled: BOOL,
    pub promise_result: JSValue,
}
pub type JSPromiseStateEnum = libc::c_uint;
pub const JS_PROMISE_REJECTED: JSPromiseStateEnum = 2;
pub const JS_PROMISE_FULFILLED: JSPromiseStateEnum = 1;
pub const JS_PROMISE_PENDING: JSPromiseStateEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSProxyData {
    pub target: JSValue,
    pub handler: JSValue,
    pub is_func: uint8_t,
    pub is_revoked: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSGeneratorData {
    pub state: JSGeneratorStateEnum,
    pub func_state: JSAsyncFunctionState,
}
pub type JSGeneratorStateEnum = libc::c_uint;
pub const JS_GENERATOR_STATE_COMPLETED: JSGeneratorStateEnum = 4;
pub const JS_GENERATOR_STATE_EXECUTING: JSGeneratorStateEnum = 3;
pub const JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR: JSGeneratorStateEnum = 2;
pub const JS_GENERATOR_STATE_SUSPENDED_YIELD: JSGeneratorStateEnum = 1;
pub const JS_GENERATOR_STATE_SUSPENDED_START: JSGeneratorStateEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSRegExpStringIteratorData {
    pub iterating_regexp: JSValue,
    pub iterated_string: JSValue,
    pub global: BOOL,
    pub unicode: BOOL,
    pub done: BOOL,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSArrayIteratorData {
    pub obj: JSValue,
    pub kind: JSIteratorKindEnum,
    pub idx: uint32_t,
}
pub type JSIteratorKindEnum = libc::c_uint;
pub const JS_ITERATOR_KIND_KEY_AND_VALUE: JSIteratorKindEnum = 2;
pub const JS_ITERATOR_KIND_VALUE: JSIteratorKindEnum = 1;
pub const JS_ITERATOR_KIND_KEY: JSIteratorKindEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMapIteratorData {
    pub obj: JSValue,
    pub kind: JSIteratorKindEnum,
    pub cur_record: *mut JSMapRecord,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMapRecord {
    pub ref_count: libc::c_int,
    pub empty: BOOL,
    pub map: *mut JSMapState,
    pub next_weak_ref: *mut JSMapRecord,
    pub link: list_head,
    pub hash_link: list_head,
    pub key: JSValue,
    pub value: JSValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMapState {
    pub is_weak: BOOL,
    pub records: list_head,
    pub record_count: uint32_t,
    pub hash_table: *mut list_head,
    pub hash_size: uint32_t,
    pub record_count_threshold: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSArrayBuffer {
    pub byte_length: libc::c_int,
    pub detached: uint8_t,
    pub shared: uint8_t,
    pub data: *mut uint8_t,
    pub array_list: list_head,
    pub opaque: *mut libc::c_void,
    pub free_func: Option::<JSFreeArrayBufferDataFunc>,
}
pub type JSFreeArrayBufferDataFunc = unsafe extern "C" fn(
    *mut JSRuntime,
    *mut libc::c_void,
    *mut libc::c_void,
) -> ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSForInIterator {
    pub obj: JSValue,
    pub is_array: BOOL,
    pub array_length: uint32_t,
    pub idx: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSCFunctionDataRecord {
    pub func: Option::<JSCFunctionData>,
    pub length: uint8_t,
    pub data_len: uint8_t,
    pub magic: uint16_t,
    pub data: [JSValue; 0],
}
pub type JSCFunctionData = unsafe extern "C" fn(
    *mut JSContext,
    JSValue,
    libc::c_int,
    *mut JSValue,
    libc::c_int,
    *mut JSValue,
) -> JSValue;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSBoundFunction {
    pub func_obj: JSValue,
    pub this_val: JSValue,
    pub argc: libc::c_int,
    pub argv: [JSValue; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSProperty {
    pub u: C2RustUnnamed_10,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub value: JSValue,
    pub getset: C2RustUnnamed_12,
    pub var_ref: *mut JSVarRef,
    pub init: C2RustUnnamed_11,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub realm_and_id: uintptr_t,
    pub opaque: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub getter: *mut JSObject,
    pub setter: *mut JSObject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub header: JSGCObjectHeader,
    pub c2rust_unnamed: C2RustUnnamed_14,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub __gc_ref_count: libc::c_int,
    pub __gc_mark: uint8_t,
    #[bitfield(name = "extensible", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "free_mark", ty = "uint8_t", bits = "1..=1")]
    #[bitfield(name = "is_exotic", ty = "uint8_t", bits = "2..=2")]
    #[bitfield(name = "fast_array", ty = "uint8_t", bits = "3..=3")]
    #[bitfield(name = "is_constructor", ty = "uint8_t", bits = "4..=4")]
    #[bitfield(name = "is_uncatchable_error", ty = "uint8_t", bits = "5..=5")]
    #[bitfield(name = "tmp_mark", ty = "uint8_t", bits = "6..=6")]
    #[bitfield(name = "is_HTMLDDA", ty = "uint8_t", bits = "7..=7")]
    pub extensible_free_mark_is_exotic_fast_array_is_constructor_is_uncatchable_error_tmp_mark_is_HTMLDDA: [u8; 1],
    pub class_id: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSSharedArrayBufferFunctions {
    pub sab_alloc: Option::<
        unsafe extern "C" fn(*mut libc::c_void, size_t) -> *mut libc::c_void,
    >,
    pub sab_free: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
    >,
    pub sab_dup: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
    >,
    pub sab_opaque: *mut libc::c_void,
}
pub type JSModuleLoaderFunc = unsafe extern "C" fn(
    *mut JSContext,
    *const libc::c_char,
    *mut libc::c_void,
) -> *mut JSModuleDef;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSModuleDef {
    pub header: JSRefCountHeader,
    pub module_name: JSAtom,
    pub link: list_head,
    pub req_module_entries: *mut JSReqModuleEntry,
    pub req_module_entries_count: libc::c_int,
    pub req_module_entries_size: libc::c_int,
    pub export_entries: *mut JSExportEntry,
    pub export_entries_count: libc::c_int,
    pub export_entries_size: libc::c_int,
    pub star_export_entries: *mut JSStarExportEntry,
    pub star_export_entries_count: libc::c_int,
    pub star_export_entries_size: libc::c_int,
    pub import_entries: *mut JSImportEntry,
    pub import_entries_count: libc::c_int,
    pub import_entries_size: libc::c_int,
    pub module_ns: JSValue,
    pub func_obj: JSValue,
    pub init_func: Option::<JSModuleInitFunc>,
    #[bitfield(name = "resolved", ty = "BOOL", bits = "0..=7")]
    #[bitfield(name = "func_created", ty = "BOOL", bits = "8..=15")]
    #[bitfield(name = "instantiated", ty = "BOOL", bits = "16..=23")]
    #[bitfield(name = "evaluated", ty = "BOOL", bits = "24..=31")]
    #[bitfield(name = "eval_mark", ty = "BOOL", bits = "32..=39")]
    #[bitfield(name = "eval_has_exception", ty = "BOOL", bits = "40..=47")]
    pub resolved_func_created_instantiated_evaluated_eval_mark_eval_has_exception: [u8; 6],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 6],
    pub eval_exception: JSValue,
    pub meta_obj: JSValue,
}
pub type JSModuleInitFunc = unsafe extern "C" fn(
    *mut JSContext,
    *mut JSModuleDef,
) -> libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSImportEntry {
    pub var_idx: libc::c_int,
    pub import_name: JSAtom,
    pub req_module_idx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSStarExportEntry {
    pub req_module_idx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSExportEntry {
    pub u: C2RustUnnamed_15,
    pub export_type: JSExportTypeEnum,
    pub local_name: JSAtom,
    pub export_name: JSAtom,
}
pub type JSExportTypeEnum = libc::c_uint;
pub const JS_EXPORT_TYPE_INDIRECT: JSExportTypeEnum = 1;
pub const JS_EXPORT_TYPE_LOCAL: JSExportTypeEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub local: C2RustUnnamed_16,
    pub req_module_idx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub var_idx: libc::c_int,
    pub var_ref: *mut JSVarRef,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSReqModuleEntry {
    pub module_name: JSAtom,
    pub module: *mut JSModuleDef,
}
pub type JSModuleNormalizeFunc = unsafe extern "C" fn(
    *mut JSContext,
    *const libc::c_char,
    *const libc::c_char,
    *mut libc::c_void,
) -> *mut libc::c_char;
pub type JSHostPromiseRejectionTracker = unsafe extern "C" fn(
    *mut JSContext,
    JSValue,
    JSValue,
    libc::c_int,
    *mut libc::c_void,
) -> ();
pub type JSInterruptHandler = unsafe extern "C" fn(
    *mut JSRuntime,
    *mut libc::c_void,
) -> libc::c_int;
pub type JSGCPhaseEnum = libc::c_uint;
pub const JS_GC_PHASE_REMOVE_CYCLES: JSGCPhaseEnum = 2;
pub const JS_GC_PHASE_DECREF: JSGCPhaseEnum = 1;
pub const JS_GC_PHASE_NONE: JSGCPhaseEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSClass {
    pub class_id: uint32_t,
    pub class_name: JSAtom,
    pub finalizer: Option::<JSClassFinalizer>,
    pub gc_mark: Option::<JSClassGCMark>,
    pub call: Option::<JSClassCall>,
    pub exotic: *const JSClassExoticMethods,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSClassExoticMethods {
    pub get_own_property: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            *mut JSPropertyDescriptor,
            JSValue,
            JSAtom,
        ) -> libc::c_int,
    >,
    pub get_own_property_names: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            *mut *mut JSPropertyEnum,
            *mut uint32_t,
            JSValue,
        ) -> libc::c_int,
    >,
    pub delete_property: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSAtom) -> libc::c_int,
    >,
    pub define_own_property: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            JSAtom,
            JSValue,
            JSValue,
            JSValue,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub has_property: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSAtom) -> libc::c_int,
    >,
    pub get_property: Option::<
        unsafe extern "C" fn(*mut JSContext, JSValue, JSAtom, JSValue) -> JSValue,
    >,
    pub set_property: Option::<
        unsafe extern "C" fn(
            *mut JSContext,
            JSValue,
            JSAtom,
            JSValue,
            JSValue,
            libc::c_int,
        ) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPropertyEnum {
    pub is_enumerable: libc::c_int,
    pub atom: JSAtom,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPropertyDescriptor {
    pub flags: libc::c_int,
    pub value: JSValue,
    pub getter: JSValue,
    pub setter: JSValue,
}
pub type JSClassCall = unsafe extern "C" fn(
    *mut JSContext,
    JSValue,
    JSValue,
    libc::c_int,
    *mut JSValue,
    libc::c_int,
) -> JSValue;
pub type JSClassGCMark = unsafe extern "C" fn(
    *mut JSRuntime,
    JSValue,
    Option::<JS_MarkFunc>,
) -> ();
pub type JS_MarkFunc = unsafe extern "C" fn(*mut JSRuntime, *mut JSGCObjectHeader) -> ();
pub type JSClassFinalizer = unsafe extern "C" fn(*mut JSRuntime, JSValue) -> ();
pub type JSAtomStruct = JSString;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMallocState {
    pub malloc_count: size_t,
    pub malloc_size: size_t,
    pub malloc_limit: size_t,
    pub opaque: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMallocFunctions {
    pub js_malloc: Option::<
        unsafe extern "C" fn(*mut JSMallocState, size_t) -> *mut libc::c_void,
    >,
    pub js_free: Option::<
        unsafe extern "C" fn(*mut JSMallocState, *mut libc::c_void) -> (),
    >,
    pub js_realloc: Option::<
        unsafe extern "C" fn(
            *mut JSMallocState,
            *mut libc::c_void,
            size_t,
        ) -> *mut libc::c_void,
    >,
    pub js_malloc_usable_size: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> size_t,
    >,
}
pub type JSClassID = uint32_t;
pub type C2RustUnnamed_17 = libc::c_int;
pub const JS_TAG_FLOAT64: C2RustUnnamed_17 = 7;
pub const JS_TAG_EXCEPTION: C2RustUnnamed_17 = 6;
pub const JS_TAG_CATCH_OFFSET: C2RustUnnamed_17 = 5;
pub const JS_TAG_UNINITIALIZED: C2RustUnnamed_17 = 4;
pub const JS_TAG_UNDEFINED: C2RustUnnamed_17 = 3;
pub const JS_TAG_NULL: C2RustUnnamed_17 = 2;
pub const JS_TAG_BOOL: C2RustUnnamed_17 = 1;
pub const JS_TAG_INT: C2RustUnnamed_17 = 0;
pub const JS_TAG_OBJECT: C2RustUnnamed_17 = -1;
pub const JS_TAG_FUNCTION_BYTECODE: C2RustUnnamed_17 = -2;
pub const JS_TAG_MODULE: C2RustUnnamed_17 = -3;
pub const JS_TAG_STRING: C2RustUnnamed_17 = -7;
pub const JS_TAG_SYMBOL: C2RustUnnamed_17 = -8;
pub const JS_TAG_BIG_FLOAT: C2RustUnnamed_17 = -9;
pub const JS_TAG_BIG_INT: C2RustUnnamed_17 = -10;
pub const JS_TAG_BIG_DECIMAL: C2RustUnnamed_17 = -11;
pub const JS_TAG_FIRST: C2RustUnnamed_17 = -11;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub v: JSValue,
    pub d: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
    pub d: libc::c_double,
    pub u64_0: uint64_t,
}
pub type JSCFunctionMagic = unsafe extern "C" fn(
    *mut JSContext,
    JSValue,
    libc::c_int,
    *mut JSValue,
    libc::c_int,
) -> JSValue;
pub const JS_ATOM_TYPE_SYMBOL: C2RustUnnamed_38 = 3;
pub const JS_ATOM_END: C2RustUnnamed_40 = 207;
pub const JS_NATIVE_ERROR_COUNT: JSErrorEnum = 8;
pub type JSFreeModuleEnum = libc::c_uint;
pub const JS_FREE_MODULE_NOT_EVALUATED: JSFreeModuleEnum = 2;
pub const JS_FREE_MODULE_NOT_RESOLVED: JSFreeModuleEnum = 1;
pub const JS_FREE_MODULE_ALL: JSFreeModuleEnum = 0;
pub const OP_FMT_atom_label_u16: OPCodeFormat = 27;
pub const OP_FMT_atom_label_u8: OPCodeFormat = 26;
pub const OP_FMT_atom_u16: OPCodeFormat = 25;
pub const OP_FMT_atom_u8: OPCodeFormat = 24;
pub const OP_FMT_atom: OPCodeFormat = 23;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSOpCode {
    pub size: uint8_t,
    pub n_pop: uint8_t,
    pub n_push: uint8_t,
    pub fmt: uint8_t,
}
pub const OP_FMT_none: OPCodeFormat = 0;
pub const OP_FMT_npopx: OPCodeFormat = 14;
pub const OP_FMT_label16: OPCodeFormat = 12;
pub const OP_FMT_label8: OPCodeFormat = 9;
pub const OP_FMT_none_var_ref: OPCodeFormat = 4;
pub const OP_FMT_none_arg: OPCodeFormat = 3;
pub const OP_FMT_none_loc: OPCodeFormat = 2;
pub const OP_FMT_loc8: OPCodeFormat = 7;
pub const OP_FMT_const8: OPCodeFormat = 8;
pub const OP_FMT_i16: OPCodeFormat = 11;
pub const OP_FMT_i8: OPCodeFormat = 6;
pub const OP_FMT_none_int: OPCodeFormat = 1;
pub const OP_FMT_u32: OPCodeFormat = 19;
pub const OP_FMT_label: OPCodeFormat = 22;
pub const OP_FMT_u16: OPCodeFormat = 10;
pub const OP_FMT_u8: OPCodeFormat = 5;
pub const OP_FMT_loc: OPCodeFormat = 16;
pub const OP_FMT_var_ref: OPCodeFormat = 18;
pub const OP_FMT_arg: OPCodeFormat = 17;
pub const OP_FMT_npop_u16: OPCodeFormat = 15;
pub const OP_FMT_npop: OPCodeFormat = 13;
pub const OP_FMT_const: OPCodeFormat = 21;
pub const OP_FMT_i32: OPCodeFormat = 20;
pub const OP_TEMP_START: OPCodeEnum_0 = 178;
pub const OP_TEMP_END: OPCodeEnum_0 = 193;
pub const JS_CLASS_OBJECT: C2RustUnnamed_37 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSJobEntry {
    pub link: list_head,
    pub ctx: *mut JSContext,
    pub job_func: Option::<JSJobFunc>,
    pub argc: libc::c_int,
    pub argv: [JSValue; 0],
}
pub type JSJobFunc = unsafe extern "C" fn(
    *mut JSContext,
    libc::c_int,
    *mut JSValue,
) -> JSValue;
pub const JS_CLASS_GENERATOR: C2RustUnnamed_37 = 40;
pub const JS_CLASS_REGEXP: C2RustUnnamed_37 = 18;
pub const JS_CLASS_DATE: C2RustUnnamed_37 = 10;
pub const JS_CLASS_SYMBOL: C2RustUnnamed_37 = 7;
pub const JS_CLASS_BOOLEAN: C2RustUnnamed_37 = 6;
pub const JS_CLASS_STRING: C2RustUnnamed_37 = 5;
pub const JS_CLASS_NUMBER: C2RustUnnamed_37 = 4;
pub const JS_CLASS_DATAVIEW: C2RustUnnamed_37 = 30;
pub const JS_CLASS_FLOAT64_ARRAY: C2RustUnnamed_37 = 29;
pub const JS_CLASS_FLOAT32_ARRAY: C2RustUnnamed_37 = 28;
pub const JS_CLASS_UINT32_ARRAY: C2RustUnnamed_37 = 27;
pub const JS_CLASS_INT32_ARRAY: C2RustUnnamed_37 = 26;
pub const JS_CLASS_UINT16_ARRAY: C2RustUnnamed_37 = 25;
pub const JS_CLASS_INT16_ARRAY: C2RustUnnamed_37 = 24;
pub const JS_CLASS_UINT8_ARRAY: C2RustUnnamed_37 = 23;
pub const JS_CLASS_INT8_ARRAY: C2RustUnnamed_37 = 22;
pub const JS_CLASS_UINT8C_ARRAY: C2RustUnnamed_37 = 21;
pub const JS_CLASS_ARGUMENTS: C2RustUnnamed_37 = 8;
pub const JS_CLASS_C_FUNCTION: C2RustUnnamed_37 = 12;
pub const JS_ATOM_length: C2RustUnnamed_40 = 48;
pub type JSErrorEnum = libc::c_uint;
pub const JS_AGGREGATE_ERROR: JSErrorEnum = 7;
pub const JS_INTERNAL_ERROR: JSErrorEnum = 6;
pub const JS_URI_ERROR: JSErrorEnum = 5;
pub const JS_TYPE_ERROR: JSErrorEnum = 4;
pub const JS_SYNTAX_ERROR: JSErrorEnum = 3;
pub const JS_REFERENCE_ERROR: JSErrorEnum = 2;
pub const JS_RANGE_ERROR: JSErrorEnum = 1;
pub const JS_EVAL_ERROR: JSErrorEnum = 0;
pub const JS_ATOM_stack: C2RustUnnamed_40 = 53;
pub const JS_CLASS_PROXY: C2RustUnnamed_37 = 41;
pub const JS_CLASS_BYTECODE_FUNCTION: C2RustUnnamed_37 = 13;
pub const JS_FUNC_NORMAL: JSFunctionKindEnum = 0;
pub const JS_CLASS_ERROR: C2RustUnnamed_37 = 3;
pub const OP_invalid: OPCodeEnum_0 = 0;
pub const JS_ATOM_function: C2RustUnnamed_40 = 27;
pub const JS_ATOM_unknown: C2RustUnnamed_40 = 76;
pub const JS_ATOM_symbol: C2RustUnnamed_40 = 74;
pub const JS_ATOM_object: C2RustUnnamed_40 = 73;
pub const JS_ATOM_undefined: C2RustUnnamed_40 = 69;
pub const JS_ATOM_string: C2RustUnnamed_40 = 72;
pub const JS_ATOM_boolean: C2RustUnnamed_40 = 71;
pub const JS_ATOM_number: C2RustUnnamed_40 = 70;
pub const OP_typeof_is_function: OPCodeEnum_0 = 243;
pub const OP_typeof_is_undefined: OPCodeEnum_0 = 242;
pub const OP_is_null: OPCodeEnum_0 = 241;
pub const OP_is_undefined: OPCodeEnum_0 = 240;
pub const OP_is_undefined_or_null: OPCodeEnum_0 = 176;
pub const OP_nop: OPCodeEnum_0 = 177;
pub const OP_initial_yield: OPCodeEnum_0 = 135;
pub const OP_return_async: OPCodeEnum_0 = 46;
pub const OP_async_yield_star: OPCodeEnum_0 = 138;
pub const OP_yield_star: OPCodeEnum_0 = 137;
pub const OP_yield: OPCodeEnum_0 = 136;
pub const OP_await: OPCodeEnum_0 = 139;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct StringBuffer {
    pub ctx: *mut JSContext,
    pub str_0: *mut JSString,
    pub len: libc::c_int,
    pub size: libc::c_int,
    pub is_wide_char: libc::c_int,
    pub error_status: libc::c_int,
}
pub const JS_ATOM_empty_string: C2RustUnnamed_40 = 47;
pub const JS_ATOM_TYPE_STRING: C2RustUnnamed_38 = 1;
pub const JS_ATOM_valueOf: C2RustUnnamed_40 = 57;
pub const JS_ATOM_toString: C2RustUnnamed_40 = 55;
pub const JS_ATOM_default: C2RustUnnamed_40 = 22;
pub const JS_ATOM_Symbol_toPrimitive: C2RustUnnamed_40 = 194;
pub const JS_ATOM_null: C2RustUnnamed_40 = 1;
pub const JS_ATOM_false: C2RustUnnamed_40 = 2;
pub const JS_ATOM_true: C2RustUnnamed_40 = 3;
pub type JSToNumberHintEnum = libc::c_uint;
pub const TON_FLAG_NUMERIC: JSToNumberHintEnum = 1;
pub const TON_FLAG_NUMBER: JSToNumberHintEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_20 {
    pub d: libc::c_double,
    pub u: uint64_t,
}
pub const JS_ATOM_HASH_PRIVATE: C2RustUnnamed_39 = 1;
pub const JS_ATOM_HASH_SYMBOL: C2RustUnnamed_39 = 0;
pub const JS_CLASS_ARRAY: C2RustUnnamed_37 = 2;
pub type JSAutoInitFunc = unsafe extern "C" fn(
    *mut JSContext,
    *mut JSObject,
    JSAtom,
    *mut libc::c_void,
) -> JSValue;
pub type JSAutoInitIDEnum = libc::c_uint;
pub const JS_AUTOINIT_ID_PROP: JSAutoInitIDEnum = 2;
pub const JS_AUTOINIT_ID_MODULE_NS: JSAutoInitIDEnum = 1;
pub const JS_AUTOINIT_ID_PROTOTYPE: JSAutoInitIDEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub tab: *const JSCFunctionListEntry,
    pub len: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSCFunctionListEntry {
    pub name: *const libc::c_char,
    pub prop_flags: uint8_t,
    pub def_type: uint8_t,
    pub magic: int16_t,
    pub u: C2RustUnnamed_22,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub func: C2RustUnnamed_25,
    pub getset: C2RustUnnamed_24,
    pub alias: C2RustUnnamed_23,
    pub prop_list: C2RustUnnamed_21,
    pub str_0: *const libc::c_char,
    pub i32_0: int32_t,
    pub i64_0: int64_t,
    pub f64_0: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub name: *const libc::c_char,
    pub base: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub get: JSCFunctionType,
    pub set: JSCFunctionType,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_25 {
    pub length: uint8_t,
    pub cproto: uint8_t,
    pub cfunc: JSCFunctionType,
}
pub type JSCFunctionEnum = libc::c_uint;
pub const JS_CFUNC_iterator_next: JSCFunctionEnum = 12;
pub const JS_CFUNC_setter_magic: JSCFunctionEnum = 11;
pub const JS_CFUNC_getter_magic: JSCFunctionEnum = 10;
pub const JS_CFUNC_setter: JSCFunctionEnum = 9;
pub const JS_CFUNC_getter: JSCFunctionEnum = 8;
pub const JS_CFUNC_f_f_f: JSCFunctionEnum = 7;
pub const JS_CFUNC_f_f: JSCFunctionEnum = 6;
pub const JS_CFUNC_constructor_or_func_magic: JSCFunctionEnum = 5;
pub const JS_CFUNC_constructor_or_func: JSCFunctionEnum = 4;
pub const JS_CFUNC_constructor_magic: JSCFunctionEnum = 3;
pub const JS_CFUNC_constructor: JSCFunctionEnum = 2;
pub const JS_CFUNC_generic_magic: JSCFunctionEnum = 1;
pub const JS_CFUNC_generic: JSCFunctionEnum = 0;
pub const JS_ATOM_name: C2RustUnnamed_40 = 54;
pub const JS_ATOM_Symbol_hasInstance: C2RustUnnamed_40 = 203;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExportedNameEntry {
    pub export_name: JSAtom,
    pub export_type: ExportedNameEntryEnum,
    pub u: C2RustUnnamed_26,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_26 {
    pub me: *mut JSExportEntry,
    pub var_ref: *mut JSVarRef,
    pub module: *mut JSModuleDef,
}
pub type ExportedNameEntryEnum = libc::c_uint;
pub const EXPORTED_NAME_NS: ExportedNameEntryEnum = 2;
pub const EXPORTED_NAME_NORMAL: ExportedNameEntryEnum = 1;
pub const EXPORTED_NAME_AMBIGUOUS: ExportedNameEntryEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GetExportNamesState {
    pub modules: *mut *mut JSModuleDef,
    pub modules_size: libc::c_int,
    pub modules_count: libc::c_int,
    pub exported_names: *mut ExportedNameEntry,
    pub exported_names_size: libc::c_int,
    pub exported_names_count: libc::c_int,
}
pub const JS_ATOM_Module: C2RustUnnamed_40 = 126;
pub const JS_ATOM_Symbol_toStringTag: C2RustUnnamed_40 = 201;
pub const JS_ATOM__star_: C2RustUnnamed_40 = 125;
pub type JSResolveResultEnum = libc::c_int;
pub const JS_RESOLVE_RES_AMBIGUOUS: JSResolveResultEnum = 3;
pub const JS_RESOLVE_RES_CIRCULAR: JSResolveResultEnum = 2;
pub const JS_RESOLVE_RES_NOT_FOUND: JSResolveResultEnum = 1;
pub const JS_RESOLVE_RES_FOUND: JSResolveResultEnum = 0;
pub const JS_RESOLVE_RES_EXCEPTION: JSResolveResultEnum = -1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSResolveEntry {
    pub module: *mut JSModuleDef,
    pub name: JSAtom,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSResolveState {
    pub array: *mut JSResolveEntry,
    pub size: libc::c_int,
    pub count: libc::c_int,
}
pub const JS_CLASS_MODULE_NS: C2RustUnnamed_37 = 11;
pub const JS_ATOM_constructor: C2RustUnnamed_40 = 60;
pub const OP_with_get_ref_undef: OPCodeEnum_0 = 119;
pub const OP_with_get_ref: OPCodeEnum_0 = 118;
pub const OP_with_make_ref: OPCodeEnum_0 = 117;
pub const OP_with_delete_var: OPCodeEnum_0 = 116;
#[derive(Copy, Clone)]
#[repr(C)]
pub union JSFloat64Union {
    pub d: libc::c_double,
    pub u64_0: uint64_t,
    pub u32_0: [uint32_t; 2],
}
pub const OP_with_put_var: OPCodeEnum_0 = 115;
pub const OP_with_get_var: OPCodeEnum_0 = 114;
pub const JS_ATOM_Symbol_unscopables: C2RustUnnamed_40 = 205;
pub const OP_to_propkey2: OPCodeEnum_0 = 113;
pub const OP_to_propkey: OPCodeEnum_0 = 112;
pub const OP_to_object: OPCodeEnum_0 = 111;
pub const OP_delete_var: OPCodeEnum_0 = 153;
pub const OP_delete: OPCodeEnum_0 = 152;
pub const OP_typeof: OPCodeEnum_0 = 151;
pub const JS_ATOM_getPrototypeOf: C2RustUnnamed_40 = 95;
pub const JS_ATOM_prototype: C2RustUnnamed_40 = 59;
pub const JS_CLASS_BOUND_FUNCTION: C2RustUnnamed_37 = 14;
pub const OP_instanceof: OPCodeEnum_0 = 167;
pub const OP_in: OPCodeEnum_0 = 168;
pub type JSStrictEqModeEnum = libc::c_uint;
pub const JS_EQ_SAME_VALUE_ZERO: JSStrictEqModeEnum = 2;
pub const JS_EQ_SAME_VALUE: JSStrictEqModeEnum = 1;
pub const JS_EQ_STRICT: JSStrictEqModeEnum = 0;
pub const OP_strict_neq: OPCodeEnum_0 = 172;
pub const OP_strict_eq: OPCodeEnum_0 = 171;
pub const OP_neq: OPCodeEnum_0 = 170;
pub const OP_eq: OPCodeEnum_0 = 169;
pub type OPCodeEnum = libc::c_uint;
pub const OP_line_num: OPCodeEnum_0 = 192;
pub const OP_set_class_name: OPCodeEnum_0 = 191;
pub const OP_scope_put_private_field: OPCodeEnum_0 = 190;
pub const OP_scope_get_private_field2: OPCodeEnum_0 = 189;
pub const OP_scope_get_private_field: OPCodeEnum_0 = 188;
pub const OP_scope_put_var_init: OPCodeEnum_0 = 187;
pub const OP_scope_get_ref: OPCodeEnum_0 = 186;
pub const OP_scope_make_ref: OPCodeEnum_0 = 185;
pub const OP_scope_delete_var: OPCodeEnum_0 = 184;
pub const OP_scope_put_var: OPCodeEnum_0 = 183;
pub const OP_scope_get_var: OPCodeEnum_0 = 182;
pub const OP_scope_get_var_undef: OPCodeEnum_0 = 181;
pub const OP_label: OPCodeEnum_0 = 180;
pub const OP_leave_scope: OPCodeEnum_0 = 179;
pub const OP_enter_scope: OPCodeEnum_0 = 178;
pub const OP___dummy: OPCodeEnum_0 = 177;
pub const OP_COUNT: OPCodeEnum_0 = 244;
pub const OP_call3: OPCodeEnum_0 = 239;
pub const OP_call2: OPCodeEnum_0 = 238;
pub const OP_call1: OPCodeEnum_0 = 237;
pub const OP_call0: OPCodeEnum_0 = 236;
pub const OP_goto16: OPCodeEnum_0 = 235;
pub const OP_goto8: OPCodeEnum_0 = 234;
pub const OP_if_true8: OPCodeEnum_0 = 233;
pub const OP_if_false8: OPCodeEnum_0 = 232;
pub const OP_get_length: OPCodeEnum_0 = 231;
pub const OP_set_var_ref3: OPCodeEnum_0 = 230;
pub const OP_set_var_ref2: OPCodeEnum_0 = 229;
pub const OP_set_var_ref1: OPCodeEnum_0 = 228;
pub const OP_set_var_ref0: OPCodeEnum_0 = 227;
pub const OP_put_var_ref3: OPCodeEnum_0 = 226;
pub const OP_put_var_ref2: OPCodeEnum_0 = 225;
pub const OP_put_var_ref1: OPCodeEnum_0 = 224;
pub const OP_put_var_ref0: OPCodeEnum_0 = 223;
pub const OP_get_var_ref3: OPCodeEnum_0 = 222;
pub const OP_get_var_ref2: OPCodeEnum_0 = 221;
pub const OP_get_var_ref1: OPCodeEnum_0 = 220;
pub const OP_get_var_ref0: OPCodeEnum_0 = 219;
pub const OP_set_arg3: OPCodeEnum_0 = 218;
pub const OP_set_arg2: OPCodeEnum_0 = 217;
pub const OP_set_arg1: OPCodeEnum_0 = 216;
pub const OP_set_arg0: OPCodeEnum_0 = 215;
pub const OP_put_arg3: OPCodeEnum_0 = 214;
pub const OP_put_arg2: OPCodeEnum_0 = 213;
pub const OP_put_arg1: OPCodeEnum_0 = 212;
pub const OP_put_arg0: OPCodeEnum_0 = 211;
pub const OP_get_arg3: OPCodeEnum_0 = 210;
pub const OP_get_arg2: OPCodeEnum_0 = 209;
pub const OP_get_arg1: OPCodeEnum_0 = 208;
pub const OP_get_arg0: OPCodeEnum_0 = 207;
pub const OP_set_loc3: OPCodeEnum_0 = 206;
pub const OP_set_loc2: OPCodeEnum_0 = 205;
pub const OP_set_loc1: OPCodeEnum_0 = 204;
pub const OP_set_loc0: OPCodeEnum_0 = 203;
pub const OP_put_loc3: OPCodeEnum_0 = 202;
pub const OP_put_loc2: OPCodeEnum_0 = 201;
pub const OP_put_loc1: OPCodeEnum_0 = 200;
pub const OP_put_loc0: OPCodeEnum_0 = 199;
pub const OP_get_loc3: OPCodeEnum_0 = 198;
pub const OP_get_loc2: OPCodeEnum_0 = 197;
pub const OP_get_loc1: OPCodeEnum_0 = 196;
pub const OP_get_loc0: OPCodeEnum_0 = 195;
pub const OP_set_loc8: OPCodeEnum_0 = 194;
pub const OP_put_loc8: OPCodeEnum_0 = 193;
pub const OP_get_loc8: OPCodeEnum_0 = 192;
pub const OP_push_empty_string: OPCodeEnum_0 = 191;
pub const OP_fclosure8: OPCodeEnum_0 = 190;
pub const OP_push_const8: OPCodeEnum_0 = 189;
pub const OP_push_i16: OPCodeEnum_0 = 188;
pub const OP_push_i8: OPCodeEnum_0 = 187;
pub const OP_push_7: OPCodeEnum_0 = 186;
pub const OP_push_6: OPCodeEnum_0 = 185;
pub const OP_push_5: OPCodeEnum_0 = 184;
pub const OP_push_4: OPCodeEnum_0 = 183;
pub const OP_push_3: OPCodeEnum_0 = 182;
pub const OP_push_2: OPCodeEnum_0 = 181;
pub const OP_push_1: OPCodeEnum_0 = 180;
pub const OP_push_0: OPCodeEnum_0 = 179;
pub const OP_push_minus1: OPCodeEnum_0 = 178;
pub const OP_or: OPCodeEnum_0 = 175;
pub const OP_xor: OPCodeEnum_0 = 174;
pub const OP_and: OPCodeEnum_0 = 173;
pub const OP_gte: OPCodeEnum_0 = 166;
pub const OP_gt: OPCodeEnum_0 = 165;
pub const OP_lte: OPCodeEnum_0 = 164;
pub const OP_lt: OPCodeEnum_0 = 163;
pub const OP_shr: OPCodeEnum_0 = 162;
pub const OP_sar: OPCodeEnum_0 = 161;
pub const OP_shl: OPCodeEnum_0 = 160;
pub const OP_pow: OPCodeEnum_0 = 159;
pub const OP_sub: OPCodeEnum_0 = 158;
pub const OP_add: OPCodeEnum_0 = 157;
pub const OP_mod: OPCodeEnum_0 = 156;
pub const OP_div: OPCodeEnum_0 = 155;
pub const OP_mul: OPCodeEnum_0 = 154;
pub const OP_lnot: OPCodeEnum_0 = 150;
pub const OP_not: OPCodeEnum_0 = 149;
pub const OP_add_loc: OPCodeEnum_0 = 148;
pub const OP_inc_loc: OPCodeEnum_0 = 147;
pub const OP_dec_loc: OPCodeEnum_0 = 146;
pub const OP_post_inc: OPCodeEnum_0 = 145;
pub const OP_post_dec: OPCodeEnum_0 = 144;
pub const OP_inc: OPCodeEnum_0 = 143;
pub const OP_dec: OPCodeEnum_0 = 142;
pub const OP_plus: OPCodeEnum_0 = 141;
pub const OP_neg: OPCodeEnum_0 = 140;
pub const OP_iterator_call: OPCodeEnum_0 = 134;
pub const OP_iterator_next: OPCodeEnum_0 = 133;
pub const OP_iterator_close_return: OPCodeEnum_0 = 132;
pub const OP_iterator_close: OPCodeEnum_0 = 131;
pub const OP_iterator_get_value_done: OPCodeEnum_0 = 130;
pub const OP_iterator_check_object: OPCodeEnum_0 = 129;
pub const OP_for_of_next: OPCodeEnum_0 = 128;
pub const OP_for_in_next: OPCodeEnum_0 = 127;
pub const OP_for_await_of_start: OPCodeEnum_0 = 126;
pub const OP_for_of_start: OPCodeEnum_0 = 125;
pub const OP_for_in_start: OPCodeEnum_0 = 124;
pub const OP_make_var_ref: OPCodeEnum_0 = 123;
pub const OP_make_var_ref_ref: OPCodeEnum_0 = 122;
pub const OP_make_arg_ref: OPCodeEnum_0 = 121;
pub const OP_make_loc_ref: OPCodeEnum_0 = 120;
pub const OP_ret: OPCodeEnum_0 = 110;
pub const OP_gosub: OPCodeEnum_0 = 109;
pub const OP_catch: OPCodeEnum_0 = 108;
pub const OP_goto: OPCodeEnum_0 = 107;
pub const OP_if_true: OPCodeEnum_0 = 106;
pub const OP_if_false: OPCodeEnum_0 = 105;
pub const OP_close_loc: OPCodeEnum_0 = 104;
pub const OP_put_var_ref_check_init: OPCodeEnum_0 = 103;
pub const OP_put_var_ref_check: OPCodeEnum_0 = 102;
pub const OP_get_var_ref_check: OPCodeEnum_0 = 101;
pub const OP_put_loc_check_init: OPCodeEnum_0 = 100;
pub const OP_put_loc_check: OPCodeEnum_0 = 99;
pub const OP_get_loc_check: OPCodeEnum_0 = 98;
pub const OP_set_loc_uninitialized: OPCodeEnum_0 = 97;
pub const OP_set_var_ref: OPCodeEnum_0 = 96;
pub const OP_put_var_ref: OPCodeEnum_0 = 95;
pub const OP_get_var_ref: OPCodeEnum_0 = 94;
pub const OP_set_arg: OPCodeEnum_0 = 93;
pub const OP_put_arg: OPCodeEnum_0 = 92;
pub const OP_get_arg: OPCodeEnum_0 = 91;
pub const OP_set_loc: OPCodeEnum_0 = 90;
pub const OP_put_loc: OPCodeEnum_0 = 89;
pub const OP_get_loc: OPCodeEnum_0 = 88;
pub const OP_define_class_computed: OPCodeEnum_0 = 87;
pub const OP_define_class: OPCodeEnum_0 = 86;
pub const OP_define_method_computed: OPCodeEnum_0 = 85;
pub const OP_define_method: OPCodeEnum_0 = 84;
pub const OP_copy_data_properties: OPCodeEnum_0 = 83;
pub const OP_append: OPCodeEnum_0 = 82;
pub const OP_define_array_el: OPCodeEnum_0 = 81;
pub const OP_set_home_object: OPCodeEnum_0 = 80;
pub const OP_set_proto: OPCodeEnum_0 = 79;
pub const OP_set_name_computed: OPCodeEnum_0 = 78;
pub const OP_set_name: OPCodeEnum_0 = 77;
pub const OP_define_field: OPCodeEnum_0 = 76;
pub const OP_put_super_value: OPCodeEnum_0 = 75;
pub const OP_get_super_value: OPCodeEnum_0 = 74;
pub const OP_put_array_el: OPCodeEnum_0 = 73;
pub const OP_get_array_el2: OPCodeEnum_0 = 72;
pub const OP_get_array_el: OPCodeEnum_0 = 71;
pub const OP_define_private_field: OPCodeEnum_0 = 70;
pub const OP_put_private_field: OPCodeEnum_0 = 69;
pub const OP_get_private_field: OPCodeEnum_0 = 68;
pub const OP_put_field: OPCodeEnum_0 = 67;
pub const OP_get_field2: OPCodeEnum_0 = 66;
pub const OP_get_field: OPCodeEnum_0 = 65;
pub const OP_define_func: OPCodeEnum_0 = 64;
pub const OP_check_define_var: OPCodeEnum_0 = 63;
pub const OP_define_var: OPCodeEnum_0 = 62;
pub const OP_put_ref_value: OPCodeEnum_0 = 61;
pub const OP_get_ref_value: OPCodeEnum_0 = 60;
pub const OP_put_var_strict: OPCodeEnum_0 = 59;
pub const OP_put_var_init: OPCodeEnum_0 = 58;
pub const OP_put_var: OPCodeEnum_0 = 57;
pub const OP_get_var: OPCodeEnum_0 = 56;
pub const OP_get_var_undef: OPCodeEnum_0 = 55;
pub const OP_check_var: OPCodeEnum_0 = 54;
pub const OP_import: OPCodeEnum_0 = 53;
pub const OP_get_super: OPCodeEnum_0 = 52;
pub const OP_regexp: OPCodeEnum_0 = 51;
pub const OP_apply_eval: OPCodeEnum_0 = 50;
pub const OP_eval: OPCodeEnum_0 = 49;
pub const OP_throw_error: OPCodeEnum_0 = 48;
pub const OP_throw: OPCodeEnum_0 = 47;
pub const OP_add_brand: OPCodeEnum_0 = 45;
pub const OP_check_brand: OPCodeEnum_0 = 44;
pub const OP_check_ctor: OPCodeEnum_0 = 43;
pub const OP_check_ctor_return: OPCodeEnum_0 = 42;
pub const OP_return_undef: OPCodeEnum_0 = 41;
pub const OP_return: OPCodeEnum_0 = 40;
pub const OP_apply: OPCodeEnum_0 = 39;
pub const OP_array_from: OPCodeEnum_0 = 38;
pub const OP_tail_call_method: OPCodeEnum_0 = 37;
pub const OP_call_method: OPCodeEnum_0 = 36;
pub const OP_tail_call: OPCodeEnum_0 = 35;
pub const OP_call: OPCodeEnum_0 = 34;
pub const OP_call_constructor: OPCodeEnum_0 = 33;
pub const OP_rot5l: OPCodeEnum_0 = 32;
pub const OP_rot4l: OPCodeEnum_0 = 31;
pub const OP_rot3r: OPCodeEnum_0 = 30;
pub const OP_rot3l: OPCodeEnum_0 = 29;
pub const OP_swap2: OPCodeEnum_0 = 28;
pub const OP_swap: OPCodeEnum_0 = 27;
pub const OP_perm5: OPCodeEnum_0 = 26;
pub const OP_perm4: OPCodeEnum_0 = 25;
pub const OP_perm3: OPCodeEnum_0 = 24;
pub const OP_insert4: OPCodeEnum_0 = 23;
pub const OP_insert3: OPCodeEnum_0 = 22;
pub const OP_insert2: OPCodeEnum_0 = 21;
pub const OP_dup3: OPCodeEnum_0 = 20;
pub const OP_dup2: OPCodeEnum_0 = 19;
pub const OP_dup1: OPCodeEnum_0 = 18;
pub const OP_dup: OPCodeEnum_0 = 17;
pub const OP_nip1: OPCodeEnum_0 = 16;
pub const OP_nip: OPCodeEnum_0 = 15;
pub const OP_drop: OPCodeEnum_0 = 14;
pub const OP_rest: OPCodeEnum_0 = 13;
pub const OP_special_object: OPCodeEnum_0 = 12;
pub const OP_object: OPCodeEnum_0 = 11;
pub const OP_push_true: OPCodeEnum_0 = 10;
pub const OP_push_false: OPCodeEnum_0 = 9;
pub const OP_push_this: OPCodeEnum_0 = 8;
pub const OP_null: OPCodeEnum_0 = 7;
pub const OP_undefined: OPCodeEnum_0 = 6;
pub const OP_private_symbol: OPCodeEnum_0 = 5;
pub const OP_push_atom_value: OPCodeEnum_0 = 4;
pub const OP_fclosure: OPCodeEnum_0 = 3;
pub const OP_push_const: OPCodeEnum_0 = 2;
pub const OP_push_i32: OPCodeEnum_0 = 1;
pub type JSAtomKindEnum = libc::c_uint;
pub const JS_ATOM_KIND_PRIVATE: JSAtomKindEnum = 2;
pub const JS_ATOM_KIND_SYMBOL: JSAtomKindEnum = 1;
pub const JS_ATOM_KIND_STRING: JSAtomKindEnum = 0;
pub const JS_ATOM_TYPE_GLOBAL_SYMBOL: C2RustUnnamed_38 = 2;
pub const JS_ATOM_return: C2RustUnnamed_40 = 6;
pub const JS_ATOM_value: C2RustUnnamed_40 = 64;
pub const JS_ATOM_done: C2RustUnnamed_40 = 105;
pub const JS_CLASS_ARRAY_ITERATOR: C2RustUnnamed_37 = 37;
pub const JS_ATOM_next: C2RustUnnamed_40 = 106;
pub const JS_ATOM_Symbol_iterator: C2RustUnnamed_40 = 195;
pub const JS_CLASS_ASYNC_FROM_SYNC_ITERATOR: C2RustUnnamed_37 = 48;
pub const JS_ATOM_Symbol_asyncIterator: C2RustUnnamed_40 = 206;
pub const JS_CLASS_STRING_ITERATOR: C2RustUnnamed_37 = 38;
pub const JS_CLASS_ASYNC_GENERATOR_FUNCTION: C2RustUnnamed_37 = 49;
pub const JS_CLASS_ASYNC_FUNCTION: C2RustUnnamed_37 = 45;
pub const JS_CLASS_GENERATOR_FUNCTION: C2RustUnnamed_37 = 16;
pub const JS_ATOM_setPrototypeOf: C2RustUnnamed_40 = 96;
pub const JS_ATOM_TYPE_PRIVATE: C2RustUnnamed_38 = 4;
pub const JS_ATOM_throw: C2RustUnnamed_40 = 23;
pub const JS_CLASS_FOR_IN_ITERATOR: C2RustUnnamed_37 = 17;
pub const JS_CLASS_ASYNC_GENERATOR: C2RustUnnamed_37 = 50;
pub const JS_FUNC_ASYNC_GENERATOR: JSFunctionKindEnum = 3;
pub const JS_FUNC_GENERATOR: JSFunctionKindEnum = 1;
pub const JS_CLASS_C_FUNCTION_DATA: C2RustUnnamed_37 = 15;
pub const JS_CLASS_PROMISE_RESOLVE_FUNCTION: C2RustUnnamed_37 = 43;
pub const JS_CLASS_PROMISE: C2RustUnnamed_37 = 42;
pub const JS_ATOM_lastIndex: C2RustUnnamed_40 = 85;
pub const JS_ATOM_Private_brand: C2RustUnnamed_40 = 193;
pub const JS_ATOM_brand: C2RustUnnamed_40 = 119;
pub const OP_SPECIAL_OBJECT_IMPORT_META: C2RustUnnamed_41 = 6;
pub const OP_SPECIAL_OBJECT_VAR_OBJECT: C2RustUnnamed_41 = 5;
pub const OP_SPECIAL_OBJECT_HOME_OBJECT: C2RustUnnamed_41 = 4;
pub const OP_SPECIAL_OBJECT_NEW_TARGET: C2RustUnnamed_41 = 3;
pub const OP_SPECIAL_OBJECT_THIS_FUNC: C2RustUnnamed_41 = 2;
pub const JS_ATOM_callee: C2RustUnnamed_40 = 78;
pub const JS_CLASS_MAPPED_ARGUMENTS: C2RustUnnamed_37 = 9;
pub const OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS: C2RustUnnamed_41 = 1;
pub const OP_SPECIAL_OBJECT_ARGUMENTS: C2RustUnnamed_41 = 0;
pub const JS_ATOM_isExtensible: C2RustUnnamed_40 = 97;
pub const JS_ATOM_lineNumber: C2RustUnnamed_40 = 50;
pub const JS_ATOM_fileName: C2RustUnnamed_40 = 49;
pub const JS_ATOM_message: C2RustUnnamed_40 = 51;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSClassShortDef {
    pub class_name: JSAtom,
    pub finalizer: Option::<JSClassFinalizer>,
    pub gc_mark: Option::<JSClassGCMark>,
}
pub const JS_ATOM_Generator: C2RustUnnamed_40 = 176;
pub const JS_ATOM_RegExp_String_Iterator: C2RustUnnamed_40 = 175;
pub const JS_ATOM_String_Iterator: C2RustUnnamed_40 = 174;
pub const JS_ATOM_Array_Iterator: C2RustUnnamed_40 = 173;
pub const JS_ATOM_Set_Iterator: C2RustUnnamed_40 = 172;
pub const JS_ATOM_Map_Iterator: C2RustUnnamed_40 = 171;
pub const JS_ATOM_WeakSet: C2RustUnnamed_40 = 170;
pub const JS_ATOM_WeakMap: C2RustUnnamed_40 = 169;
pub const JS_ATOM_Set: C2RustUnnamed_40 = 168;
pub const JS_ATOM_Map: C2RustUnnamed_40 = 167;
pub const JS_ATOM_DataView: C2RustUnnamed_40 = 166;
pub const JS_ATOM_Float64Array: C2RustUnnamed_40 = 165;
pub const JS_ATOM_Float32Array: C2RustUnnamed_40 = 164;
pub const JS_ATOM_Uint32Array: C2RustUnnamed_40 = 163;
pub const JS_ATOM_Int32Array: C2RustUnnamed_40 = 162;
pub const JS_ATOM_Uint16Array: C2RustUnnamed_40 = 161;
pub const JS_ATOM_Int16Array: C2RustUnnamed_40 = 160;
pub const JS_ATOM_Uint8Array: C2RustUnnamed_40 = 159;
pub const JS_ATOM_Int8Array: C2RustUnnamed_40 = 158;
pub const JS_ATOM_Uint8ClampedArray: C2RustUnnamed_40 = 157;
pub const JS_ATOM_SharedArrayBuffer: C2RustUnnamed_40 = 156;
pub const JS_ATOM_ArrayBuffer: C2RustUnnamed_40 = 155;
pub const JS_ATOM_RegExp: C2RustUnnamed_40 = 154;
pub const JS_ATOM_ForInIterator: C2RustUnnamed_40 = 153;
pub const JS_ATOM_GeneratorFunction: C2RustUnnamed_40 = 152;
pub const JS_ATOM_Function: C2RustUnnamed_40 = 151;
pub const JS_ATOM_Object: C2RustUnnamed_40 = 140;
pub const JS_ATOM_Date: C2RustUnnamed_40 = 150;
pub const JS_ATOM_Arguments: C2RustUnnamed_40 = 147;
pub const JS_ATOM_Symbol: C2RustUnnamed_40 = 146;
pub const JS_ATOM_Boolean: C2RustUnnamed_40 = 145;
pub const JS_ATOM_String: C2RustUnnamed_40 = 144;
pub const JS_ATOM_Number: C2RustUnnamed_40 = 143;
pub const JS_ATOM_Error: C2RustUnnamed_40 = 142;
pub const JS_ATOM_Array: C2RustUnnamed_40 = 141;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSClassDef {
    pub class_name: *const libc::c_char,
    pub finalizer: Option::<JSClassFinalizer>,
    pub gc_mark: Option::<JSClassGCMark>,
    pub call: Option::<JSClassCall>,
    pub exotic: *mut JSClassExoticMethods,
}
pub const JS_CLASS_INIT_COUNT: C2RustUnnamed_37 = 51;
pub type JSFunctionKindEnum = libc::c_uint;
pub const JS_FUNC_ASYNC: JSFunctionKindEnum = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSAsyncGeneratorRequest {
    pub link: list_head,
    pub completion_type: libc::c_int,
    pub result: JSValue,
    pub promise: JSValue,
    pub resolving_funcs: [JSValue; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSPromiseReactionData {
    pub link: list_head,
    pub resolving_funcs: [JSValue; 2],
    pub handler: JSValue,
}
pub const JS_ATOM_then: C2RustUnnamed_40 = 127;
pub const JS_ATOM_resolve: C2RustUnnamed_40 = 128;
pub const JS_ATOM_errors: C2RustUnnamed_40 = 52;
pub const JS_ATOM_reason: C2RustUnnamed_40 = 137;
pub const JS_ATOM_status: C2RustUnnamed_40 = 136;
pub const JS_ATOM_Symbol_species: C2RustUnnamed_40 = 204;
pub const JS_CLASS_ASYNC_FUNCTION_RESOLVE: C2RustUnnamed_37 = 46;
pub const JS_CLASS_ASYNC_FUNCTION_REJECT: C2RustUnnamed_37 = 47;
pub const JS_CLASS_PROMISE_REJECT_FUNCTION: C2RustUnnamed_37 = 44;
pub const JS_ATOM_AsyncGenerator: C2RustUnnamed_40 = 185;
pub const JS_ATOM_AsyncGeneratorFunction: C2RustUnnamed_40 = 184;
pub const JS_ATOM_AsyncFunctionReject: C2RustUnnamed_40 = 183;
pub const JS_ATOM_AsyncFunctionResolve: C2RustUnnamed_40 = 182;
pub const JS_ATOM_AsyncFunction: C2RustUnnamed_40 = 181;
pub const JS_ATOM_PromiseRejectFunction: C2RustUnnamed_40 = 180;
pub const JS_ATOM_PromiseResolveFunction: C2RustUnnamed_40 = 179;
pub const JS_ATOM_Promise: C2RustUnnamed_40 = 178;
pub const JS_CLASS_ARRAY_BUFFER: C2RustUnnamed_37 = 19;
pub const JS_CLASS_SHARED_ARRAY_BUFFER: C2RustUnnamed_37 = 20;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
    pub f: libc::c_float,
    pub i: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_28 {
    pub f: libc::c_double,
    pub i: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_29 {
    pub f: libc::c_float,
    pub i: uint32_t,
}
pub const JS_ATOM_toLocaleString: C2RustUnnamed_40 = 56;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TA_sort_context {
    pub ctx: *mut JSContext,
    pub exception: libc::c_int,
    pub arr: JSValue,
    pub cmp: JSValue,
    pub getfun: Option::<
        unsafe extern "C" fn(*mut JSContext, *const libc::c_void) -> JSValue,
    >,
    pub array_ptr: *mut uint8_t,
    pub elt_size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_30 {
    pub f: libc::c_float,
    pub u32_0: uint32_t,
}
pub const JS_ATOM_set: C2RustUnnamed_40 = 66;
pub const JS_CLASS_MAP: C2RustUnnamed_37 = 31;
pub const JS_CLASS_MAP_ITERATOR: C2RustUnnamed_37 = 35;
pub const JS_ATOM_add: C2RustUnnamed_40 = 104;
pub const JS_ATOM_revoke: C2RustUnnamed_40 = 132;
pub const JS_ATOM_proxy: C2RustUnnamed_40 = 131;
pub const JS_ATOM_apply: C2RustUnnamed_40 = 90;
pub const JS_ATOM_construct: C2RustUnnamed_40 = 94;
pub const JS_ATOM_get: C2RustUnnamed_40 = 65;
pub const JS_ATOM_has: C2RustUnnamed_40 = 99;
pub const JS_ATOM_ownKeys: C2RustUnnamed_40 = 103;
pub const JS_ATOM_deleteProperty: C2RustUnnamed_40 = 100;
pub const JS_ATOM_configurable: C2RustUnnamed_40 = 61;
pub const JS_ATOM_enumerable: C2RustUnnamed_40 = 63;
pub const JS_ATOM_writable: C2RustUnnamed_40 = 62;
pub const JS_ATOM_defineProperty: C2RustUnnamed_40 = 101;
pub const JS_ATOM_getOwnPropertyDescriptor: C2RustUnnamed_40 = 102;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSONStringifyContext {
    pub replacer_func: JSValue,
    pub stack: JSValue,
    pub property_list: JSValue,
    pub gap: JSValue,
    pub empty: JSValue,
    pub b: *mut StringBuffer,
}
pub const JS_ATOM_toJSON: C2RustUnnamed_40 = 139;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSToken {
    pub val: libc::c_int,
    pub line_num: libc::c_int,
    pub ptr: *const uint8_t,
    pub u: C2RustUnnamed_31,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_31 {
    pub str_0: C2RustUnnamed_35,
    pub num: C2RustUnnamed_34,
    pub ident: C2RustUnnamed_33,
    pub regexp: C2RustUnnamed_32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
    pub body: JSValue,
    pub flags: JSValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_33 {
    pub atom: JSAtom,
    pub has_escape: BOOL,
    pub is_reserved: BOOL,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_34 {
    pub val: JSValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_35 {
    pub str_0: JSValue,
    pub sep: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSParseState {
    pub ctx: *mut JSContext,
    pub last_line_num: libc::c_int,
    pub line_num: libc::c_int,
    pub filename: *const libc::c_char,
    pub token: JSToken,
    pub got_lf: BOOL,
    pub last_ptr: *const uint8_t,
    pub buf_ptr: *const uint8_t,
    pub buf_end: *const uint8_t,
    pub cur_func: *mut JSFunctionDef,
    pub is_module: BOOL,
    pub allow_html_comments: BOOL,
    pub ext_json: BOOL,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSFunctionDef {
    pub ctx: *mut JSContext,
    pub parent: *mut JSFunctionDef,
    pub parent_cpool_idx: libc::c_int,
    pub parent_scope_level: libc::c_int,
    pub child_list: list_head,
    pub link: list_head,
    pub is_eval: BOOL,
    pub eval_type: libc::c_int,
    pub is_global_var: BOOL,
    pub is_func_expr: BOOL,
    pub has_home_object: BOOL,
    pub has_prototype: BOOL,
    pub has_simple_parameter_list: BOOL,
    pub has_parameter_expressions: BOOL,
    pub has_use_strict: BOOL,
    pub has_eval_call: BOOL,
    pub has_arguments_binding: BOOL,
    pub has_this_binding: BOOL,
    pub new_target_allowed: BOOL,
    pub super_call_allowed: BOOL,
    pub super_allowed: BOOL,
    pub arguments_allowed: BOOL,
    pub is_derived_class_constructor: BOOL,
    pub in_function_body: BOOL,
    pub backtrace_barrier: BOOL,
    #[bitfield(name = "func_kind", ty = "JSFunctionKindEnum", bits = "0..=7")]
    #[bitfield(name = "func_type", ty = "JSParseFunctionEnum", bits = "8..=15")]
    pub func_kind_func_type: [u8; 2],
    pub js_mode: uint8_t,
    pub func_name: JSAtom,
    pub vars: *mut JSVarDef,
    pub var_size: libc::c_int,
    pub var_count: libc::c_int,
    pub args: *mut JSVarDef,
    pub arg_size: libc::c_int,
    pub arg_count: libc::c_int,
    pub defined_arg_count: libc::c_int,
    pub var_object_idx: libc::c_int,
    pub arg_var_object_idx: libc::c_int,
    pub arguments_var_idx: libc::c_int,
    pub arguments_arg_idx: libc::c_int,
    pub func_var_idx: libc::c_int,
    pub eval_ret_idx: libc::c_int,
    pub this_var_idx: libc::c_int,
    pub new_target_var_idx: libc::c_int,
    pub this_active_func_var_idx: libc::c_int,
    pub home_object_var_idx: libc::c_int,
    pub need_home_object: BOOL,
    pub scope_level: libc::c_int,
    pub scope_first: libc::c_int,
    pub scope_size: libc::c_int,
    pub scope_count: libc::c_int,
    pub scopes: *mut JSVarScope,
    pub def_scope_array: [JSVarScope; 4],
    pub body_scope: libc::c_int,
    pub global_var_count: libc::c_int,
    pub global_var_size: libc::c_int,
    pub global_vars: *mut JSGlobalVar,
    pub byte_code: DynBuf,
    pub last_opcode_pos: libc::c_int,
    pub last_opcode_line_num: libc::c_int,
    pub use_short_opcodes: BOOL,
    pub label_slots: *mut LabelSlot,
    pub label_size: libc::c_int,
    pub label_count: libc::c_int,
    pub top_break: *mut BlockEnv,
    pub cpool: *mut JSValue,
    pub cpool_count: libc::c_int,
    pub cpool_size: libc::c_int,
    pub closure_var_count: libc::c_int,
    pub closure_var_size: libc::c_int,
    pub closure_var: *mut JSClosureVar,
    pub jump_slots: *mut JumpSlot,
    pub jump_size: libc::c_int,
    pub jump_count: libc::c_int,
    pub line_number_slots: *mut LineNumberSlot,
    pub line_number_size: libc::c_int,
    pub line_number_count: libc::c_int,
    pub line_number_last: libc::c_int,
    pub line_number_last_pc: libc::c_int,
    pub filename: JSAtom,
    pub line_num: libc::c_int,
    pub pc2line: DynBuf,
    pub source: *mut libc::c_char,
    pub source_len: libc::c_int,
    pub module: *mut JSModuleDef,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LineNumberSlot {
    pub pc: uint32_t,
    pub line_num: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JumpSlot {
    pub op: libc::c_int,
    pub size: libc::c_int,
    pub pos: libc::c_int,
    pub label: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BlockEnv {
    pub prev: *mut BlockEnv,
    pub label_name: JSAtom,
    pub label_break: libc::c_int,
    pub label_cont: libc::c_int,
    pub drop_count: libc::c_int,
    pub label_finally: libc::c_int,
    pub scope_level: libc::c_int,
    pub has_iterator: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LabelSlot {
    pub ref_count: libc::c_int,
    pub pos: libc::c_int,
    pub pos2: libc::c_int,
    pub addr: libc::c_int,
    pub first_reloc: *mut RelocEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RelocEntry {
    pub next: *mut RelocEntry,
    pub addr: uint32_t,
    pub size: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct JSGlobalVar {
    pub cpool_idx: libc::c_int,
    #[bitfield(name = "force_init", ty = "uint8_t", bits = "0..=0")]
    #[bitfield(name = "is_lexical", ty = "uint8_t", bits = "1..=1")]
    #[bitfield(name = "is_const", ty = "uint8_t", bits = "2..=2")]
    pub force_init_is_lexical_is_const: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub scope_level: libc::c_int,
    pub var_name: JSAtom,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSVarScope {
    pub parent: libc::c_int,
    pub first: libc::c_int,
}
pub type JSParseFunctionEnum = libc::c_uint;
pub const JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR: JSParseFunctionEnum = 8;
pub const JS_PARSE_FUNC_CLASS_CONSTRUCTOR: JSParseFunctionEnum = 7;
pub const JS_PARSE_FUNC_METHOD: JSParseFunctionEnum = 6;
pub const JS_PARSE_FUNC_SETTER: JSParseFunctionEnum = 5;
pub const JS_PARSE_FUNC_GETTER: JSParseFunctionEnum = 4;
pub const JS_PARSE_FUNC_ARROW: JSParseFunctionEnum = 3;
pub const JS_PARSE_FUNC_EXPR: JSParseFunctionEnum = 2;
pub const JS_PARSE_FUNC_VAR: JSParseFunctionEnum = 1;
pub const JS_PARSE_FUNC_STATEMENT: JSParseFunctionEnum = 0;
pub const TOK_AWAIT: C2RustUnnamed_42 = -40;
pub const TOK_NULL: C2RustUnnamed_42 = -85;
pub const TOK_PRIVATE_NAME: C2RustUnnamed_42 = -87;
pub const TOK_IDENT: C2RustUnnamed_42 = -125;
pub const TOK_REGEXP: C2RustUnnamed_42 = -124;
pub const TOK_TEMPLATE: C2RustUnnamed_42 = -126;
pub const TOK_STRING: C2RustUnnamed_42 = -127;
pub const TOK_EOF: C2RustUnnamed_42 = -86;
pub const TOK_ERROR: C2RustUnnamed_42 = -88;
pub const TOK_NUMBER: C2RustUnnamed_42 = -128;
pub const JS_ATOM_input: C2RustUnnamed_40 = 88;
pub const JS_ATOM_index: C2RustUnnamed_40 = 87;
pub const JS_ATOM_groups: C2RustUnnamed_40 = 135;
pub const JS_ATOM_exec: C2RustUnnamed_40 = 134;
pub const JS_CLASS_REGEXP_STRING_ITERATOR: C2RustUnnamed_37 = 39;
pub const JS_ATOM_flags: C2RustUnnamed_40 = 109;
pub const JS_ATOM_source: C2RustUnnamed_40 = 108;
pub const JS_ATOM_Symbol_match: C2RustUnnamed_40 = 196;
pub const JS_ATOM_unicode: C2RustUnnamed_40 = 111;
pub const JS_ATOM_global: C2RustUnnamed_40 = 110;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ValueBuffer {
    pub ctx: *mut JSContext,
    pub arr: *mut JSValue,
    pub def: [JSValue; 4],
    pub len: libc::c_int,
    pub size: libc::c_int,
    pub error_status: libc::c_int,
}
pub type UnicodeNormalizationEnum = libc::c_uint;
pub const UNICODE_NFKD: UnicodeNormalizationEnum = 3;
pub const UNICODE_NFKC: UnicodeNormalizationEnum = 2;
pub const UNICODE_NFD: UnicodeNormalizationEnum = 1;
pub const UNICODE_NFC: UnicodeNormalizationEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct StackSizeState {
    pub bc_len: libc::c_int,
    pub stack_len_max: libc::c_int,
    pub stack_level_tab: *mut uint16_t,
    pub pc_stack: *mut libc::c_int,
    pub pc_stack_len: libc::c_int,
    pub pc_stack_size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CodeContext {
    pub bc_buf: *const uint8_t,
    pub bc_len: libc::c_int,
    pub pos: libc::c_int,
    pub line_num: libc::c_int,
    pub op: libc::c_int,
    pub idx: libc::c_int,
    pub label: libc::c_int,
    pub val: libc::c_int,
    pub atom: JSAtom,
}
pub const OP_FMT_label_u16: OPCodeFormat = 28;
pub const JS_VAR_NEW_FUNCTION_DECL: JSVarKindEnum = 2;
pub const JS_VAR_FUNCTION_DECL: JSVarKindEnum = 1;
pub const JS_ATOM__default_: C2RustUnnamed_40 = 124;
pub const JS_ATOM__arg_var_: C2RustUnnamed_40 = 83;
pub const JS_ATOM__var_: C2RustUnnamed_40 = 82;
pub const JS_VAR_PRIVATE_SETTER: JSVarKindEnum = 8;
pub type JSVarKindEnum = libc::c_uint;
pub const JS_VAR_PRIVATE_GETTER_SETTER: JSVarKindEnum = 9;
pub const JS_VAR_PRIVATE_GETTER: JSVarKindEnum = 7;
pub const JS_VAR_PRIVATE_METHOD: JSVarKindEnum = 6;
pub const JS_VAR_PRIVATE_FIELD: JSVarKindEnum = 5;
pub const JS_VAR_FUNCTION_NAME: JSVarKindEnum = 4;
pub const JS_VAR_CATCH: JSVarKindEnum = 3;
pub const JS_VAR_NORMAL: JSVarKindEnum = 0;
pub const JS_ATOM_this: C2RustUnnamed_40 = 8;
pub const JS_ATOM__with_: C2RustUnnamed_40 = 84;
pub const JS_ATOM_arguments: C2RustUnnamed_40 = 77;
pub const JS_ATOM_new_target: C2RustUnnamed_40 = 113;
pub const JS_ATOM_this_active_func: C2RustUnnamed_40 = 114;
pub const JS_ATOM_home_object: C2RustUnnamed_40 = 115;
pub const JS_ATOM__ret_: C2RustUnnamed_40 = 81;
pub const TOK_QUESTION_MARK_DOT: C2RustUnnamed_42 = -89;
pub const TOK_DOUBLE_QUESTION_MARK: C2RustUnnamed_42 = -90;
pub const TOK_DOUBLE_QUESTION_MARK_ASSIGN: C2RustUnnamed_42 = -109;
pub const TOK_LOR: C2RustUnnamed_42 = -94;
pub const TOK_LOR_ASSIGN: C2RustUnnamed_42 = -110;
pub const TOK_OR_ASSIGN: C2RustUnnamed_42 = -113;
pub const TOK_XOR_ASSIGN: C2RustUnnamed_42 = -114;
pub const TOK_LAND: C2RustUnnamed_42 = -95;
pub const TOK_LAND_ASSIGN: C2RustUnnamed_42 = -111;
pub const TOK_AND_ASSIGN: C2RustUnnamed_42 = -115;
pub const TOK_NEQ: C2RustUnnamed_42 = -97;
pub const TOK_STRICT_NEQ: C2RustUnnamed_42 = -96;
pub const TOK_ARROW: C2RustUnnamed_42 = -92;
pub const TOK_EQ: C2RustUnnamed_42 = -99;
pub const TOK_STRICT_EQ: C2RustUnnamed_42 = -98;
pub const TOK_SAR: C2RustUnnamed_42 = -105;
pub const TOK_SAR_ASSIGN: C2RustUnnamed_42 = -117;
pub const TOK_SHR: C2RustUnnamed_42 = -104;
pub const TOK_SHR_ASSIGN: C2RustUnnamed_42 = -116;
pub const TOK_GTE: C2RustUnnamed_42 = -100;
pub const TOK_SHL: C2RustUnnamed_42 = -106;
pub const TOK_SHL_ASSIGN: C2RustUnnamed_42 = -118;
pub const TOK_LTE: C2RustUnnamed_42 = -102;
pub const TOK_DEC: C2RustUnnamed_42 = -108;
pub const TOK_MINUS_ASSIGN: C2RustUnnamed_42 = -119;
pub const TOK_INC: C2RustUnnamed_42 = -107;
pub const TOK_PLUS_ASSIGN: C2RustUnnamed_42 = -120;
pub const TOK_MOD_ASSIGN: C2RustUnnamed_42 = -121;
pub const TOK_POW: C2RustUnnamed_42 = -93;
pub const TOK_POW_ASSIGN: C2RustUnnamed_42 = -112;
pub const TOK_MUL_ASSIGN: C2RustUnnamed_42 = -123;
pub const TOK_ELLIPSIS: C2RustUnnamed_42 = -91;
pub const JS_ATOM_await: C2RustUnnamed_40 = 46;
pub const JS_ATOM_yield: C2RustUnnamed_40 = 45;
pub const JS_ATOM_super: C2RustUnnamed_40 = 36;
pub const TOK_DIV_ASSIGN: C2RustUnnamed_42 = -122;
pub type PutLValueEnum = libc::c_uint;
pub const PUT_LVALUE_NOKEEP_BOTTOM: PutLValueEnum = 4;
pub const PUT_LVALUE_KEEP_SECOND: PutLValueEnum = 3;
pub const PUT_LVALUE_KEEP_TOP: PutLValueEnum = 2;
pub const PUT_LVALUE_NOKEEP_DEPTH: PutLValueEnum = 1;
pub const PUT_LVALUE_NOKEEP: PutLValueEnum = 0;
pub const TOK_FOR: C2RustUnnamed_42 = -69;
pub const JS_ATOM_eval: C2RustUnnamed_40 = 58;
pub const TOK_IN: C2RustUnnamed_42 = -73;
pub const TOK_INSTANCEOF: C2RustUnnamed_42 = -72;
pub type FuncCallType = libc::c_uint;
pub const FUNC_CALL_TEMPLATE: FuncCallType = 3;
pub const FUNC_CALL_SUPER_CTOR: FuncCallType = 2;
pub const FUNC_CALL_NEW: FuncCallType = 1;
pub const FUNC_CALL_NORMAL: FuncCallType = 0;
pub const JS_ATOM_class_fields_init: C2RustUnnamed_40 = 118;
pub const JS_ATOM_concat: C2RustUnnamed_40 = 92;
pub const JS_ATOM_raw: C2RustUnnamed_40 = 112;
pub const JS_ATOM_meta: C2RustUnnamed_40 = 123;
pub const TOK_IMPORT: C2RustUnnamed_42 = -51;
pub const TOK_SUPER: C2RustUnnamed_42 = -50;
pub const JS_ATOM_target: C2RustUnnamed_40 = 86;
pub const TOK_NEW: C2RustUnnamed_42 = -74;
pub const JS_ATOM___proto__: C2RustUnnamed_40 = 68;
pub type JSParseExportEnum = libc::c_uint;
pub const JS_PARSE_EXPORT_DEFAULT: JSParseExportEnum = 2;
pub const JS_PARSE_EXPORT_NAMED: JSParseExportEnum = 1;
pub const JS_PARSE_EXPORT_NONE: JSParseExportEnum = 0;
pub type JSVarDefEnum = libc::c_uint;
pub const JS_VAR_DEF_VAR: JSVarDefEnum = 6;
pub const JS_VAR_DEF_CATCH: JSVarDefEnum = 5;
pub const JS_VAR_DEF_NEW_FUNCTION_DECL: JSVarDefEnum = 4;
pub const JS_VAR_DEF_FUNCTION_DECL: JSVarDefEnum = 3;
pub const JS_VAR_DEF_CONST: JSVarDefEnum = 2;
pub const JS_VAR_DEF_LET: JSVarDefEnum = 1;
pub const JS_VAR_DEF_WITH: JSVarDefEnum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSParsePos {
    pub last_line_num: libc::c_int,
    pub line_num: libc::c_int,
    pub got_lf: BOOL,
    pub ptr: *const uint8_t,
}
pub const TOK_STATIC: C2RustUnnamed_42 = -42;
pub const TOK_PUBLIC: C2RustUnnamed_42 = -43;
pub const TOK_PROTECTED: C2RustUnnamed_42 = -44;
pub const TOK_PRIVATE: C2RustUnnamed_42 = -45;
pub const TOK_PACKAGE: C2RustUnnamed_42 = -46;
pub const TOK_LET: C2RustUnnamed_42 = -47;
pub const TOK_INTERFACE: C2RustUnnamed_42 = -48;
pub const TOK_EXPORT: C2RustUnnamed_42 = -53;
pub const TOK_ENUM: C2RustUnnamed_42 = -54;
pub const TOK_CONST: C2RustUnnamed_42 = -55;
pub const TOK_CLASS: C2RustUnnamed_42 = -56;
pub const TOK_WITH: C2RustUnnamed_42 = -57;
pub const TOK_DEBUGGER: C2RustUnnamed_42 = -58;
pub const TOK_FUNCTION: C2RustUnnamed_42 = -59;
pub const TOK_TRY: C2RustUnnamed_42 = -62;
pub const TOK_THROW: C2RustUnnamed_42 = -63;
pub const TOK_SWITCH: C2RustUnnamed_42 = -66;
pub const TOK_WHILE: C2RustUnnamed_42 = -70;
pub const TOK_DO: C2RustUnnamed_42 = -71;
pub const TOK_TYPEOF: C2RustUnnamed_42 = -75;
pub const TOK_DELETE: C2RustUnnamed_42 = -77;
pub const TOK_THIS: C2RustUnnamed_42 = -78;
pub const TOK_VAR: C2RustUnnamed_42 = -79;
pub const TOK_RETURN: C2RustUnnamed_42 = -80;
pub const TOK_IF: C2RustUnnamed_42 = -82;
pub const TOK_TRUE: C2RustUnnamed_42 = -83;
pub const TOK_FALSE: C2RustUnnamed_42 = -84;
pub const TOK_CATCH: C2RustUnnamed_42 = -61;
pub const JS_ATOM_let: C2RustUnnamed_40 = 39;
pub const TOK_OF: C2RustUnnamed_42 = -39;
pub const JS_ATOM_of: C2RustUnnamed_40 = 67;
pub const JS_ATOM_async: C2RustUnnamed_40 = 133;
pub const TOK_YIELD: C2RustUnnamed_42 = -41;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ClassFieldsDef {
    pub fields_init_fd: *mut JSFunctionDef,
    pub computed_fields_count: libc::c_int,
    pub has_brand: BOOL,
    pub brand_push_pos: libc::c_int,
}
pub const JS_ATOM_computed_field: C2RustUnnamed_40 = 116;
pub const JS_ATOM_hash_constructor: C2RustUnnamed_40 = 120;
pub const JS_ATOM_static: C2RustUnnamed_40 = 44;
pub const TOK_EXTENDS: C2RustUnnamed_42 = -52;
pub const TOK_VOID: C2RustUnnamed_42 = -76;
pub const TOK_FINALLY: C2RustUnnamed_42 = -60;
pub const TOK_DEFAULT: C2RustUnnamed_42 = -64;
pub const TOK_CASE: C2RustUnnamed_42 = -65;
pub const TOK_BREAK: C2RustUnnamed_42 = -68;
pub const TOK_CONTINUE: C2RustUnnamed_42 = -67;
pub const TOK_ELSE: C2RustUnnamed_42 = -81;
pub const JS_ATOM_from: C2RustUnnamed_40 = 122;
pub const JS_ATOM_as: C2RustUnnamed_40 = 121;
pub const JS_ATOM__eval_: C2RustUnnamed_40 = 80;
pub const JS_ATOM_globalThis: C2RustUnnamed_40 = 138;
pub const JS_ATOM_preventExtensions: C2RustUnnamed_40 = 98;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
    pub tag: *const libc::c_char,
    pub attr: *const libc::c_char,
}
pub const magic_string_sup: C2RustUnnamed_43 = 12;
pub const magic_string_sub: C2RustUnnamed_43 = 11;
pub const magic_string_strike: C2RustUnnamed_43 = 10;
pub const magic_string_small: C2RustUnnamed_43 = 9;
pub const magic_string_link: C2RustUnnamed_43 = 8;
pub const magic_string_italics: C2RustUnnamed_43 = 7;
pub const magic_string_fontsize: C2RustUnnamed_43 = 6;
pub const magic_string_fontcolor: C2RustUnnamed_43 = 5;
pub const magic_string_fixed: C2RustUnnamed_43 = 4;
pub const magic_string_bold: C2RustUnnamed_43 = 3;
pub const magic_string_blink: C2RustUnnamed_43 = 2;
pub const magic_string_big: C2RustUnnamed_43 = 1;
pub const magic_string_anchor: C2RustUnnamed_43 = 0;
pub const JS_ATOM_Symbol_replace: C2RustUnnamed_40 = 198;
pub const JS_ATOM_Symbol_split: C2RustUnnamed_40 = 200;
pub const JS_ATOM_Symbol_matchAll: C2RustUnnamed_40 = 197;
pub const JS_ATOM_Symbol_search: C2RustUnnamed_40 = 199;
pub const JS_ATOM_values: C2RustUnnamed_40 = 107;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ValueSlot {
    pub val: JSValue,
    pub str_0: *mut JSString,
    pub pos: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct array_sort_context {
    pub ctx: *mut JSContext,
    pub exception: libc::c_int,
    pub has_method: libc::c_int,
    pub method: JSValue,
}
pub const JS_ATOM_join: C2RustUnnamed_40 = 91;
pub const JS_ATOM_Symbol_isConcatSpreadable: C2RustUnnamed_40 = 202;
pub const JS_ATOM_caller: C2RustUnnamed_40 = 79;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMemoryUsage {
    pub malloc_size: int64_t,
    pub malloc_limit: int64_t,
    pub memory_used_size: int64_t,
    pub malloc_count: int64_t,
    pub memory_used_count: int64_t,
    pub atom_count: int64_t,
    pub atom_size: int64_t,
    pub str_count: int64_t,
    pub str_size: int64_t,
    pub obj_count: int64_t,
    pub obj_size: int64_t,
    pub prop_count: int64_t,
    pub prop_size: int64_t,
    pub shape_count: int64_t,
    pub shape_size: int64_t,
    pub js_func_count: int64_t,
    pub js_func_size: int64_t,
    pub js_func_code_size: int64_t,
    pub js_func_pc2line_count: int64_t,
    pub js_func_pc2line_size: int64_t,
    pub c_func_count: int64_t,
    pub array_count: int64_t,
    pub fast_array_count: int64_t,
    pub fast_array_elements: int64_t,
    pub binary_object_count: int64_t,
    pub binary_object_size: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSMemoryUsage_helper {
    pub memory_used_count: libc::c_double,
    pub str_count: libc::c_double,
    pub str_size: libc::c_double,
    pub js_func_count: int64_t,
    pub js_func_size: libc::c_double,
    pub js_func_code_size: int64_t,
    pub js_func_pc2line_count: int64_t,
    pub js_func_pc2line_size: int64_t,
}
pub const JS_CLASS_SET_ITERATOR: C2RustUnnamed_37 = 36;
pub const JS_CLASS_WEAKSET: C2RustUnnamed_37 = 34;
pub const JS_CLASS_WEAKMAP: C2RustUnnamed_37 = 33;
pub const JS_CLASS_SET: C2RustUnnamed_37 = 32;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct BCWriterState {
    pub ctx: *mut JSContext,
    pub dbuf: DynBuf,
    #[bitfield(name = "byte_swap", ty = "BOOL", bits = "0..=7")]
    #[bitfield(name = "allow_bytecode", ty = "BOOL", bits = "8..=15")]
    #[bitfield(name = "allow_sab", ty = "BOOL", bits = "16..=23")]
    #[bitfield(name = "allow_reference", ty = "BOOL", bits = "24..=31")]
    pub byte_swap_allow_bytecode_allow_sab_allow_reference: [u8; 4],
    pub first_atom: uint32_t,
    pub atom_to_idx: *mut uint32_t,
    pub atom_to_idx_size: libc::c_int,
    pub idx_to_atom: *mut JSAtom,
    pub idx_to_atom_count: libc::c_int,
    pub idx_to_atom_size: libc::c_int,
    pub sab_tab: *mut *mut uint8_t,
    pub sab_tab_len: libc::c_int,
    pub sab_tab_size: libc::c_int,
    pub object_list: JSObjectList,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSObjectList {
    pub object_tab: *mut JSObjectListEntry,
    pub object_count: libc::c_int,
    pub object_size: libc::c_int,
    pub hash_table: *mut uint32_t,
    pub hash_size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JSObjectListEntry {
    pub obj: *mut JSObject,
    pub hash_next: uint32_t,
}
pub const BC_TAG_TYPED_ARRAY: BCTagEnum = 16;
pub const BC_TAG_OBJECT_VALUE: BCTagEnum = 20;
pub const BC_TAG_DATE: BCTagEnum = 19;
pub const BC_TAG_SHARED_ARRAY_BUFFER: BCTagEnum = 18;
pub const BC_TAG_ARRAY_BUFFER: BCTagEnum = 17;
pub const BC_TAG_OBJECT: BCTagEnum = 8;
pub const BC_TAG_ARRAY: BCTagEnum = 9;
pub const BC_TAG_TEMPLATE_OBJECT: BCTagEnum = 13;
pub const BC_TAG_OBJECT_REFERENCE: BCTagEnum = 21;
pub const BC_TAG_MODULE: BCTagEnum = 15;
pub const BC_TAG_FUNCTION_BYTECODE: BCTagEnum = 14;
pub const BC_TAG_STRING: BCTagEnum = 7;
pub const BC_TAG_FLOAT64: BCTagEnum = 6;
pub const BC_TAG_INT32: BCTagEnum = 5;
pub const BC_TAG_BOOL_FALSE: BCTagEnum = 3;
pub const BC_TAG_UNDEFINED: BCTagEnum = 2;
pub const BC_TAG_NULL: BCTagEnum = 1;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct BCReaderState {
    pub ctx: *mut JSContext,
    pub buf_start: *const uint8_t,
    pub ptr: *const uint8_t,
    pub buf_end: *const uint8_t,
    pub first_atom: uint32_t,
    pub idx_to_atom_count: uint32_t,
    pub idx_to_atom: *mut JSAtom,
    pub error_state: libc::c_int,
    #[bitfield(name = "allow_sab", ty = "BOOL", bits = "0..=7")]
    #[bitfield(name = "allow_bytecode", ty = "BOOL", bits = "8..=15")]
    #[bitfield(name = "is_rom_data", ty = "BOOL", bits = "16..=23")]
    #[bitfield(name = "allow_reference", ty = "BOOL", bits = "24..=31")]
    pub allow_sab_allow_bytecode_is_rom_data_allow_reference: [u8; 4],
    pub objects: *mut *mut JSObject,
    pub objects_count: libc::c_int,
    pub objects_size: libc::c_int,
}
pub const BC_TAG_BOOL_TRUE: BCTagEnum = 4;
pub type C2RustUnnamed_37 = libc::c_uint;
pub type C2RustUnnamed_38 = libc::c_uint;
pub type C2RustUnnamed_39 = libc::c_uint;
pub type C2RustUnnamed_40 = libc::c_uint;
pub const JS_ATOM_InternalError: C2RustUnnamed_40 = 192;
pub const JS_ATOM_URIError: C2RustUnnamed_40 = 191;
pub const JS_ATOM_TypeError: C2RustUnnamed_40 = 190;
pub const JS_ATOM_SyntaxError: C2RustUnnamed_40 = 189;
pub const JS_ATOM_ReferenceError: C2RustUnnamed_40 = 188;
pub const JS_ATOM_RangeError: C2RustUnnamed_40 = 187;
pub const JS_ATOM_EvalError: C2RustUnnamed_40 = 186;
pub const JS_ATOM_Proxy: C2RustUnnamed_40 = 177;
pub const JS_ATOM_JSON: C2RustUnnamed_40 = 149;
pub const JS_ATOM_Math: C2RustUnnamed_40 = 148;
pub const JS_ATOM_promise: C2RustUnnamed_40 = 130;
pub const JS_ATOM_reject: C2RustUnnamed_40 = 129;
pub const JS_ATOM_static_computed_field: C2RustUnnamed_40 = 117;
pub const JS_ATOM_split: C2RustUnnamed_40 = 93;
pub const JS_ATOM_defineProperties: C2RustUnnamed_40 = 89;
pub const JS_ATOM_integer: C2RustUnnamed_40 = 75;
pub const JS_ATOM_public: C2RustUnnamed_40 = 43;
pub const JS_ATOM_protected: C2RustUnnamed_40 = 42;
pub const JS_ATOM_private: C2RustUnnamed_40 = 41;
pub const JS_ATOM_package: C2RustUnnamed_40 = 40;
pub const JS_ATOM_interface: C2RustUnnamed_40 = 38;
pub const JS_ATOM_implements: C2RustUnnamed_40 = 37;
pub const JS_ATOM_import: C2RustUnnamed_40 = 35;
pub const JS_ATOM_extends: C2RustUnnamed_40 = 34;
pub const JS_ATOM_export: C2RustUnnamed_40 = 33;
pub const JS_ATOM_enum: C2RustUnnamed_40 = 32;
pub const JS_ATOM_const: C2RustUnnamed_40 = 31;
pub const JS_ATOM_class: C2RustUnnamed_40 = 30;
pub const JS_ATOM_with: C2RustUnnamed_40 = 29;
pub const JS_ATOM_debugger: C2RustUnnamed_40 = 28;
pub const JS_ATOM_finally: C2RustUnnamed_40 = 26;
pub const JS_ATOM_catch: C2RustUnnamed_40 = 25;
pub const JS_ATOM_try: C2RustUnnamed_40 = 24;
pub const JS_ATOM_case: C2RustUnnamed_40 = 21;
pub const JS_ATOM_switch: C2RustUnnamed_40 = 20;
pub const JS_ATOM_continue: C2RustUnnamed_40 = 19;
pub const JS_ATOM_break: C2RustUnnamed_40 = 18;
pub const JS_ATOM_for: C2RustUnnamed_40 = 17;
pub const JS_ATOM_while: C2RustUnnamed_40 = 16;
pub const JS_ATOM_do: C2RustUnnamed_40 = 15;
pub const JS_ATOM_instanceof: C2RustUnnamed_40 = 14;
pub const JS_ATOM_in: C2RustUnnamed_40 = 13;
pub const JS_ATOM_new: C2RustUnnamed_40 = 12;
pub const JS_ATOM_typeof: C2RustUnnamed_40 = 11;
pub const JS_ATOM_void: C2RustUnnamed_40 = 10;
pub const JS_ATOM_delete: C2RustUnnamed_40 = 9;
pub const JS_ATOM_var: C2RustUnnamed_40 = 7;
pub const JS_ATOM_else: C2RustUnnamed_40 = 5;
pub const JS_ATOM_if: C2RustUnnamed_40 = 4;
pub const __JS_ATOM_NULL: C2RustUnnamed_40 = 0;
pub type OPCodeFormat = libc::c_uint;
pub type C2RustUnnamed_41 = libc::c_uint;
pub type C2RustUnnamed_42 = libc::c_int;
pub const TOK_IMPLEMENTS: C2RustUnnamed_42 = -49;
pub const TOK_GT: C2RustUnnamed_42 = -101;
pub const TOK_LT: C2RustUnnamed_42 = -103;
pub type BCTagEnum = libc::c_uint;
pub const BC_TAG_BIG_DECIMAL: BCTagEnum = 12;
pub const BC_TAG_BIG_FLOAT: BCTagEnum = 11;
pub const BC_TAG_BIG_INT: BCTagEnum = 10;
pub type C2RustUnnamed_43 = libc::c_uint;
#[inline]
unsafe extern "C" fn max_int(mut a: libc::c_int, mut b: libc::c_int) -> libc::c_int {
    if a > b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn min_int(mut a: libc::c_int, mut b: libc::c_int) -> libc::c_int {
    if a < b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn max_uint32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    if a > b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn min_uint32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    if a < b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn max_int64(mut a: int64_t, mut b: int64_t) -> int64_t {
    if a > b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn min_int64(mut a: int64_t, mut b: int64_t) -> int64_t {
    if a < b { return a } else { return b };
}
#[inline]
unsafe extern "C" fn clz32(mut a: libc::c_uint) -> libc::c_int {
    return a.leading_zeros() as i32;
}
#[inline]
unsafe extern "C" fn get_u64(mut tab: *const uint8_t) -> uint64_t {
    return (*(tab as *const packed_u64)).v;
}
#[inline]
unsafe extern "C" fn put_u64(mut tab: *mut uint8_t, mut val: uint64_t) {
    (*(tab as *mut packed_u64)).v = val;
}
#[inline]
unsafe extern "C" fn get_u32(mut tab: *const uint8_t) -> uint32_t {
    return (*(tab as *const packed_u32)).v;
}
#[inline]
unsafe extern "C" fn get_i32(mut tab: *const uint8_t) -> int32_t {
    return (*(tab as *const packed_u32)).v as int32_t;
}
#[inline]
unsafe extern "C" fn put_u32(mut tab: *mut uint8_t, mut val: uint32_t) {
    (*(tab as *mut packed_u32)).v = val;
}
#[inline]
unsafe extern "C" fn get_u16(mut tab: *const uint8_t) -> uint32_t {
    return (*(tab as *const packed_u16)).v as uint32_t;
}
#[inline]
unsafe extern "C" fn get_i16(mut tab: *const uint8_t) -> int32_t {
    return (*(tab as *const packed_u16)).v as int16_t as int32_t;
}
#[inline]
unsafe extern "C" fn put_u16(mut tab: *mut uint8_t, mut val: uint16_t) {
    (*(tab as *mut packed_u16)).v = val;
}
#[inline]
unsafe extern "C" fn get_u8(mut tab: *const uint8_t) -> uint32_t {
    return *tab as uint32_t;
}
#[inline]
unsafe extern "C" fn get_i8(mut tab: *const uint8_t) -> int32_t {
    return *tab as int8_t as int32_t;
}
#[inline]
unsafe extern "C" fn put_u8(mut tab: *mut uint8_t, mut val: uint8_t) {
    *tab = val;
}
#[inline]
unsafe extern "C" fn bswap16(mut x: uint16_t) -> uint16_t {
    return (x as libc::c_int >> 8 as libc::c_int
        | (x as libc::c_int) << 8 as libc::c_int) as uint16_t;
}
#[inline]
unsafe extern "C" fn bswap32(mut v: uint32_t) -> uint32_t {
    return (v & 0xff000000 as libc::c_uint) >> 24 as libc::c_int
        | (v & 0xff0000 as libc::c_int as libc::c_uint) >> 8 as libc::c_int
        | (v & 0xff00 as libc::c_int as libc::c_uint) << 8 as libc::c_int
        | (v & 0xff as libc::c_int as libc::c_uint) << 24 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bswap64(mut v: uint64_t) -> uint64_t {
    return (v & (0xff as libc::c_int as uint64_t) << 7 as libc::c_int * 8 as libc::c_int)
        >> 7 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 6 as libc::c_int * 8 as libc::c_int)
            >> 5 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 5 as libc::c_int * 8 as libc::c_int)
            >> 3 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 4 as libc::c_int * 8 as libc::c_int)
            >> 1 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 3 as libc::c_int * 8 as libc::c_int)
            << 1 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 2 as libc::c_int * 8 as libc::c_int)
            << 3 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 1 as libc::c_int * 8 as libc::c_int)
            << 5 as libc::c_int * 8 as libc::c_int
        | (v & (0xff as libc::c_int as uint64_t) << 0 as libc::c_int * 8 as libc::c_int)
            << 7 as libc::c_int * 8 as libc::c_int;
}
#[inline]
unsafe extern "C" fn dbuf_put_u16(mut s: *mut DynBuf, mut val: uint16_t) -> libc::c_int {
    return dbuf_put(
        s,
        &mut val as *mut uint16_t as *mut uint8_t,
        2 as libc::c_int as size_t,
    );
}
#[inline]
unsafe extern "C" fn dbuf_put_u32(mut s: *mut DynBuf, mut val: uint32_t) -> libc::c_int {
    return dbuf_put(
        s,
        &mut val as *mut uint32_t as *mut uint8_t,
        4 as libc::c_int as size_t,
    );
}
#[inline]
unsafe extern "C" fn dbuf_error(mut s: *mut DynBuf) -> BOOL {
    return (*s).error;
}
#[inline]
unsafe extern "C" fn from_hex(mut c: libc::c_int) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        return c - '0' as i32
    } else if c >= 'A' as i32 && c <= 'F' as i32 {
        return c - 'A' as i32 + 10 as libc::c_int
    } else if c >= 'a' as i32 && c <= 'f' as i32 {
        return c - 'a' as i32 + 10 as libc::c_int
    } else {
        return -(1 as libc::c_int)
    };
}
#[inline]
unsafe extern "C" fn init_list_head(mut head: *mut list_head) {
    let ref mut fresh0 = (*head).prev;
    *fresh0 = head;
    let ref mut fresh1 = (*head).next;
    *fresh1 = head;
}
#[inline]
unsafe extern "C" fn __list_add(
    mut el: *mut list_head,
    mut prev: *mut list_head,
    mut next: *mut list_head,
) {
    let ref mut fresh2 = (*prev).next;
    *fresh2 = el;
    let ref mut fresh3 = (*el).prev;
    *fresh3 = prev;
    let ref mut fresh4 = (*el).next;
    *fresh4 = next;
    let ref mut fresh5 = (*next).prev;
    *fresh5 = el;
}
#[inline]
unsafe extern "C" fn list_add(mut el: *mut list_head, mut head: *mut list_head) {
    __list_add(el, head, (*head).next);
}
#[inline]
unsafe extern "C" fn list_add_tail(mut el: *mut list_head, mut head: *mut list_head) {
    __list_add(el, (*head).prev, head);
}
#[inline]
unsafe extern "C" fn list_del(mut el: *mut list_head) {
    let mut prev: *mut list_head = 0 as *mut list_head;
    let mut next: *mut list_head = 0 as *mut list_head;
    prev = (*el).prev;
    next = (*el).next;
    let ref mut fresh6 = (*prev).next;
    *fresh6 = next;
    let ref mut fresh7 = (*next).prev;
    *fresh7 = prev;
    let ref mut fresh8 = (*el).prev;
    *fresh8 = 0 as *mut list_head;
    let ref mut fresh9 = (*el).next;
    *fresh9 = 0 as *mut list_head;
}
#[inline]
unsafe extern "C" fn list_empty(mut el: *mut list_head) -> libc::c_int {
    return ((*el).next == el) as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_VALUE_GET_FLOAT64(mut v: JSValue) -> libc::c_double {
    let mut u: C2RustUnnamed_18 = C2RustUnnamed_18 { v: 0 };
    u.v = v;
    u
        .v = (u.v as libc::c_ulonglong)
        .wrapping_add(
            ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int + 1 as libc::c_int)
                as uint64_t) << 32 as libc::c_int,
        ) as JSValue as JSValue;
    return u.d;
}
#[inline]
unsafe extern "C" fn __JS_NewFloat64(
    mut ctx: *mut JSContext,
    mut d: libc::c_double,
) -> JSValue {
    let mut u: C2RustUnnamed_19 = C2RustUnnamed_19 { d: 0. };
    let mut v: JSValue = 0;
    u.d = d;
    if (u.u64_0 & 0x7fffffffffffffff as libc::c_longlong as libc::c_ulonglong
        > 0x7ff0000000000000 as libc::c_longlong as libc::c_ulonglong) as libc::c_int
        as libc::c_long != 0
    {
        v = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    } else {
        v = (u.u64_0)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    }
    return v;
}
#[inline]
unsafe extern "C" fn JS_VALUE_GET_NORM_TAG(mut v: JSValue) -> libc::c_int {
    let mut tag: uint32_t = 0;
    tag = (v >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
        >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int) as libc::c_uint
    {
        return JS_TAG_FLOAT64 as libc::c_int
    } else {
        return tag as libc::c_int
    };
}
#[inline]
unsafe extern "C" fn JS_VALUE_IS_NAN(mut v: JSValue) -> libc::c_int {
    let mut tag: uint32_t = 0;
    tag = (v >> 32 as libc::c_int) as libc::c_int as uint32_t;
    return (tag as libc::c_ulonglong
        == (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            ) >> 32 as libc::c_int) as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn JS_NewBool(
    mut ctx: *mut JSContext,
    mut val: libc::c_int,
) -> JSValue {
    return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
        | (val != 0 as libc::c_int) as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[inline(always)]
unsafe extern "C" fn JS_NewInt32(mut ctx: *mut JSContext, mut val: int32_t) -> JSValue {
    return (JS_TAG_INT as libc::c_int as uint64_t) << 32 as libc::c_int
        | val as uint32_t as libc::c_ulonglong;
}
#[inline(always)]
unsafe extern "C" fn JS_NewCatchOffset(
    mut ctx: *mut JSContext,
    mut val: int32_t,
) -> JSValue {
    return (JS_TAG_CATCH_OFFSET as libc::c_int as uint64_t) << 32 as libc::c_int
        | val as uint32_t as libc::c_ulonglong;
}
#[inline(always)]
unsafe extern "C" fn JS_NewInt64(mut ctx: *mut JSContext, mut val: int64_t) -> JSValue {
    let mut v: JSValue = 0;
    if val == val as int32_t as libc::c_longlong {
        v = JS_NewInt32(ctx, val as int32_t);
    } else {
        v = __JS_NewFloat64(ctx, val as libc::c_double);
    }
    return v;
}
#[inline(always)]
unsafe extern "C" fn JS_NewUint32(
    mut ctx: *mut JSContext,
    mut val: uint32_t,
) -> JSValue {
    let mut v: JSValue = 0;
    if val <= 0x7fffffff as libc::c_int as libc::c_uint {
        v = JS_NewInt32(ctx, val as int32_t);
    } else {
        v = __JS_NewFloat64(ctx, val as libc::c_double);
    }
    return v;
}
#[inline(always)]
unsafe extern "C" fn JS_NewFloat64(
    mut ctx: *mut JSContext,
    mut d: libc::c_double,
) -> JSValue {
    let mut v: JSValue = 0;
    let mut val: int32_t = 0;
    let mut u: C2RustUnnamed_20 = C2RustUnnamed_20 { d: 0. };
    let mut t: C2RustUnnamed_20 = C2RustUnnamed_20 { d: 0. };
    u.d = d;
    val = d as int32_t;
    t.d = val as libc::c_double;
    if u.u == t.u {
        v = (JS_TAG_INT as libc::c_int as uint64_t) << 32 as libc::c_int
            | val as uint32_t as libc::c_ulonglong;
    } else {
        v = __JS_NewFloat64(ctx, d);
    }
    return v;
}
#[inline]
unsafe extern "C" fn JS_IsNumber(mut v: JSValue) -> libc::c_int {
    let mut tag: libc::c_int = (v >> 32 as libc::c_int) as libc::c_int;
    return (tag == JS_TAG_INT as libc::c_int
        || (tag - JS_TAG_FIRST as libc::c_int) as libc::c_uint
            >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int)
                as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsBigInt(
    mut ctx: *mut JSContext,
    mut v: JSValue,
) -> libc::c_int {
    let mut tag: libc::c_int = (v >> 32 as libc::c_int) as libc::c_int;
    return (tag == JS_TAG_BIG_INT as libc::c_int) as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsNull(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_NULL as libc::c_int)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsUndefined(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_UNDEFINED as libc::c_int)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsException(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_EXCEPTION as libc::c_int)
        as libc::c_int as libc::c_long as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsUninitialized(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int
        == JS_TAG_UNINITIALIZED as libc::c_int) as libc::c_int as libc::c_long
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsString(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_STRING as libc::c_int)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsSymbol(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_SYMBOL as libc::c_int)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_IsObject(mut v: JSValue) -> libc::c_int {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_FreeValue(mut ctx: *mut JSContext, mut v: JSValue) {
    if (v >> 32 as libc::c_int) as libc::c_int as libc::c_uint
        >= JS_TAG_FIRST as libc::c_int as libc::c_uint
    {
        let mut p: *mut JSRefCountHeader = v as intptr_t as *mut libc::c_void
            as *mut JSRefCountHeader;
        let ref mut fresh10 = (*p).ref_count;
        *fresh10 -= 1;
        if *fresh10 <= 0 as libc::c_int {
            __JS_FreeValue(ctx, v);
        }
    }
}
#[inline]
unsafe extern "C" fn JS_FreeValueRT(mut rt: *mut JSRuntime, mut v: JSValue) {
    if (v >> 32 as libc::c_int) as libc::c_int as libc::c_uint
        >= JS_TAG_FIRST as libc::c_int as libc::c_uint
    {
        let mut p: *mut JSRefCountHeader = v as intptr_t as *mut libc::c_void
            as *mut JSRefCountHeader;
        let ref mut fresh11 = (*p).ref_count;
        *fresh11 -= 1;
        if *fresh11 <= 0 as libc::c_int {
            __JS_FreeValueRT(rt, v);
        }
    }
}
#[inline]
unsafe extern "C" fn JS_DupValue(mut ctx: *mut JSContext, mut v: JSValue) -> JSValue {
    if (v >> 32 as libc::c_int) as libc::c_int as libc::c_uint
        >= JS_TAG_FIRST as libc::c_int as libc::c_uint
    {
        let mut p: *mut JSRefCountHeader = v as intptr_t as *mut libc::c_void
            as *mut JSRefCountHeader;
        let ref mut fresh12 = (*p).ref_count;
        *fresh12 += 1;
    }
    return v;
}
#[inline]
unsafe extern "C" fn JS_DupValueRT(mut rt: *mut JSRuntime, mut v: JSValue) -> JSValue {
    if (v >> 32 as libc::c_int) as libc::c_int as libc::c_uint
        >= JS_TAG_FIRST as libc::c_int as libc::c_uint
    {
        let mut p: *mut JSRefCountHeader = v as intptr_t as *mut libc::c_void
            as *mut JSRefCountHeader;
        let ref mut fresh13 = (*p).ref_count;
        *fresh13 += 1;
    }
    return v;
}
#[inline]
unsafe extern "C" fn JS_ToUint32(
    mut ctx: *mut JSContext,
    mut pres: *mut uint32_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt32(ctx, pres as *mut int32_t, val);
}
#[inline]
unsafe extern "C" fn JS_ToCStringLen(
    mut ctx: *mut JSContext,
    mut plen: *mut size_t,
    mut val1: JSValue,
) -> *const libc::c_char {
    return JS_ToCStringLen2(ctx, plen, val1, 0 as libc::c_int);
}
#[inline]
unsafe extern "C" fn JS_ToCString(
    mut ctx: *mut JSContext,
    mut val1: JSValue,
) -> *const libc::c_char {
    return JS_ToCStringLen2(ctx, 0 as *mut size_t, val1, 0 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn JS_GetProperty(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
) -> JSValue {
    return JS_GetPropertyInternal(ctx, this_obj, prop, this_obj, 0 as libc::c_int);
}
#[inline]
unsafe extern "C" fn JS_SetProperty(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
) -> libc::c_int {
    return JS_SetPropertyInternal(
        ctx,
        this_obj,
        prop,
        val,
        (1 as libc::c_int) << 14 as libc::c_int,
    );
}
#[inline]
unsafe extern "C" fn JS_NewCFunction(
    mut ctx: *mut JSContext,
    mut func: Option::<JSCFunction>,
    mut name: *const libc::c_char,
    mut length: libc::c_int,
) -> JSValue {
    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0 as libc::c_int);
}
#[inline]
unsafe extern "C" fn JS_NewCFunctionMagic(
    mut ctx: *mut JSContext,
    mut func: Option::<JSCFunctionMagic>,
    mut name: *const libc::c_char,
    mut length: libc::c_int,
    mut cproto: JSCFunctionEnum,
    mut magic: libc::c_int,
) -> JSValue {
    return JS_NewCFunction2(
        ctx,
        ::core::mem::transmute::<
            Option::<JSCFunctionMagic>,
            Option::<JSCFunction>,
        >(func),
        name,
        length,
        cproto,
        magic,
    );
}
#[inline]
unsafe extern "C" fn lre_js_is_ident_first(mut c: libc::c_int) -> libc::c_int {
    if (c as uint32_t) < 128 as libc::c_int as libc::c_uint {
        return (lre_id_start_table_ascii[(c >> 5 as libc::c_int) as usize]
            >> (c & 31 as libc::c_int) & 1 as libc::c_int as libc::c_uint) as libc::c_int
    } else {
        return lre_is_id_start(c as uint32_t)
    };
}
#[inline]
unsafe extern "C" fn lre_js_is_ident_next(mut c: libc::c_int) -> libc::c_int {
    if (c as uint32_t) < 128 as libc::c_int as libc::c_uint {
        return (lre_id_continue_table_ascii[(c >> 5 as libc::c_int) as usize]
            >> (c & 31 as libc::c_int) & 1 as libc::c_int as libc::c_uint) as libc::c_int
    } else {
        return (lre_is_id_continue(c as uint32_t) != 0 || c == 0x200c as libc::c_int
            || c == 0x200d as libc::c_int) as libc::c_int
    };
}
static mut js_atom_init: [libc::c_char; 1949] = unsafe {
    *::core::mem::transmute::<
        &[u8; 1949],
        &[libc::c_char; 1949],
    >(
        b"null\0false\0true\0if\0else\0return\0var\0this\0delete\0void\0typeof\0new\0in\0instanceof\0do\0while\0for\0break\0continue\0switch\0case\0default\0throw\0try\0catch\0finally\0function\0debugger\0with\0class\0const\0enum\0export\0extends\0import\0super\0implements\0interface\0let\0package\0private\0protected\0public\0static\0yield\0await\0\0length\0fileName\0lineNumber\0message\0errors\0stack\0name\0toString\0toLocaleString\0valueOf\0eval\0prototype\0constructor\0configurable\0writable\0enumerable\0value\0get\0set\0of\0__proto__\0undefined\0number\0boolean\0string\0object\0symbol\0integer\0unknown\0arguments\0callee\0caller\0<eval>\0<ret>\0<var>\0<arg_var>\0<with>\0lastIndex\0target\0index\0input\0defineProperties\0apply\0join\0concat\0split\0construct\0getPrototypeOf\0setPrototypeOf\0isExtensible\0preventExtensions\0has\0deleteProperty\0defineProperty\0getOwnPropertyDescriptor\0ownKeys\0add\0done\0next\0values\0source\0flags\0global\0unicode\0raw\0new.target\0this.active_func\0<home_object>\0<computed_field>\0<static_computed_field>\0<class_fields_init>\0<brand>\0#constructor\0as\0from\0meta\0*default*\0*\0Module\0then\0resolve\0reject\0promise\0proxy\0revoke\0async\0exec\0groups\0status\0reason\0globalThis\0toJSON\0Object\0Array\0Error\0Number\0String\0Boolean\0Symbol\0Arguments\0Math\0JSON\0Date\0Function\0GeneratorFunction\0ForInIterator\0RegExp\0ArrayBuffer\0SharedArrayBuffer\0Uint8ClampedArray\0Int8Array\0Uint8Array\0Int16Array\0Uint16Array\0Int32Array\0Uint32Array\0Float32Array\0Float64Array\0DataView\0Map\0Set\0WeakMap\0WeakSet\0Map Iterator\0Set Iterator\0Array Iterator\0String Iterator\0RegExp String Iterator\0Generator\0Proxy\0Promise\0PromiseResolveFunction\0PromiseRejectFunction\0AsyncFunction\0AsyncFunctionResolve\0AsyncFunctionReject\0AsyncGeneratorFunction\0AsyncGenerator\0EvalError\0RangeError\0ReferenceError\0SyntaxError\0TypeError\0URIError\0InternalError\0<brand>\0Symbol.toPrimitive\0Symbol.iterator\0Symbol.match\0Symbol.matchAll\0Symbol.replace\0Symbol.search\0Symbol.split\0Symbol.toStringTag\0Symbol.isConcatSpreadable\0Symbol.hasInstance\0Symbol.species\0Symbol.unscopables\0Symbol.asyncIterator\0\0",
    )
};
static mut js_class_id_alloc: JSClassID = JS_CLASS_INIT_COUNT as libc::c_int
    as JSClassID;
unsafe extern "C" fn js_trigger_gc(mut rt: *mut JSRuntime, mut size: size_t) {
    let mut force_gc: BOOL = 0;
    force_gc = (((*rt).malloc_state.malloc_size).wrapping_add(size)
        > (*rt).malloc_gc_threshold) as libc::c_int;
    if force_gc != 0 {
        JS_RunGC(rt);
        (*rt)
            .malloc_gc_threshold = ((*rt).malloc_state.malloc_size)
            .wrapping_add((*rt).malloc_state.malloc_size >> 1 as libc::c_int);
    }
}
unsafe extern "C" fn js_malloc_usable_size_unknown(
    mut ptr: *const libc::c_void,
) -> size_t {
    return 0 as libc::c_int as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn js_malloc_rt(
    mut rt: *mut JSRuntime,
    mut size: size_t,
) -> *mut libc::c_void {
    return ((*rt).mf.js_malloc)
        .expect("non-null function pointer")(&mut (*rt).malloc_state, size);
}
#[no_mangle]
pub unsafe extern "C" fn js_free_rt(mut rt: *mut JSRuntime, mut ptr: *mut libc::c_void) {
    ((*rt).mf.js_free).expect("non-null function pointer")(&mut (*rt).malloc_state, ptr);
}
#[no_mangle]
pub unsafe extern "C" fn js_realloc_rt(
    mut rt: *mut JSRuntime,
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    return ((*rt).mf.js_realloc)
        .expect("non-null function pointer")(&mut (*rt).malloc_state, ptr, size);
}
#[no_mangle]
pub unsafe extern "C" fn js_malloc_usable_size_rt(
    mut rt: *mut JSRuntime,
    mut ptr: *const libc::c_void,
) -> size_t {
    return ((*rt).mf.js_malloc_usable_size).expect("non-null function pointer")(ptr);
}
#[no_mangle]
pub unsafe extern "C" fn js_mallocz_rt(
    mut rt: *mut JSRuntime,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    ptr = js_malloc_rt(rt, size);
    if ptr.is_null() {
        return 0 as *mut libc::c_void;
    }
    return memset(ptr, 0 as libc::c_int, size);
}
#[no_mangle]
pub unsafe extern "C" fn js_malloc(
    mut ctx: *mut JSContext,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    ptr = js_malloc_rt((*ctx).rt, size);
    if ptr.is_null() as libc::c_int as libc::c_long != 0 {
        JS_ThrowOutOfMemory(ctx);
        return 0 as *mut libc::c_void;
    }
    return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn js_mallocz(
    mut ctx: *mut JSContext,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    ptr = js_mallocz_rt((*ctx).rt, size);
    if ptr.is_null() as libc::c_int as libc::c_long != 0 {
        JS_ThrowOutOfMemory(ctx);
        return 0 as *mut libc::c_void;
    }
    return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn js_free(mut ctx: *mut JSContext, mut ptr: *mut libc::c_void) {
    js_free_rt((*ctx).rt, ptr);
}
#[no_mangle]
pub unsafe extern "C" fn js_realloc(
    mut ctx: *mut JSContext,
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ret: *mut libc::c_void = 0 as *mut libc::c_void;
    ret = js_realloc_rt((*ctx).rt, ptr, size);
    if (ret.is_null() && size != 0 as libc::c_int as libc::c_ulong) as libc::c_int
        as libc::c_long != 0
    {
        JS_ThrowOutOfMemory(ctx);
        return 0 as *mut libc::c_void;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn js_realloc2(
    mut ctx: *mut JSContext,
    mut ptr: *mut libc::c_void,
    mut size: size_t,
    mut pslack: *mut size_t,
) -> *mut libc::c_void {
    let mut ret: *mut libc::c_void = 0 as *mut libc::c_void;
    ret = js_realloc_rt((*ctx).rt, ptr, size);
    if (ret.is_null() && size != 0 as libc::c_int as libc::c_ulong) as libc::c_int
        as libc::c_long != 0
    {
        JS_ThrowOutOfMemory(ctx);
        return 0 as *mut libc::c_void;
    }
    if !pslack.is_null() {
        let mut new_size: size_t = js_malloc_usable_size_rt((*ctx).rt, ret);
        *pslack = if new_size > size {
            new_size.wrapping_sub(size)
        } else {
            0 as libc::c_int as libc::c_ulong
        };
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn js_malloc_usable_size(
    mut ctx: *mut JSContext,
    mut ptr: *const libc::c_void,
) -> size_t {
    return js_malloc_usable_size_rt((*ctx).rt, ptr);
}
#[no_mangle]
pub unsafe extern "C" fn js_strndup(
    mut ctx: *mut JSContext,
    mut s: *const libc::c_char,
    mut n: size_t,
) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    ptr = js_malloc(ctx, n.wrapping_add(1 as libc::c_int as libc::c_ulong))
        as *mut libc::c_char;
    if !ptr.is_null() {
        memcpy(ptr as *mut libc::c_void, s as *const libc::c_void, n);
        *ptr.offset(n as isize) = '\0' as i32 as libc::c_char;
    }
    return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn js_strdup(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
) -> *mut libc::c_char {
    return js_strndup(ctx, str, strlen(str));
}
#[inline(never)]
unsafe extern "C" fn js_realloc_array(
    mut ctx: *mut JSContext,
    mut parray: *mut *mut libc::c_void,
    mut elem_size: libc::c_int,
    mut psize: *mut libc::c_int,
    mut req_size: libc::c_int,
) -> libc::c_int {
    let mut new_size: libc::c_int = 0;
    let mut slack: size_t = 0;
    let mut new_array: *mut libc::c_void = 0 as *mut libc::c_void;
    new_size = max_int(req_size, *psize * 3 as libc::c_int / 2 as libc::c_int);
    new_array = js_realloc2(ctx, *parray, (new_size * elem_size) as size_t, &mut slack);
    if new_array.is_null() {
        return -(1 as libc::c_int);
    }
    new_size = (new_size as libc::c_ulong)
        .wrapping_add(slack.wrapping_div(elem_size as libc::c_ulong)) as libc::c_int
        as libc::c_int;
    *psize = new_size;
    *parray = new_array;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn js_resize_array(
    mut ctx: *mut JSContext,
    mut parray: *mut *mut libc::c_void,
    mut elem_size: libc::c_int,
    mut psize: *mut libc::c_int,
    mut req_size: libc::c_int,
) -> libc::c_int {
    if (req_size > *psize) as libc::c_int as libc::c_long != 0 {
        return js_realloc_array(ctx, parray, elem_size, psize, req_size)
    } else {
        return 0 as libc::c_int
    };
}
#[inline]
unsafe extern "C" fn js_dbuf_init(mut ctx: *mut JSContext, mut s: *mut DynBuf) {
    dbuf_init2(
        s,
        (*ctx).rt as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut JSRuntime,
                    *mut libc::c_void,
                    size_t,
                ) -> *mut libc::c_void,
            >,
            Option::<DynBufReallocFunc>,
        >(
            Some(
                js_realloc_rt
                    as unsafe extern "C" fn(
                        *mut JSRuntime,
                        *mut libc::c_void,
                        size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
    );
}
#[inline]
unsafe extern "C" fn is_digit(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
static mut js_std_class_def: [JSClassShortDef; 40] = unsafe {
    [
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Object as libc::c_int as JSAtom,
                finalizer: None,
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Error as libc::c_int as JSAtom,
                finalizer: None,
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Number as libc::c_int as JSAtom,
                finalizer: Some(
                    js_object_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_object_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_String as libc::c_int as JSAtom,
                finalizer: Some(
                    js_object_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_object_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Boolean as libc::c_int as JSAtom,
                finalizer: Some(
                    js_object_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_object_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Symbol as libc::c_int as JSAtom,
                finalizer: Some(
                    js_object_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_object_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Arguments as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Arguments as libc::c_int as JSAtom,
                finalizer: None,
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Date as libc::c_int as JSAtom,
                finalizer: Some(
                    js_object_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_object_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Object as libc::c_int as JSAtom,
                finalizer: None,
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Function as libc::c_int as JSAtom,
                finalizer: Some(
                    js_c_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_c_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Function as libc::c_int as JSAtom,
                finalizer: Some(
                    js_bytecode_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_bytecode_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Function as libc::c_int as JSAtom,
                finalizer: Some(
                    js_bound_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_bound_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Function as libc::c_int as JSAtom,
                finalizer: Some(
                    js_c_function_data_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_c_function_data_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_GeneratorFunction as libc::c_int as JSAtom,
                finalizer: Some(
                    js_bytecode_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_bytecode_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_ForInIterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_for_in_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_for_in_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_RegExp as libc::c_int as JSAtom,
                finalizer: Some(
                    js_regexp_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_ArrayBuffer as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_buffer_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_SharedArrayBuffer as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_buffer_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: None,
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Uint8ClampedArray as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Int8Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Uint8Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Int16Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Uint16Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Int32Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Uint32Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Float32Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Float64Array as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_DataView as libc::c_int as JSAtom,
                finalizer: Some(
                    js_typed_array_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_typed_array_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Map as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Set as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_WeakMap as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_WeakSet as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Map_Iterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Set_Iterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_map_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_map_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Array_Iterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_array_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_String_Iterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_array_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_array_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_RegExp_String_Iterator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_regexp_string_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_regexp_string_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Generator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_generator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_generator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
    ]
};
unsafe extern "C" fn init_class_range(
    mut rt: *mut JSRuntime,
    mut tab: *const JSClassShortDef,
    mut start: libc::c_int,
    mut count: libc::c_int,
) -> libc::c_int {
    let mut cm_s: JSClassDef = JSClassDef {
        class_name: 0 as *const libc::c_char,
        finalizer: None,
        gc_mark: None,
        call: None,
        exotic: 0 as *mut JSClassExoticMethods,
    };
    let mut cm: *mut JSClassDef = &mut cm_s;
    let mut i: libc::c_int = 0;
    let mut class_id: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < count {
        class_id = i + start;
        memset(
            cm as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<JSClassDef>() as libc::c_ulong,
        );
        let ref mut fresh14 = (*cm).finalizer;
        *fresh14 = (*tab.offset(i as isize)).finalizer;
        let ref mut fresh15 = (*cm).gc_mark;
        *fresh15 = (*tab.offset(i as isize)).gc_mark;
        if JS_NewClass1(
            rt,
            class_id as JSClassID,
            cm,
            (*tab.offset(i as isize)).class_name,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn js_get_stack_pointer() -> uintptr_t {
    return 0 as libc::c_int as uintptr_t;
}
#[inline]
unsafe extern "C" fn js_check_stack_overflow(
    mut rt: *mut JSRuntime,
    mut alloca_size: size_t,
) -> BOOL {
    return FALSE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewRuntime2(
    mut mf: *const JSMallocFunctions,
    mut opaque: *mut libc::c_void,
) -> *mut JSRuntime {
    let mut rt: *mut JSRuntime = 0 as *mut JSRuntime;
    let mut ms: JSMallocState = JSMallocState {
        malloc_count: 0,
        malloc_size: 0,
        malloc_limit: 0,
        opaque: 0 as *mut libc::c_void,
    };
    memset(
        &mut ms as *mut JSMallocState as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSMallocState>() as libc::c_ulong,
    );
    ms.opaque = opaque;
    ms.malloc_limit = -(1 as libc::c_int) as size_t;
    rt = ((*mf).js_malloc)
        .expect(
            "non-null function pointer",
        )(&mut ms, ::core::mem::size_of::<JSRuntime>() as libc::c_ulong)
        as *mut JSRuntime;
    if rt.is_null() {
        return 0 as *mut JSRuntime;
    }
    memset(
        rt as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSRuntime>() as libc::c_ulong,
    );
    (*rt).mf = *mf;
    if ((*rt).mf.js_malloc_usable_size).is_none() {
        let ref mut fresh16 = (*rt).mf.js_malloc_usable_size;
        *fresh16 = Some(
            js_malloc_usable_size_unknown
                as unsafe extern "C" fn(*const libc::c_void) -> size_t,
        );
    }
    (*rt).malloc_state = ms;
    (*rt).malloc_gc_threshold = (256 as libc::c_int * 1024 as libc::c_int) as size_t;
    init_list_head(&mut (*rt).context_list);
    init_list_head(&mut (*rt).gc_obj_list);
    init_list_head(&mut (*rt).gc_zero_ref_count_list);
    (*rt).set_gc_phase(JS_GC_PHASE_NONE);
    init_list_head(&mut (*rt).job_list);
    if !(JS_InitAtoms(rt) != 0) {
        if !(init_class_range(
            rt,
            js_std_class_def.as_ptr(),
            JS_CLASS_OBJECT as libc::c_int,
            (::core::mem::size_of::<[JSClassShortDef; 40]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<JSClassShortDef>() as libc::c_ulong)
                as libc::c_int,
        ) < 0 as libc::c_int)
        {
            let ref mut fresh17 = (*((*rt).class_array)
                .offset(JS_CLASS_ARGUMENTS as libc::c_int as isize))
                .exotic;
            *fresh17 = &js_arguments_exotic_methods;
            let ref mut fresh18 = (*((*rt).class_array)
                .offset(JS_CLASS_STRING as libc::c_int as isize))
                .exotic;
            *fresh18 = &js_string_exotic_methods;
            let ref mut fresh19 = (*((*rt).class_array)
                .offset(JS_CLASS_MODULE_NS as libc::c_int as isize))
                .exotic;
            *fresh19 = &js_module_ns_exotic_methods;
            let ref mut fresh20 = (*((*rt).class_array)
                .offset(JS_CLASS_C_FUNCTION as libc::c_int as isize))
                .call;
            *fresh20 = Some(
                js_call_c_function
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            );
            let ref mut fresh21 = (*((*rt).class_array)
                .offset(JS_CLASS_C_FUNCTION_DATA as libc::c_int as isize))
                .call;
            *fresh21 = Some(
                js_c_function_data_call
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            );
            let ref mut fresh22 = (*((*rt).class_array)
                .offset(JS_CLASS_BOUND_FUNCTION as libc::c_int as isize))
                .call;
            *fresh22 = Some(
                js_call_bound_function
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            );
            let ref mut fresh23 = (*((*rt).class_array)
                .offset(JS_CLASS_GENERATOR_FUNCTION as libc::c_int as isize))
                .call;
            *fresh23 = Some(
                js_generator_function_call
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            );
            if !(init_shape_hash(rt) != 0) {
                (*rt)
                    .stack_size = (256 as libc::c_int * 1024 as libc::c_int)
                    as uintptr_t;
                JS_UpdateStackTop(rt);
                (*rt)
                    .current_exception = (JS_TAG_NULL as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                return rt;
            }
        }
    }
    JS_FreeRuntime(rt);
    return 0 as *mut JSRuntime;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetRuntimeOpaque(
    mut rt: *mut JSRuntime,
) -> *mut libc::c_void {
    return (*rt).user_opaque;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetRuntimeOpaque(
    mut rt: *mut JSRuntime,
    mut opaque: *mut libc::c_void,
) {
    let ref mut fresh24 = (*rt).user_opaque;
    *fresh24 = opaque;
}
#[inline]
unsafe extern "C" fn js_def_malloc_usable_size(mut ptr: *mut libc::c_void) -> size_t {
    return 0 as libc::c_int as size_t;
}
unsafe extern "C" fn js_def_malloc(
    mut s: *mut JSMallocState,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    assert((size != 0 as libc::c_int as libc::c_ulong) as libc::c_int);
    if (((*s).malloc_size).wrapping_add(size) > (*s).malloc_limit) as libc::c_int
        as libc::c_long != 0
    {
        return 0 as *mut libc::c_void;
    }
    ptr = malloc(size);
    if ptr.is_null() {
        return 0 as *mut libc::c_void;
    }
    let ref mut fresh25 = (*s).malloc_count;
    *fresh25 = (*fresh25).wrapping_add(1);
    let ref mut fresh26 = (*s).malloc_size;
    *fresh26 = (*fresh26 as libc::c_ulong)
        .wrapping_add(
            (js_def_malloc_usable_size(ptr))
                .wrapping_add(8 as libc::c_int as libc::c_ulong),
        ) as size_t as size_t;
    return ptr;
}
unsafe extern "C" fn js_def_free(mut s: *mut JSMallocState, mut ptr: *mut libc::c_void) {
    if ptr.is_null() {
        return;
    }
    let ref mut fresh27 = (*s).malloc_count;
    *fresh27 = (*fresh27).wrapping_sub(1);
    let ref mut fresh28 = (*s).malloc_size;
    *fresh28 = (*fresh28 as libc::c_ulong)
        .wrapping_sub(
            (js_def_malloc_usable_size(ptr))
                .wrapping_add(8 as libc::c_int as libc::c_ulong),
        ) as size_t as size_t;
    free(ptr);
}
unsafe extern "C" fn js_def_realloc(
    mut s: *mut JSMallocState,
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut old_size: size_t = 0;
    if ptr.is_null() {
        if size == 0 as libc::c_int as libc::c_ulong {
            return 0 as *mut libc::c_void;
        }
        return js_def_malloc(s, size);
    }
    old_size = js_def_malloc_usable_size(ptr);
    if size == 0 as libc::c_int as libc::c_ulong {
        let ref mut fresh29 = (*s).malloc_count;
        *fresh29 = (*fresh29).wrapping_sub(1);
        let ref mut fresh30 = (*s).malloc_size;
        *fresh30 = (*fresh30 as libc::c_ulong)
            .wrapping_sub(old_size.wrapping_add(8 as libc::c_int as libc::c_ulong))
            as size_t as size_t;
        free(ptr);
        return 0 as *mut libc::c_void;
    }
    if ((*s).malloc_size).wrapping_add(size).wrapping_sub(old_size) > (*s).malloc_limit {
        return 0 as *mut libc::c_void;
    }
    ptr = realloc(ptr, size);
    if ptr.is_null() {
        return 0 as *mut libc::c_void;
    }
    let ref mut fresh31 = (*s).malloc_size;
    *fresh31 = (*fresh31 as libc::c_ulong)
        .wrapping_add((js_def_malloc_usable_size(ptr)).wrapping_sub(old_size)) as size_t
        as size_t;
    return ptr;
}
static mut def_malloc_funcs: JSMallocFunctions = unsafe {
    {
        let mut init = JSMallocFunctions {
            js_malloc: Some(
                js_def_malloc
                    as unsafe extern "C" fn(
                        *mut JSMallocState,
                        size_t,
                    ) -> *mut libc::c_void,
            ),
            js_free: Some(
                js_def_free
                    as unsafe extern "C" fn(*mut JSMallocState, *mut libc::c_void) -> (),
            ),
            js_realloc: Some(
                js_def_realloc
                    as unsafe extern "C" fn(
                        *mut JSMallocState,
                        *mut libc::c_void,
                        size_t,
                    ) -> *mut libc::c_void,
            ),
            js_malloc_usable_size: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn JS_NewRuntime() -> *mut JSRuntime {
    return JS_NewRuntime2(&def_malloc_funcs, 0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetMemoryLimit(mut rt: *mut JSRuntime, mut limit: size_t) {
    (*rt).malloc_state.malloc_limit = limit;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetGCThreshold(
    mut rt: *mut JSRuntime,
    mut gc_threshold: size_t,
) {
    (*rt).malloc_gc_threshold = gc_threshold;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetInterruptHandler(
    mut rt: *mut JSRuntime,
    mut cb: Option::<JSInterruptHandler>,
    mut opaque: *mut libc::c_void,
) {
    let ref mut fresh32 = (*rt).interrupt_handler;
    *fresh32 = cb;
    let ref mut fresh33 = (*rt).interrupt_opaque;
    *fresh33 = opaque;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetCanBlock(mut rt: *mut JSRuntime, mut can_block: BOOL) {
    (*rt).set_can_block(can_block);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetSharedArrayBufferFunctions(
    mut rt: *mut JSRuntime,
    mut sf: *const JSSharedArrayBufferFunctions,
) {
    (*rt).sab_funcs = *sf;
}
#[no_mangle]
pub unsafe extern "C" fn JS_EnqueueJob(
    mut ctx: *mut JSContext,
    mut job_func: Option::<JSJobFunc>,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> libc::c_int {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut e: *mut JSJobEntry = 0 as *mut JSJobEntry;
    let mut i: libc::c_int = 0;
    e = js_malloc(
        ctx,
        (::core::mem::size_of::<JSJobEntry>() as libc::c_ulong)
            .wrapping_add(
                (argc as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<JSValue>() as libc::c_ulong),
            ),
    ) as *mut JSJobEntry;
    if e.is_null() {
        return -(1 as libc::c_int);
    }
    let ref mut fresh34 = (*e).ctx;
    *fresh34 = ctx;
    let ref mut fresh35 = (*e).job_func;
    *fresh35 = job_func;
    (*e).argc = argc;
    i = 0 as libc::c_int;
    while i < argc {
        *((*e).argv)
            .as_mut_ptr()
            .offset(i as isize) = JS_DupValue(ctx, *argv.offset(i as isize));
        i += 1;
    }
    list_add_tail(&mut (*e).link, &mut (*rt).job_list);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsJobPending(mut rt: *mut JSRuntime) -> libc::c_int {
    return (list_empty(&mut (*rt).job_list) == 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ExecutePendingJob(
    mut rt: *mut JSRuntime,
    mut pctx: *mut *mut JSContext,
) -> libc::c_int {
    let mut ctx: *mut JSContext = 0 as *mut JSContext;
    let mut e: *mut JSJobEntry = 0 as *mut JSJobEntry;
    let mut res: JSValue = 0;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    if list_empty(&mut (*rt).job_list) != 0 {
        *pctx = 0 as *mut JSContext;
        return 0 as libc::c_int;
    }
    e = ((*rt).job_list.next as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
        as *mut JSJobEntry;
    list_del(&mut (*e).link);
    ctx = (*e).ctx;
    res = ((*e).job_func)
        .expect(
            "non-null function pointer",
        )((*e).ctx, (*e).argc, ((*e).argv).as_mut_ptr());
    i = 0 as libc::c_int;
    while i < (*e).argc {
        JS_FreeValue(ctx, *((*e).argv).as_mut_ptr().offset(i as isize));
        i += 1;
    }
    if JS_IsException(res) != 0 {
        ret = -(1 as libc::c_int);
    } else {
        ret = 1 as libc::c_int;
    }
    JS_FreeValue(ctx, res);
    js_free(ctx, e as *mut libc::c_void);
    *pctx = ctx;
    return ret;
}
#[inline]
unsafe extern "C" fn atom_get_free(mut p: *const JSAtomStruct) -> uint32_t {
    return p as uintptr_t >> 1 as libc::c_int;
}
#[inline]
unsafe extern "C" fn atom_is_free(mut p: *const JSAtomStruct) -> BOOL {
    return (p as uintptr_t & 1 as libc::c_int as libc::c_uint) as BOOL;
}
#[inline]
unsafe extern "C" fn atom_set_free(mut v: uint32_t) -> *mut JSAtomStruct {
    return (v << 1 as libc::c_int | 1 as libc::c_int as libc::c_uint)
        as *mut JSAtomStruct;
}
unsafe extern "C" fn js_alloc_string_rt(
    mut rt: *mut JSRuntime,
    mut max_len: libc::c_int,
    mut is_wide_char: libc::c_int,
) -> *mut JSString {
    let mut str: *mut JSString = 0 as *mut JSString;
    str = js_malloc_rt(
        rt,
        (::core::mem::size_of::<JSString>() as libc::c_ulong)
            .wrapping_add((max_len << is_wide_char) as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_sub(is_wide_char as libc::c_ulong),
    ) as *mut JSString;
    if str.is_null() as libc::c_int as libc::c_long != 0 {
        return 0 as *mut JSString;
    }
    (*str).header.ref_count = 1 as libc::c_int;
    (*str).set_is_wide_char(is_wide_char as uint8_t);
    (*str).set_len(max_len as uint32_t);
    (*str).set_atom_type(0 as libc::c_int as uint8_t);
    (*str).set_hash(0 as libc::c_int as uint32_t);
    (*str).hash_next = 0 as libc::c_int as uint32_t;
    return str;
}
unsafe extern "C" fn js_alloc_string(
    mut ctx: *mut JSContext,
    mut max_len: libc::c_int,
    mut is_wide_char: libc::c_int,
) -> *mut JSString {
    let mut p: *mut JSString = 0 as *mut JSString;
    p = js_alloc_string_rt((*ctx).rt, max_len, is_wide_char);
    if p.is_null() as libc::c_int as libc::c_long != 0 {
        JS_ThrowOutOfMemory(ctx);
        return 0 as *mut JSString;
    }
    return p;
}
#[inline]
unsafe extern "C" fn js_free_string(mut rt: *mut JSRuntime, mut str: *mut JSString) {
    let ref mut fresh36 = (*str).header.ref_count;
    *fresh36 -= 1;
    if *fresh36 <= 0 as libc::c_int {
        if (*str).atom_type() != 0 {
            JS_FreeAtomStruct(rt, str);
        } else {
            js_free_rt(rt, str as *mut libc::c_void);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetRuntimeInfo(
    mut rt: *mut JSRuntime,
    mut s: *const libc::c_char,
) {
    if !rt.is_null() {
        let ref mut fresh37 = (*rt).rt_info;
        *fresh37 = s;
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_FreeRuntime(mut rt: *mut JSRuntime) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut i: libc::c_int = 0;
    JS_FreeValueRT(rt, (*rt).current_exception);
    el = (*rt).job_list.next;
    el1 = (*el).next;
    while el != &mut (*rt).job_list as *mut list_head {
        let mut e: *mut JSJobEntry = (el as *mut uint8_t)
            .offset(-(0 as libc::c_ulong as isize)) as *mut JSJobEntry;
        i = 0 as libc::c_int;
        while i < (*e).argc {
            JS_FreeValueRT(rt, *((*e).argv).as_mut_ptr().offset(i as isize));
            i += 1;
        }
        js_free_rt(rt, e as *mut libc::c_void);
        el = el1;
        el1 = (*el).next;
    }
    init_list_head(&mut (*rt).job_list);
    JS_RunGC(rt);
    assert(list_empty(&mut (*rt).gc_obj_list));
    i = 0 as libc::c_int;
    while i < (*rt).class_count {
        let mut cl: *mut JSClass = &mut *((*rt).class_array).offset(i as isize)
            as *mut JSClass;
        if (*cl).class_id != 0 as libc::c_int as libc::c_uint {
            JS_FreeAtomRT(rt, (*cl).class_name);
        }
        i += 1;
    }
    js_free_rt(rt, (*rt).class_array as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*rt).atom_size {
        let mut p: *mut JSAtomStruct = *((*rt).atom_array).offset(i as isize);
        if atom_is_free(p) == 0 {
            js_free_rt(rt, p as *mut libc::c_void);
        }
        i += 1;
    }
    js_free_rt(rt, (*rt).atom_array as *mut libc::c_void);
    js_free_rt(rt, (*rt).atom_hash as *mut libc::c_void);
    js_free_rt(rt, (*rt).shape_hash as *mut libc::c_void);
    let mut ms: JSMallocState = (*rt).malloc_state;
    ((*rt).mf.js_free)
        .expect("non-null function pointer")(&mut ms, rt as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewContextRaw(mut rt: *mut JSRuntime) -> *mut JSContext {
    let mut ctx: *mut JSContext = 0 as *mut JSContext;
    let mut i: libc::c_int = 0;
    ctx = js_mallocz_rt(rt, ::core::mem::size_of::<JSContext>() as libc::c_ulong)
        as *mut JSContext;
    if ctx.is_null() {
        return 0 as *mut JSContext;
    }
    (*ctx).header.ref_count = 1 as libc::c_int;
    add_gc_object(rt, &mut (*ctx).header, JS_GC_OBJ_TYPE_JS_CONTEXT);
    let ref mut fresh38 = (*ctx).class_proto;
    *fresh38 = js_malloc_rt(
        rt,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul((*rt).class_count as libc::c_ulong),
    ) as *mut JSValue;
    if ((*ctx).class_proto).is_null() {
        js_free_rt(rt, ctx as *mut libc::c_void);
        return 0 as *mut JSContext;
    }
    let ref mut fresh39 = (*ctx).rt;
    *fresh39 = rt;
    list_add_tail(&mut (*ctx).link, &mut (*rt).context_list);
    i = 0 as libc::c_int;
    while i < (*rt).class_count {
        *((*ctx).class_proto)
            .offset(
                i as isize,
            ) = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        i += 1;
    }
    (*ctx)
        .array_ctor = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*ctx)
        .regexp_ctor = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*ctx)
        .promise_ctor = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    init_list_head(&mut (*ctx).loaded_modules);
    JS_AddIntrinsicBasicObjects(ctx);
    return ctx;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewContext(mut rt: *mut JSRuntime) -> *mut JSContext {
    let mut ctx: *mut JSContext = 0 as *mut JSContext;
    ctx = JS_NewContextRaw(rt);
    if ctx.is_null() {
        return 0 as *mut JSContext;
    }
    JS_AddIntrinsicBaseObjects(ctx);
    JS_AddIntrinsicDate(ctx);
    JS_AddIntrinsicEval(ctx);
    JS_AddIntrinsicStringNormalize(ctx);
    JS_AddIntrinsicRegExp(ctx);
    JS_AddIntrinsicJSON(ctx);
    JS_AddIntrinsicProxy(ctx);
    JS_AddIntrinsicMapSet(ctx);
    JS_AddIntrinsicTypedArrays(ctx);
    JS_AddIntrinsicPromise(ctx);
    return ctx;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetContextOpaque(
    mut ctx: *mut JSContext,
) -> *mut libc::c_void {
    return (*ctx).user_opaque;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetContextOpaque(
    mut ctx: *mut JSContext,
    mut opaque: *mut libc::c_void,
) {
    let ref mut fresh40 = (*ctx).user_opaque;
    *fresh40 = opaque;
}
#[inline]
unsafe extern "C" fn set_value(
    mut ctx: *mut JSContext,
    mut pval: *mut JSValue,
    mut new_val: JSValue,
) {
    let mut old_val: JSValue = 0;
    old_val = *pval;
    *pval = new_val;
    JS_FreeValue(ctx, old_val);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetClassProto(
    mut ctx: *mut JSContext,
    mut class_id: JSClassID,
    mut obj: JSValue,
) {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    assert((class_id < (*rt).class_count as libc::c_uint) as libc::c_int);
    set_value(ctx, &mut *((*ctx).class_proto).offset(class_id as isize), obj);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetClassProto(
    mut ctx: *mut JSContext,
    mut class_id: JSClassID,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    assert((class_id < (*rt).class_count as libc::c_uint) as libc::c_int);
    return JS_DupValue(ctx, *((*ctx).class_proto).offset(class_id as isize));
}
unsafe extern "C" fn js_free_modules(
    mut ctx: *mut JSContext,
    mut flag: JSFreeModuleEnum,
) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    el = (*ctx).loaded_modules.next;
    el1 = (*el).next;
    while el != &mut (*ctx).loaded_modules as *mut list_head {
        let mut m: *mut JSModuleDef = (el as *mut uint8_t)
            .offset(-(8 as libc::c_ulong as isize)) as *mut JSModuleDef;
        if flag as libc::c_uint == JS_FREE_MODULE_ALL as libc::c_int as libc::c_uint
            || flag as libc::c_uint
                == JS_FREE_MODULE_NOT_RESOLVED as libc::c_int as libc::c_uint
                && (*m).resolved() == 0
            || flag as libc::c_uint
                == JS_FREE_MODULE_NOT_EVALUATED as libc::c_int as libc::c_uint
                && (*m).evaluated() == 0
        {
            js_free_module_def(ctx, m);
        }
        el = el1;
        el1 = (*el).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_DupContext(mut ctx: *mut JSContext) -> *mut JSContext {
    let ref mut fresh41 = (*ctx).header.ref_count;
    *fresh41 += 1;
    return ctx;
}
unsafe extern "C" fn JS_MarkContext(
    mut rt: *mut JSRuntime,
    mut ctx: *mut JSContext,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut i: libc::c_int = 0;
    let mut el: *mut list_head = 0 as *mut list_head;
    el = (*ctx).loaded_modules.next;
    while el != &mut (*ctx).loaded_modules as *mut list_head {
        let mut m: *mut JSModuleDef = (el as *mut uint8_t)
            .offset(-(8 as libc::c_ulong as isize)) as *mut JSModuleDef;
        js_mark_module_def(rt, m, mark_func);
        el = (*el).next;
    }
    JS_MarkValue(rt, (*ctx).global_obj, mark_func);
    JS_MarkValue(rt, (*ctx).global_var_obj, mark_func);
    JS_MarkValue(rt, (*ctx).throw_type_error, mark_func);
    JS_MarkValue(rt, (*ctx).eval_obj, mark_func);
    JS_MarkValue(rt, (*ctx).array_proto_values, mark_func);
    i = 0 as libc::c_int;
    while i < JS_NATIVE_ERROR_COUNT as libc::c_int {
        JS_MarkValue(rt, (*ctx).native_error_proto[i as usize], mark_func);
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*rt).class_count {
        JS_MarkValue(rt, *((*ctx).class_proto).offset(i as isize), mark_func);
        i += 1;
    }
    JS_MarkValue(rt, (*ctx).iterator_proto, mark_func);
    JS_MarkValue(rt, (*ctx).async_iterator_proto, mark_func);
    JS_MarkValue(rt, (*ctx).promise_ctor, mark_func);
    JS_MarkValue(rt, (*ctx).array_ctor, mark_func);
    JS_MarkValue(rt, (*ctx).regexp_ctor, mark_func);
    JS_MarkValue(rt, (*ctx).function_ctor, mark_func);
    JS_MarkValue(rt, (*ctx).function_proto, mark_func);
    if !((*ctx).array_shape).is_null() {
        mark_func
            .expect("non-null function pointer")(rt, &mut (*(*ctx).array_shape).header);
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_FreeContext(mut ctx: *mut JSContext) {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut i: libc::c_int = 0;
    let ref mut fresh42 = (*ctx).header.ref_count;
    *fresh42 -= 1;
    if *fresh42 > 0 as libc::c_int {
        return;
    }
    assert(((*ctx).header.ref_count == 0 as libc::c_int) as libc::c_int);
    js_free_modules(ctx, JS_FREE_MODULE_ALL);
    JS_FreeValue(ctx, (*ctx).global_obj);
    JS_FreeValue(ctx, (*ctx).global_var_obj);
    JS_FreeValue(ctx, (*ctx).throw_type_error);
    JS_FreeValue(ctx, (*ctx).eval_obj);
    JS_FreeValue(ctx, (*ctx).array_proto_values);
    i = 0 as libc::c_int;
    while i < JS_NATIVE_ERROR_COUNT as libc::c_int {
        JS_FreeValue(ctx, (*ctx).native_error_proto[i as usize]);
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*rt).class_count {
        JS_FreeValue(ctx, *((*ctx).class_proto).offset(i as isize));
        i += 1;
    }
    js_free_rt(rt, (*ctx).class_proto as *mut libc::c_void);
    JS_FreeValue(ctx, (*ctx).iterator_proto);
    JS_FreeValue(ctx, (*ctx).async_iterator_proto);
    JS_FreeValue(ctx, (*ctx).promise_ctor);
    JS_FreeValue(ctx, (*ctx).array_ctor);
    JS_FreeValue(ctx, (*ctx).regexp_ctor);
    JS_FreeValue(ctx, (*ctx).function_ctor);
    JS_FreeValue(ctx, (*ctx).function_proto);
    js_free_shape_null((*ctx).rt, (*ctx).array_shape);
    list_del(&mut (*ctx).link);
    remove_gc_object(&mut (*ctx).header);
    js_free_rt((*ctx).rt, ctx as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetRuntime(mut ctx: *mut JSContext) -> *mut JSRuntime {
    return (*ctx).rt;
}
unsafe extern "C" fn update_stack_limit(mut rt: *mut JSRuntime) {
    if (*rt).stack_size == 0 as libc::c_int as libc::c_uint {
        (*rt).stack_limit = 0 as libc::c_int as uintptr_t;
    } else {
        (*rt).stack_limit = ((*rt).stack_top).wrapping_sub((*rt).stack_size);
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetMaxStackSize(
    mut rt: *mut JSRuntime,
    mut stack_size: size_t,
) {
    (*rt).stack_size = stack_size as uintptr_t;
    update_stack_limit(rt);
}
#[no_mangle]
pub unsafe extern "C" fn JS_UpdateStackTop(mut rt: *mut JSRuntime) {
    (*rt).stack_top = js_get_stack_pointer();
    update_stack_limit(rt);
}
#[inline]
unsafe extern "C" fn is_strict_mode(mut ctx: *mut JSContext) -> BOOL {
    let mut sf: *mut JSStackFrame = (*(*ctx).rt).current_stack_frame;
    return (!sf.is_null() && (*sf).js_mode & (1 as libc::c_int) << 0 as libc::c_int != 0)
        as libc::c_int;
}
#[inline]
unsafe extern "C" fn __JS_AtomIsConst(mut v: JSAtom) -> BOOL {
    return ((v as int32_t) < JS_ATOM_END as libc::c_int) as libc::c_int;
}
#[inline]
unsafe extern "C" fn __JS_AtomIsTaggedInt(mut v: JSAtom) -> BOOL {
    return (v & (1 as libc::c_uint) << 31 as libc::c_int
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn __JS_AtomFromUInt32(mut v: uint32_t) -> JSAtom {
    return v | (1 as libc::c_uint) << 31 as libc::c_int;
}
#[inline]
unsafe extern "C" fn __JS_AtomToUInt32(mut atom: JSAtom) -> uint32_t {
    return atom & !((1 as libc::c_uint) << 31 as libc::c_int);
}
#[inline]
unsafe extern "C" fn is_num(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn is_num_string(
    mut pval: *mut uint32_t,
    mut p: *const JSString,
) -> BOOL {
    let mut n: uint32_t = 0;
    let mut n64: uint64_t = 0;
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    len = (*p).len() as libc::c_int;
    if len == 0 as libc::c_int || len > 10 as libc::c_int {
        return FALSE as libc::c_int;
    }
    if (*p).is_wide_char() != 0 {
        c = (*p).u.str16[0 as libc::c_int as usize] as libc::c_int;
    } else {
        c = (*p).u.str8[0 as libc::c_int as usize] as libc::c_int;
    }
    if is_num(c) != 0 {
        if c == '0' as i32 {
            if len != 1 as libc::c_int {
                return FALSE as libc::c_int;
            }
            n = 0 as libc::c_int as uint32_t;
        } else {
            n = (c - '0' as i32) as uint32_t;
            i = 1 as libc::c_int;
            while i < len {
                if (*p).is_wide_char() != 0 {
                    c = (*p).u.str16[i as usize] as libc::c_int;
                } else {
                    c = (*p).u.str8[i as usize] as libc::c_int;
                }
                if is_num(c) == 0 {
                    return FALSE as libc::c_int;
                }
                n64 = (n as uint64_t)
                    .wrapping_mul(10 as libc::c_int as libc::c_ulonglong)
                    .wrapping_add((c - '0' as i32) as libc::c_ulonglong);
                if n64 >> 32 as libc::c_int != 0 as libc::c_int as libc::c_ulonglong {
                    return FALSE as libc::c_int;
                }
                n = n64 as uint32_t;
                i += 1;
            }
        }
        *pval = n;
        return TRUE as libc::c_int;
    } else {
        return FALSE as libc::c_int
    };
}
#[inline]
unsafe extern "C" fn hash_string8(
    mut str: *const uint8_t,
    mut len: size_t,
    mut h: uint32_t,
) -> uint32_t {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < len {
        h = h
            .wrapping_mul(263 as libc::c_int as libc::c_uint)
            .wrapping_add(*str.offset(i as isize) as libc::c_uint);
        i = i.wrapping_add(1);
    }
    return h;
}
#[inline]
unsafe extern "C" fn hash_string16(
    mut str: *const uint16_t,
    mut len: size_t,
    mut h: uint32_t,
) -> uint32_t {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < len {
        h = h
            .wrapping_mul(263 as libc::c_int as libc::c_uint)
            .wrapping_add(*str.offset(i as isize) as libc::c_uint);
        i = i.wrapping_add(1);
    }
    return h;
}
unsafe extern "C" fn hash_string(mut str: *const JSString, mut h: uint32_t) -> uint32_t {
    if (*str).is_wide_char() != 0 {
        h = hash_string16(((*str).u.str16).as_ptr(), (*str).len() as size_t, h);
    } else {
        h = hash_string8(((*str).u.str8).as_ptr(), (*str).len() as size_t, h);
    }
    return h;
}
unsafe extern "C" fn JS_ResizeAtomHash(
    mut rt: *mut JSRuntime,
    mut new_hash_size: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    let mut new_hash_mask: uint32_t = 0;
    let mut h: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut hash_next1: uint32_t = 0;
    let mut j: uint32_t = 0;
    let mut new_hash: *mut uint32_t = 0 as *mut uint32_t;
    assert(
        (new_hash_size & new_hash_size - 1 as libc::c_int == 0 as libc::c_int)
            as libc::c_int,
    );
    new_hash_mask = (new_hash_size - 1 as libc::c_int) as uint32_t;
    new_hash = js_mallocz_rt(
        rt,
        (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
            .wrapping_mul(new_hash_size as libc::c_ulong),
    ) as *mut uint32_t;
    if new_hash.is_null() {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int as uint32_t;
    while i < (*rt).atom_hash_size as libc::c_uint {
        h = *((*rt).atom_hash).offset(i as isize);
        while h != 0 as libc::c_int as libc::c_uint {
            p = *((*rt).atom_array).offset(h as isize);
            hash_next1 = (*p).hash_next;
            j = (*p).hash() & new_hash_mask;
            (*p).hash_next = *new_hash.offset(j as isize);
            *new_hash.offset(j as isize) = h;
            h = hash_next1;
        }
        i = i.wrapping_add(1);
    }
    js_free_rt(rt, (*rt).atom_hash as *mut libc::c_void);
    let ref mut fresh43 = (*rt).atom_hash;
    *fresh43 = new_hash;
    (*rt).atom_hash_size = new_hash_size;
    (*rt).atom_count_resize = new_hash_size * 2 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_InitAtoms(mut rt: *mut JSRuntime) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut atom_type: libc::c_int = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    (*rt).atom_hash_size = 0 as libc::c_int;
    let ref mut fresh44 = (*rt).atom_hash;
    *fresh44 = 0 as *mut uint32_t;
    (*rt).atom_count = 0 as libc::c_int;
    (*rt).atom_size = 0 as libc::c_int;
    (*rt).atom_free_index = 0 as libc::c_int;
    if JS_ResizeAtomHash(rt, 256 as libc::c_int) != 0 {
        return -(1 as libc::c_int);
    }
    p = js_atom_init.as_ptr();
    i = 1 as libc::c_int;
    while i < JS_ATOM_END as libc::c_int {
        if i == JS_ATOM_Private_brand as libc::c_int {
            atom_type = JS_ATOM_TYPE_PRIVATE as libc::c_int;
        } else if i >= JS_ATOM_Symbol_toPrimitive as libc::c_int {
            atom_type = JS_ATOM_TYPE_SYMBOL as libc::c_int;
        } else {
            atom_type = JS_ATOM_TYPE_STRING as libc::c_int;
        }
        len = strlen(p) as libc::c_int;
        if __JS_NewAtomInit(rt, p, len, atom_type) == 0 as libc::c_int as libc::c_uint {
            return -(1 as libc::c_int);
        }
        p = p.offset(len as isize).offset(1 as libc::c_int as isize);
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_DupAtomRT(mut rt: *mut JSRuntime, mut v: JSAtom) -> JSAtom {
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    if __JS_AtomIsConst(v) == 0 {
        p = *((*rt).atom_array).offset(v as isize);
        let ref mut fresh45 = (*p).header.ref_count;
        *fresh45 += 1;
    }
    return v;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DupAtom(mut ctx: *mut JSContext, mut v: JSAtom) -> JSAtom {
    let mut rt: *mut JSRuntime = 0 as *mut JSRuntime;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    if __JS_AtomIsConst(v) == 0 {
        rt = (*ctx).rt;
        p = *((*rt).atom_array).offset(v as isize);
        let ref mut fresh46 = (*p).header.ref_count;
        *fresh46 += 1;
    }
    return v;
}
unsafe extern "C" fn JS_AtomGetKind(
    mut ctx: *mut JSContext,
    mut v: JSAtom,
) -> JSAtomKindEnum {
    let mut rt: *mut JSRuntime = 0 as *mut JSRuntime;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    rt = (*ctx).rt;
    if __JS_AtomIsTaggedInt(v) != 0 {
        return JS_ATOM_KIND_STRING;
    }
    p = *((*rt).atom_array).offset(v as isize);
    match (*p).atom_type() as libc::c_int {
        1 => return JS_ATOM_KIND_STRING,
        2 => return JS_ATOM_KIND_SYMBOL,
        3 => {
            match (*p).hash() as libc::c_int {
                0 => return JS_ATOM_KIND_SYMBOL,
                1 => return JS_ATOM_KIND_PRIVATE,
                _ => {
                    abort();
                }
            }
        }
        _ => {
            abort();
        }
    };
}
unsafe extern "C" fn JS_AtomIsString(mut ctx: *mut JSContext, mut v: JSAtom) -> BOOL {
    return (JS_AtomGetKind(ctx, v) as libc::c_uint
        == JS_ATOM_KIND_STRING as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn js_get_atom_index(
    mut rt: *mut JSRuntime,
    mut p: *mut JSAtomStruct,
) -> JSAtom {
    let mut i: uint32_t = (*p).hash_next;
    if (*p).atom_type() as libc::c_int != JS_ATOM_TYPE_SYMBOL as libc::c_int {
        let mut p1: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        i = *((*rt).atom_hash)
            .offset(
                ((*p).hash() as libc::c_int & (*rt).atom_hash_size - 1 as libc::c_int)
                    as isize,
            );
        p1 = *((*rt).atom_array).offset(i as isize);
        while p1 != p {
            assert((i != 0 as libc::c_int as libc::c_uint) as libc::c_int);
            i = (*p1).hash_next;
            p1 = *((*rt).atom_array).offset(i as isize);
        }
    }
    return i;
}
unsafe extern "C" fn __JS_NewAtom(
    mut rt: *mut JSRuntime,
    mut str: *mut JSString,
    mut atom_type: libc::c_int,
) -> JSAtom {
    let mut current_block: u64;
    let mut h: uint32_t = 0;
    let mut h1: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    let mut len: libc::c_int = 0;
    if atom_type < JS_ATOM_TYPE_SYMBOL as libc::c_int {
        if (*str).atom_type() as libc::c_int == atom_type {
            i = js_get_atom_index(rt, str);
            if __JS_AtomIsConst(i) != 0 {
                let ref mut fresh47 = (*str).header.ref_count;
                *fresh47 -= 1;
            }
            return i;
        }
        len = (*str).len() as libc::c_int;
        h = hash_string(str, atom_type as uint32_t);
        h
            &= (((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int)
                as libc::c_uint;
        h1 = h & ((*rt).atom_hash_size - 1 as libc::c_int) as libc::c_uint;
        i = *((*rt).atom_hash).offset(h1 as isize);
        loop {
            if !(i != 0 as libc::c_int as libc::c_uint) {
                current_block = 4068382217303356765;
                break;
            }
            p = *((*rt).atom_array).offset(i as isize);
            if (*p).hash() == h && (*p).atom_type() as libc::c_int == atom_type
                && (*p).len() as libc::c_int == len
                && js_string_memcmp(p, str, len) == 0 as libc::c_int
            {
                if __JS_AtomIsConst(i) == 0 {
                    let ref mut fresh48 = (*p).header.ref_count;
                    *fresh48 += 1;
                }
                current_block = 16222025271411265472;
                break;
            } else {
                i = (*p).hash_next;
            }
        }
    } else {
        h1 = 0 as libc::c_int as uint32_t;
        if atom_type == JS_ATOM_TYPE_SYMBOL as libc::c_int {
            h = JS_ATOM_HASH_SYMBOL as libc::c_int as uint32_t;
        } else {
            h = JS_ATOM_HASH_PRIVATE as libc::c_int as uint32_t;
            atom_type = JS_ATOM_TYPE_SYMBOL as libc::c_int;
        }
        current_block = 4068382217303356765;
    }
    match current_block {
        4068382217303356765 => {
            if (*rt).atom_free_index == 0 as libc::c_int {
                let mut new_size: uint32_t = 0;
                let mut start: uint32_t = 0;
                let mut new_array: *mut *mut JSAtomStruct = 0 as *mut *mut JSAtomStruct;
                new_size = max_int(
                    211 as libc::c_int,
                    (*rt).atom_size * 3 as libc::c_int / 2 as libc::c_int,
                ) as uint32_t;
                if new_size
                    > ((1 as libc::c_uint) << 30 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                {
                    current_block = 9969020475962272818;
                } else {
                    new_array = js_realloc_rt(
                        rt,
                        (*rt).atom_array as *mut libc::c_void,
                        (::core::mem::size_of::<*mut JSAtomStruct>() as libc::c_ulong)
                            .wrapping_mul(new_size as libc::c_ulong),
                    ) as *mut *mut JSAtomStruct;
                    if new_array.is_null() {
                        current_block = 9969020475962272818;
                    } else {
                        start = (*rt).atom_size as uint32_t;
                        if start == 0 as libc::c_int as libc::c_uint {
                            p = js_mallocz_rt(
                                rt,
                                ::core::mem::size_of::<JSAtomStruct>() as libc::c_ulong,
                            ) as *mut JSAtomStruct;
                            if p.is_null() {
                                js_free_rt(rt, new_array as *mut libc::c_void);
                                current_block = 9969020475962272818;
                            } else {
                                (*p).header.ref_count = 1 as libc::c_int;
                                (*p)
                                    .set_atom_type(
                                        JS_ATOM_TYPE_SYMBOL as libc::c_int as uint8_t,
                                    );
                                let ref mut fresh49 = *new_array
                                    .offset(0 as libc::c_int as isize);
                                *fresh49 = p;
                                let ref mut fresh50 = (*rt).atom_count;
                                *fresh50 += 1;
                                start = 1 as libc::c_int as uint32_t;
                                current_block = 5330834795799507926;
                            }
                        } else {
                            current_block = 5330834795799507926;
                        }
                        match current_block {
                            9969020475962272818 => {}
                            _ => {
                                (*rt).atom_size = new_size as libc::c_int;
                                let ref mut fresh51 = (*rt).atom_array;
                                *fresh51 = new_array;
                                (*rt).atom_free_index = start as libc::c_int;
                                i = start;
                                while i < new_size {
                                    let mut next: uint32_t = 0;
                                    if i
                                        == new_size.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    {
                                        next = 0 as libc::c_int as uint32_t;
                                    } else {
                                        next = i.wrapping_add(1 as libc::c_int as libc::c_uint);
                                    }
                                    let ref mut fresh52 = *((*rt).atom_array)
                                        .offset(i as isize);
                                    *fresh52 = atom_set_free(next);
                                    i = i.wrapping_add(1);
                                }
                                current_block = 5892776923941496671;
                            }
                        }
                    }
                }
            } else {
                current_block = 5892776923941496671;
            }
            match current_block {
                5892776923941496671 => {
                    if !str.is_null() {
                        if (*str).atom_type() as libc::c_int == 0 as libc::c_int {
                            p = str;
                            (*p).set_atom_type(atom_type as uint8_t);
                            current_block = 7330218953828964527;
                        } else {
                            p = js_malloc_rt(
                                rt,
                                (::core::mem::size_of::<JSString>() as libc::c_ulong)
                                    .wrapping_add(
                                        (((*str).len() as libc::c_int)
                                            << (*str).is_wide_char() as libc::c_int) as libc::c_ulong,
                                    )
                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                    .wrapping_sub((*str).is_wide_char() as libc::c_ulong),
                            ) as *mut JSAtomStruct;
                            if p.is_null() as libc::c_int as libc::c_long != 0 {
                                current_block = 9969020475962272818;
                            } else {
                                (*p).header.ref_count = 1 as libc::c_int;
                                (*p).set_is_wide_char((*str).is_wide_char());
                                (*p).set_len((*str).len());
                                memcpy(
                                    ((*p).u.str8).as_mut_ptr() as *mut libc::c_void,
                                    ((*str).u.str8).as_mut_ptr() as *const libc::c_void,
                                    ((((*str).len() as libc::c_int)
                                        << (*str).is_wide_char() as libc::c_int) + 1 as libc::c_int
                                        - (*str).is_wide_char() as libc::c_int) as libc::c_ulong,
                                );
                                js_free_string(rt, str);
                                current_block = 7330218953828964527;
                            }
                        }
                    } else {
                        p = js_malloc_rt(
                            rt,
                            ::core::mem::size_of::<JSAtomStruct>() as libc::c_ulong,
                        ) as *mut JSAtomStruct;
                        if p.is_null() {
                            return 0 as libc::c_int as JSAtom;
                        }
                        (*p).header.ref_count = 1 as libc::c_int;
                        (*p).set_is_wide_char(1 as libc::c_int as uint8_t);
                        (*p).set_len(0 as libc::c_int as uint32_t);
                        current_block = 7330218953828964527;
                    }
                    match current_block {
                        9969020475962272818 => {}
                        _ => {
                            i = (*rt).atom_free_index as uint32_t;
                            (*rt)
                                .atom_free_index = atom_get_free(
                                *((*rt).atom_array).offset(i as isize),
                            ) as libc::c_int;
                            let ref mut fresh53 = *((*rt).atom_array).offset(i as isize);
                            *fresh53 = p;
                            (*p).set_hash(h);
                            (*p).hash_next = i;
                            (*p).set_atom_type(atom_type as uint8_t);
                            let ref mut fresh54 = (*rt).atom_count;
                            *fresh54 += 1;
                            if atom_type != JS_ATOM_TYPE_SYMBOL as libc::c_int {
                                (*p).hash_next = *((*rt).atom_hash).offset(h1 as isize);
                                *((*rt).atom_hash).offset(h1 as isize) = i;
                                if ((*rt).atom_count >= (*rt).atom_count_resize)
                                    as libc::c_int as libc::c_long != 0
                                {
                                    JS_ResizeAtomHash(
                                        rt,
                                        (*rt).atom_hash_size * 2 as libc::c_int,
                                    );
                                }
                            }
                            return i;
                        }
                    }
                }
                _ => {}
            }
            i = 0 as libc::c_int as uint32_t;
        }
        _ => {}
    }
    if !str.is_null() {
        js_free_string(rt, str);
    }
    return i;
}
unsafe extern "C" fn __JS_NewAtomInit(
    mut rt: *mut JSRuntime,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut atom_type: libc::c_int,
) -> JSAtom {
    let mut p: *mut JSString = 0 as *mut JSString;
    p = js_alloc_string_rt(rt, len, 0 as libc::c_int);
    if p.is_null() {
        return 0 as libc::c_int as JSAtom;
    }
    memcpy(
        ((*p).u.str8).as_mut_ptr() as *mut libc::c_void,
        str as *const libc::c_void,
        len as libc::c_ulong,
    );
    (*p).u.str8[len as usize] = '\0' as i32 as uint8_t;
    return __JS_NewAtom(rt, p, atom_type);
}
unsafe extern "C" fn __JS_FindAtom(
    mut rt: *mut JSRuntime,
    mut str: *const libc::c_char,
    mut len: size_t,
    mut atom_type: libc::c_int,
) -> JSAtom {
    let mut h: uint32_t = 0;
    let mut h1: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    h = hash_string8(
        str as *const uint8_t,
        len,
        JS_ATOM_TYPE_STRING as libc::c_int as uint32_t,
    );
    h &= (((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int) as libc::c_uint;
    h1 = h & ((*rt).atom_hash_size - 1 as libc::c_int) as libc::c_uint;
    i = *((*rt).atom_hash).offset(h1 as isize);
    while i != 0 as libc::c_int as libc::c_uint {
        p = *((*rt).atom_array).offset(i as isize);
        if (*p).hash() == h
            && (*p).atom_type() as libc::c_int == JS_ATOM_TYPE_STRING as libc::c_int
            && (*p).len() as libc::c_ulong == len
            && (*p).is_wide_char() as libc::c_int == 0 as libc::c_int
            && memcmp(
                ((*p).u.str8).as_mut_ptr() as *const libc::c_void,
                str as *const libc::c_void,
                len,
            ) == 0 as libc::c_int
        {
            if __JS_AtomIsConst(i) == 0 {
                let ref mut fresh55 = (*p).header.ref_count;
                *fresh55 += 1;
            }
            return i;
        }
        i = (*p).hash_next;
    }
    return 0 as libc::c_int as JSAtom;
}
unsafe extern "C" fn JS_FreeAtomStruct(
    mut rt: *mut JSRuntime,
    mut p: *mut JSAtomStruct,
) {
    let mut i: uint32_t = (*p).hash_next;
    if (*p).atom_type() as libc::c_int != JS_ATOM_TYPE_SYMBOL as libc::c_int {
        let mut p0: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        let mut p1: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        let mut h0: uint32_t = 0;
        h0 = ((*p).hash() as libc::c_int & (*rt).atom_hash_size - 1 as libc::c_int)
            as uint32_t;
        i = *((*rt).atom_hash).offset(h0 as isize);
        p1 = *((*rt).atom_array).offset(i as isize);
        if p1 == p {
            *((*rt).atom_hash).offset(h0 as isize) = (*p1).hash_next;
        } else {
            loop {
                assert((i != 0 as libc::c_int as libc::c_uint) as libc::c_int);
                p0 = p1;
                i = (*p1).hash_next;
                p1 = *((*rt).atom_array).offset(i as isize);
                if !(p1 == p) {
                    continue;
                }
                (*p0).hash_next = (*p1).hash_next;
                break;
            }
        }
    }
    let ref mut fresh56 = *((*rt).atom_array).offset(i as isize);
    *fresh56 = atom_set_free((*rt).atom_free_index as uint32_t);
    (*rt).atom_free_index = i as libc::c_int;
    js_free_rt(rt, p as *mut libc::c_void);
    let ref mut fresh57 = (*rt).atom_count;
    *fresh57 -= 1;
    assert(((*rt).atom_count >= 0 as libc::c_int) as libc::c_int);
}
unsafe extern "C" fn __JS_FreeAtom(mut rt: *mut JSRuntime, mut i: uint32_t) {
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    p = *((*rt).atom_array).offset(i as isize);
    let ref mut fresh58 = (*p).header.ref_count;
    *fresh58 -= 1;
    if *fresh58 > 0 as libc::c_int {
        return;
    }
    JS_FreeAtomStruct(rt, p);
}
unsafe extern "C" fn JS_NewAtomStr(
    mut ctx: *mut JSContext,
    mut p: *mut JSString,
) -> JSAtom {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut n: uint32_t = 0;
    if is_num_string(&mut n, p) != 0 {
        if n
            <= ((1 as libc::c_uint) << 31 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint)
        {
            js_free_string(rt, p);
            return __JS_AtomFromUInt32(n);
        }
    }
    return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewAtomLen(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
    mut len: size_t,
) -> JSAtom {
    let mut val: JSValue = 0;
    if len == 0 as libc::c_int as libc::c_ulong || is_digit(*str as libc::c_int) == 0 {
        let mut atom: JSAtom = __JS_FindAtom(
            (*ctx).rt,
            str,
            len,
            JS_ATOM_TYPE_STRING as libc::c_int,
        );
        if atom != 0 {
            return atom;
        }
    }
    val = JS_NewStringLen(ctx, str, len);
    if JS_IsException(val) != 0 {
        return 0 as libc::c_int as JSAtom;
    }
    return JS_NewAtomStr(ctx, val as intptr_t as *mut libc::c_void as *mut JSString);
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewAtom(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
) -> JSAtom {
    return JS_NewAtomLen(ctx, str, strlen(str));
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewAtomUInt32(
    mut ctx: *mut JSContext,
    mut n: uint32_t,
) -> JSAtom {
    if n
        <= ((1 as libc::c_uint) << 31 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint)
    {
        return __JS_AtomFromUInt32(n)
    } else {
        let mut buf: [libc::c_char; 11] = [0; 11];
        let mut val: JSValue = 0;
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong,
            b"%u\0" as *const u8 as *const libc::c_char,
            n,
        );
        val = JS_NewString(ctx, buf.as_mut_ptr());
        if JS_IsException(val) != 0 {
            return 0 as libc::c_int as JSAtom;
        }
        return __JS_NewAtom(
            (*ctx).rt,
            val as intptr_t as *mut libc::c_void as *mut JSString,
            JS_ATOM_TYPE_STRING as libc::c_int,
        );
    };
}
unsafe extern "C" fn JS_NewAtomInt64(mut ctx: *mut JSContext, mut n: int64_t) -> JSAtom {
    if n as uint64_t
        <= ((1 as libc::c_uint) << 31 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulonglong
    {
        return __JS_AtomFromUInt32(n as uint32_t)
    } else {
        let mut buf: [libc::c_char; 24] = [0; 24];
        let mut val: JSValue = 0;
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong,
            b"%lld\0" as *const u8 as *const libc::c_char,
            n,
        );
        val = JS_NewString(ctx, buf.as_mut_ptr());
        if JS_IsException(val) != 0 {
            return 0 as libc::c_int as JSAtom;
        }
        return __JS_NewAtom(
            (*ctx).rt,
            val as intptr_t as *mut libc::c_void as *mut JSString,
            JS_ATOM_TYPE_STRING as libc::c_int,
        );
    };
}
unsafe extern "C" fn JS_NewSymbol(
    mut ctx: *mut JSContext,
    mut p: *mut JSString,
    mut atom_type: libc::c_int,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut atom: JSAtom = 0;
    atom = __JS_NewAtom(rt, p, atom_type);
    if atom == 0 as libc::c_int as libc::c_uint {
        return JS_ThrowOutOfMemory(ctx);
    }
    return (JS_TAG_SYMBOL as libc::c_int as uint64_t) << 32 as libc::c_int
        | *((*rt).atom_array).offset(atom as isize) as uintptr_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_NewSymbolFromAtom(
    mut ctx: *mut JSContext,
    mut descr: JSAtom,
    mut atom_type: libc::c_int,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut p: *mut JSString = 0 as *mut JSString;
    assert((__JS_AtomIsTaggedInt(descr) == 0) as libc::c_int);
    assert((descr < (*rt).atom_size as libc::c_uint) as libc::c_int);
    p = *((*rt).atom_array).offset(descr as isize);
    JS_DupValue(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | p as uintptr_t as libc::c_ulonglong,
    );
    return JS_NewSymbol(ctx, p, atom_type);
}
unsafe extern "C" fn JS_AtomGetStrRT(
    mut rt: *mut JSRuntime,
    mut buf: *mut libc::c_char,
    mut buf_size: libc::c_int,
    mut atom: JSAtom,
) -> *const libc::c_char {
    if __JS_AtomIsTaggedInt(atom) != 0 {
        snprintf(
            buf,
            buf_size as libc::c_ulong,
            b"%u\0" as *const u8 as *const libc::c_char,
            __JS_AtomToUInt32(atom),
        );
    } else {
        let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        assert((atom < (*rt).atom_size as libc::c_uint) as libc::c_int);
        if atom == 0 as libc::c_int as libc::c_uint {
            snprintf(
                buf,
                buf_size as libc::c_ulong,
                b"<null>\0" as *const u8 as *const libc::c_char,
            );
        } else {
            let mut i: libc::c_int = 0;
            let mut c: libc::c_int = 0;
            let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut str: *mut JSString = 0 as *mut JSString;
            q = buf;
            p = *((*rt).atom_array).offset(atom as isize);
            assert((atom_is_free(p) == 0) as libc::c_int);
            str = p;
            if !str.is_null() {
                if (*str).is_wide_char() == 0 {
                    c = 0 as libc::c_int;
                    i = 0 as libc::c_int;
                    while i < (*str).len() as libc::c_int {
                        c |= (*str).u.str8[i as usize] as libc::c_int;
                        i += 1;
                    }
                    if c < 0x80 as libc::c_int {
                        return ((*str).u.str8).as_mut_ptr() as *const libc::c_char;
                    }
                }
                i = 0 as libc::c_int;
                while i < (*str).len() as libc::c_int {
                    if (*str).is_wide_char() != 0 {
                        c = (*str).u.str16[i as usize] as libc::c_int;
                    } else {
                        c = (*str).u.str8[i as usize] as libc::c_int;
                    }
                    if q.offset_from(buf) as libc::c_long
                        >= (buf_size - 6 as libc::c_int) as libc::c_long
                    {
                        break;
                    }
                    if c < 128 as libc::c_int {
                        let fresh59 = q;
                        q = q.offset(1);
                        *fresh59 = c as libc::c_char;
                    } else {
                        q = q
                            .offset(
                                unicode_to_utf8(q as *mut uint8_t, c as libc::c_uint)
                                    as isize,
                            );
                    }
                    i += 1;
                }
            }
            *q = '\0' as i32 as libc::c_char;
        }
    }
    return buf;
}
unsafe extern "C" fn JS_AtomGetStr(
    mut ctx: *mut JSContext,
    mut buf: *mut libc::c_char,
    mut buf_size: libc::c_int,
    mut atom: JSAtom,
) -> *const libc::c_char {
    return JS_AtomGetStrRT((*ctx).rt, buf, buf_size, atom);
}
unsafe extern "C" fn __JS_AtomToValue(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
    mut force_string: BOOL,
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    if __JS_AtomIsTaggedInt(atom) != 0 {
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"%u\0" as *const u8 as *const libc::c_char,
            __JS_AtomToUInt32(atom),
        );
        return JS_NewString(ctx, buf.as_mut_ptr());
    } else {
        let mut rt: *mut JSRuntime = (*ctx).rt;
        let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        assert((atom < (*rt).atom_size as libc::c_uint) as libc::c_int);
        p = *((*rt).atom_array).offset(atom as isize);
        if !((*p).atom_type() as libc::c_int == JS_ATOM_TYPE_STRING as libc::c_int) {
            if force_string != 0 {
                if (*p).len() as libc::c_int == 0 as libc::c_int
                    && (*p).is_wide_char() as libc::c_int != 0 as libc::c_int
                {
                    p = *((*rt).atom_array)
                        .offset(JS_ATOM_empty_string as libc::c_int as isize);
                }
            } else {
                return JS_DupValue(
                    ctx,
                    (JS_TAG_SYMBOL as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                )
            }
        }
        return JS_DupValue(
            ctx,
            (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_AtomToValue(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> JSValue {
    return __JS_AtomToValue(ctx, atom, FALSE as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_AtomToString(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> JSValue {
    return __JS_AtomToValue(ctx, atom, TRUE as libc::c_int);
}
unsafe extern "C" fn JS_AtomIsArrayIndex(
    mut ctx: *mut JSContext,
    mut pval: *mut uint32_t,
    mut atom: JSAtom,
) -> BOOL {
    if __JS_AtomIsTaggedInt(atom) != 0 {
        *pval = __JS_AtomToUInt32(atom);
        return TRUE as libc::c_int;
    } else {
        let mut rt: *mut JSRuntime = (*ctx).rt;
        let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
        let mut val: uint32_t = 0;
        assert((atom < (*rt).atom_size as libc::c_uint) as libc::c_int);
        p = *((*rt).atom_array).offset(atom as isize);
        if (*p).atom_type() as libc::c_int == JS_ATOM_TYPE_STRING as libc::c_int
            && is_num_string(&mut val, p) != 0
            && val != -(1 as libc::c_int) as libc::c_uint
        {
            *pval = val;
            return TRUE as libc::c_int;
        } else {
            *pval = 0 as libc::c_int as uint32_t;
            return FALSE as libc::c_int;
        }
    };
}
unsafe extern "C" fn JS_AtomIsNumericIndex1(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut p1: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut c: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut num: JSValue = 0;
    let mut str: JSValue = 0;
    if __JS_AtomIsTaggedInt(atom) != 0 {
        return JS_NewInt32(ctx, __JS_AtomToUInt32(atom) as int32_t);
    }
    assert((atom < (*rt).atom_size as libc::c_uint) as libc::c_int);
    p1 = *((*rt).atom_array).offset(atom as isize);
    if (*p1).atom_type() as libc::c_int != JS_ATOM_TYPE_STRING as libc::c_int {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = p1;
    len = (*p).len() as libc::c_int;
    let mut r_0: *const uint8_t = 0 as *const uint8_t;
    let mut r_end_0: *const uint8_t = 0 as *const uint8_t;
    let mut current_block_30: u64;
    if (*p).is_wide_char() != 0 {
        let mut r: *const uint16_t = ((*p).u.str16).as_mut_ptr();
        let mut r_end: *const uint16_t = ((*p).u.str16)
            .as_mut_ptr()
            .offset(len as isize);
        if r >= r_end {
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        c = *r as libc::c_int;
        if c == '-' as i32 {
            if r >= r_end {
                return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            r = r.offset(1);
            c = *r as libc::c_int;
            if c == '0' as i32 && len == 2 as libc::c_int {
                current_block_30 = 8817505251474110666;
            } else {
                current_block_30 = 13242334135786603907;
            }
        } else {
            current_block_30 = 13242334135786603907;
        }
        match current_block_30 {
            8817505251474110666 => {}
            _ => {
                if is_num(c) == 0 {
                    let nfinity16: [uint16_t; 7] = [
                        'n' as i32 as uint16_t,
                        'f' as i32 as uint16_t,
                        'i' as i32 as uint16_t,
                        'n' as i32 as uint16_t,
                        'i' as i32 as uint16_t,
                        't' as i32 as uint16_t,
                        'y' as i32 as uint16_t,
                    ];
                    if !(c == 'I' as i32
                        && r_end.offset_from(r) as libc::c_long
                            == 8 as libc::c_int as libc::c_long
                        && memcmp(
                            r.offset(1 as libc::c_int as isize) as *const libc::c_void,
                            nfinity16.as_ptr() as *const libc::c_void,
                            ::core::mem::size_of::<[uint16_t; 7]>() as libc::c_ulong,
                        ) == 0)
                    {
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                }
                current_block_30 = 5529461102203738653;
            }
        }
    } else {
        r_0 = ((*p).u.str8).as_mut_ptr();
        r_end_0 = ((*p).u.str8).as_mut_ptr().offset(len as isize);
        if r_0 >= r_end_0 {
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        c = *r_0 as libc::c_int;
        if c == '-' as i32 {
            if r_0 >= r_end_0 {
                return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            r_0 = r_0.offset(1);
            c = *r_0 as libc::c_int;
            if c == '0' as i32 && len == 2 as libc::c_int {
                current_block_30 = 8817505251474110666;
            } else {
                current_block_30 = 14434620278749266018;
            }
        } else {
            current_block_30 = 14434620278749266018;
        }
        match current_block_30 {
            8817505251474110666 => {}
            _ => {
                if is_num(c) == 0 {
                    if !(c == 'I' as i32
                        && r_end_0.offset_from(r_0) as libc::c_long
                            == 8 as libc::c_int as libc::c_long
                        && memcmp(
                            r_0.offset(1 as libc::c_int as isize) as *const libc::c_void,
                            b"nfinity\0" as *const u8 as *const libc::c_char
                                as *const libc::c_void,
                            7 as libc::c_int as libc::c_ulong,
                        ) == 0)
                    {
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                }
                current_block_30 = 5529461102203738653;
            }
        }
    }
    match current_block_30 {
        5529461102203738653 => {}
        _ => return __JS_NewFloat64(ctx, -0.0f64),
    }
    num = JS_ToNumber(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | p as uintptr_t as libc::c_ulonglong,
    );
    if JS_IsException(num) != 0 {
        return num;
    }
    str = JS_ToString(ctx, num);
    if JS_IsException(str) != 0 {
        JS_FreeValue(ctx, num);
        return str;
    }
    ret = js_string_compare(
        ctx,
        p,
        str as intptr_t as *mut libc::c_void as *mut JSString,
    );
    JS_FreeValue(ctx, str);
    if ret == 0 as libc::c_int {
        return num
    } else {
        JS_FreeValue(ctx, num);
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    };
}
unsafe extern "C" fn JS_AtomIsNumericIndex(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut num: JSValue = 0;
    num = JS_AtomIsNumericIndex1(ctx, atom);
    if (JS_IsUndefined(num) != 0) as libc::c_int as libc::c_long != 0 {
        return FALSE as libc::c_int;
    }
    if JS_IsException(num) != 0 {
        return -(1 as libc::c_int);
    }
    JS_FreeValue(ctx, num);
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_FreeAtom(mut ctx: *mut JSContext, mut v: JSAtom) {
    if __JS_AtomIsConst(v) == 0 {
        __JS_FreeAtom((*ctx).rt, v);
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_FreeAtomRT(mut rt: *mut JSRuntime, mut v: JSAtom) {
    if __JS_AtomIsConst(v) == 0 {
        __JS_FreeAtom(rt, v);
    }
}
unsafe extern "C" fn JS_AtomSymbolHasDescription(
    mut ctx: *mut JSContext,
    mut v: JSAtom,
) -> BOOL {
    let mut rt: *mut JSRuntime = 0 as *mut JSRuntime;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    rt = (*ctx).rt;
    if __JS_AtomIsTaggedInt(v) != 0 {
        return FALSE as libc::c_int;
    }
    p = *((*rt).atom_array).offset(v as isize);
    return (((*p).atom_type() as libc::c_int == JS_ATOM_TYPE_SYMBOL as libc::c_int
        && (*p).hash() as libc::c_int == JS_ATOM_HASH_SYMBOL as libc::c_int
        || (*p).atom_type() as libc::c_int == JS_ATOM_TYPE_GLOBAL_SYMBOL as libc::c_int)
        && !((*p).len() as libc::c_int == 0 as libc::c_int
            && (*p).is_wide_char() as libc::c_int != 0 as libc::c_int)) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_AtomToCString(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> *const libc::c_char {
    let mut str: JSValue = 0;
    let mut cstr: *const libc::c_char = 0 as *const libc::c_char;
    str = JS_AtomToString(ctx, atom);
    if JS_IsException(str) != 0 {
        return 0 as *const libc::c_char;
    }
    cstr = JS_ToCString(ctx, str);
    JS_FreeValue(ctx, str);
    return cstr;
}
unsafe extern "C" fn js_atom_concat_str(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
    mut str1: *const libc::c_char,
) -> JSAtom {
    let mut str: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut cstr: *const libc::c_char = 0 as *const libc::c_char;
    let mut cstr2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut len1: size_t = 0;
    str = JS_AtomToString(ctx, name);
    if JS_IsException(str) != 0 {
        return 0 as libc::c_int as JSAtom;
    }
    cstr = JS_ToCStringLen(ctx, &mut len, str);
    if !cstr.is_null() {
        len1 = strlen(str1);
        cstr2 = js_malloc(
            ctx,
            len.wrapping_add(len1).wrapping_add(1 as libc::c_int as libc::c_ulong),
        ) as *mut libc::c_char;
        if !cstr2.is_null() {
            memcpy(cstr2 as *mut libc::c_void, cstr as *const libc::c_void, len);
            memcpy(
                cstr2.offset(len as isize) as *mut libc::c_void,
                str1 as *const libc::c_void,
                len1,
            );
            *cstr2.offset(len.wrapping_add(len1) as isize) = '\0' as i32 as libc::c_char;
            atom = JS_NewAtomLen(ctx, cstr2, len.wrapping_add(len1));
            js_free(ctx, cstr2 as *mut libc::c_void);
            JS_FreeCString(ctx, cstr);
            JS_FreeValue(ctx, str);
            return atom;
        }
    }
    JS_FreeCString(ctx, cstr);
    JS_FreeValue(ctx, str);
    return 0 as libc::c_int as JSAtom;
}
unsafe extern "C" fn js_atom_concat_num(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
    mut n: uint32_t,
) -> JSAtom {
    let mut buf: [libc::c_char; 16] = [0; 16];
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%u\0" as *const u8 as *const libc::c_char,
        n,
    );
    return js_atom_concat_str(ctx, name, buf.as_mut_ptr());
}
#[inline]
unsafe extern "C" fn JS_IsEmptyString(mut v: JSValue) -> BOOL {
    return ((v >> 32 as libc::c_int) as libc::c_int == JS_TAG_STRING as libc::c_int
        && (*(v as intptr_t as *mut libc::c_void as *mut JSString)).len() as libc::c_int
            == 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewClassID(mut pclass_id: *mut JSClassID) -> JSClassID {
    let mut class_id: JSClassID = 0;
    class_id = *pclass_id;
    if class_id == 0 as libc::c_int as libc::c_uint {
        let fresh60 = js_class_id_alloc;
        js_class_id_alloc = js_class_id_alloc.wrapping_add(1);
        class_id = fresh60;
        *pclass_id = class_id;
    }
    return class_id;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsRegisteredClass(
    mut rt: *mut JSRuntime,
    mut class_id: JSClassID,
) -> libc::c_int {
    return (class_id < (*rt).class_count as libc::c_uint
        && (*((*rt).class_array).offset(class_id as isize)).class_id
            != 0 as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn JS_NewClass1(
    mut rt: *mut JSRuntime,
    mut class_id: JSClassID,
    mut class_def: *const JSClassDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut new_size: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut cl: *mut JSClass = 0 as *mut JSClass;
    let mut new_class_array: *mut JSClass = 0 as *mut JSClass;
    let mut el: *mut list_head = 0 as *mut list_head;
    if class_id >= ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_uint {
        return -(1 as libc::c_int);
    }
    if class_id < (*rt).class_count as libc::c_uint
        && (*((*rt).class_array).offset(class_id as isize)).class_id
            != 0 as libc::c_int as libc::c_uint
    {
        return -(1 as libc::c_int);
    }
    if class_id >= (*rt).class_count as libc::c_uint {
        new_size = max_int(
            JS_CLASS_INIT_COUNT as libc::c_int,
            max_int(
                class_id.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                (*rt).class_count * 3 as libc::c_int / 2 as libc::c_int,
            ),
        );
        el = (*rt).context_list.next;
        while el != &mut (*rt).context_list as *mut list_head {
            let mut ctx: *mut JSContext = (el as *mut uint8_t)
                .offset(-(20 as libc::c_ulong as isize)) as *mut JSContext;
            let mut new_tab: *mut JSValue = 0 as *mut JSValue;
            new_tab = js_realloc_rt(
                rt,
                (*ctx).class_proto as *mut libc::c_void,
                (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                    .wrapping_mul(new_size as libc::c_ulong),
            ) as *mut JSValue;
            if new_tab.is_null() {
                return -(1 as libc::c_int);
            }
            i = (*rt).class_count;
            while i < new_size {
                *new_tab
                    .offset(
                        i as isize,
                    ) = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                i += 1;
            }
            let ref mut fresh61 = (*ctx).class_proto;
            *fresh61 = new_tab;
            el = (*el).next;
        }
        new_class_array = js_realloc_rt(
            rt,
            (*rt).class_array as *mut libc::c_void,
            (::core::mem::size_of::<JSClass>() as libc::c_ulong)
                .wrapping_mul(new_size as libc::c_ulong),
        ) as *mut JSClass;
        if new_class_array.is_null() {
            return -(1 as libc::c_int);
        }
        memset(
            new_class_array.offset((*rt).class_count as isize) as *mut libc::c_void,
            0 as libc::c_int,
            ((new_size - (*rt).class_count) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<JSClass>() as libc::c_ulong),
        );
        let ref mut fresh62 = (*rt).class_array;
        *fresh62 = new_class_array;
        (*rt).class_count = new_size;
    }
    cl = &mut *((*rt).class_array).offset(class_id as isize) as *mut JSClass;
    (*cl).class_id = class_id;
    (*cl).class_name = JS_DupAtomRT(rt, name);
    let ref mut fresh63 = (*cl).finalizer;
    *fresh63 = (*class_def).finalizer;
    let ref mut fresh64 = (*cl).gc_mark;
    *fresh64 = (*class_def).gc_mark;
    let ref mut fresh65 = (*cl).call;
    *fresh65 = (*class_def).call;
    let ref mut fresh66 = (*cl).exotic;
    *fresh66 = (*class_def).exotic;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewClass(
    mut rt: *mut JSRuntime,
    mut class_id: JSClassID,
    mut class_def: *const JSClassDef,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut name: JSAtom = 0;
    len = strlen((*class_def).class_name) as libc::c_int;
    name = __JS_FindAtom(
        rt,
        (*class_def).class_name,
        len as size_t,
        JS_ATOM_TYPE_STRING as libc::c_int,
    );
    if name == 0 as libc::c_int as libc::c_uint {
        name = __JS_NewAtomInit(
            rt,
            (*class_def).class_name,
            len,
            JS_ATOM_TYPE_STRING as libc::c_int,
        );
        if name == 0 as libc::c_int as libc::c_uint {
            return -(1 as libc::c_int);
        }
    }
    ret = JS_NewClass1(rt, class_id, class_def, name);
    JS_FreeAtomRT(rt, name);
    return ret;
}
unsafe extern "C" fn js_new_string8(
    mut ctx: *mut JSContext,
    mut buf: *const uint8_t,
    mut len: libc::c_int,
) -> JSValue {
    let mut str: *mut JSString = 0 as *mut JSString;
    if len <= 0 as libc::c_int {
        return JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    }
    str = js_alloc_string(ctx, len, 0 as libc::c_int);
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    memcpy(
        ((*str).u.str8).as_mut_ptr() as *mut libc::c_void,
        buf as *const libc::c_void,
        len as libc::c_ulong,
    );
    (*str).u.str8[len as usize] = '\0' as i32 as uint8_t;
    return (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
        | str as uintptr_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_new_string16(
    mut ctx: *mut JSContext,
    mut buf: *const uint16_t,
    mut len: libc::c_int,
) -> JSValue {
    let mut str: *mut JSString = 0 as *mut JSString;
    str = js_alloc_string(ctx, len, 1 as libc::c_int);
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    memcpy(
        ((*str).u.str16).as_mut_ptr() as *mut libc::c_void,
        buf as *const libc::c_void,
        (len * 2 as libc::c_int) as libc::c_ulong,
    );
    return (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
        | str as uintptr_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_new_string_char(
    mut ctx: *mut JSContext,
    mut c: uint16_t,
) -> JSValue {
    if (c as libc::c_int) < 0x100 as libc::c_int {
        let mut ch8: uint8_t = c as uint8_t;
        return js_new_string8(ctx, &mut ch8, 1 as libc::c_int);
    } else {
        let mut ch16: uint16_t = c;
        return js_new_string16(ctx, &mut ch16, 1 as libc::c_int);
    };
}
unsafe extern "C" fn js_sub_string(
    mut ctx: *mut JSContext,
    mut p: *mut JSString,
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> JSValue {
    let mut len: libc::c_int = end - start;
    if start == 0 as libc::c_int && end == (*p).len() as libc::c_int {
        return JS_DupValue(
            ctx,
            (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong,
        );
    }
    if (*p).is_wide_char() as libc::c_int != 0 && len > 0 as libc::c_int {
        let mut str: *mut JSString = 0 as *mut JSString;
        let mut i: libc::c_int = 0;
        let mut c: uint16_t = 0 as libc::c_int as uint16_t;
        i = start;
        while i < end {
            c = (c as libc::c_int | (*p).u.str16[i as usize] as libc::c_int) as uint16_t;
            i += 1;
        }
        if c as libc::c_int > 0xff as libc::c_int {
            return js_new_string16(
                ctx,
                ((*p).u.str16).as_mut_ptr().offset(start as isize),
                len,
            );
        }
        str = js_alloc_string(ctx, len, 0 as libc::c_int);
        if str.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i = 0 as libc::c_int;
        while i < len {
            (*str).u.str8[i as usize] = (*p).u.str16[(start + i) as usize] as uint8_t;
            i += 1;
        }
        (*str).u.str8[len as usize] = '\0' as i32 as uint8_t;
        return (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | str as uintptr_t as libc::c_ulonglong;
    } else {
        return js_new_string8(
            ctx,
            ((*p).u.str8).as_mut_ptr().offset(start as isize),
            len,
        )
    };
}
unsafe extern "C" fn string_buffer_init2(
    mut ctx: *mut JSContext,
    mut s: *mut StringBuffer,
    mut size: libc::c_int,
    mut is_wide: libc::c_int,
) -> libc::c_int {
    let ref mut fresh67 = (*s).ctx;
    *fresh67 = ctx;
    (*s).size = size;
    (*s).len = 0 as libc::c_int;
    (*s).is_wide_char = is_wide;
    (*s).error_status = 0 as libc::c_int;
    let ref mut fresh68 = (*s).str_0;
    *fresh68 = js_alloc_string(ctx, size, is_wide);
    if ((*s).str_0).is_null() as libc::c_int as libc::c_long != 0 {
        (*s).size = 0 as libc::c_int;
        let ref mut fresh69 = (*s).error_status;
        *fresh69 = -(1 as libc::c_int);
        return *fresh69;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn string_buffer_init(
    mut ctx: *mut JSContext,
    mut s: *mut StringBuffer,
    mut size: libc::c_int,
) -> libc::c_int {
    return string_buffer_init2(ctx, s, size, 0 as libc::c_int);
}
unsafe extern "C" fn string_buffer_free(mut s: *mut StringBuffer) {
    js_free((*s).ctx, (*s).str_0 as *mut libc::c_void);
    let ref mut fresh70 = (*s).str_0;
    *fresh70 = 0 as *mut JSString;
}
unsafe extern "C" fn string_buffer_set_error(mut s: *mut StringBuffer) -> libc::c_int {
    js_free((*s).ctx, (*s).str_0 as *mut libc::c_void);
    let ref mut fresh71 = (*s).str_0;
    *fresh71 = 0 as *mut JSString;
    (*s).size = 0 as libc::c_int;
    (*s).len = 0 as libc::c_int;
    let ref mut fresh72 = (*s).error_status;
    *fresh72 = -(1 as libc::c_int);
    return *fresh72;
}
#[inline(never)]
unsafe extern "C" fn string_buffer_widen(
    mut s: *mut StringBuffer,
    mut size: libc::c_int,
) -> libc::c_int {
    let mut str: *mut JSString = 0 as *mut JSString;
    let mut slack: size_t = 0;
    let mut i: libc::c_int = 0;
    if (*s).error_status != 0 {
        return -(1 as libc::c_int);
    }
    str = js_realloc2(
        (*s).ctx,
        (*s).str_0 as *mut libc::c_void,
        (::core::mem::size_of::<JSString>() as libc::c_ulong)
            .wrapping_add((size << 1 as libc::c_int) as libc::c_ulong),
        &mut slack,
    ) as *mut JSString;
    if str.is_null() {
        return string_buffer_set_error(s);
    }
    size = (size as libc::c_ulong).wrapping_add(slack >> 1 as libc::c_int) as libc::c_int
        as libc::c_int;
    i = (*s).len;
    loop {
        let fresh73 = i;
        i = i - 1;
        if !(fresh73 > 0 as libc::c_int) {
            break;
        }
        (*str).u.str16[i as usize] = (*str).u.str8[i as usize] as uint16_t;
    }
    (*s).is_wide_char = 1 as libc::c_int;
    (*s).size = size;
    let ref mut fresh74 = (*s).str_0;
    *fresh74 = str;
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn string_buffer_realloc(
    mut s: *mut StringBuffer,
    mut new_len: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut new_str: *mut JSString = 0 as *mut JSString;
    let mut new_size: libc::c_int = 0;
    let mut new_size_bytes: size_t = 0;
    let mut slack: size_t = 0;
    if (*s).error_status != 0 {
        return -(1 as libc::c_int);
    }
    if new_len > ((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int {
        JS_ThrowInternalError(
            (*s).ctx,
            b"string too long\0" as *const u8 as *const libc::c_char,
        );
        return string_buffer_set_error(s);
    }
    new_size = min_int(
        max_int(new_len, (*s).size * 3 as libc::c_int / 2 as libc::c_int),
        ((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int,
    );
    if (*s).is_wide_char == 0 && c >= 0x100 as libc::c_int {
        return string_buffer_widen(s, new_size);
    }
    new_size_bytes = (::core::mem::size_of::<JSString>() as libc::c_ulong)
        .wrapping_add((new_size << (*s).is_wide_char) as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_sub((*s).is_wide_char as libc::c_ulong);
    new_str = js_realloc2(
        (*s).ctx,
        (*s).str_0 as *mut libc::c_void,
        new_size_bytes,
        &mut slack,
    ) as *mut JSString;
    if new_str.is_null() {
        return string_buffer_set_error(s);
    }
    new_size = min_int(
        (new_size as libc::c_ulong).wrapping_add(slack >> (*s).is_wide_char)
            as libc::c_int,
        ((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int,
    );
    (*s).size = new_size;
    let ref mut fresh75 = (*s).str_0;
    *fresh75 = new_str;
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn string_buffer_putc_slow(
    mut s: *mut StringBuffer,
    mut c: uint32_t,
) -> libc::c_int {
    if ((*s).len >= (*s).size) as libc::c_int as libc::c_long != 0 {
        if string_buffer_realloc(s, (*s).len + 1 as libc::c_int, c as libc::c_int) != 0 {
            return -(1 as libc::c_int);
        }
    }
    if (*s).is_wide_char != 0 {
        let ref mut fresh76 = (*s).len;
        let fresh77 = *fresh76;
        *fresh76 = *fresh76 + 1;
        (*(*s).str_0).u.str16[fresh77 as usize] = c as uint16_t;
    } else if c < 0x100 as libc::c_int as libc::c_uint {
        let ref mut fresh78 = (*s).len;
        let fresh79 = *fresh78;
        *fresh78 = *fresh78 + 1;
        (*(*s).str_0).u.str8[fresh79 as usize] = c as uint8_t;
    } else {
        if string_buffer_widen(s, (*s).size) != 0 {
            return -(1 as libc::c_int);
        }
        let ref mut fresh80 = (*s).len;
        let fresh81 = *fresh80;
        *fresh80 = *fresh80 + 1;
        (*(*s).str_0).u.str16[fresh81 as usize] = c as uint16_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_buffer_putc8(
    mut s: *mut StringBuffer,
    mut c: uint32_t,
) -> libc::c_int {
    if ((*s).len >= (*s).size) as libc::c_int as libc::c_long != 0 {
        if string_buffer_realloc(s, (*s).len + 1 as libc::c_int, c as libc::c_int) != 0 {
            return -(1 as libc::c_int);
        }
    }
    if (*s).is_wide_char != 0 {
        let ref mut fresh82 = (*s).len;
        let fresh83 = *fresh82;
        *fresh82 = *fresh82 + 1;
        (*(*s).str_0).u.str16[fresh83 as usize] = c as uint16_t;
    } else {
        let ref mut fresh84 = (*s).len;
        let fresh85 = *fresh84;
        *fresh84 = *fresh84 + 1;
        (*(*s).str_0).u.str8[fresh85 as usize] = c as uint8_t;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_buffer_putc16(
    mut s: *mut StringBuffer,
    mut c: uint32_t,
) -> libc::c_int {
    if ((*s).len < (*s).size) as libc::c_int as libc::c_long != 0 {
        if (*s).is_wide_char != 0 {
            let ref mut fresh86 = (*s).len;
            let fresh87 = *fresh86;
            *fresh86 = *fresh86 + 1;
            (*(*s).str_0).u.str16[fresh87 as usize] = c as uint16_t;
            return 0 as libc::c_int;
        } else {
            if c < 0x100 as libc::c_int as libc::c_uint {
                let ref mut fresh88 = (*s).len;
                let fresh89 = *fresh88;
                *fresh88 = *fresh88 + 1;
                (*(*s).str_0).u.str8[fresh89 as usize] = c as uint8_t;
                return 0 as libc::c_int;
            }
        }
    }
    return string_buffer_putc_slow(s, c);
}
unsafe extern "C" fn string_buffer_putc(
    mut s: *mut StringBuffer,
    mut c: uint32_t,
) -> libc::c_int {
    if (c >= 0x10000 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0
    {
        c = (c as libc::c_uint).wrapping_sub(0x10000 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        if string_buffer_putc16(
            s,
            (c >> 10 as libc::c_int).wrapping_add(0xd800 as libc::c_int as libc::c_uint),
        ) != 0
        {
            return -(1 as libc::c_int);
        }
        c = (c & 0x3ff as libc::c_int as libc::c_uint)
            .wrapping_add(0xdc00 as libc::c_int as libc::c_uint);
    }
    return string_buffer_putc16(s, c);
}
unsafe extern "C" fn string_get(
    mut p: *const JSString,
    mut idx: libc::c_int,
) -> libc::c_int {
    return if (*p).is_wide_char() as libc::c_int != 0 {
        (*p).u.str16[idx as usize] as libc::c_int
    } else {
        (*p).u.str8[idx as usize] as libc::c_int
    };
}
unsafe extern "C" fn string_getc(
    mut p: *const JSString,
    mut pidx: *mut libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    idx = *pidx;
    if (*p).is_wide_char() != 0 {
        let fresh90 = idx;
        idx = idx + 1;
        c = (*p).u.str16[fresh90 as usize] as libc::c_int;
        if c >= 0xd800 as libc::c_int && c < 0xdc00 as libc::c_int
            && idx < (*p).len() as libc::c_int
        {
            c1 = (*p).u.str16[idx as usize] as libc::c_int;
            if c1 >= 0xdc00 as libc::c_int && c1 < 0xe000 as libc::c_int {
                c = ((c & 0x3ff as libc::c_int) << 10 as libc::c_int
                    | c1 & 0x3ff as libc::c_int) + 0x10000 as libc::c_int;
                idx += 1;
            }
        }
    } else {
        let fresh91 = idx;
        idx = idx + 1;
        c = (*p).u.str8[fresh91 as usize] as libc::c_int;
    }
    *pidx = idx;
    return c;
}
unsafe extern "C" fn string_buffer_write8(
    mut s: *mut StringBuffer,
    mut p: *const uint8_t,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if (*s).len + len > (*s).size {
        if string_buffer_realloc(s, (*s).len + len, 0 as libc::c_int) != 0 {
            return -(1 as libc::c_int);
        }
    }
    if (*s).is_wide_char != 0 {
        i = 0 as libc::c_int;
        while i < len {
            (*(*s).str_0)
                .u
                .str16[((*s).len + i) as usize] = *p.offset(i as isize) as uint16_t;
            i += 1;
        }
        (*s).len += len;
    } else {
        memcpy(
            &mut *((*(*s).str_0).u.str8).as_mut_ptr().offset((*s).len as isize)
                as *mut uint8_t as *mut libc::c_void,
            p as *const libc::c_void,
            len as libc::c_ulong,
        );
        (*s).len += len;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_buffer_write16(
    mut s: *mut StringBuffer,
    mut p: *const uint16_t,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        c |= *p.offset(i as isize) as libc::c_int;
        i += 1;
    }
    if (*s).len + len > (*s).size {
        if string_buffer_realloc(s, (*s).len + len, c) != 0 {
            return -(1 as libc::c_int);
        }
    } else if (*s).is_wide_char == 0 && c >= 0x100 as libc::c_int {
        if string_buffer_widen(s, (*s).size) != 0 {
            return -(1 as libc::c_int);
        }
    }
    if (*s).is_wide_char != 0 {
        memcpy(
            &mut *((*(*s).str_0).u.str16).as_mut_ptr().offset((*s).len as isize)
                as *mut uint16_t as *mut libc::c_void,
            p as *const libc::c_void,
            (len << 1 as libc::c_int) as libc::c_ulong,
        );
        (*s).len += len;
    } else {
        i = 0 as libc::c_int;
        while i < len {
            (*(*s).str_0)
                .u
                .str8[((*s).len + i) as usize] = *p.offset(i as isize) as uint8_t;
            i += 1;
        }
        (*s).len += len;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_buffer_puts8(
    mut s: *mut StringBuffer,
    mut str: *const libc::c_char,
) -> libc::c_int {
    return string_buffer_write8(s, str as *const uint8_t, strlen(str) as libc::c_int);
}
unsafe extern "C" fn string_buffer_concat(
    mut s: *mut StringBuffer,
    mut p: *const JSString,
    mut from: uint32_t,
    mut to: uint32_t,
) -> libc::c_int {
    if to <= from {
        return 0 as libc::c_int;
    }
    if (*p).is_wide_char() != 0 {
        return string_buffer_write16(
            s,
            ((*p).u.str16).as_ptr().offset(from as isize),
            to.wrapping_sub(from) as libc::c_int,
        )
    } else {
        return string_buffer_write8(
            s,
            ((*p).u.str8).as_ptr().offset(from as isize),
            to.wrapping_sub(from) as libc::c_int,
        )
    };
}
unsafe extern "C" fn string_buffer_concat_value(
    mut s: *mut StringBuffer,
    mut v: JSValue,
) -> libc::c_int {
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut v1: JSValue = 0;
    let mut res: libc::c_int = 0;
    if (*s).error_status != 0 {
        return -(1 as libc::c_int);
    }
    if ((v >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        v1 = JS_ToString((*s).ctx, v);
        if JS_IsException(v1) != 0 {
            return string_buffer_set_error(s);
        }
        p = v1 as intptr_t as *mut libc::c_void as *mut JSString;
        res = string_buffer_concat(s, p, 0 as libc::c_int as uint32_t, (*p).len());
        JS_FreeValue((*s).ctx, v1);
        return res;
    }
    p = v as intptr_t as *mut libc::c_void as *mut JSString;
    return string_buffer_concat(s, p, 0 as libc::c_int as uint32_t, (*p).len());
}
unsafe extern "C" fn string_buffer_concat_value_free(
    mut s: *mut StringBuffer,
    mut v: JSValue,
) -> libc::c_int {
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut res: libc::c_int = 0;
    if (*s).error_status != 0 {
        JS_FreeValue((*s).ctx, v);
        return -(1 as libc::c_int);
    }
    if ((v >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        v = JS_ToStringFree((*s).ctx, v);
        if JS_IsException(v) != 0 {
            return string_buffer_set_error(s);
        }
    }
    p = v as intptr_t as *mut libc::c_void as *mut JSString;
    res = string_buffer_concat(s, p, 0 as libc::c_int as uint32_t, (*p).len());
    JS_FreeValue((*s).ctx, v);
    return res;
}
unsafe extern "C" fn string_buffer_fill(
    mut s: *mut StringBuffer,
    mut c: libc::c_int,
    mut count: libc::c_int,
) -> libc::c_int {
    if (*s).len + count > (*s).size {
        if string_buffer_realloc(s, (*s).len + count, c) != 0 {
            return -(1 as libc::c_int);
        }
    }
    loop {
        let fresh92 = count;
        count = count - 1;
        if !(fresh92 > 0 as libc::c_int) {
            break;
        }
        if string_buffer_putc16(s, c as uint32_t) != 0 {
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_buffer_end(mut s: *mut StringBuffer) -> JSValue {
    let mut str: *mut JSString = 0 as *mut JSString;
    str = (*s).str_0;
    if (*s).error_status != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (*s).len == 0 as libc::c_int {
        js_free((*s).ctx, str as *mut libc::c_void);
        let ref mut fresh93 = (*s).str_0;
        *fresh93 = 0 as *mut JSString;
        return JS_AtomToString((*s).ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    }
    if (*s).len < (*s).size {
        str = js_realloc_rt(
            (*(*s).ctx).rt,
            str as *mut libc::c_void,
            (::core::mem::size_of::<JSString>() as libc::c_ulong)
                .wrapping_add(((*s).len << (*s).is_wide_char) as libc::c_ulong)
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                .wrapping_sub((*s).is_wide_char as libc::c_ulong),
        ) as *mut JSString;
        if str.is_null() {
            str = (*s).str_0;
        }
        let ref mut fresh94 = (*s).str_0;
        *fresh94 = str;
    }
    if (*s).is_wide_char == 0 {
        (*str).u.str8[(*s).len as usize] = 0 as libc::c_int as uint8_t;
    }
    (*str).set_is_wide_char((*s).is_wide_char as uint8_t);
    (*str).set_len((*s).len as uint32_t);
    let ref mut fresh95 = (*s).str_0;
    *fresh95 = 0 as *mut JSString;
    return (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
        | str as uintptr_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewStringLen(
    mut ctx: *mut JSContext,
    mut buf: *const libc::c_char,
    mut buf_len: size_t,
) -> JSValue {
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut p_end: *const uint8_t = 0 as *const uint8_t;
    let mut p_start: *const uint8_t = 0 as *const uint8_t;
    let mut p_next: *const uint8_t = 0 as *const uint8_t;
    let mut c: uint32_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut len1: size_t = 0;
    p_start = buf as *const uint8_t;
    p_end = p_start.offset(buf_len as isize);
    p = p_start;
    while p < p_end && (*p as libc::c_int) < 128 as libc::c_int {
        p = p.offset(1);
    }
    len1 = p.offset_from(p_start) as libc::c_long as size_t;
    if len1
        > (((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int) as libc::c_ulong
    {
        return JS_ThrowInternalError(
            ctx,
            b"string too long\0" as *const u8 as *const libc::c_char,
        );
    }
    if p == p_end {
        return js_new_string8(ctx, buf as *const uint8_t, buf_len as libc::c_int)
    } else if string_buffer_init(ctx, b, buf_len as libc::c_int) != 0 {
        string_buffer_free(b);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        string_buffer_write8(b, p_start, len1 as libc::c_int);
        while p < p_end {
            if (*p as libc::c_int) < 128 as libc::c_int {
                let fresh96 = p;
                p = p.offset(1);
                string_buffer_putc8(b, *fresh96 as uint32_t);
            } else {
                c = unicode_from_utf8(
                    p,
                    p_end.offset_from(p) as libc::c_long as libc::c_int,
                    &mut p_next,
                ) as uint32_t;
                if c < 0x10000 as libc::c_int as libc::c_uint {
                    p = p_next;
                } else if c <= 0x10ffff as libc::c_int as libc::c_uint {
                    p = p_next;
                    c = (c as libc::c_uint)
                        .wrapping_sub(0x10000 as libc::c_int as libc::c_uint) as uint32_t
                        as uint32_t;
                    string_buffer_putc16(
                        b,
                        (c >> 10 as libc::c_int)
                            .wrapping_add(0xd800 as libc::c_int as libc::c_uint),
                    );
                    c = (c & 0x3ff as libc::c_int as libc::c_uint)
                        .wrapping_add(0xdc00 as libc::c_int as libc::c_uint);
                } else {
                    c = 0xfffd as libc::c_int as uint32_t;
                    while p < p_end
                        && (*p as libc::c_int >= 0x80 as libc::c_int
                            && (*p as libc::c_int) < 0xc0 as libc::c_int)
                    {
                        p = p.offset(1);
                    }
                    if p < p_end {
                        p = p.offset(1);
                        while p < p_end
                            && (*p as libc::c_int >= 0x80 as libc::c_int
                                && (*p as libc::c_int) < 0xc0 as libc::c_int)
                        {
                            p = p.offset(1);
                        }
                    }
                }
                string_buffer_putc16(b, c);
            }
        }
        return string_buffer_end(b);
    };
}
unsafe extern "C" fn JS_ConcatString3(
    mut ctx: *mut JSContext,
    mut str1: *const libc::c_char,
    mut str2: JSValue,
    mut str3: *const libc::c_char,
) -> JSValue {
    let mut current_block: u64;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut len1: libc::c_int = 0;
    let mut len3: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    if ((str2 >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        str2 = JS_ToStringFree(ctx, str2);
        if JS_IsException(str2) != 0 {
            current_block = 10945279814399962961;
        } else {
            current_block = 7095457783677275021;
        }
    } else {
        current_block = 7095457783677275021;
    }
    match current_block {
        7095457783677275021 => {
            p = str2 as intptr_t as *mut libc::c_void as *mut JSString;
            len1 = strlen(str1) as libc::c_int;
            len3 = strlen(str3) as libc::c_int;
            if !(string_buffer_init2(
                ctx,
                b,
                len1 + (*p).len() as libc::c_int + len3,
                (*p).is_wide_char() as libc::c_int,
            ) != 0)
            {
                string_buffer_write8(b, str1 as *const uint8_t, len1);
                string_buffer_concat(b, p, 0 as libc::c_int as uint32_t, (*p).len());
                string_buffer_write8(b, str3 as *const uint8_t, len3);
                JS_FreeValue(ctx, str2);
                return string_buffer_end(b);
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, str2);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewString(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
) -> JSValue {
    return JS_NewStringLen(ctx, str, strlen(str));
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewAtomString(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
) -> JSValue {
    let mut atom: JSAtom = JS_NewAtom(ctx, str);
    if atom == 0 as libc::c_int as libc::c_uint {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    let mut val: JSValue = JS_AtomToString(ctx, atom);
    JS_FreeAtom(ctx, atom);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToCStringLen2(
    mut ctx: *mut JSContext,
    mut plen: *mut size_t,
    mut val1: JSValue,
    mut cesu8: BOOL,
) -> *const libc::c_char {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut str: *mut JSString = 0 as *mut JSString;
    let mut str_new: *mut JSString = 0 as *mut JSString;
    let mut pos: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    let mut q: *mut uint8_t = 0 as *mut uint8_t;
    if (val1 >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int {
        val = JS_ToString(ctx, val1);
        if JS_IsException(val) != 0 {
            current_block = 3744173141220556273;
        } else {
            current_block = 7815301370352969686;
        }
    } else {
        val = JS_DupValue(ctx, val1);
        current_block = 7815301370352969686;
    }
    match current_block {
        7815301370352969686 => {
            str = val as intptr_t as *mut libc::c_void as *mut JSString;
            len = (*str).len() as libc::c_int;
            if (*str).is_wide_char() == 0 {
                let mut src: *const uint8_t = ((*str).u.str8).as_mut_ptr();
                let mut count: libc::c_int = 0;
                count = 0 as libc::c_int;
                pos = 0 as libc::c_int;
                while pos < len {
                    count
                        += *src.offset(pos as isize) as libc::c_int >> 7 as libc::c_int;
                    pos += 1;
                }
                if count == 0 as libc::c_int {
                    if !plen.is_null() {
                        *plen = len as size_t;
                    }
                    return src as *const libc::c_char;
                }
                str_new = js_alloc_string(ctx, len + count, 0 as libc::c_int);
                if str_new.is_null() {
                    current_block = 3744173141220556273;
                } else {
                    q = ((*str_new).u.str8).as_mut_ptr();
                    pos = 0 as libc::c_int;
                    while pos < len {
                        c = *src.offset(pos as isize) as libc::c_int;
                        if c < 0x80 as libc::c_int {
                            let fresh97 = q;
                            q = q.offset(1);
                            *fresh97 = c as uint8_t;
                        } else {
                            let fresh98 = q;
                            q = q.offset(1);
                            *fresh98 = (c >> 6 as libc::c_int | 0xc0 as libc::c_int)
                                as uint8_t;
                            let fresh99 = q;
                            q = q.offset(1);
                            *fresh99 = (c & 0x3f as libc::c_int | 0x80 as libc::c_int)
                                as uint8_t;
                        }
                        pos += 1;
                    }
                    current_block = 8347882395825654554;
                }
            } else {
                let mut src_0: *const uint16_t = ((*str).u.str16).as_mut_ptr();
                str_new = js_alloc_string(ctx, len * 3 as libc::c_int, 0 as libc::c_int);
                if str_new.is_null() {
                    current_block = 3744173141220556273;
                } else {
                    q = ((*str_new).u.str8).as_mut_ptr();
                    pos = 0 as libc::c_int;
                    while pos < len {
                        let fresh100 = pos;
                        pos = pos + 1;
                        c = *src_0.offset(fresh100 as isize) as libc::c_int;
                        if c < 0x80 as libc::c_int {
                            let fresh101 = q;
                            q = q.offset(1);
                            *fresh101 = c as uint8_t;
                        } else {
                            if c >= 0xd800 as libc::c_int && c < 0xdc00 as libc::c_int {
                                if pos < len && cesu8 == 0 {
                                    c1 = *src_0.offset(pos as isize) as libc::c_int;
                                    if c1 >= 0xdc00 as libc::c_int && c1 < 0xe000 as libc::c_int
                                    {
                                        pos += 1;
                                        c = ((c & 0x3ff as libc::c_int) << 10 as libc::c_int
                                            | c1 & 0x3ff as libc::c_int) + 0x10000 as libc::c_int;
                                    }
                                }
                            }
                            q = q.offset(unicode_to_utf8(q, c as libc::c_uint) as isize);
                        }
                    }
                    current_block = 8347882395825654554;
                }
            }
            match current_block {
                3744173141220556273 => {}
                _ => {
                    *q = '\0' as i32 as uint8_t;
                    (*str_new)
                        .set_len(
                            q.offset_from(((*str_new).u.str8).as_mut_ptr())
                                as libc::c_long as uint32_t,
                        );
                    JS_FreeValue(ctx, val);
                    if !plen.is_null() {
                        *plen = (*str_new).len() as size_t;
                    }
                    return ((*str_new).u.str8).as_mut_ptr() as *const libc::c_char;
                }
            }
        }
        _ => {}
    }
    if !plen.is_null() {
        *plen = 0 as libc::c_int as size_t;
    }
    return 0 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn JS_FreeCString(
    mut ctx: *mut JSContext,
    mut ptr: *const libc::c_char,
) {
    let mut p: *mut JSString = 0 as *mut JSString;
    if ptr.is_null() {
        return;
    }
    p = ptr.offset(-(16 as libc::c_ulong as isize)) as *mut libc::c_void
        as *mut JSString;
    JS_FreeValue(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | p as uintptr_t as libc::c_ulonglong,
    );
}
unsafe extern "C" fn memcmp16_8(
    mut src1: *const uint16_t,
    mut src2: *const uint8_t,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        c = *src1.offset(i as isize) as libc::c_int
            - *src2.offset(i as isize) as libc::c_int;
        if c != 0 as libc::c_int {
            return c;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn memcmp16(
    mut src1: *const uint16_t,
    mut src2: *const uint16_t,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        c = *src1.offset(i as isize) as libc::c_int
            - *src2.offset(i as isize) as libc::c_int;
        if c != 0 as libc::c_int {
            return c;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_string_memcmp(
    mut p1: *const JSString,
    mut p2: *const JSString,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if ((*p1).is_wide_char() == 0) as libc::c_int as libc::c_long != 0 {
        if ((*p2).is_wide_char() == 0) as libc::c_int as libc::c_long != 0 {
            res = memcmp(
                ((*p1).u.str8).as_ptr() as *const libc::c_void,
                ((*p2).u.str8).as_ptr() as *const libc::c_void,
                len as libc::c_ulong,
            );
        } else {
            res = -memcmp16_8(((*p2).u.str16).as_ptr(), ((*p1).u.str8).as_ptr(), len);
        }
    } else if (*p2).is_wide_char() == 0 {
        res = memcmp16_8(((*p1).u.str16).as_ptr(), ((*p2).u.str8).as_ptr(), len);
    } else {
        res = memcmp16(((*p1).u.str16).as_ptr(), ((*p2).u.str16).as_ptr(), len);
    }
    return res;
}
unsafe extern "C" fn js_string_compare(
    mut ctx: *mut JSContext,
    mut p1: *const JSString,
    mut p2: *const JSString,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    len = min_int((*p1).len() as libc::c_int, (*p2).len() as libc::c_int);
    res = js_string_memcmp(p1, p2, len);
    if res == 0 as libc::c_int {
        if (*p1).len() as libc::c_int == (*p2).len() as libc::c_int {
            res = 0 as libc::c_int;
        } else if ((*p1).len() as libc::c_int) < (*p2).len() as libc::c_int {
            res = -(1 as libc::c_int);
        } else {
            res = 1 as libc::c_int;
        }
    }
    return res;
}
unsafe extern "C" fn copy_str16(
    mut dst: *mut uint16_t,
    mut p: *const JSString,
    mut offset: libc::c_int,
    mut len: libc::c_int,
) {
    if (*p).is_wide_char() != 0 {
        memcpy(
            dst as *mut libc::c_void,
            ((*p).u.str16).as_ptr().offset(offset as isize) as *const libc::c_void,
            (len * 2 as libc::c_int) as libc::c_ulong,
        );
    } else {
        let mut src1: *const uint8_t = ((*p).u.str8).as_ptr().offset(offset as isize);
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < len {
            *dst.offset(i as isize) = *src1.offset(i as isize) as uint16_t;
            i += 1;
        }
    };
}
unsafe extern "C" fn JS_ConcatString1(
    mut ctx: *mut JSContext,
    mut p1: *const JSString,
    mut p2: *const JSString,
) -> JSValue {
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut len: uint32_t = 0;
    let mut is_wide_char: libc::c_int = 0;
    len = ((*p1).len() as libc::c_int + (*p2).len() as libc::c_int) as uint32_t;
    if len
        > (((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int) as libc::c_uint
    {
        return JS_ThrowInternalError(
            ctx,
            b"string too long\0" as *const u8 as *const libc::c_char,
        );
    }
    is_wide_char = (*p1).is_wide_char() as libc::c_int
        | (*p2).is_wide_char() as libc::c_int;
    p = js_alloc_string(ctx, len as libc::c_int, is_wide_char);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if is_wide_char == 0 {
        memcpy(
            ((*p).u.str8).as_mut_ptr() as *mut libc::c_void,
            ((*p1).u.str8).as_ptr() as *const libc::c_void,
            (*p1).len() as libc::c_ulong,
        );
        memcpy(
            ((*p).u.str8).as_mut_ptr().offset((*p1).len() as libc::c_int as isize)
                as *mut libc::c_void,
            ((*p2).u.str8).as_ptr() as *const libc::c_void,
            (*p2).len() as libc::c_ulong,
        );
        (*p).u.str8[len as usize] = '\0' as i32 as uint8_t;
    } else {
        copy_str16(
            ((*p).u.str16).as_mut_ptr(),
            p1,
            0 as libc::c_int,
            (*p1).len() as libc::c_int,
        );
        copy_str16(
            ((*p).u.str16).as_mut_ptr().offset((*p1).len() as libc::c_int as isize),
            p2,
            0 as libc::c_int,
            (*p2).len() as libc::c_int,
        );
    }
    return (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
        | p as uintptr_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ConcatString(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
    mut op2: JSValue,
) -> JSValue {
    let mut ret: JSValue = 0;
    let mut p1: *mut JSString = 0 as *mut JSString;
    let mut p2: *mut JSString = 0 as *mut JSString;
    if ((op1 >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        op1 = JS_ToStringFree(ctx, op1);
        if JS_IsException(op1) != 0 {
            JS_FreeValue(ctx, op2);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if ((op2 >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        op2 = JS_ToStringFree(ctx, op2);
        if JS_IsException(op2) != 0 {
            JS_FreeValue(ctx, op1);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    p1 = op1 as intptr_t as *mut libc::c_void as *mut JSString;
    p2 = op2 as intptr_t as *mut libc::c_void as *mut JSString;
    if !((*p2).len() as libc::c_int == 0 as libc::c_int) {
        if (*p1).header.ref_count == 1 as libc::c_int
            && (*p1).is_wide_char() as libc::c_int == (*p2).is_wide_char() as libc::c_int
            && js_malloc_usable_size(ctx, p1 as *const libc::c_void)
                >= (::core::mem::size_of::<JSString>() as libc::c_ulong)
                    .wrapping_add(
                        (((*p1).len() as libc::c_int + (*p2).len() as libc::c_int)
                            << (*p2).is_wide_char() as libc::c_int) as libc::c_ulong,
                    )
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    .wrapping_sub((*p1).is_wide_char() as libc::c_ulong)
        {
            if (*p1).is_wide_char() != 0 {
                memcpy(
                    ((*p1).u.str16)
                        .as_mut_ptr()
                        .offset((*p1).len() as libc::c_int as isize)
                        as *mut libc::c_void,
                    ((*p2).u.str16).as_mut_ptr() as *const libc::c_void,
                    (((*p2).len() as libc::c_int) << 1 as libc::c_int) as libc::c_ulong,
                );
                (*p1).set_len((*p1).len() + (*p2).len() as libc::c_int as uint32_t);
            } else {
                memcpy(
                    ((*p1).u.str8)
                        .as_mut_ptr()
                        .offset((*p1).len() as libc::c_int as isize)
                        as *mut libc::c_void,
                    ((*p2).u.str8).as_mut_ptr() as *const libc::c_void,
                    (*p2).len() as libc::c_ulong,
                );
                (*p1).set_len((*p1).len() + (*p2).len() as libc::c_int as uint32_t);
                (*p1).u.str8[(*p1).len() as usize] = '\0' as i32 as uint8_t;
            }
        } else {
            ret = JS_ConcatString1(ctx, p1, p2);
            JS_FreeValue(ctx, op1);
            JS_FreeValue(ctx, op2);
            return ret;
        }
    }
    JS_FreeValue(ctx, op2);
    return op1;
}
#[inline]
unsafe extern "C" fn get_shape_size(
    mut hash_size: size_t,
    mut prop_size: size_t,
) -> size_t {
    return hash_size
        .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<JSShape>() as libc::c_ulong)
        .wrapping_add(
            prop_size
                .wrapping_mul(::core::mem::size_of::<JSShapeProperty>() as libc::c_ulong),
        );
}
#[inline]
unsafe extern "C" fn get_shape_from_alloc(
    mut sh_alloc: *mut libc::c_void,
    mut hash_size: size_t,
) -> *mut JSShape {
    return (sh_alloc as *mut uint32_t).offset(hash_size as isize) as *mut libc::c_void
        as *mut JSShape;
}
#[inline]
unsafe extern "C" fn prop_hash_end(mut sh: *mut JSShape) -> *mut uint32_t {
    return sh as *mut uint32_t;
}
#[inline]
unsafe extern "C" fn get_alloc_from_shape(mut sh: *mut JSShape) -> *mut libc::c_void {
    return (prop_hash_end(sh))
        .offset(-(((*sh).prop_hash_mask as intptr_t + 1 as libc::c_int) as isize))
        as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn get_shape_prop(mut sh: *mut JSShape) -> *mut JSShapeProperty {
    return ((*sh).prop).as_mut_ptr();
}
unsafe extern "C" fn init_shape_hash(mut rt: *mut JSRuntime) -> libc::c_int {
    (*rt).shape_hash_bits = 4 as libc::c_int;
    (*rt).shape_hash_size = (1 as libc::c_int) << (*rt).shape_hash_bits;
    (*rt).shape_hash_count = 0 as libc::c_int;
    let ref mut fresh102 = (*rt).shape_hash;
    *fresh102 = js_mallocz_rt(
        rt,
        (::core::mem::size_of::<*mut JSShape>() as libc::c_ulong)
            .wrapping_mul((*rt).shape_hash_size as libc::c_ulong),
    ) as *mut *mut JSShape;
    if ((*rt).shape_hash).is_null() {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn shape_hash(mut h: uint32_t, mut val: uint32_t) -> uint32_t {
    return h.wrapping_add(val).wrapping_mul(0x9e370001 as libc::c_uint);
}
unsafe extern "C" fn get_shape_hash(
    mut h: uint32_t,
    mut hash_bits: libc::c_int,
) -> uint32_t {
    return h >> 32 as libc::c_int - hash_bits;
}
unsafe extern "C" fn shape_initial_hash(mut proto: *mut JSObject) -> uint32_t {
    let mut h: uint32_t = 0;
    h = shape_hash(1 as libc::c_int as uint32_t, proto as uintptr_t);
    if ::core::mem::size_of::<*mut JSObject>() as libc::c_ulong
        > 4 as libc::c_int as libc::c_ulong
    {
        h = shape_hash(
            h,
            (proto as uintptr_t as uint64_t >> 32 as libc::c_int) as uint32_t,
        );
    }
    return h;
}
unsafe extern "C" fn resize_shape_hash(
    mut rt: *mut JSRuntime,
    mut new_shape_hash_bits: libc::c_int,
) -> libc::c_int {
    let mut new_shape_hash_size: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut h: uint32_t = 0;
    let mut new_shape_hash: *mut *mut JSShape = 0 as *mut *mut JSShape;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut sh_next: *mut JSShape = 0 as *mut JSShape;
    new_shape_hash_size = (1 as libc::c_int) << new_shape_hash_bits;
    new_shape_hash = js_mallocz_rt(
        rt,
        (::core::mem::size_of::<*mut JSShape>() as libc::c_ulong)
            .wrapping_mul(new_shape_hash_size as libc::c_ulong),
    ) as *mut *mut JSShape;
    if new_shape_hash.is_null() {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int;
    while i < (*rt).shape_hash_size {
        sh = *((*rt).shape_hash).offset(i as isize);
        while !sh.is_null() {
            sh_next = (*sh).shape_hash_next;
            h = get_shape_hash((*sh).hash, new_shape_hash_bits);
            let ref mut fresh103 = (*sh).shape_hash_next;
            *fresh103 = *new_shape_hash.offset(h as isize);
            let ref mut fresh104 = *new_shape_hash.offset(h as isize);
            *fresh104 = sh;
            sh = sh_next;
        }
        i += 1;
    }
    js_free_rt(rt, (*rt).shape_hash as *mut libc::c_void);
    (*rt).shape_hash_bits = new_shape_hash_bits;
    (*rt).shape_hash_size = new_shape_hash_size;
    let ref mut fresh105 = (*rt).shape_hash;
    *fresh105 = new_shape_hash;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_shape_hash_link(mut rt: *mut JSRuntime, mut sh: *mut JSShape) {
    let mut h: uint32_t = 0;
    h = get_shape_hash((*sh).hash, (*rt).shape_hash_bits);
    let ref mut fresh106 = (*sh).shape_hash_next;
    *fresh106 = *((*rt).shape_hash).offset(h as isize);
    let ref mut fresh107 = *((*rt).shape_hash).offset(h as isize);
    *fresh107 = sh;
    let ref mut fresh108 = (*rt).shape_hash_count;
    *fresh108 += 1;
}
unsafe extern "C" fn js_shape_hash_unlink(mut rt: *mut JSRuntime, mut sh: *mut JSShape) {
    let mut h: uint32_t = 0;
    let mut psh: *mut *mut JSShape = 0 as *mut *mut JSShape;
    h = get_shape_hash((*sh).hash, (*rt).shape_hash_bits);
    psh = &mut *((*rt).shape_hash).offset(h as isize) as *mut *mut JSShape;
    while *psh != sh {
        psh = &mut (**psh).shape_hash_next;
    }
    *psh = (*sh).shape_hash_next;
    let ref mut fresh109 = (*rt).shape_hash_count;
    *fresh109 -= 1;
}
#[inline(never)]
unsafe extern "C" fn js_new_shape2(
    mut ctx: *mut JSContext,
    mut proto: *mut JSObject,
    mut hash_size: libc::c_int,
    mut prop_size: libc::c_int,
) -> *mut JSShape {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut sh_alloc: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    if 2 as libc::c_int * ((*rt).shape_hash_count + 1 as libc::c_int)
        > (*rt).shape_hash_size
    {
        resize_shape_hash(rt, (*rt).shape_hash_bits + 1 as libc::c_int);
    }
    sh_alloc = js_malloc(ctx, get_shape_size(hash_size as size_t, prop_size as size_t));
    if sh_alloc.is_null() {
        return 0 as *mut JSShape;
    }
    sh = get_shape_from_alloc(sh_alloc, hash_size as size_t);
    (*sh).header.ref_count = 1 as libc::c_int;
    add_gc_object(rt, &mut (*sh).header, JS_GC_OBJ_TYPE_SHAPE);
    if !proto.is_null() {
        JS_DupValue(
            ctx,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | proto as uintptr_t as libc::c_ulonglong,
        );
    }
    let ref mut fresh110 = (*sh).proto;
    *fresh110 = proto;
    memset(
        (prop_hash_end(sh)).offset(-(hash_size as isize)) as *mut libc::c_void,
        0 as libc::c_int,
        (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
            .wrapping_mul(hash_size as libc::c_ulong),
    );
    (*sh).prop_hash_mask = (hash_size - 1 as libc::c_int) as uint32_t;
    (*sh).prop_size = prop_size;
    (*sh).prop_count = 0 as libc::c_int;
    (*sh).deleted_prop_count = 0 as libc::c_int;
    (*sh).hash = shape_initial_hash(proto);
    (*sh).is_hashed = TRUE as libc::c_int as uint8_t;
    (*sh).has_small_array_index = FALSE as libc::c_int as uint8_t;
    js_shape_hash_link((*ctx).rt, sh);
    return sh;
}
unsafe extern "C" fn js_new_shape(
    mut ctx: *mut JSContext,
    mut proto: *mut JSObject,
) -> *mut JSShape {
    return js_new_shape2(ctx, proto, 4 as libc::c_int, 2 as libc::c_int);
}
unsafe extern "C" fn js_clone_shape(
    mut ctx: *mut JSContext,
    mut sh1: *mut JSShape,
) -> *mut JSShape {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut sh_alloc: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut sh_alloc1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut size: size_t = 0;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut i: uint32_t = 0;
    let mut hash_size: uint32_t = 0;
    hash_size = ((*sh1).prop_hash_mask).wrapping_add(1 as libc::c_int as libc::c_uint);
    size = get_shape_size(hash_size as size_t, (*sh1).prop_size as size_t);
    sh_alloc = js_malloc(ctx, size);
    if sh_alloc.is_null() {
        return 0 as *mut JSShape;
    }
    sh_alloc1 = get_alloc_from_shape(sh1);
    memcpy(sh_alloc, sh_alloc1, size);
    sh = get_shape_from_alloc(sh_alloc, hash_size as size_t);
    (*sh).header.ref_count = 1 as libc::c_int;
    add_gc_object((*ctx).rt, &mut (*sh).header, JS_GC_OBJ_TYPE_SHAPE);
    (*sh).is_hashed = FALSE as libc::c_int as uint8_t;
    if !((*sh).proto).is_null() {
        JS_DupValue(
            ctx,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*sh).proto as uintptr_t as libc::c_ulonglong,
        );
    }
    i = 0 as libc::c_int as uint32_t;
    pr = get_shape_prop(sh);
    while i < (*sh).prop_count as libc::c_uint {
        JS_DupAtom(ctx, (*pr).atom);
        i = i.wrapping_add(1);
        pr = pr.offset(1);
    }
    return sh;
}
unsafe extern "C" fn js_dup_shape(mut sh: *mut JSShape) -> *mut JSShape {
    let ref mut fresh111 = (*sh).header.ref_count;
    *fresh111 += 1;
    return sh;
}
unsafe extern "C" fn js_free_shape0(mut rt: *mut JSRuntime, mut sh: *mut JSShape) {
    let mut i: uint32_t = 0;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    assert(((*sh).header.ref_count == 0 as libc::c_int) as libc::c_int);
    if (*sh).is_hashed != 0 {
        js_shape_hash_unlink(rt, sh);
    }
    if !((*sh).proto).is_null() {
        JS_FreeValueRT(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*sh).proto as uintptr_t as libc::c_ulonglong,
        );
    }
    pr = get_shape_prop(sh);
    i = 0 as libc::c_int as uint32_t;
    while i < (*sh).prop_count as libc::c_uint {
        JS_FreeAtomRT(rt, (*pr).atom);
        pr = pr.offset(1);
        i = i.wrapping_add(1);
    }
    remove_gc_object(&mut (*sh).header);
    js_free_rt(rt, get_alloc_from_shape(sh));
}
unsafe extern "C" fn js_free_shape(mut rt: *mut JSRuntime, mut sh: *mut JSShape) {
    let ref mut fresh112 = (*sh).header.ref_count;
    *fresh112 -= 1;
    if (*fresh112 <= 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        js_free_shape0(rt, sh);
    }
}
unsafe extern "C" fn js_free_shape_null(mut rt: *mut JSRuntime, mut sh: *mut JSShape) {
    if !sh.is_null() {
        js_free_shape(rt, sh);
    }
}
#[inline(never)]
unsafe extern "C" fn resize_properties(
    mut ctx: *mut JSContext,
    mut psh: *mut *mut JSShape,
    mut p: *mut JSObject,
    mut count: uint32_t,
) -> libc::c_int {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut new_size: uint32_t = 0;
    let mut new_hash_size: uint32_t = 0;
    let mut new_hash_mask: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut sh_alloc: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut h: intptr_t = 0;
    sh = *psh;
    new_size = max_int(
        count as libc::c_int,
        (*sh).prop_size * 3 as libc::c_int / 2 as libc::c_int,
    ) as uint32_t;
    if !p.is_null() {
        let mut new_prop: *mut JSProperty = 0 as *mut JSProperty;
        new_prop = js_realloc(
            ctx,
            (*p).prop as *mut libc::c_void,
            (::core::mem::size_of::<JSProperty>() as libc::c_ulong)
                .wrapping_mul(new_size as libc::c_ulong),
        ) as *mut JSProperty;
        if new_prop.is_null() as libc::c_int as libc::c_long != 0 {
            return -(1 as libc::c_int);
        }
        let ref mut fresh113 = (*p).prop;
        *fresh113 = new_prop;
    }
    new_hash_size = ((*sh).prop_hash_mask)
        .wrapping_add(1 as libc::c_int as libc::c_uint);
    while new_hash_size < new_size {
        new_hash_size = (2 as libc::c_int as libc::c_uint).wrapping_mul(new_hash_size);
    }
    if new_hash_size
        != ((*sh).prop_hash_mask).wrapping_add(1 as libc::c_int as libc::c_uint)
    {
        let mut old_sh: *mut JSShape = 0 as *mut JSShape;
        old_sh = sh;
        sh_alloc = js_malloc(
            ctx,
            get_shape_size(new_hash_size as size_t, new_size as size_t),
        );
        if sh_alloc.is_null() {
            return -(1 as libc::c_int);
        }
        sh = get_shape_from_alloc(sh_alloc, new_hash_size as size_t);
        list_del(&mut (*old_sh).header.link);
        memcpy(
            sh as *mut libc::c_void,
            old_sh as *const libc::c_void,
            (::core::mem::size_of::<JSShape>() as libc::c_ulong)
                .wrapping_add(
                    (::core::mem::size_of::<JSShapeProperty>() as libc::c_ulong)
                        .wrapping_mul((*old_sh).prop_count as libc::c_ulong),
                ),
        );
        list_add_tail(&mut (*sh).header.link, &mut (*(*ctx).rt).gc_obj_list);
        new_hash_mask = new_hash_size.wrapping_sub(1 as libc::c_int as libc::c_uint);
        (*sh).prop_hash_mask = new_hash_mask;
        memset(
            (prop_hash_end(sh)).offset(-(new_hash_size as isize)) as *mut libc::c_void,
            0 as libc::c_int,
            (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
                .wrapping_mul(new_hash_size as libc::c_ulong),
        );
        i = 0 as libc::c_int as uint32_t;
        pr = ((*sh).prop).as_mut_ptr();
        while i < (*sh).prop_count as libc::c_uint {
            if (*pr).atom != 0 as libc::c_int as libc::c_uint {
                h = ((*pr).atom & new_hash_mask) as intptr_t;
                (*pr)
                    .set_hash_next(
                        *(prop_hash_end(sh)).offset((-h - 1 as libc::c_int) as isize),
                    );
                *(prop_hash_end(sh))
                    .offset(
                        (-h - 1 as libc::c_int) as isize,
                    ) = i.wrapping_add(1 as libc::c_int as libc::c_uint);
            }
            i = i.wrapping_add(1);
            pr = pr.offset(1);
        }
        js_free(ctx, get_alloc_from_shape(old_sh));
    } else {
        list_del(&mut (*sh).header.link);
        sh_alloc = js_realloc(
            ctx,
            get_alloc_from_shape(sh),
            get_shape_size(new_hash_size as size_t, new_size as size_t),
        );
        if sh_alloc.is_null() as libc::c_int as libc::c_long != 0 {
            list_add_tail(&mut (*sh).header.link, &mut (*(*ctx).rt).gc_obj_list);
            return -(1 as libc::c_int);
        }
        sh = get_shape_from_alloc(sh_alloc, new_hash_size as size_t);
        list_add_tail(&mut (*sh).header.link, &mut (*(*ctx).rt).gc_obj_list);
    }
    *psh = sh;
    (*sh).prop_size = new_size as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn compact_properties(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
) -> libc::c_int {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut old_sh: *mut JSShape = 0 as *mut JSShape;
    let mut sh_alloc: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut h: intptr_t = 0;
    let mut new_hash_size: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut j: uint32_t = 0;
    let mut new_hash_mask: uint32_t = 0;
    let mut new_size: uint32_t = 0;
    let mut old_pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut prop: *mut JSProperty = 0 as *mut JSProperty;
    let mut new_prop: *mut JSProperty = 0 as *mut JSProperty;
    sh = (*p).shape;
    assert(((*sh).is_hashed == 0) as libc::c_int);
    new_size = max_int(2 as libc::c_int, (*sh).prop_count - (*sh).deleted_prop_count)
        as uint32_t;
    assert((new_size <= (*sh).prop_size as libc::c_uint) as libc::c_int);
    new_hash_size = ((*sh).prop_hash_mask)
        .wrapping_add(1 as libc::c_int as libc::c_uint);
    while new_hash_size.wrapping_div(2 as libc::c_int as libc::c_uint) >= new_size {
        new_hash_size = new_hash_size.wrapping_div(2 as libc::c_int as libc::c_uint);
    }
    new_hash_mask = new_hash_size.wrapping_sub(1 as libc::c_int as libc::c_uint);
    old_sh = sh;
    sh_alloc = js_malloc(
        ctx,
        get_shape_size(new_hash_size as size_t, new_size as size_t),
    );
    if sh_alloc.is_null() {
        return -(1 as libc::c_int);
    }
    sh = get_shape_from_alloc(sh_alloc, new_hash_size as size_t);
    list_del(&mut (*old_sh).header.link);
    memcpy(
        sh as *mut libc::c_void,
        old_sh as *const libc::c_void,
        ::core::mem::size_of::<JSShape>() as libc::c_ulong,
    );
    list_add_tail(&mut (*sh).header.link, &mut (*(*ctx).rt).gc_obj_list);
    memset(
        (prop_hash_end(sh)).offset(-(new_hash_size as isize)) as *mut libc::c_void,
        0 as libc::c_int,
        (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
            .wrapping_mul(new_hash_size as libc::c_ulong),
    );
    j = 0 as libc::c_int as uint32_t;
    old_pr = ((*old_sh).prop).as_mut_ptr();
    pr = ((*sh).prop).as_mut_ptr();
    prop = (*p).prop;
    i = 0 as libc::c_int as uint32_t;
    while i < (*sh).prop_count as libc::c_uint {
        if (*old_pr).atom != 0 as libc::c_int as libc::c_uint {
            (*pr).atom = (*old_pr).atom;
            (*pr).set_flags((*old_pr).flags());
            h = ((*old_pr).atom & new_hash_mask) as intptr_t;
            (*pr)
                .set_hash_next(
                    *(prop_hash_end(sh)).offset((-h - 1 as libc::c_int) as isize),
                );
            *(prop_hash_end(sh))
                .offset(
                    (-h - 1 as libc::c_int) as isize,
                ) = j.wrapping_add(1 as libc::c_int as libc::c_uint);
            *prop.offset(j as isize) = *prop.offset(i as isize);
            j = j.wrapping_add(1);
            pr = pr.offset(1);
        }
        old_pr = old_pr.offset(1);
        i = i.wrapping_add(1);
    }
    assert(
        (j == ((*sh).prop_count - (*sh).deleted_prop_count) as libc::c_uint)
            as libc::c_int,
    );
    (*sh).prop_hash_mask = new_hash_mask;
    (*sh).prop_size = new_size as libc::c_int;
    (*sh).deleted_prop_count = 0 as libc::c_int;
    (*sh).prop_count = j as libc::c_int;
    let ref mut fresh114 = (*p).shape;
    *fresh114 = sh;
    js_free(ctx, get_alloc_from_shape(old_sh));
    new_prop = js_realloc(
        ctx,
        (*p).prop as *mut libc::c_void,
        (::core::mem::size_of::<JSProperty>() as libc::c_ulong)
            .wrapping_mul(new_size as libc::c_ulong),
    ) as *mut JSProperty;
    if !new_prop.is_null() {
        let ref mut fresh115 = (*p).prop;
        *fresh115 = new_prop;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn add_shape_property(
    mut ctx: *mut JSContext,
    mut psh: *mut *mut JSShape,
    mut p: *mut JSObject,
    mut atom: JSAtom,
    mut prop_flags: libc::c_int,
) -> libc::c_int {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut sh: *mut JSShape = *psh;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut prop: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut hash_mask: uint32_t = 0;
    let mut new_shape_hash: uint32_t = 0 as libc::c_int as uint32_t;
    let mut h: intptr_t = 0;
    if (*sh).is_hashed != 0 {
        js_shape_hash_unlink(rt, sh);
        new_shape_hash = shape_hash(
            shape_hash((*sh).hash, atom),
            prop_flags as uint32_t,
        );
    }
    if ((*sh).prop_count >= (*sh).prop_size) as libc::c_int as libc::c_long != 0 {
        if resize_properties(
            ctx,
            psh,
            p,
            ((*sh).prop_count + 1 as libc::c_int) as uint32_t,
        ) != 0
        {
            if (*sh).is_hashed != 0 {
                js_shape_hash_link(rt, sh);
            }
            return -(1 as libc::c_int);
        }
        sh = *psh;
    }
    if (*sh).is_hashed != 0 {
        (*sh).hash = new_shape_hash;
        js_shape_hash_link(rt, sh);
    }
    prop = get_shape_prop(sh);
    let ref mut fresh116 = (*sh).prop_count;
    let fresh117 = *fresh116;
    *fresh116 = *fresh116 + 1;
    pr = &mut *prop.offset(fresh117 as isize) as *mut JSShapeProperty;
    (*pr).atom = JS_DupAtom(ctx, atom);
    (*pr).set_flags(prop_flags as uint32_t);
    let ref mut fresh118 = (*sh).has_small_array_index;
    *fresh118 = (*fresh118 as libc::c_int | __JS_AtomIsTaggedInt(atom)) as uint8_t;
    hash_mask = (*sh).prop_hash_mask;
    h = (atom & hash_mask) as intptr_t;
    (*pr).set_hash_next(*(prop_hash_end(sh)).offset((-h - 1 as libc::c_int) as isize));
    *(prop_hash_end(sh))
        .offset((-h - 1 as libc::c_int) as isize) = (*sh).prop_count as uint32_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn find_hashed_shape_proto(
    mut rt: *mut JSRuntime,
    mut proto: *mut JSObject,
) -> *mut JSShape {
    let mut sh1: *mut JSShape = 0 as *mut JSShape;
    let mut h: uint32_t = 0;
    let mut h1: uint32_t = 0;
    h = shape_initial_hash(proto);
    h1 = get_shape_hash(h, (*rt).shape_hash_bits);
    sh1 = *((*rt).shape_hash).offset(h1 as isize);
    while !sh1.is_null() {
        if (*sh1).hash == h && (*sh1).proto == proto
            && (*sh1).prop_count == 0 as libc::c_int
        {
            return sh1;
        }
        sh1 = (*sh1).shape_hash_next;
    }
    return 0 as *mut JSShape;
}
unsafe extern "C" fn find_hashed_shape_prop(
    mut rt: *mut JSRuntime,
    mut sh: *mut JSShape,
    mut atom: JSAtom,
    mut prop_flags: libc::c_int,
) -> *mut JSShape {
    let mut current_block: u64;
    let mut sh1: *mut JSShape = 0 as *mut JSShape;
    let mut h: uint32_t = 0;
    let mut h1: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut n: uint32_t = 0;
    h = (*sh).hash;
    h = shape_hash(h, atom);
    h = shape_hash(h, prop_flags as uint32_t);
    h1 = get_shape_hash(h, (*rt).shape_hash_bits);
    sh1 = *((*rt).shape_hash).offset(h1 as isize);
    while !sh1.is_null() {
        if (*sh1).hash == h && (*sh1).proto == (*sh).proto
            && {
                n = (*sh).prop_count as uint32_t;
                (*sh1).prop_count as libc::c_uint
                    == n.wrapping_add(1 as libc::c_int as libc::c_uint)
            }
        {
            i = 0 as libc::c_int as uint32_t;
            loop {
                if !(i < n) {
                    current_block = 13536709405535804910;
                    break;
                }
                if ((*((*sh1).prop).as_mut_ptr().offset(i as isize)).atom
                    != (*((*sh).prop).as_mut_ptr().offset(i as isize)).atom)
                    as libc::c_int as libc::c_long != 0
                    || ((*((*sh1).prop).as_mut_ptr().offset(i as isize)).flags()
                        as libc::c_int
                        != (*((*sh).prop).as_mut_ptr().offset(i as isize)).flags()
                            as libc::c_int) as libc::c_int as libc::c_long != 0
                {
                    current_block = 7095457783677275021;
                    break;
                }
                i = i.wrapping_add(1);
            }
            match current_block {
                7095457783677275021 => {}
                _ => {
                    if !(((*((*sh1).prop).as_mut_ptr().offset(n as isize)).atom != atom)
                        as libc::c_int as libc::c_long != 0
                        || ((*((*sh1).prop).as_mut_ptr().offset(n as isize)).flags()
                            as libc::c_int != prop_flags) as libc::c_int as libc::c_long
                            != 0)
                    {
                        return sh1;
                    }
                }
            }
        }
        sh1 = (*sh1).shape_hash_next;
    }
    return 0 as *mut JSShape;
}
unsafe extern "C" fn JS_NewObjectFromShape(
    mut ctx: *mut JSContext,
    mut sh: *mut JSShape,
    mut class_id: JSClassID,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    js_trigger_gc((*ctx).rt, ::core::mem::size_of::<JSObject>() as libc::c_ulong);
    p = js_malloc(ctx, ::core::mem::size_of::<JSObject>() as libc::c_ulong)
        as *mut JSObject;
    if !(p.is_null() as libc::c_int as libc::c_long != 0) {
        (*p).c2rust_unnamed.c2rust_unnamed.class_id = class_id as uint16_t;
        let ref mut fresh119 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh119).set_extensible(TRUE as libc::c_int as uint8_t);
        let ref mut fresh120 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh120).set_free_mark(0 as libc::c_int as uint8_t);
        let ref mut fresh121 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh121).set_is_exotic(0 as libc::c_int as uint8_t);
        let ref mut fresh122 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh122).set_fast_array(0 as libc::c_int as uint8_t);
        let ref mut fresh123 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh123).set_is_constructor(0 as libc::c_int as uint8_t);
        let ref mut fresh124 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh124).set_is_uncatchable_error(0 as libc::c_int as uint8_t);
        let ref mut fresh125 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh125).set_tmp_mark(0 as libc::c_int as uint8_t);
        let ref mut fresh126 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh126).set_is_HTMLDDA(0 as libc::c_int as uint8_t);
        let ref mut fresh127 = (*p).first_weak_ref;
        *fresh127 = 0 as *mut JSMapRecord;
        let ref mut fresh128 = (*p).u.opaque;
        *fresh128 = 0 as *mut libc::c_void;
        let ref mut fresh129 = (*p).shape;
        *fresh129 = sh;
        let ref mut fresh130 = (*p).prop;
        *fresh130 = js_malloc(
            ctx,
            (::core::mem::size_of::<JSProperty>() as libc::c_ulong)
                .wrapping_mul((*sh).prop_size as libc::c_ulong),
        ) as *mut JSProperty;
        if ((*p).prop).is_null() as libc::c_int as libc::c_long != 0 {
            js_free(ctx, p as *mut libc::c_void);
        } else {
            match class_id {
                1 => {
                    current_block = 5892776923941496671;
                }
                2 => {
                    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
                    let ref mut fresh131 = (*p).c2rust_unnamed.c2rust_unnamed;
                    (*fresh131).set_is_exotic(1 as libc::c_int as uint8_t);
                    let ref mut fresh132 = (*p).c2rust_unnamed.c2rust_unnamed;
                    (*fresh132).set_fast_array(1 as libc::c_int as uint8_t);
                    let ref mut fresh133 = (*p).u.array.u.values;
                    *fresh133 = 0 as *mut JSValue;
                    (*p).u.array.count = 0 as libc::c_int as uint32_t;
                    (*p).u.array.u1.size = 0 as libc::c_int as uint32_t;
                    if (sh == (*ctx).array_shape) as libc::c_int as libc::c_long != 0 {
                        pr = &mut *((*p).prop).offset(0 as libc::c_int as isize)
                            as *mut JSProperty;
                    } else {
                        pr = add_property(
                            ctx,
                            p,
                            JS_ATOM_length as libc::c_int as JSAtom,
                            (1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 3 as libc::c_int,
                        );
                    }
                    (*pr).u.value = JS_NewInt32(ctx, 0 as libc::c_int);
                    current_block = 5892776923941496671;
                }
                12 => {
                    (*((*p).prop).offset(0 as libc::c_int as isize))
                        .u
                        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block = 5892776923941496671;
                }
                8 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 => {
                    let ref mut fresh134 = (*p).c2rust_unnamed.c2rust_unnamed;
                    (*fresh134).set_is_exotic(1 as libc::c_int as uint8_t);
                    let ref mut fresh135 = (*p).c2rust_unnamed.c2rust_unnamed;
                    (*fresh135).set_fast_array(1 as libc::c_int as uint8_t);
                    let ref mut fresh136 = (*p).u.array.u.ptr;
                    *fresh136 = 0 as *mut libc::c_void;
                    (*p).u.array.count = 0 as libc::c_int as uint32_t;
                    current_block = 5892776923941496671;
                }
                30 => {
                    let ref mut fresh137 = (*p).u.array.u.ptr;
                    *fresh137 = 0 as *mut libc::c_void;
                    (*p).u.array.count = 0 as libc::c_int as uint32_t;
                    current_block = 5892776923941496671;
                }
                4 | 5 | 6 | 7 | 10 => {
                    (*p)
                        .u
                        .object_data = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block = 11922022654171465835;
                }
                18 => {
                    let ref mut fresh138 = (*p).u.regexp.pattern;
                    *fresh138 = 0 as *mut JSString;
                    let ref mut fresh139 = (*p).u.regexp.bytecode;
                    *fresh139 = 0 as *mut JSString;
                    current_block = 11922022654171465835;
                }
                _ => {
                    current_block = 11922022654171465835;
                }
            }
            match current_block {
                11922022654171465835 => {
                    if !((*((*(*ctx).rt).class_array).offset(class_id as isize)).exotic)
                        .is_null()
                    {
                        let ref mut fresh140 = (*p).c2rust_unnamed.c2rust_unnamed;
                        (*fresh140).set_is_exotic(1 as libc::c_int as uint8_t);
                    }
                }
                _ => {}
            }
            (*p).c2rust_unnamed.header.ref_count = 1 as libc::c_int;
            add_gc_object(
                (*ctx).rt,
                &mut (*p).c2rust_unnamed.header,
                JS_GC_OBJ_TYPE_JS_OBJECT,
            );
            return (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong;
        }
    }
    js_free_shape((*ctx).rt, sh);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn get_proto_obj(mut proto_val: JSValue) -> *mut JSObject {
    if (proto_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return 0 as *mut JSObject
    } else {
        return proto_val as intptr_t as *mut libc::c_void as *mut JSObject
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewObjectProtoClass(
    mut ctx: *mut JSContext,
    mut proto_val: JSValue,
    mut class_id: JSClassID,
) -> JSValue {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut proto: *mut JSObject = 0 as *mut JSObject;
    proto = get_proto_obj(proto_val);
    sh = find_hashed_shape_proto((*ctx).rt, proto);
    if !sh.is_null() as libc::c_int as libc::c_long != 0 {
        sh = js_dup_shape(sh);
    } else {
        sh = js_new_shape(ctx, proto);
        if sh.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    return JS_NewObjectFromShape(ctx, sh, class_id);
}
unsafe extern "C" fn JS_SetObjectData(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
            4 | 5 | 6 | 7 | 10 => {
                JS_FreeValue(ctx, (*p).u.object_data);
                (*p).u.object_data = val;
                return 0 as libc::c_int;
            }
            _ => {}
        }
    }
    JS_FreeValue(ctx, val);
    if JS_IsException(obj) == 0 {
        JS_ThrowTypeError(
            ctx,
            b"invalid object type\0" as *const u8 as *const libc::c_char,
        );
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewObjectClass(
    mut ctx: *mut JSContext,
    mut class_id: libc::c_int,
) -> JSValue {
    return JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(class_id as isize),
        class_id as JSClassID,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewObjectProto(
    mut ctx: *mut JSContext,
    mut proto: JSValue,
) -> JSValue {
    return JS_NewObjectProtoClass(
        ctx,
        proto,
        JS_CLASS_OBJECT as libc::c_int as JSClassID,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewArray(mut ctx: *mut JSContext) -> JSValue {
    return JS_NewObjectFromShape(
        ctx,
        js_dup_shape((*ctx).array_shape),
        JS_CLASS_ARRAY as libc::c_int as JSClassID,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewObject(mut ctx: *mut JSContext) -> JSValue {
    return JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_OBJECT as libc::c_int as JSClassID,
    );
}
unsafe extern "C" fn js_function_set_properties(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut name: JSAtom,
    mut len: libc::c_int,
) {
    JS_DefinePropertyValue(
        ctx,
        func_obj,
        JS_ATOM_length as libc::c_int as JSAtom,
        JS_NewInt32(ctx, len),
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_DefinePropertyValue(
        ctx,
        func_obj,
        JS_ATOM_name as libc::c_int as JSAtom,
        JS_AtomToString(ctx, name),
        (1 as libc::c_int) << 0 as libc::c_int,
    );
}
unsafe extern "C" fn js_class_has_bytecode(mut class_id: JSClassID) -> BOOL {
    return (class_id == JS_CLASS_BYTECODE_FUNCTION as libc::c_int as libc::c_uint
        || class_id == JS_CLASS_GENERATOR_FUNCTION as libc::c_int as libc::c_uint
        || class_id == JS_CLASS_ASYNC_FUNCTION as libc::c_int as libc::c_uint
        || class_id == JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as libc::c_uint)
        as libc::c_int;
}
unsafe extern "C" fn JS_GetFunctionBytecode(
    mut val: JSValue,
) -> *mut JSFunctionBytecode {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return 0 as *mut JSFunctionBytecode;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    if js_class_has_bytecode((*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID)
        == 0
    {
        return 0 as *mut JSFunctionBytecode;
    }
    return (*p).u.func.function_bytecode;
}
unsafe extern "C" fn js_method_set_home_object(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut home_obj: JSValue,
) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    if (func_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return;
    }
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if js_class_has_bytecode((*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID)
        == 0
    {
        return;
    }
    b = (*p).u.func.function_bytecode;
    if (*b).need_home_object() != 0 {
        p1 = (*p).u.func.home_object;
        if !p1.is_null() {
            JS_FreeValue(
                ctx,
                (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                    | p1 as uintptr_t as libc::c_ulonglong,
            );
        }
        if (home_obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int
        {
            p1 = JS_DupValue(ctx, home_obj) as intptr_t as *mut libc::c_void
                as *mut JSObject;
        } else {
            p1 = 0 as *mut JSObject;
        }
        let ref mut fresh141 = (*p).u.func.home_object;
        *fresh141 = p1;
    }
}
unsafe extern "C" fn js_get_function_name(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> JSValue {
    let mut name_str: JSValue = 0;
    name_str = JS_AtomToString(ctx, name);
    if JS_AtomSymbolHasDescription(ctx, name) != 0 {
        name_str = JS_ConcatString3(
            ctx,
            b"[\0" as *const u8 as *const libc::c_char,
            name_str,
            b"]\0" as *const u8 as *const libc::c_char,
        );
    }
    return name_str;
}
unsafe extern "C" fn js_method_set_properties(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut name: JSAtom,
    mut flags: libc::c_int,
    mut home_obj: JSValue,
) -> libc::c_int {
    let mut name_str: JSValue = 0;
    name_str = js_get_function_name(ctx, name);
    if flags & (1 as libc::c_int) << 11 as libc::c_int != 0 {
        name_str = JS_ConcatString3(
            ctx,
            b"get \0" as *const u8 as *const libc::c_char,
            name_str,
            b"\0" as *const u8 as *const libc::c_char,
        );
    } else if flags & (1 as libc::c_int) << 12 as libc::c_int != 0 {
        name_str = JS_ConcatString3(
            ctx,
            b"set \0" as *const u8 as *const libc::c_char,
            name_str,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    if JS_IsException(name_str) != 0 {
        return -(1 as libc::c_int);
    }
    if JS_DefinePropertyValue(
        ctx,
        func_obj,
        JS_ATOM_name as libc::c_int as JSAtom,
        name_str,
        (1 as libc::c_int) << 0 as libc::c_int,
    ) < 0 as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    js_method_set_home_object(ctx, func_obj, home_obj);
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_NewCFunction3(
    mut ctx: *mut JSContext,
    mut func: Option::<JSCFunction>,
    mut name: *const libc::c_char,
    mut length: libc::c_int,
    mut cproto: JSCFunctionEnum,
    mut magic: libc::c_int,
    mut proto_val: JSValue,
) -> JSValue {
    let mut func_obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut name_atom: JSAtom = 0;
    func_obj = JS_NewObjectProtoClass(
        ctx,
        proto_val,
        JS_CLASS_C_FUNCTION as libc::c_int as JSClassID,
    );
    if JS_IsException(func_obj) != 0 {
        return func_obj;
    }
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh142 = (*p).u.cfunc.realm;
    *fresh142 = JS_DupContext(ctx);
    let ref mut fresh143 = (*p).u.cfunc.c_function.generic;
    *fresh143 = func;
    (*p).u.cfunc.length = length as uint8_t;
    (*p).u.cfunc.cproto = cproto as uint8_t;
    (*p).u.cfunc.magic = magic as int16_t;
    let ref mut fresh144 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh144)
        .set_is_constructor(
            (cproto as libc::c_uint
                == JS_CFUNC_constructor as libc::c_int as libc::c_uint
                || cproto as libc::c_uint
                    == JS_CFUNC_constructor_magic as libc::c_int as libc::c_uint
                || cproto as libc::c_uint
                    == JS_CFUNC_constructor_or_func as libc::c_int as libc::c_uint
                || cproto as libc::c_uint
                    == JS_CFUNC_constructor_or_func_magic as libc::c_int as libc::c_uint)
                as libc::c_int as uint8_t,
        );
    if name.is_null() {
        name = b"\0" as *const u8 as *const libc::c_char;
    }
    name_atom = JS_NewAtom(ctx, name);
    js_function_set_properties(ctx, func_obj, name_atom, length);
    JS_FreeAtom(ctx, name_atom);
    return func_obj;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewCFunction2(
    mut ctx: *mut JSContext,
    mut func: Option::<JSCFunction>,
    mut name: *const libc::c_char,
    mut length: libc::c_int,
    mut cproto: JSCFunctionEnum,
    mut magic: libc::c_int,
) -> JSValue {
    return JS_NewCFunction3(
        ctx,
        func,
        name,
        length,
        cproto,
        magic,
        (*ctx).function_proto,
    );
}
unsafe extern "C" fn js_c_function_data_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut s: *mut JSCFunctionDataRecord = JS_GetOpaque(
        val,
        JS_CLASS_C_FUNCTION_DATA as libc::c_int as JSClassID,
    ) as *mut JSCFunctionDataRecord;
    let mut i: libc::c_int = 0;
    if !s.is_null() {
        i = 0 as libc::c_int;
        while i < (*s).data_len as libc::c_int {
            JS_FreeValueRT(rt, *((*s).data).as_mut_ptr().offset(i as isize));
            i += 1;
        }
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_c_function_data_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSCFunctionDataRecord = JS_GetOpaque(
        val,
        JS_CLASS_C_FUNCTION_DATA as libc::c_int as JSClassID,
    ) as *mut JSCFunctionDataRecord;
    let mut i: libc::c_int = 0;
    if !s.is_null() {
        i = 0 as libc::c_int;
        while i < (*s).data_len as libc::c_int {
            JS_MarkValue(rt, *((*s).data).as_mut_ptr().offset(i as isize), mark_func);
            i += 1;
        }
    }
}
unsafe extern "C" fn js_c_function_data_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut s: *mut JSCFunctionDataRecord = JS_GetOpaque(
        func_obj,
        JS_CLASS_C_FUNCTION_DATA as libc::c_int as JSClassID,
    ) as *mut JSCFunctionDataRecord;
    let mut arg_buf: *mut JSValue = 0 as *mut JSValue;
    let mut i: libc::c_int = 0;
    if (argc < (*s).length as libc::c_int) as libc::c_int as libc::c_long != 0 {
        arg_buf = alloca(
            (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                .wrapping_mul((*s).length as libc::c_ulong),
        ) as *mut JSValue;
        i = 0 as libc::c_int;
        while i < argc {
            *arg_buf.offset(i as isize) = *argv.offset(i as isize);
            i += 1;
        }
        i = argc;
        while i < (*s).length as libc::c_int {
            *arg_buf
                .offset(
                    i as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            i += 1;
        }
    } else {
        arg_buf = argv;
    }
    return ((*s).func)
        .expect(
            "non-null function pointer",
        )(
        ctx,
        this_val,
        argc,
        arg_buf,
        (*s).magic as libc::c_int,
        ((*s).data).as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewCFunctionData(
    mut ctx: *mut JSContext,
    mut func: Option::<JSCFunctionData>,
    mut length: libc::c_int,
    mut magic: libc::c_int,
    mut data_len: libc::c_int,
    mut data: *mut JSValue,
) -> JSValue {
    let mut s: *mut JSCFunctionDataRecord = 0 as *mut JSCFunctionDataRecord;
    let mut func_obj: JSValue = 0;
    let mut i: libc::c_int = 0;
    func_obj = JS_NewObjectProtoClass(
        ctx,
        (*ctx).function_proto,
        JS_CLASS_C_FUNCTION_DATA as libc::c_int as JSClassID,
    );
    if JS_IsException(func_obj) != 0 {
        return func_obj;
    }
    s = js_malloc(
        ctx,
        (::core::mem::size_of::<JSCFunctionDataRecord>() as libc::c_ulong)
            .wrapping_add(
                (data_len as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<JSValue>() as libc::c_ulong),
            ),
    ) as *mut JSCFunctionDataRecord;
    if s.is_null() {
        JS_FreeValue(ctx, func_obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    let ref mut fresh145 = (*s).func;
    *fresh145 = func;
    (*s).length = length as uint8_t;
    (*s).data_len = data_len as uint8_t;
    (*s).magic = magic as uint16_t;
    i = 0 as libc::c_int;
    while i < data_len {
        *((*s).data)
            .as_mut_ptr()
            .offset(i as isize) = JS_DupValue(ctx, *data.offset(i as isize));
        i += 1;
    }
    JS_SetOpaque(func_obj, s as *mut libc::c_void);
    js_function_set_properties(
        ctx,
        func_obj,
        JS_ATOM_empty_string as libc::c_int as JSAtom,
        length,
    );
    return func_obj;
}
unsafe extern "C" fn js_autoinit_get_realm(mut pr: *mut JSProperty) -> *mut JSContext {
    return ((*pr).u.init.realm_and_id & !(3 as libc::c_int) as libc::c_uint)
        as *mut JSContext;
}
unsafe extern "C" fn js_autoinit_get_id(mut pr: *mut JSProperty) -> JSAutoInitIDEnum {
    return ((*pr).u.init.realm_and_id & 3 as libc::c_int as libc::c_uint)
        as JSAutoInitIDEnum;
}
unsafe extern "C" fn js_autoinit_free(mut rt: *mut JSRuntime, mut pr: *mut JSProperty) {
    JS_FreeContext(js_autoinit_get_realm(pr));
}
unsafe extern "C" fn js_autoinit_mark(
    mut rt: *mut JSRuntime,
    mut pr: *mut JSProperty,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    mark_func
        .expect(
            "non-null function pointer",
        )(
        rt,
        &mut (*(js_autoinit_get_realm
            as unsafe extern "C" fn(*mut JSProperty) -> *mut JSContext)(pr))
            .header,
    );
}
unsafe extern "C" fn free_property(
    mut rt: *mut JSRuntime,
    mut pr: *mut JSProperty,
    mut prop_flags: libc::c_int,
) {
    if (prop_flags & (3 as libc::c_int) << 4 as libc::c_int != 0) as libc::c_int
        as libc::c_long != 0
    {
        if prop_flags & (3 as libc::c_int) << 4 as libc::c_int
            == (1 as libc::c_int) << 4 as libc::c_int
        {
            if !((*pr).u.getset.getter).is_null() {
                JS_FreeValueRT(
                    rt,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | (*pr).u.getset.getter as uintptr_t as libc::c_ulonglong,
                );
            }
            if !((*pr).u.getset.setter).is_null() {
                JS_FreeValueRT(
                    rt,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | (*pr).u.getset.setter as uintptr_t as libc::c_ulonglong,
                );
            }
        } else if prop_flags & (3 as libc::c_int) << 4 as libc::c_int
            == (2 as libc::c_int) << 4 as libc::c_int
        {
            free_var_ref(rt, (*pr).u.var_ref);
        } else if prop_flags & (3 as libc::c_int) << 4 as libc::c_int
            == (3 as libc::c_int) << 4 as libc::c_int
        {
            js_autoinit_free(rt, pr);
        }
    } else {
        JS_FreeValueRT(rt, (*pr).u.value);
    };
}
#[inline(always)]
unsafe extern "C" fn find_own_property1(
    mut p: *mut JSObject,
    mut atom: JSAtom,
) -> *mut JSShapeProperty {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut prop: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut h: intptr_t = 0;
    sh = (*p).shape;
    h = (atom & (*sh).prop_hash_mask) as intptr_t;
    h = *(prop_hash_end(sh)).offset((-h - 1 as libc::c_int) as isize) as intptr_t;
    prop = get_shape_prop(sh);
    while h != 0 {
        pr = &mut *prop.offset((h - 1 as libc::c_int) as isize) as *mut JSShapeProperty;
        if ((*pr).atom == atom) as libc::c_int as libc::c_long != 0 {
            return pr;
        }
        h = (*pr).hash_next() as intptr_t;
    }
    return 0 as *mut JSShapeProperty;
}
#[inline(always)]
unsafe extern "C" fn find_own_property(
    mut ppr: *mut *mut JSProperty,
    mut p: *mut JSObject,
    mut atom: JSAtom,
) -> *mut JSShapeProperty {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut prop: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut h: intptr_t = 0;
    sh = (*p).shape;
    h = (atom & (*sh).prop_hash_mask) as intptr_t;
    h = *(prop_hash_end(sh)).offset((-h - 1 as libc::c_int) as isize) as intptr_t;
    prop = get_shape_prop(sh);
    while h != 0 {
        pr = &mut *prop.offset((h - 1 as libc::c_int) as isize) as *mut JSShapeProperty;
        if ((*pr).atom == atom) as libc::c_int as libc::c_long != 0 {
            *ppr = &mut *((*p).prop).offset((h - 1 as libc::c_int) as isize)
                as *mut JSProperty;
            return pr;
        }
        h = (*pr).hash_next() as intptr_t;
    }
    *ppr = 0 as *mut JSProperty;
    return 0 as *mut JSShapeProperty;
}
unsafe extern "C" fn set_cycle_flag(mut ctx: *mut JSContext, mut obj: JSValue) {}
unsafe extern "C" fn free_var_ref(mut rt: *mut JSRuntime, mut var_ref: *mut JSVarRef) {
    if !var_ref.is_null() {
        assert(
            ((*var_ref).c2rust_unnamed.header.ref_count > 0 as libc::c_int)
                as libc::c_int,
        );
        let ref mut fresh146 = (*var_ref).c2rust_unnamed.header.ref_count;
        *fresh146 -= 1;
        if *fresh146 == 0 as libc::c_int {
            if ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_detached() != 0 {
                JS_FreeValueRT(rt, (*var_ref).value);
                remove_gc_object(&mut (*var_ref).c2rust_unnamed.header);
            } else {
                list_del(&mut (*var_ref).c2rust_unnamed.header.link);
            }
            js_free_rt(rt, var_ref as *mut libc::c_void);
        }
    }
}
unsafe extern "C" fn js_array_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_uint) < (*p).u.array.count {
        JS_FreeValueRT(rt, *((*p).u.array.u.values).offset(i as isize));
        i += 1;
    }
    js_free_rt(rt, (*p).u.array.u.values as *mut libc::c_void);
}
unsafe extern "C" fn js_array_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_uint) < (*p).u.array.count {
        JS_MarkValue(rt, *((*p).u.array.u.values).offset(i as isize), mark_func);
        i += 1;
    }
}
unsafe extern "C" fn js_object_data_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    JS_FreeValueRT(rt, (*p).u.object_data);
    (*p)
        .u
        .object_data = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_object_data_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    JS_MarkValue(rt, (*p).u.object_data, mark_func);
}
unsafe extern "C" fn js_c_function_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    if !((*p).u.cfunc.realm).is_null() {
        JS_FreeContext((*p).u.cfunc.realm);
    }
}
unsafe extern "C" fn js_c_function_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    if !((*p).u.cfunc.realm).is_null() {
        mark_func
            .expect("non-null function pointer")(rt, &mut (*(*p).u.cfunc.realm).header);
    }
}
unsafe extern "C" fn js_bytecode_function_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut i: libc::c_int = 0;
    p1 = (*p).u.func.home_object;
    if !p1.is_null() {
        JS_FreeValueRT(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | p1 as uintptr_t as libc::c_ulonglong,
        );
    }
    b = (*p).u.func.function_bytecode;
    if !b.is_null() {
        var_refs = (*p).u.func.var_refs;
        if !var_refs.is_null() {
            i = 0 as libc::c_int;
            while i < (*b).closure_var_count {
                free_var_ref(rt, *var_refs.offset(i as isize));
                i += 1;
            }
            js_free_rt(rt, var_refs as *mut libc::c_void);
        }
        JS_FreeValueRT(
            rt,
            (JS_TAG_FUNCTION_BYTECODE as libc::c_int as uint64_t) << 32 as libc::c_int
                | b as uintptr_t as libc::c_ulonglong,
        );
    }
}
unsafe extern "C" fn js_bytecode_function_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut var_refs: *mut *mut JSVarRef = (*p).u.func.var_refs;
    let mut b: *mut JSFunctionBytecode = (*p).u.func.function_bytecode;
    let mut i: libc::c_int = 0;
    if !((*p).u.func.home_object).is_null() {
        JS_MarkValue(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*p).u.func.home_object as uintptr_t as libc::c_ulonglong,
            mark_func,
        );
    }
    if !b.is_null() {
        if !var_refs.is_null() {
            i = 0 as libc::c_int;
            while i < (*b).closure_var_count {
                let mut var_ref: *mut JSVarRef = *var_refs.offset(i as isize);
                if !var_ref.is_null()
                    && ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_detached()
                        as libc::c_int != 0
                {
                    mark_func
                        .expect(
                            "non-null function pointer",
                        )(rt, &mut (*var_ref).c2rust_unnamed.header);
                }
                i += 1;
            }
        }
        JS_MarkValue(
            rt,
            (JS_TAG_FUNCTION_BYTECODE as libc::c_int as uint64_t) << 32 as libc::c_int
                | b as uintptr_t as libc::c_ulonglong,
            mark_func,
        );
    }
}
unsafe extern "C" fn js_bound_function_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut bf: *mut JSBoundFunction = (*p).u.bound_function;
    let mut i: libc::c_int = 0;
    JS_FreeValueRT(rt, (*bf).func_obj);
    JS_FreeValueRT(rt, (*bf).this_val);
    i = 0 as libc::c_int;
    while i < (*bf).argc {
        JS_FreeValueRT(rt, *((*bf).argv).as_mut_ptr().offset(i as isize));
        i += 1;
    }
    js_free_rt(rt, bf as *mut libc::c_void);
}
unsafe extern "C" fn js_bound_function_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut bf: *mut JSBoundFunction = (*p).u.bound_function;
    let mut i: libc::c_int = 0;
    JS_MarkValue(rt, (*bf).func_obj, mark_func);
    JS_MarkValue(rt, (*bf).this_val, mark_func);
    i = 0 as libc::c_int;
    while i < (*bf).argc {
        JS_MarkValue(rt, *((*bf).argv).as_mut_ptr().offset(i as isize), mark_func);
        i += 1;
    }
}
unsafe extern "C" fn js_for_in_iterator_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSForInIterator = (*p).u.for_in_iterator;
    JS_FreeValueRT(rt, (*it).obj);
    js_free_rt(rt, it as *mut libc::c_void);
}
unsafe extern "C" fn js_for_in_iterator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSForInIterator = (*p).u.for_in_iterator;
    JS_MarkValue(rt, (*it).obj, mark_func);
}
unsafe extern "C" fn free_object(mut rt: *mut JSRuntime, mut p: *mut JSObject) {
    let mut i: libc::c_int = 0;
    let mut finalizer: Option::<JSClassFinalizer> = None;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let ref mut fresh147 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh147).set_free_mark(1 as libc::c_int as uint8_t);
    sh = (*p).shape;
    pr = get_shape_prop(sh);
    i = 0 as libc::c_int;
    while i < (*sh).prop_count {
        free_property(
            rt,
            &mut *((*p).prop).offset(i as isize),
            (*pr).flags() as libc::c_int,
        );
        pr = pr.offset(1);
        i += 1;
    }
    js_free_rt(rt, (*p).prop as *mut libc::c_void);
    js_free_shape(rt, sh);
    let ref mut fresh148 = (*p).shape;
    *fresh148 = 0 as *mut JSShape;
    let ref mut fresh149 = (*p).prop;
    *fresh149 = 0 as *mut JSProperty;
    if !((*p).first_weak_ref).is_null() as libc::c_int as libc::c_long != 0 {
        reset_weak_ref(rt, p);
    }
    finalizer = (*((*rt).class_array)
        .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
        .finalizer;
    if finalizer.is_some() {
        (Some(finalizer.expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong,
        );
    }
    (*p).c2rust_unnamed.c2rust_unnamed.class_id = 0 as libc::c_int as uint16_t;
    let ref mut fresh150 = (*p).u.opaque;
    *fresh150 = 0 as *mut libc::c_void;
    let ref mut fresh151 = (*p).u.func.var_refs;
    *fresh151 = 0 as *mut *mut JSVarRef;
    let ref mut fresh152 = (*p).u.func.home_object;
    *fresh152 = 0 as *mut JSObject;
    remove_gc_object(&mut (*p).c2rust_unnamed.header);
    if (*rt).gc_phase() as libc::c_int == JS_GC_PHASE_REMOVE_CYCLES as libc::c_int
        && (*p).c2rust_unnamed.header.ref_count != 0 as libc::c_int
    {
        list_add_tail(
            &mut (*p).c2rust_unnamed.header.link,
            &mut (*rt).gc_zero_ref_count_list,
        );
    } else {
        js_free_rt(rt, p as *mut libc::c_void);
    };
}
unsafe extern "C" fn free_gc_object(
    mut rt: *mut JSRuntime,
    mut gp: *mut JSGCObjectHeader,
) {
    match (*gp).gc_obj_type() as libc::c_int {
        0 => {
            free_object(rt, gp as *mut JSObject);
        }
        1 => {
            free_function_bytecode(rt, gp as *mut JSFunctionBytecode);
        }
        _ => {
            abort();
        }
    };
}
unsafe extern "C" fn free_zero_refcount(mut rt: *mut JSRuntime) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut p: *mut JSGCObjectHeader = 0 as *mut JSGCObjectHeader;
    (*rt).set_gc_phase(JS_GC_PHASE_DECREF);
    loop {
        el = (*rt).gc_zero_ref_count_list.next;
        if el == &mut (*rt).gc_zero_ref_count_list as *mut list_head {
            break;
        }
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        assert(((*p).ref_count == 0 as libc::c_int) as libc::c_int);
        free_gc_object(rt, p);
    }
    (*rt).set_gc_phase(JS_GC_PHASE_NONE);
}
#[no_mangle]
pub unsafe extern "C" fn __JS_FreeValueRT(mut rt: *mut JSRuntime, mut v: JSValue) {
    let mut tag: uint32_t = (v >> 32 as libc::c_int) as libc::c_int as uint32_t;
    match tag {
        4294967289 => {
            let mut p: *mut JSString = v as intptr_t as *mut libc::c_void
                as *mut JSString;
            if (*p).atom_type() != 0 {
                JS_FreeAtomStruct(rt, p);
            } else {
                js_free_rt(rt, p as *mut libc::c_void);
            }
        }
        4294967295 | 4294967294 => {
            let mut p_0: *mut JSGCObjectHeader = v as intptr_t as *mut libc::c_void
                as *mut JSGCObjectHeader;
            if (*rt).gc_phase() as libc::c_int
                != JS_GC_PHASE_REMOVE_CYCLES as libc::c_int
            {
                list_del(&mut (*p_0).link);
                list_add(&mut (*p_0).link, &mut (*rt).gc_zero_ref_count_list);
                if (*rt).gc_phase() as libc::c_int == JS_GC_PHASE_NONE as libc::c_int {
                    free_zero_refcount(rt);
                }
            }
        }
        4294967293 => {
            abort();
        }
        4294967288 => {
            let mut p_1: *mut JSAtomStruct = v as intptr_t as *mut libc::c_void
                as *mut JSAtomStruct;
            JS_FreeAtomStruct(rt, p_1);
        }
        _ => {
            printf(
                b"__JS_FreeValue: unknown tag=%d\n\0" as *const u8
                    as *const libc::c_char,
                tag,
            );
            abort();
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn __JS_FreeValue(mut ctx: *mut JSContext, mut v: JSValue) {
    __JS_FreeValueRT((*ctx).rt, v);
}
unsafe extern "C" fn add_gc_object(
    mut rt: *mut JSRuntime,
    mut h: *mut JSGCObjectHeader,
    mut type_0: JSGCObjectTypeEnum,
) {
    (*h).set_mark(0 as libc::c_int as uint8_t);
    (*h).set_gc_obj_type(type_0);
    list_add_tail(&mut (*h).link, &mut (*rt).gc_obj_list);
}
unsafe extern "C" fn remove_gc_object(mut h: *mut JSGCObjectHeader) {
    list_del(&mut (*h).link);
}
#[no_mangle]
pub unsafe extern "C" fn JS_MarkValue(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    if (val >> 32 as libc::c_int) as libc::c_int as libc::c_uint
        >= JS_TAG_FIRST as libc::c_int as libc::c_uint
    {
        match (val >> 32 as libc::c_int) as libc::c_int {
            -1 | -2 => {
                mark_func
                    .expect(
                        "non-null function pointer",
                    )(rt, val as intptr_t as *mut libc::c_void as *mut JSGCObjectHeader);
            }
            _ => {}
        }
    }
}
unsafe extern "C" fn mark_children(
    mut rt: *mut JSRuntime,
    mut gp: *mut JSGCObjectHeader,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    match (*gp).gc_obj_type() as libc::c_int {
        0 => {
            let mut p: *mut JSObject = gp as *mut JSObject;
            let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
            let mut sh: *mut JSShape = 0 as *mut JSShape;
            let mut i: libc::c_int = 0;
            sh = (*p).shape;
            mark_func.expect("non-null function pointer")(rt, &mut (*sh).header);
            prs = get_shape_prop(sh);
            i = 0 as libc::c_int;
            while i < (*sh).prop_count {
                let mut pr: *mut JSProperty = &mut *((*p).prop).offset(i as isize)
                    as *mut JSProperty;
                if (*prs).atom != 0 as libc::c_int as libc::c_uint {
                    if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int != 0
                    {
                        if (*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int
                            == (1 as libc::c_int) << 4 as libc::c_int
                        {
                            if !((*pr).u.getset.getter).is_null() {
                                mark_func
                                    .expect(
                                        "non-null function pointer",
                                    )(rt, &mut (*(*pr).u.getset.getter).c2rust_unnamed.header);
                            }
                            if !((*pr).u.getset.setter).is_null() {
                                mark_func
                                    .expect(
                                        "non-null function pointer",
                                    )(rt, &mut (*(*pr).u.getset.setter).c2rust_unnamed.header);
                            }
                        } else if (*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int
                            == (2 as libc::c_int) << 4 as libc::c_int
                        {
                            if ((*(*pr).u.var_ref).c2rust_unnamed.c2rust_unnamed)
                                .is_detached() != 0
                            {
                                mark_func
                                    .expect(
                                        "non-null function pointer",
                                    )(rt, &mut (*(*pr).u.var_ref).c2rust_unnamed.header);
                            }
                        } else if (*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int
                            == (3 as libc::c_int) << 4 as libc::c_int
                        {
                            js_autoinit_mark(rt, pr, mark_func);
                        }
                    } else {
                        JS_MarkValue(rt, (*pr).u.value, mark_func);
                    }
                }
                prs = prs.offset(1);
                i += 1;
            }
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                != JS_CLASS_OBJECT as libc::c_int
            {
                let mut gc_mark: Option::<JSClassGCMark> = None;
                gc_mark = (*((*rt).class_array)
                    .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                    .gc_mark;
                if gc_mark.is_some() {
                    gc_mark
                        .expect(
                            "non-null function pointer",
                        )(
                        rt,
                        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                            | p as uintptr_t as libc::c_ulonglong,
                        mark_func,
                    );
                }
            }
        }
        1 => {
            let mut b: *mut JSFunctionBytecode = gp as *mut JSFunctionBytecode;
            let mut i_0: libc::c_int = 0;
            i_0 = 0 as libc::c_int;
            while i_0 < (*b).cpool_count {
                JS_MarkValue(rt, *((*b).cpool).offset(i_0 as isize), mark_func);
                i_0 += 1;
            }
            if !((*b).realm).is_null() {
                mark_func
                    .expect("non-null function pointer")(rt, &mut (*(*b).realm).header);
            }
        }
        3 => {
            let mut var_ref: *mut JSVarRef = gp as *mut JSVarRef;
            assert(
                ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_detached() as libc::c_int,
            );
            JS_MarkValue(rt, *(*var_ref).pvalue, mark_func);
        }
        4 => {
            let mut s: *mut JSAsyncFunctionData = gp as *mut JSAsyncFunctionData;
            if (*s).is_active != 0 {
                async_func_mark(rt, &mut (*s).func_state, mark_func);
            }
            JS_MarkValue(rt, (*s).resolving_funcs[0 as libc::c_int as usize], mark_func);
            JS_MarkValue(rt, (*s).resolving_funcs[1 as libc::c_int as usize], mark_func);
        }
        2 => {
            let mut sh_0: *mut JSShape = gp as *mut JSShape;
            if !((*sh_0).proto).is_null() {
                mark_func
                    .expect(
                        "non-null function pointer",
                    )(rt, &mut (*(*sh_0).proto).c2rust_unnamed.header);
            }
        }
        5 => {
            let mut ctx: *mut JSContext = gp as *mut JSContext;
            JS_MarkContext(rt, ctx, mark_func);
        }
        _ => {
            abort();
        }
    };
}
unsafe extern "C" fn gc_decref_child(
    mut rt: *mut JSRuntime,
    mut p: *mut JSGCObjectHeader,
) {
    assert(((*p).ref_count > 0 as libc::c_int) as libc::c_int);
    let ref mut fresh153 = (*p).ref_count;
    *fresh153 -= 1;
    if (*p).ref_count == 0 as libc::c_int
        && (*p).mark() as libc::c_int == 1 as libc::c_int
    {
        list_del(&mut (*p).link);
        list_add_tail(&mut (*p).link, &mut (*rt).tmp_obj_list);
    }
}
unsafe extern "C" fn gc_decref(mut rt: *mut JSRuntime) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut p: *mut JSGCObjectHeader = 0 as *mut JSGCObjectHeader;
    init_list_head(&mut (*rt).tmp_obj_list);
    el = (*rt).gc_obj_list.next;
    el1 = (*el).next;
    while el != &mut (*rt).gc_obj_list as *mut list_head {
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        assert(((*p).mark() as libc::c_int == 0 as libc::c_int) as libc::c_int);
        mark_children(
            rt,
            p,
            Some(
                gc_decref_child
                    as unsafe extern "C" fn(*mut JSRuntime, *mut JSGCObjectHeader) -> (),
            ),
        );
        (*p).set_mark(1 as libc::c_int as uint8_t);
        if (*p).ref_count == 0 as libc::c_int {
            list_del(&mut (*p).link);
            list_add_tail(&mut (*p).link, &mut (*rt).tmp_obj_list);
        }
        el = el1;
        el1 = (*el).next;
    }
}
unsafe extern "C" fn gc_scan_incref_child(
    mut rt: *mut JSRuntime,
    mut p: *mut JSGCObjectHeader,
) {
    let ref mut fresh154 = (*p).ref_count;
    *fresh154 += 1;
    if (*p).ref_count == 1 as libc::c_int {
        list_del(&mut (*p).link);
        list_add_tail(&mut (*p).link, &mut (*rt).gc_obj_list);
        (*p).set_mark(0 as libc::c_int as uint8_t);
    }
}
unsafe extern "C" fn gc_scan_incref_child2(
    mut rt: *mut JSRuntime,
    mut p: *mut JSGCObjectHeader,
) {
    let ref mut fresh155 = (*p).ref_count;
    *fresh155 += 1;
}
unsafe extern "C" fn gc_scan(mut rt: *mut JSRuntime) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut p: *mut JSGCObjectHeader = 0 as *mut JSGCObjectHeader;
    el = (*rt).gc_obj_list.next;
    while el != &mut (*rt).gc_obj_list as *mut list_head {
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        assert(((*p).ref_count > 0 as libc::c_int) as libc::c_int);
        (*p).set_mark(0 as libc::c_int as uint8_t);
        mark_children(
            rt,
            p,
            Some(
                gc_scan_incref_child
                    as unsafe extern "C" fn(*mut JSRuntime, *mut JSGCObjectHeader) -> (),
            ),
        );
        el = (*el).next;
    }
    el = (*rt).tmp_obj_list.next;
    while el != &mut (*rt).tmp_obj_list as *mut list_head {
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        mark_children(
            rt,
            p,
            Some(
                gc_scan_incref_child2
                    as unsafe extern "C" fn(*mut JSRuntime, *mut JSGCObjectHeader) -> (),
            ),
        );
        el = (*el).next;
    }
}
unsafe extern "C" fn gc_free_cycles(mut rt: *mut JSRuntime) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut p: *mut JSGCObjectHeader = 0 as *mut JSGCObjectHeader;
    (*rt).set_gc_phase(JS_GC_PHASE_REMOVE_CYCLES);
    loop {
        el = (*rt).tmp_obj_list.next;
        if el == &mut (*rt).tmp_obj_list as *mut list_head {
            break;
        }
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        match (*p).gc_obj_type() as libc::c_int {
            0 | 1 => {
                free_gc_object(rt, p);
            }
            _ => {
                list_del(&mut (*p).link);
                list_add_tail(&mut (*p).link, &mut (*rt).gc_zero_ref_count_list);
            }
        }
    }
    (*rt).set_gc_phase(JS_GC_PHASE_NONE);
    el = (*rt).gc_zero_ref_count_list.next;
    el1 = (*el).next;
    while el != &mut (*rt).gc_zero_ref_count_list as *mut list_head {
        p = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSGCObjectHeader;
        assert(
            ((*p).gc_obj_type() as libc::c_int == JS_GC_OBJ_TYPE_JS_OBJECT as libc::c_int
                || (*p).gc_obj_type() as libc::c_int
                    == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE as libc::c_int) as libc::c_int,
        );
        js_free_rt(rt, p as *mut libc::c_void);
        el = el1;
        el1 = (*el).next;
    }
    init_list_head(&mut (*rt).gc_zero_ref_count_list);
}
#[no_mangle]
pub unsafe extern "C" fn JS_RunGC(mut rt: *mut JSRuntime) {
    gc_decref(rt);
    gc_scan(rt);
    gc_free_cycles(rt);
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsLiveObject(
    mut rt: *mut JSRuntime,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if JS_IsObject(obj) == 0 {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    return (((*p).c2rust_unnamed.c2rust_unnamed).free_mark() == 0) as libc::c_int;
}
unsafe extern "C" fn compute_jsstring_size(
    mut str: *mut JSString,
    mut hp: *mut JSMemoryUsage_helper,
) {
    if (*str).atom_type() == 0 {
        let mut s_ref_count: libc::c_double = (*str).header.ref_count as libc::c_double;
        (*hp).str_count += 1 as libc::c_int as libc::c_double / s_ref_count;
        (*hp).str_size
            += (::core::mem::size_of::<JSString>() as libc::c_ulong)
                .wrapping_add(
                    (((*str).len() as libc::c_int)
                        << (*str).is_wide_char() as libc::c_int) as libc::c_ulong,
                )
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                .wrapping_sub((*str).is_wide_char() as libc::c_ulong) as libc::c_double
                / s_ref_count;
    }
}
unsafe extern "C" fn compute_bytecode_size(
    mut b: *mut JSFunctionBytecode,
    mut hp: *mut JSMemoryUsage_helper,
) {
    let mut memory_used_count: libc::c_int = 0;
    let mut js_func_size: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    memory_used_count = 0 as libc::c_int;
    js_func_size = 64 as libc::c_ulong as libc::c_int;
    if !((*b).vardefs).is_null() {
        js_func_size = (js_func_size as libc::c_ulong)
            .wrapping_add(
                (((*b).arg_count as libc::c_int + (*b).var_count as libc::c_int)
                    as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<JSVarDef>() as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
    }
    if !((*b).cpool).is_null() {
        js_func_size = (js_func_size as libc::c_ulong)
            .wrapping_add(
                ((*b).cpool_count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<JSValue>() as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
        i = 0 as libc::c_int;
        while i < (*b).cpool_count {
            let mut val: JSValue = *((*b).cpool).offset(i as isize);
            compute_value_size(val, hp);
            i += 1;
        }
    }
    if !((*b).closure_var).is_null() {
        js_func_size = (js_func_size as libc::c_ulong)
            .wrapping_add(
                ((*b).closure_var_count as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<JSClosureVar>() as libc::c_ulong,
                    ),
            ) as libc::c_int as libc::c_int;
    }
    if (*b).read_only_bytecode() == 0 && !((*b).byte_code_buf).is_null() {
        let ref mut fresh156 = (*hp).js_func_code_size;
        *fresh156 += (*b).byte_code_len as libc::c_longlong;
    }
    if (*b).has_debug() != 0 {
        js_func_size = (js_func_size as libc::c_ulong)
            .wrapping_add(
                (::core::mem::size_of::<JSFunctionBytecode>() as libc::c_ulong)
                    .wrapping_sub(64 as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
        if !((*b).debug.source).is_null() {
            memory_used_count += 1;
            js_func_size += (*b).debug.source_len + 1 as libc::c_int;
        }
        if (*b).debug.pc2line_len != 0 {
            memory_used_count += 1;
            let ref mut fresh157 = (*hp).js_func_pc2line_count;
            *fresh157 += 1 as libc::c_int as libc::c_longlong;
            let ref mut fresh158 = (*hp).js_func_pc2line_size;
            *fresh158 += (*b).debug.pc2line_len as libc::c_longlong;
        }
    }
    (*hp).js_func_size += js_func_size as libc::c_double;
    let ref mut fresh159 = (*hp).js_func_count;
    *fresh159 += 1 as libc::c_int as libc::c_longlong;
    (*hp).memory_used_count += memory_used_count as libc::c_double;
}
unsafe extern "C" fn compute_value_size(
    mut val: JSValue,
    mut hp: *mut JSMemoryUsage_helper,
) {
    match (val >> 32 as libc::c_int) as libc::c_int {
        -7 => {
            compute_jsstring_size(
                val as intptr_t as *mut libc::c_void as *mut JSString,
                hp,
            );
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_ComputeMemoryUsage(
    mut rt: *mut JSRuntime,
    mut s: *mut JSMemoryUsage,
) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut i: libc::c_int = 0;
    let mut mem: JSMemoryUsage_helper = {
        let mut init = JSMemoryUsage_helper {
            memory_used_count: 0 as libc::c_int as libc::c_double,
            str_count: 0.,
            str_size: 0.,
            js_func_count: 0,
            js_func_size: 0.,
            js_func_code_size: 0,
            js_func_pc2line_count: 0,
            js_func_pc2line_size: 0,
        };
        init
    };
    let mut hp: *mut JSMemoryUsage_helper = &mut mem;
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSMemoryUsage>() as libc::c_ulong,
    );
    (*s).malloc_count = (*rt).malloc_state.malloc_count as int64_t;
    (*s).malloc_size = (*rt).malloc_state.malloc_size as int64_t;
    (*s).malloc_limit = (*rt).malloc_state.malloc_limit as int64_t;
    (*s).memory_used_count = 2 as libc::c_int as int64_t;
    (*s)
        .memory_used_size = (::core::mem::size_of::<JSRuntime>() as libc::c_ulong)
        .wrapping_add(
            (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                .wrapping_mul((*rt).class_count as libc::c_ulong),
        ) as int64_t;
    el = (*rt).context_list.next;
    while el != &mut (*rt).context_list as *mut list_head {
        let mut ctx: *mut JSContext = (el as *mut uint8_t)
            .offset(-(20 as libc::c_ulong as isize)) as *mut JSContext;
        let mut sh: *mut JSShape = (*ctx).array_shape;
        let ref mut fresh160 = (*s).memory_used_count;
        *fresh160 += 2 as libc::c_int as libc::c_longlong;
        let ref mut fresh161 = (*s).memory_used_size;
        *fresh161
            += (::core::mem::size_of::<JSContext>() as libc::c_ulong)
                .wrapping_add(
                    (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                        .wrapping_mul((*rt).class_count as libc::c_ulong),
                ) as libc::c_longlong;
        let ref mut fresh162 = (*s).binary_object_count;
        *fresh162 += (*ctx).binary_object_count as libc::c_longlong;
        let ref mut fresh163 = (*s).binary_object_size;
        *fresh163 += (*ctx).binary_object_size as libc::c_longlong;
        if !sh.is_null() && (*sh).is_hashed == 0 {
            let mut hash_size: libc::c_int = ((*sh).prop_hash_mask)
                .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int;
            let ref mut fresh164 = (*s).shape_count;
            *fresh164 += 1;
            let ref mut fresh165 = (*s).shape_size;
            *fresh165
                += get_shape_size(hash_size as size_t, (*sh).prop_size as size_t)
                    as libc::c_longlong;
        }
        el1 = (*ctx).loaded_modules.next;
        while el1 != &mut (*ctx).loaded_modules as *mut list_head {
            let mut m: *mut JSModuleDef = (el1 as *mut uint8_t)
                .offset(-(8 as libc::c_ulong as isize)) as *mut JSModuleDef;
            let ref mut fresh166 = (*s).memory_used_count;
            *fresh166 += 1 as libc::c_int as libc::c_longlong;
            let ref mut fresh167 = (*s).memory_used_size;
            *fresh167
                += ::core::mem::size_of::<JSModuleDef>() as libc::c_ulong
                    as libc::c_longlong;
            if !((*m).req_module_entries).is_null() {
                let ref mut fresh168 = (*s).memory_used_count;
                *fresh168 += 1 as libc::c_int as libc::c_longlong;
                let ref mut fresh169 = (*s).memory_used_size;
                *fresh169
                    += ((*m).req_module_entries_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSReqModuleEntry>() as libc::c_ulong,
                        ) as libc::c_longlong;
            }
            if !((*m).export_entries).is_null() {
                let ref mut fresh170 = (*s).memory_used_count;
                *fresh170 += 1 as libc::c_int as libc::c_longlong;
                let ref mut fresh171 = (*s).memory_used_size;
                *fresh171
                    += ((*m).export_entries_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSExportEntry>() as libc::c_ulong,
                        ) as libc::c_longlong;
                i = 0 as libc::c_int;
                while i < (*m).export_entries_count {
                    let mut me: *mut JSExportEntry = &mut *((*m).export_entries)
                        .offset(i as isize) as *mut JSExportEntry;
                    if (*me).export_type as libc::c_uint
                        == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
                        && !((*me).u.local.var_ref).is_null()
                    {
                        let ref mut fresh172 = (*s).memory_used_count;
                        *fresh172 += 1 as libc::c_int as libc::c_longlong;
                        compute_value_size((*(*me).u.local.var_ref).value, hp);
                    }
                    i += 1;
                }
            }
            if !((*m).star_export_entries).is_null() {
                let ref mut fresh173 = (*s).memory_used_count;
                *fresh173 += 1 as libc::c_int as libc::c_longlong;
                let ref mut fresh174 = (*s).memory_used_size;
                *fresh174
                    += ((*m).star_export_entries_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSStarExportEntry>() as libc::c_ulong,
                        ) as libc::c_longlong;
            }
            if !((*m).import_entries).is_null() {
                let ref mut fresh175 = (*s).memory_used_count;
                *fresh175 += 1 as libc::c_int as libc::c_longlong;
                let ref mut fresh176 = (*s).memory_used_size;
                *fresh176
                    += ((*m).import_entries_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSImportEntry>() as libc::c_ulong,
                        ) as libc::c_longlong;
            }
            compute_value_size((*m).module_ns, hp);
            compute_value_size((*m).func_obj, hp);
            el1 = (*el1).next;
        }
        el = (*el).next;
    }
    el = (*rt).gc_obj_list.next;
    while el != &mut (*rt).gc_obj_list as *mut list_head {
        let mut gp: *mut JSGCObjectHeader = (el as *mut uint8_t)
            .offset(-(8 as libc::c_ulong as isize)) as *mut JSGCObjectHeader;
        let mut p: *mut JSObject = 0 as *mut JSObject;
        let mut sh_0: *mut JSShape = 0 as *mut JSShape;
        let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
        if (*gp).gc_obj_type() as libc::c_int
            == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE as libc::c_int
        {
            compute_bytecode_size(gp as *mut JSFunctionBytecode, hp);
        } else if !((*gp).gc_obj_type() as libc::c_int
            != JS_GC_OBJ_TYPE_JS_OBJECT as libc::c_int)
        {
            p = gp as *mut JSObject;
            sh_0 = (*p).shape;
            let ref mut fresh177 = (*s).obj_count;
            *fresh177 += 1;
            if !((*p).prop).is_null() {
                let ref mut fresh178 = (*s).memory_used_count;
                *fresh178 += 1;
                let ref mut fresh179 = (*s).prop_size;
                *fresh179
                    += ((*sh_0).prop_size as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSProperty>() as libc::c_ulong,
                        ) as libc::c_longlong;
                let ref mut fresh180 = (*s).prop_count;
                *fresh180 += (*sh_0).prop_count as libc::c_longlong;
                prs = get_shape_prop(sh_0);
                i = 0 as libc::c_int;
                while i < (*sh_0).prop_count {
                    let mut pr: *mut JSProperty = &mut *((*p).prop).offset(i as isize)
                        as *mut JSProperty;
                    if (*prs).atom != 0 as libc::c_int as libc::c_uint
                        && (*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int == 0
                    {
                        compute_value_size((*pr).u.value, hp);
                    }
                    prs = prs.offset(1);
                    i += 1;
                }
            }
            if (*sh_0).is_hashed == 0 {
                let mut hash_size_0: libc::c_int = ((*sh_0).prop_hash_mask)
                    .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int;
                let ref mut fresh181 = (*s).shape_count;
                *fresh181 += 1;
                let ref mut fresh182 = (*s).shape_size;
                *fresh182
                    += get_shape_size(hash_size_0 as size_t, (*sh_0).prop_size as size_t)
                        as libc::c_longlong;
            }
            let mut current_block_134: u64;
            match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
                2 | 8 => {
                    let ref mut fresh183 = (*s).array_count;
                    *fresh183 += 1;
                    if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                        let ref mut fresh184 = (*s).fast_array_count;
                        *fresh184 += 1;
                        if !((*p).u.array.u.values).is_null() {
                            let ref mut fresh185 = (*s).memory_used_count;
                            *fresh185 += 1;
                            let ref mut fresh186 = (*s).memory_used_size;
                            *fresh186
                                += ((*p).u.array.count as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                    ) as libc::c_longlong;
                            let ref mut fresh187 = (*s).fast_array_elements;
                            *fresh187 += (*p).u.array.count as libc::c_longlong;
                            i = 0 as libc::c_int;
                            while (i as libc::c_uint) < (*p).u.array.count {
                                compute_value_size(
                                    *((*p).u.array.u.values).offset(i as isize),
                                    hp,
                                );
                                i += 1;
                            }
                        }
                    }
                    current_block_134 = 11359721434352816539;
                }
                4 => {
                    current_block_134 = 10867192565214684417;
                }
                5 => {
                    current_block_134 = 10867192565214684417;
                }
                6 => {
                    current_block_134 = 18079399445274821774;
                }
                7 | 10 => {
                    current_block_134 = 16351556430899482314;
                }
                12 => {
                    let ref mut fresh188 = (*s).c_func_count;
                    *fresh188 += 1;
                    current_block_134 = 11359721434352816539;
                }
                13 => {
                    let mut b: *mut JSFunctionBytecode = (*p).u.func.function_bytecode;
                    let mut var_refs: *mut *mut JSVarRef = (*p).u.func.var_refs;
                    if !var_refs.is_null() {
                        let ref mut fresh189 = (*s).memory_used_count;
                        *fresh189 += 1;
                        let ref mut fresh190 = (*s).js_func_size;
                        *fresh190
                            += ((*b).closure_var_count as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<*mut JSVarRef>() as libc::c_ulong,
                                ) as libc::c_longlong;
                        i = 0 as libc::c_int;
                        while i < (*b).closure_var_count {
                            if !(*var_refs.offset(i as isize)).is_null() {
                                let mut ref_count: libc::c_double = (**var_refs
                                    .offset(i as isize))
                                    .c2rust_unnamed
                                    .header
                                    .ref_count as libc::c_double;
                                let ref mut fresh191 = (*s).memory_used_count;
                                *fresh191 = (*fresh191 as libc::c_double
                                    + 1 as libc::c_int as libc::c_double / ref_count)
                                    as int64_t;
                                let ref mut fresh192 = (*s).js_func_size;
                                *fresh192 = (*fresh192 as libc::c_double
                                    + ::core::mem::size_of::<JSVarRef>() as libc::c_ulong
                                        as libc::c_double / ref_count) as int64_t;
                                if (**var_refs.offset(i as isize)).pvalue
                                    == &mut (**var_refs.offset(i as isize)).value
                                        as *mut JSValue
                                {
                                    compute_value_size(
                                        (**var_refs.offset(i as isize)).value,
                                        hp,
                                    );
                                }
                            }
                            i += 1;
                        }
                    }
                    current_block_134 = 11359721434352816539;
                }
                14 => {
                    let mut bf: *mut JSBoundFunction = (*p).u.bound_function;
                    i = 0 as libc::c_int;
                    while i < (*bf).argc {
                        compute_value_size(
                            *((*bf).argv).as_mut_ptr().offset(i as isize),
                            hp,
                        );
                        i += 1;
                    }
                    let ref mut fresh193 = (*s).memory_used_count;
                    *fresh193 += 1 as libc::c_int as libc::c_longlong;
                    let ref mut fresh194 = (*s).memory_used_size;
                    *fresh194
                        += (::core::mem::size_of::<JSBoundFunction>() as libc::c_ulong)
                            .wrapping_add(
                                ((*bf).argc as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                    ),
                            ) as libc::c_longlong;
                    current_block_134 = 11359721434352816539;
                }
                15 => {
                    let mut fd: *mut JSCFunctionDataRecord = (*p)
                        .u
                        .c_function_data_record;
                    if !fd.is_null() {
                        i = 0 as libc::c_int;
                        while i < (*fd).data_len as libc::c_int {
                            compute_value_size(
                                *((*fd).data).as_mut_ptr().offset(i as isize),
                                hp,
                            );
                            i += 1;
                        }
                        let ref mut fresh195 = (*s).memory_used_count;
                        *fresh195 += 1 as libc::c_int as libc::c_longlong;
                        let ref mut fresh196 = (*s).memory_used_size;
                        *fresh196
                            += (::core::mem::size_of::<JSCFunctionDataRecord>()
                                as libc::c_ulong)
                                .wrapping_add(
                                    ((*fd).data_len as libc::c_ulong)
                                        .wrapping_mul(
                                            ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                        ),
                                ) as libc::c_longlong;
                    }
                    current_block_134 = 11359721434352816539;
                }
                18 => {
                    compute_jsstring_size((*p).u.regexp.pattern, hp);
                    compute_jsstring_size((*p).u.regexp.bytecode, hp);
                    current_block_134 = 11359721434352816539;
                }
                17 => {
                    let mut it: *mut JSForInIterator = (*p).u.for_in_iterator;
                    if !it.is_null() {
                        compute_value_size((*it).obj, hp);
                        let ref mut fresh197 = (*s).memory_used_count;
                        *fresh197 += 1 as libc::c_int as libc::c_longlong;
                        let ref mut fresh198 = (*s).memory_used_size;
                        *fresh198
                            += ::core::mem::size_of::<JSForInIterator>() as libc::c_ulong
                                as libc::c_longlong;
                    }
                    current_block_134 = 11359721434352816539;
                }
                19 | 20 => {
                    let mut abuf: *mut JSArrayBuffer = (*p).u.array_buffer;
                    if !abuf.is_null() {
                        let ref mut fresh199 = (*s).memory_used_count;
                        *fresh199 += 1 as libc::c_int as libc::c_longlong;
                        let ref mut fresh200 = (*s).memory_used_size;
                        *fresh200
                            += ::core::mem::size_of::<JSArrayBuffer>() as libc::c_ulong
                                as libc::c_longlong;
                        if !((*abuf).data).is_null() {
                            let ref mut fresh201 = (*s).memory_used_count;
                            *fresh201 += 1 as libc::c_int as libc::c_longlong;
                            let ref mut fresh202 = (*s).memory_used_size;
                            *fresh202 += (*abuf).byte_length as libc::c_longlong;
                        }
                    }
                    current_block_134 = 11359721434352816539;
                }
                40 => {
                    current_block_134 = 10054799046046256589;
                }
                21 => {
                    current_block_134 = 10054799046046256589;
                }
                22 => {
                    current_block_134 = 17443406579758703473;
                }
                23 => {
                    current_block_134 = 5046721025850219319;
                }
                24 => {
                    current_block_134 = 1308789571918269509;
                }
                25 => {
                    current_block_134 = 5412785166595323958;
                }
                26 => {
                    current_block_134 = 14697457813067742355;
                }
                27 => {
                    current_block_134 = 13547522518843045011;
                }
                28 => {
                    current_block_134 = 11103332933140570706;
                }
                29 => {
                    current_block_134 = 10014846097290165301;
                }
                30 => {
                    current_block_134 = 13357041211866645142;
                }
                31 => {
                    current_block_134 = 11066568145396400249;
                }
                32 => {
                    current_block_134 = 9006071797282293046;
                }
                33 => {
                    current_block_134 = 14401735873133716692;
                }
                34 => {
                    current_block_134 = 1727163134657490093;
                }
                35 => {
                    current_block_134 = 12573352275476877106;
                }
                36 => {
                    current_block_134 = 2539375345947363877;
                }
                37 => {
                    current_block_134 = 18019795471304502970;
                }
                38 => {
                    current_block_134 = 15220926492384398838;
                }
                41 => {
                    current_block_134 = 18265545647934411009;
                }
                42 => {
                    current_block_134 = 15636490109207546666;
                }
                43 => {
                    current_block_134 = 17742856178112727283;
                }
                44 => {
                    current_block_134 = 18161271716332252810;
                }
                46 => {
                    current_block_134 = 3024776149172998278;
                }
                47 => {
                    current_block_134 = 15978361623280177444;
                }
                50 => {
                    current_block_134 = 15995055513084336898;
                }
                48 | _ => {
                    current_block_134 = 15995055513084336898;
                }
            }
            match current_block_134 {
                10867192565214684417 => {
                    current_block_134 = 18079399445274821774;
                }
                10054799046046256589 => {
                    current_block_134 = 17443406579758703473;
                }
                _ => {}
            }
            match current_block_134 {
                18079399445274821774 => {
                    current_block_134 = 16351556430899482314;
                }
                17443406579758703473 => {
                    current_block_134 = 5046721025850219319;
                }
                _ => {}
            }
            match current_block_134 {
                16351556430899482314 => {
                    compute_value_size((*p).u.object_data, hp);
                    current_block_134 = 11359721434352816539;
                }
                5046721025850219319 => {
                    current_block_134 = 1308789571918269509;
                }
                _ => {}
            }
            match current_block_134 {
                1308789571918269509 => {
                    current_block_134 = 5412785166595323958;
                }
                _ => {}
            }
            match current_block_134 {
                5412785166595323958 => {
                    current_block_134 = 14697457813067742355;
                }
                _ => {}
            }
            match current_block_134 {
                14697457813067742355 => {
                    current_block_134 = 13547522518843045011;
                }
                _ => {}
            }
            match current_block_134 {
                13547522518843045011 => {
                    current_block_134 = 11103332933140570706;
                }
                _ => {}
            }
            match current_block_134 {
                11103332933140570706 => {
                    current_block_134 = 10014846097290165301;
                }
                _ => {}
            }
            match current_block_134 {
                10014846097290165301 => {
                    current_block_134 = 13357041211866645142;
                }
                _ => {}
            }
            match current_block_134 {
                13357041211866645142 => {
                    current_block_134 = 11066568145396400249;
                }
                _ => {}
            }
            match current_block_134 {
                11066568145396400249 => {
                    current_block_134 = 9006071797282293046;
                }
                _ => {}
            }
            match current_block_134 {
                9006071797282293046 => {
                    current_block_134 = 14401735873133716692;
                }
                _ => {}
            }
            match current_block_134 {
                14401735873133716692 => {
                    current_block_134 = 1727163134657490093;
                }
                _ => {}
            }
            match current_block_134 {
                1727163134657490093 => {
                    current_block_134 = 12573352275476877106;
                }
                _ => {}
            }
            match current_block_134 {
                12573352275476877106 => {
                    current_block_134 = 2539375345947363877;
                }
                _ => {}
            }
            match current_block_134 {
                2539375345947363877 => {
                    current_block_134 = 18019795471304502970;
                }
                _ => {}
            }
            match current_block_134 {
                18019795471304502970 => {
                    current_block_134 = 15220926492384398838;
                }
                _ => {}
            }
            match current_block_134 {
                15220926492384398838 => {
                    current_block_134 = 18265545647934411009;
                }
                _ => {}
            }
            match current_block_134 {
                18265545647934411009 => {
                    current_block_134 = 15636490109207546666;
                }
                _ => {}
            }
            match current_block_134 {
                15636490109207546666 => {
                    current_block_134 = 17742856178112727283;
                }
                _ => {}
            }
            match current_block_134 {
                17742856178112727283 => {
                    current_block_134 = 18161271716332252810;
                }
                _ => {}
            }
            match current_block_134 {
                18161271716332252810 => {
                    current_block_134 = 3024776149172998278;
                }
                _ => {}
            }
            match current_block_134 {
                3024776149172998278 => {
                    current_block_134 = 15978361623280177444;
                }
                _ => {}
            }
            match current_block_134 {
                15978361623280177444 => {
                    current_block_134 = 15995055513084336898;
                }
                _ => {}
            }
            match current_block_134 {
                15995055513084336898 => {
                    if !((*p).u.opaque).is_null() {
                        let ref mut fresh203 = (*s).memory_used_count;
                        *fresh203 += 1 as libc::c_int as libc::c_longlong;
                    }
                }
                _ => {}
            }
        }
        el = (*el).next;
    }
    let ref mut fresh204 = (*s).obj_size;
    *fresh204
        += (*s).obj_count
            * ::core::mem::size_of::<JSObject>() as libc::c_ulong as libc::c_longlong;
    let ref mut fresh205 = (*s).memory_used_count;
    *fresh205 += 1;
    let ref mut fresh206 = (*s).memory_used_size;
    *fresh206
        += (::core::mem::size_of::<*mut JSShape>() as libc::c_ulong)
            .wrapping_mul((*rt).shape_hash_size as libc::c_ulong) as libc::c_longlong;
    i = 0 as libc::c_int;
    while i < (*rt).shape_hash_size {
        let mut sh_1: *mut JSShape = 0 as *mut JSShape;
        sh_1 = *((*rt).shape_hash).offset(i as isize);
        while !sh_1.is_null() {
            let mut hash_size_1: libc::c_int = ((*sh_1).prop_hash_mask)
                .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int;
            let ref mut fresh207 = (*s).shape_count;
            *fresh207 += 1;
            let ref mut fresh208 = (*s).shape_size;
            *fresh208
                += get_shape_size(hash_size_1 as size_t, (*sh_1).prop_size as size_t)
                    as libc::c_longlong;
            sh_1 = (*sh_1).shape_hash_next;
        }
        i += 1;
    }
    let ref mut fresh209 = (*s).memory_used_count;
    *fresh209 += 2 as libc::c_int as libc::c_longlong;
    (*s).atom_count = (*rt).atom_count as int64_t;
    (*s)
        .atom_size = (::core::mem::size_of::<*mut JSAtomStruct>() as libc::c_ulong)
        .wrapping_mul((*rt).atom_size as libc::c_ulong)
        .wrapping_add(
            (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
                .wrapping_mul((*rt).atom_hash_size as libc::c_ulong),
        ) as int64_t;
    i = 0 as libc::c_int;
    while i < (*rt).atom_size {
        let mut p_0: *mut JSAtomStruct = *((*rt).atom_array).offset(i as isize);
        if atom_is_free(p_0) == 0 {
            let ref mut fresh210 = (*s).atom_size;
            *fresh210
                += (::core::mem::size_of::<JSAtomStruct>() as libc::c_ulong)
                    .wrapping_add(
                        (((*p_0).len() as libc::c_int)
                            << (*p_0).is_wide_char() as libc::c_int) as libc::c_ulong,
                    )
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    .wrapping_sub((*p_0).is_wide_char() as libc::c_ulong)
                    as libc::c_longlong;
        }
        i += 1;
    }
    (*s).str_count = round(mem.str_count) as int64_t;
    (*s).str_size = round(mem.str_size) as int64_t;
    (*s).js_func_count = mem.js_func_count;
    (*s).js_func_size = round(mem.js_func_size) as int64_t;
    (*s).js_func_code_size = mem.js_func_code_size;
    (*s).js_func_pc2line_count = mem.js_func_pc2line_count;
    (*s).js_func_pc2line_size = mem.js_func_pc2line_size;
    let ref mut fresh211 = (*s).memory_used_count;
    *fresh211 = (*fresh211 as libc::c_double
        + (round(mem.memory_used_count) + (*s).atom_count as libc::c_double
            + (*s).str_count as libc::c_double + (*s).obj_count as libc::c_double
            + (*s).shape_count as libc::c_double + (*s).js_func_count as libc::c_double
            + (*s).js_func_pc2line_count as libc::c_double)) as int64_t;
    let ref mut fresh212 = (*s).memory_used_size;
    *fresh212
        += (*s).atom_size + (*s).str_size + (*s).obj_size + (*s).prop_size
            + (*s).shape_size + (*s).js_func_size + (*s).js_func_code_size
            + (*s).js_func_pc2line_size;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetGlobalObject(mut ctx: *mut JSContext) -> JSValue {
    return JS_DupValue(ctx, (*ctx).global_obj);
}
#[no_mangle]
pub unsafe extern "C" fn JS_Throw(mut ctx: *mut JSContext, mut obj: JSValue) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    JS_FreeValue(ctx, (*rt).current_exception);
    (*rt).current_exception = obj;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetException(mut ctx: *mut JSContext) -> JSValue {
    let mut val: JSValue = 0;
    let mut rt: *mut JSRuntime = (*ctx).rt;
    val = (*rt).current_exception;
    (*rt)
        .current_exception = (JS_TAG_NULL as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return val;
}
unsafe extern "C" fn dbuf_put_leb128(mut s: *mut DynBuf, mut v: uint32_t) {
    let mut a: uint32_t = 0;
    loop {
        a = v & 0x7f as libc::c_int as libc::c_uint;
        v >>= 7 as libc::c_int;
        if v != 0 as libc::c_int as libc::c_uint {
            dbuf_putc(s, (a | 0x80 as libc::c_int as libc::c_uint) as uint8_t);
        } else {
            dbuf_putc(s, a as uint8_t);
            break;
        }
    };
}
unsafe extern "C" fn dbuf_put_sleb128(mut s: *mut DynBuf, mut v1: int32_t) {
    let mut v: uint32_t = v1 as uint32_t;
    dbuf_put_leb128(
        s,
        (2 as libc::c_int as libc::c_uint).wrapping_mul(v)
            ^ (v >> 31 as libc::c_int).wrapping_neg(),
    );
}
unsafe extern "C" fn get_leb128(
    mut pval: *mut uint32_t,
    mut buf: *const uint8_t,
    mut buf_end: *const uint8_t,
) -> libc::c_int {
    let mut ptr: *const uint8_t = buf;
    let mut v: uint32_t = 0;
    let mut a: uint32_t = 0;
    let mut i: uint32_t = 0;
    v = 0 as libc::c_int as uint32_t;
    i = 0 as libc::c_int as uint32_t;
    while i < 5 as libc::c_int as libc::c_uint {
        if (ptr >= buf_end) as libc::c_int as libc::c_long != 0 {
            break;
        }
        let fresh213 = ptr;
        ptr = ptr.offset(1);
        a = *fresh213 as uint32_t;
        v
            |= (a & 0x7f as libc::c_int as libc::c_uint)
                << i.wrapping_mul(7 as libc::c_int as libc::c_uint);
        if a & 0x80 as libc::c_int as libc::c_uint == 0 {
            *pval = v;
            return ptr.offset_from(buf) as libc::c_long as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    *pval = 0 as libc::c_int as uint32_t;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn get_sleb128(
    mut pval: *mut int32_t,
    mut buf: *const uint8_t,
    mut buf_end: *const uint8_t,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut val: uint32_t = 0;
    ret = get_leb128(&mut val, buf, buf_end);
    if ret < 0 as libc::c_int {
        *pval = 0 as libc::c_int;
        return -(1 as libc::c_int);
    }
    *pval = (val >> 1 as libc::c_int
        ^ (val & 1 as libc::c_int as libc::c_uint).wrapping_neg()) as int32_t;
    return ret;
}
unsafe extern "C" fn find_line_num(
    mut ctx: *mut JSContext,
    mut b: *mut JSFunctionBytecode,
    mut pc_value: uint32_t,
) -> libc::c_int {
    let mut p_end: *const uint8_t = 0 as *const uint8_t;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut new_line_num: libc::c_int = 0;
    let mut line_num: libc::c_int = 0;
    let mut pc: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut op: libc::c_uint = 0;
    if (*b).has_debug() == 0 || ((*b).debug.pc2line_buf).is_null() {
        return -(1 as libc::c_int);
    }
    p = (*b).debug.pc2line_buf;
    p_end = p.offset((*b).debug.pc2line_len as isize);
    pc = 0 as libc::c_int;
    line_num = (*b).debug.line_num;
    while p < p_end {
        let fresh214 = p;
        p = p.offset(1);
        op = *fresh214 as libc::c_uint;
        if op == 0 as libc::c_int as libc::c_uint {
            's_97: {
                let mut val: uint32_t = 0;
                ret = get_leb128(&mut val, p, p_end);
                if !(ret < 0 as libc::c_int) {
                    pc = (pc as libc::c_uint).wrapping_add(val) as libc::c_int
                        as libc::c_int;
                    p = p.offset(ret as isize);
                    ret = get_sleb128(&mut v, p, p_end);
                    if !(ret < 0 as libc::c_int) {
                        p = p.offset(ret as isize);
                        new_line_num = line_num + v;
                        break 's_97;
                    }
                }
                return (*b).debug.line_num;
            }
        } else {
            op = op.wrapping_sub(1 as libc::c_int as libc::c_uint);
            pc = (pc as libc::c_uint)
                .wrapping_add(op.wrapping_div(5 as libc::c_int as libc::c_uint))
                as libc::c_int as libc::c_int;
            new_line_num = (line_num as libc::c_uint)
                .wrapping_add(op.wrapping_rem(5 as libc::c_int as libc::c_uint))
                .wrapping_add(-(1 as libc::c_int) as libc::c_uint) as libc::c_int;
        }
        if pc_value < pc as libc::c_uint {
            return line_num;
        }
        line_num = new_line_num;
    }
    return line_num;
}
unsafe extern "C" fn get_func_name(
    mut ctx: *mut JSContext,
    mut func: JSValue,
) -> *const libc::c_char {
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut val: JSValue = 0;
    if (func >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return 0 as *const libc::c_char;
    }
    prs = find_own_property(
        &mut pr,
        func as intptr_t as *mut libc::c_void as *mut JSObject,
        JS_ATOM_name as libc::c_int as JSAtom,
    );
    if prs.is_null() {
        return 0 as *const libc::c_char;
    }
    if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
        != (0 as libc::c_int) << 4 as libc::c_int
    {
        return 0 as *const libc::c_char;
    }
    val = (*pr).u.value;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int {
        return 0 as *const libc::c_char;
    }
    return JS_ToCString(ctx, val);
}
unsafe extern "C" fn build_backtrace(
    mut ctx: *mut JSContext,
    mut error_obj: JSValue,
    mut filename: *const libc::c_char,
    mut line_num: libc::c_int,
    mut backtrace_flags: libc::c_int,
) {
    let mut current_block: u64;
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut str: JSValue = 0;
    let mut dbuf: DynBuf = DynBuf {
        buf: 0 as *mut uint8_t,
        size: 0,
        allocated_size: 0,
        error: 0,
        realloc_func: None,
        opaque: 0 as *mut libc::c_void,
    };
    let mut func_name_str: *const libc::c_char = 0 as *const libc::c_char;
    let mut str1: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut backtrace_barrier: BOOL = 0;
    js_dbuf_init(ctx, &mut dbuf);
    if !filename.is_null() {
        dbuf_printf(
            &mut dbuf as *mut DynBuf,
            b"    at %s\0" as *const u8 as *const libc::c_char,
            filename,
        );
        if line_num != -(1 as libc::c_int) {
            dbuf_printf(
                &mut dbuf as *mut DynBuf,
                b":%d\0" as *const u8 as *const libc::c_char,
                line_num,
            );
        }
        dbuf_putc(&mut dbuf, '\n' as i32 as uint8_t);
        str = JS_NewString(ctx, filename);
        JS_DefinePropertyValue(
            ctx,
            error_obj,
            JS_ATOM_fileName as libc::c_int as JSAtom,
            str,
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        JS_DefinePropertyValue(
            ctx,
            error_obj,
            JS_ATOM_lineNumber as libc::c_int as JSAtom,
            JS_NewInt32(ctx, line_num),
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        if backtrace_flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
            current_block = 6255957599059113722;
        } else {
            current_block = 12800627514080957624;
        }
    } else {
        current_block = 12800627514080957624;
    }
    match current_block {
        12800627514080957624 => {
            sf = (*(*ctx).rt).current_stack_frame;
            while !sf.is_null() {
                if backtrace_flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                    backtrace_flags &= !((1 as libc::c_int) << 0 as libc::c_int);
                } else {
                    func_name_str = get_func_name(ctx, (*sf).cur_func);
                    if func_name_str.is_null()
                        || *func_name_str.offset(0 as libc::c_int as isize)
                            as libc::c_int == '\0' as i32
                    {
                        str1 = b"<anonymous>\0" as *const u8 as *const libc::c_char;
                    } else {
                        str1 = func_name_str;
                    }
                    dbuf_printf(
                        &mut dbuf as *mut DynBuf,
                        b"    at %s\0" as *const u8 as *const libc::c_char,
                        str1,
                    );
                    JS_FreeCString(ctx, func_name_str);
                    p = (*sf).cur_func as intptr_t as *mut libc::c_void as *mut JSObject;
                    backtrace_barrier = FALSE as libc::c_int;
                    if js_class_has_bytecode(
                        (*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID,
                    ) != 0
                    {
                        let mut b: *mut JSFunctionBytecode = 0
                            as *mut JSFunctionBytecode;
                        let mut atom_str: *const libc::c_char = 0 as *const libc::c_char;
                        let mut line_num1: libc::c_int = 0;
                        b = (*p).u.func.function_bytecode;
                        backtrace_barrier = (*b).backtrace_barrier() as BOOL;
                        if (*b).has_debug() != 0 {
                            line_num1 = find_line_num(
                                ctx,
                                b,
                                (((*sf).cur_pc).offset_from((*b).byte_code_buf)
                                    as libc::c_long - 1 as libc::c_int as libc::c_long)
                                    as uint32_t,
                            );
                            atom_str = JS_AtomToCString(ctx, (*b).debug.filename);
                            dbuf_printf(
                                &mut dbuf as *mut DynBuf,
                                b" (%s\0" as *const u8 as *const libc::c_char,
                                if !atom_str.is_null() {
                                    atom_str
                                } else {
                                    b"<null>\0" as *const u8 as *const libc::c_char
                                },
                            );
                            JS_FreeCString(ctx, atom_str);
                            if line_num1 != -(1 as libc::c_int) {
                                dbuf_printf(
                                    &mut dbuf as *mut DynBuf,
                                    b":%d\0" as *const u8 as *const libc::c_char,
                                    line_num1,
                                );
                            }
                            dbuf_putc(&mut dbuf, ')' as i32 as uint8_t);
                        }
                    } else {
                        dbuf_printf(
                            &mut dbuf as *mut DynBuf,
                            b" (native)\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    dbuf_putc(&mut dbuf, '\n' as i32 as uint8_t);
                    if backtrace_barrier != 0 {
                        break;
                    }
                }
                sf = (*sf).prev_frame;
            }
        }
        _ => {}
    }
    dbuf_putc(&mut dbuf, '\0' as i32 as uint8_t);
    if dbuf_error(&mut dbuf) != 0 {
        str = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        str = JS_NewString(ctx, dbuf.buf as *mut libc::c_char);
    }
    dbuf_free(&mut dbuf);
    JS_DefinePropertyValue(
        ctx,
        error_obj,
        JS_ATOM_stack as libc::c_int as JSAtom,
        str,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
}
unsafe extern "C" fn is_backtrace_needed(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> BOOL {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        != JS_CLASS_ERROR as libc::c_int
    {
        return FALSE as libc::c_int;
    }
    if !(find_own_property1(p, JS_ATOM_stack as libc::c_int as JSAtom)).is_null() {
        return FALSE as libc::c_int;
    }
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewError(mut ctx: *mut JSContext) -> JSValue {
    return JS_NewObjectClass(ctx, JS_CLASS_ERROR as libc::c_int);
}
unsafe extern "C" fn JS_ThrowError2(
    mut ctx: *mut JSContext,
    mut error_num: JSErrorEnum,
    mut fmt: *const libc::c_char,
    mut ap: va_list,
    mut add_backtrace: BOOL,
) -> JSValue {
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut obj: JSValue = 0;
    let mut ret: JSValue = 0;
    vsnprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        fmt,
        ap,
    );
    obj = JS_NewObjectProtoClass(
        ctx,
        (*ctx).native_error_proto[error_num as usize],
        JS_CLASS_ERROR as libc::c_int as JSClassID,
    );
    if (JS_IsException(obj) != 0) as libc::c_int as libc::c_long != 0 {
        obj = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        JS_DefinePropertyValue(
            ctx,
            obj,
            JS_ATOM_message as libc::c_int as JSAtom,
            JS_NewString(ctx, buf.as_mut_ptr()),
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
    }
    if add_backtrace != 0 {
        build_backtrace(
            ctx,
            obj,
            0 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
        );
    }
    ret = JS_Throw(ctx, obj);
    return ret;
}
unsafe extern "C" fn JS_ThrowError(
    mut ctx: *mut JSContext,
    mut error_num: JSErrorEnum,
    mut fmt: *const libc::c_char,
    mut ap: va_list,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut add_backtrace: BOOL = 0;
    sf = (*rt).current_stack_frame;
    add_backtrace = ((*rt).in_out_of_memory() == 0
        && (sf.is_null() || (JS_GetFunctionBytecode((*sf).cur_func)).is_null()))
        as libc::c_int;
    return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowSyntaxError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    val = JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowTypeError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    val = JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
    return val;
}
unsafe extern "C" fn JS_ThrowTypeErrorOrFalse(
    mut ctx: *mut JSContext,
    mut flags: libc::c_int,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: va_list = 0 as *mut libc::c_void;
    if flags & (1 as libc::c_int) << 14 as libc::c_int != 0
        || flags & (1 as libc::c_int) << 15 as libc::c_int != 0
            && is_strict_mode(ctx) != 0
    {
        ap = args.clone();
        JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
        return -(1 as libc::c_int);
    } else {
        return FALSE as libc::c_int
    };
}
unsafe extern "C" fn __JS_ThrowTypeErrorAtom(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    return JS_ThrowTypeError(
        ctx,
        fmt,
        JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            atom,
        ),
    );
}
unsafe extern "C" fn __JS_ThrowSyntaxErrorAtom(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    return JS_ThrowSyntaxError(
        ctx,
        fmt,
        JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            atom,
        ),
    );
}
unsafe extern "C" fn JS_ThrowTypeErrorReadOnly(
    mut ctx: *mut JSContext,
    mut flags: libc::c_int,
    mut atom: JSAtom,
) -> libc::c_int {
    if flags & (1 as libc::c_int) << 14 as libc::c_int != 0
        || flags & (1 as libc::c_int) << 15 as libc::c_int != 0
            && is_strict_mode(ctx) != 0
    {
        __JS_ThrowTypeErrorAtom(
            ctx,
            atom,
            b"'%s' is read-only\0" as *const u8 as *const libc::c_char,
            b"\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    } else {
        return FALSE as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowReferenceError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    val = JS_ThrowError(ctx, JS_REFERENCE_ERROR, fmt, ap);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowRangeError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    val = JS_ThrowError(ctx, JS_RANGE_ERROR, fmt, ap);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowInternalError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    val = JS_ThrowError(ctx, JS_INTERNAL_ERROR, fmt, ap);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ThrowOutOfMemory(mut ctx: *mut JSContext) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    if (*rt).in_out_of_memory() == 0 {
        (*rt).set_in_out_of_memory(TRUE as libc::c_int);
        JS_ThrowInternalError(
            ctx,
            b"out of memory\0" as *const u8 as *const libc::c_char,
        );
        (*rt).set_in_out_of_memory(FALSE as libc::c_int);
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ThrowStackOverflow(mut ctx: *mut JSContext) -> JSValue {
    return JS_ThrowInternalError(
        ctx,
        b"stack overflow\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn JS_ThrowTypeErrorNotAnObject(mut ctx: *mut JSContext) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"not an object\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn JS_ThrowTypeErrorNotASymbol(mut ctx: *mut JSContext) -> JSValue {
    return JS_ThrowTypeError(ctx, b"not a symbol\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn JS_ThrowReferenceErrorNotDefined(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    return JS_ThrowReferenceError(
        ctx,
        b"'%s' is not defined\0" as *const u8 as *const libc::c_char,
        JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            name,
        ),
    );
}
unsafe extern "C" fn JS_ThrowReferenceErrorUninitialized(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    return JS_ThrowReferenceError(
        ctx,
        b"%s is not initialized\0" as *const u8 as *const libc::c_char,
        if name == 0 as libc::c_int as libc::c_uint {
            b"lexical variable\0" as *const u8 as *const libc::c_char
        } else {
            JS_AtomGetStr(
                ctx,
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                    as libc::c_int,
                name,
            )
        },
    );
}
unsafe extern "C" fn JS_ThrowReferenceErrorUninitialized2(
    mut ctx: *mut JSContext,
    mut b: *mut JSFunctionBytecode,
    mut idx: libc::c_int,
    mut is_ref: BOOL,
) -> JSValue {
    let mut atom: JSAtom = 0 as libc::c_int as JSAtom;
    if is_ref != 0 {
        atom = (*((*b).closure_var).offset(idx as isize)).var_name;
    } else if !((*b).vardefs).is_null() {
        atom = (*((*b).vardefs).offset(((*b).arg_count as libc::c_int + idx) as isize))
            .var_name;
    }
    return JS_ThrowReferenceErrorUninitialized(ctx, atom);
}
unsafe extern "C" fn JS_ThrowTypeErrorInvalidClass(
    mut ctx: *mut JSContext,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut name: JSAtom = 0;
    name = (*((*rt).class_array).offset(class_id as isize)).class_name;
    return __JS_ThrowTypeErrorAtom(
        ctx,
        name,
        b"%s object expected\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
    );
}
#[inline(never)]
unsafe extern "C" fn __js_poll_interrupts(mut ctx: *mut JSContext) -> libc::c_int {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    (*ctx).interrupt_counter = 10000 as libc::c_int;
    if ((*rt).interrupt_handler).is_some() {
        if ((*rt).interrupt_handler)
            .expect("non-null function pointer")(rt, (*rt).interrupt_opaque) != 0
        {
            JS_ThrowInternalError(
                ctx,
                b"interrupted\0" as *const u8 as *const libc::c_char,
            );
            JS_SetUncatchableError(
                ctx,
                (*(*ctx).rt).current_exception,
                TRUE as libc::c_int,
            );
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn js_poll_interrupts(mut ctx: *mut JSContext) -> libc::c_int {
    let ref mut fresh215 = (*ctx).interrupt_counter;
    *fresh215 -= 1;
    if (*fresh215 <= 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        return __js_poll_interrupts(ctx)
    } else {
        return 0 as libc::c_int
    };
}
unsafe extern "C" fn JS_SetPrototypeInternal(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut proto_val: JSValue,
    mut throw_flag: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut proto: *mut JSObject = 0 as *mut JSObject;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    if throw_flag != 0 {
        if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_NULL as libc::c_int
            || (obj >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_UNDEFINED as libc::c_int
        {
            current_block = 12760067722607269187;
        } else {
            current_block = 6873731126896040597;
        }
    } else if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        current_block = 12760067722607269187;
    } else {
        current_block = 6873731126896040597;
    }
    match current_block {
        6873731126896040597 => {
            p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            if (proto_val >> 32 as libc::c_int) as libc::c_int
                != JS_TAG_OBJECT as libc::c_int
            {
                if (proto_val >> 32 as libc::c_int) as libc::c_int
                    != JS_TAG_NULL as libc::c_int
                {
                    current_block = 12760067722607269187;
                } else {
                    proto = 0 as *mut JSObject;
                    current_block = 3512920355445576850;
                }
            } else {
                proto = proto_val as intptr_t as *mut libc::c_void as *mut JSObject;
                current_block = 3512920355445576850;
            }
            match current_block {
                12760067722607269187 => {}
                _ => {
                    if throw_flag != 0
                        && (obj >> 32 as libc::c_int) as libc::c_int
                            != JS_TAG_OBJECT as libc::c_int
                    {
                        return TRUE as libc::c_int;
                    }
                    if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                        == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long
                        != 0
                    {
                        return js_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);
                    }
                    sh = (*p).shape;
                    if (*sh).proto == proto {
                        return TRUE as libc::c_int;
                    }
                    if ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0 {
                        if throw_flag != 0 {
                            JS_ThrowTypeError(
                                ctx,
                                b"object is not extensible\0" as *const u8
                                    as *const libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        } else {
                            return FALSE as libc::c_int
                        }
                    }
                    if !proto.is_null() {
                        p1 = proto;
                        loop {
                            if p1 == p {
                                if throw_flag != 0 {
                                    JS_ThrowTypeError(
                                        ctx,
                                        b"circular prototype chain\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    return -(1 as libc::c_int);
                                } else {
                                    return FALSE as libc::c_int
                                }
                            }
                            p1 = (*(*p1).shape).proto;
                            if p1.is_null() {
                                break;
                            }
                        }
                        JS_DupValue(ctx, proto_val);
                    }
                    if js_shape_prepare_update(ctx, p, 0 as *mut *mut JSShapeProperty)
                        != 0
                    {
                        return -(1 as libc::c_int);
                    }
                    sh = (*p).shape;
                    if !((*sh).proto).is_null() {
                        JS_FreeValue(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | (*sh).proto as uintptr_t as libc::c_ulonglong,
                        );
                    }
                    let ref mut fresh216 = (*sh).proto;
                    *fresh216 = proto;
                    return TRUE as libc::c_int;
                }
            }
        }
        _ => {}
    }
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPrototype(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut proto_val: JSValue,
) -> libc::c_int {
    return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE as libc::c_int);
}
unsafe extern "C" fn JS_GetPrototypePrimitive(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    match JS_VALUE_GET_NORM_TAG(val) {
        0 | 7 => {
            val = *((*ctx).class_proto).offset(JS_CLASS_NUMBER as libc::c_int as isize);
        }
        1 => {
            val = *((*ctx).class_proto).offset(JS_CLASS_BOOLEAN as libc::c_int as isize);
        }
        -7 => {
            val = *((*ctx).class_proto).offset(JS_CLASS_STRING as libc::c_int as isize);
        }
        -8 => {
            val = *((*ctx).class_proto).offset(JS_CLASS_SYMBOL as libc::c_int as isize);
        }
        -1 | 2 | 3 | _ => {
            val = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetPrototype(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = 0 as *mut JSObject;
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
        {
            val = js_proxy_getPrototypeOf(ctx, obj);
        } else {
            p = (*(*p).shape).proto;
            if p.is_null() {
                val = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                val = JS_DupValue(
                    ctx,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                );
            }
        }
    } else {
        val = JS_DupValue(ctx, JS_GetPrototypePrimitive(ctx, obj));
    }
    return val;
}
unsafe extern "C" fn JS_GetPrototypeFree(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> JSValue {
    let mut obj1: JSValue = 0;
    obj1 = JS_GetPrototype(ctx, obj);
    JS_FreeValue(ctx, obj);
    return obj1;
}
unsafe extern "C" fn JS_OrdinaryIsInstanceOf(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut obj: JSValue,
) -> libc::c_int {
    let mut obj_proto: JSValue = 0;
    let mut proto: *mut JSObject = 0 as *mut JSObject;
    let mut p: *const JSObject = 0 as *const JSObject;
    let mut proto1: *const JSObject = 0 as *const JSObject;
    let mut ret: BOOL = 0;
    if JS_IsFunction(ctx, obj) == 0 {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_BOUND_FUNCTION as libc::c_int
    {
        let mut s: *mut JSBoundFunction = (*p).u.bound_function;
        return JS_IsInstanceOf(ctx, val, (*s).func_obj);
    }
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    obj_proto = JS_GetProperty(ctx, obj, JS_ATOM_prototype as libc::c_int as JSAtom);
    if (obj_proto >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        if JS_IsException(obj_proto) == 0 {
            JS_ThrowTypeError(
                ctx,
                b"operand 'prototype' property is not an object\0" as *const u8
                    as *const libc::c_char,
            );
        }
        ret = -(1 as libc::c_int);
    } else {
        proto = obj_proto as intptr_t as *mut libc::c_void as *mut JSObject;
        p = val as intptr_t as *mut libc::c_void as *mut JSObject;
        loop {
            proto1 = (*(*p).shape).proto;
            if proto1.is_null() {
                if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                    == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
                {
                    let mut obj1: JSValue = 0;
                    obj1 = JS_DupValue(
                        ctx,
                        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                            | p as *mut JSObject as uintptr_t as libc::c_ulonglong,
                    );
                    loop {
                        obj1 = JS_GetPrototypeFree(ctx, obj1);
                        if JS_IsException(obj1) != 0 {
                            ret = -(1 as libc::c_int);
                            break;
                        } else if JS_IsNull(obj1) != 0 {
                            ret = FALSE as libc::c_int;
                            break;
                        } else if proto
                            == obj1 as intptr_t as *mut libc::c_void as *mut JSObject
                        {
                            JS_FreeValue(ctx, obj1);
                            ret = TRUE as libc::c_int;
                            break;
                        } else {
                            if !(js_poll_interrupts(ctx) != 0) {
                                continue;
                            }
                            JS_FreeValue(ctx, obj1);
                            ret = -(1 as libc::c_int);
                            break;
                        }
                    }
                } else {
                    ret = FALSE as libc::c_int;
                }
                break;
            } else {
                p = proto1;
                if !(proto == p as *mut JSObject) {
                    continue;
                }
                ret = TRUE as libc::c_int;
                break;
            }
        }
    }
    JS_FreeValue(ctx, obj_proto);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsInstanceOf(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut obj: JSValue,
) -> libc::c_int {
    let mut method: JSValue = 0;
    if !(JS_IsObject(obj) == 0) {
        method = JS_GetProperty(
            ctx,
            obj,
            JS_ATOM_Symbol_hasInstance as libc::c_int as JSAtom,
        );
        if JS_IsException(method) != 0 {
            return -(1 as libc::c_int);
        }
        if JS_IsNull(method) == 0 && JS_IsUndefined(method) == 0 {
            let mut ret: JSValue = 0;
            ret = JS_CallFree(ctx, method, obj, 1 as libc::c_int, &mut val);
            return JS_ToBoolFree(ctx, ret);
        }
        if !(JS_IsFunction(ctx, obj) == 0) {
            return JS_OrdinaryIsInstanceOf(ctx, val, obj);
        }
    }
    JS_ThrowTypeError(
        ctx,
        b"invalid 'instanceof' right operand\0" as *const u8 as *const libc::c_char,
    );
    return -(1 as libc::c_int);
}
static mut js_autoinit_func_table: [Option::<JSAutoInitFunc>; 3] = unsafe {
    [
        Some(
            js_instantiate_prototype
                as unsafe extern "C" fn(
                    *mut JSContext,
                    *mut JSObject,
                    JSAtom,
                    *mut libc::c_void,
                ) -> JSValue,
        ),
        Some(
            js_module_ns_autoinit
                as unsafe extern "C" fn(
                    *mut JSContext,
                    *mut JSObject,
                    JSAtom,
                    *mut libc::c_void,
                ) -> JSValue,
        ),
        Some(
            JS_InstantiateFunctionListItem2
                as unsafe extern "C" fn(
                    *mut JSContext,
                    *mut JSObject,
                    JSAtom,
                    *mut libc::c_void,
                ) -> JSValue,
        ),
    ]
};
unsafe extern "C" fn JS_AutoInitProperty(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut prop: JSAtom,
    mut pr: *mut JSProperty,
    mut prs: *mut JSShapeProperty,
) -> libc::c_int {
    let mut val: JSValue = 0;
    let mut realm: *mut JSContext = 0 as *mut JSContext;
    let mut func: Option::<JSAutoInitFunc> = None;
    if js_shape_prepare_update(ctx, p, &mut prs) != 0 {
        return -(1 as libc::c_int);
    }
    realm = js_autoinit_get_realm(pr);
    func = js_autoinit_func_table[js_autoinit_get_id(pr) as usize];
    val = func.expect("non-null function pointer")(realm, p, prop, (*pr).u.init.opaque);
    js_autoinit_free((*ctx).rt, pr);
    (*prs)
        .set_flags(
            (*prs).flags() & !((3 as libc::c_int) << 4 as libc::c_int) as uint32_t,
        );
    (*pr)
        .u
        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if JS_IsException(val) != 0 {
        return -(1 as libc::c_int);
    }
    (*pr).u.value = val;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetPropertyInternal(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
    mut this_obj: JSValue,
    mut throw_ref_error: BOOL,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut tag: uint32_t = 0;
    tag = (obj >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if (tag != JS_TAG_OBJECT as libc::c_int as libc::c_uint) as libc::c_int
        as libc::c_long != 0
    {
        match tag {
            2 => {
                return __JS_ThrowTypeErrorAtom(
                    ctx,
                    prop,
                    b"cannot read property '%s' of null\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
            }
            3 => {
                return __JS_ThrowTypeErrorAtom(
                    ctx,
                    prop,
                    b"cannot read property '%s' of undefined\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
            }
            6 => {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            4294967289 => {
                let mut p1: *mut JSString = obj as intptr_t as *mut libc::c_void
                    as *mut JSString;
                if __JS_AtomIsTaggedInt(prop) != 0 {
                    let mut idx: uint32_t = 0;
                    let mut ch: uint32_t = 0;
                    idx = __JS_AtomToUInt32(prop);
                    if idx < (*p1).len() {
                        if (*p1).is_wide_char() != 0 {
                            ch = (*p1).u.str16[idx as usize] as uint32_t;
                        } else {
                            ch = (*p1).u.str8[idx as usize] as uint32_t;
                        }
                        return js_new_string_char(ctx, ch as uint16_t);
                    }
                } else if prop == JS_ATOM_length as libc::c_int as libc::c_uint {
                    return JS_NewInt32(ctx, (*p1).len() as int32_t)
                }
            }
            _ => {}
        }
        p = JS_GetPrototypePrimitive(ctx, obj) as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if p.is_null() {
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    } else {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    }
    loop {
        prs = find_own_property(&mut pr, p, prop);
        if !prs.is_null() {
            if ((*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                != 0) as libc::c_int as libc::c_long != 0
            {
                if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                    == (1 as libc::c_int) << 4 as libc::c_int
                {
                    if ((*pr).u.getset.getter).is_null() as libc::c_int as libc::c_long
                        != 0
                    {
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
                    } else {
                        let mut func: JSValue = (JS_TAG_OBJECT as libc::c_int
                            as uint64_t) << 32 as libc::c_int
                            | (*pr).u.getset.getter as uintptr_t as libc::c_ulonglong;
                        func = JS_DupValue(ctx, func);
                        return JS_CallFree(
                            ctx,
                            func,
                            this_obj,
                            0 as libc::c_int,
                            0 as *mut JSValue,
                        );
                    }
                } else if (*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (2 as libc::c_int) << 4 as libc::c_int
                {
                    let mut val: JSValue = *(*(*pr).u.var_ref).pvalue;
                    if (JS_IsUninitialized(val) != 0) as libc::c_int as libc::c_long != 0
                    {
                        return JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
                    }
                    return JS_DupValue(ctx, val);
                } else if (*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (3 as libc::c_int) << 4 as libc::c_int
                {
                    if JS_AutoInitProperty(ctx, p, prop, pr, prs) != 0 {
                        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                    continue;
                }
            } else {
                return JS_DupValue(ctx, (*pr).u.value)
            }
        }
        if (((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0) as libc::c_int
            as libc::c_long != 0
        {
            if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                if __JS_AtomIsTaggedInt(prop) != 0 {
                    let mut idx_0: uint32_t = __JS_AtomToUInt32(prop);
                    if idx_0 < (*p).u.array.count {
                        return JS_GetPropertyUint32(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                            idx_0,
                        )
                    } else {
                        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                                <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                        {
                            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        }
                    }
                } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                    >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                    && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                        <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                {
                    let mut ret: libc::c_int = 0;
                    ret = JS_AtomIsNumericIndex(ctx, prop);
                    if ret != 0 as libc::c_int {
                        if ret < 0 as libc::c_int {
                            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        }
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                }
            } else {
                let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                    .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                    .exotic;
                if !em.is_null() {
                    if ((*em).get_property).is_some() {
                        let mut obj1: JSValue = 0;
                        let mut retval: JSValue = 0;
                        obj1 = JS_DupValue(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                        );
                        retval = ((*em).get_property)
                            .expect(
                                "non-null function pointer",
                            )(ctx, obj1, prop, this_obj);
                        JS_FreeValue(ctx, obj1);
                        return retval;
                    }
                    if ((*em).get_own_property).is_some() {
                        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
                            flags: 0,
                            value: 0,
                            getter: 0,
                            setter: 0,
                        };
                        let mut ret_0: libc::c_int = 0;
                        let mut obj1_0: JSValue = 0;
                        obj1_0 = JS_DupValue(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                        );
                        ret_0 = ((*em).get_own_property)
                            .expect(
                                "non-null function pointer",
                            )(ctx, &mut desc, obj1_0, prop);
                        JS_FreeValue(ctx, obj1_0);
                        if ret_0 < 0 as libc::c_int {
                            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        }
                        if ret_0 != 0 {
                            if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                                JS_FreeValue(ctx, desc.setter);
                                return JS_CallFree(
                                    ctx,
                                    desc.getter,
                                    this_obj,
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                );
                            } else {
                                return desc.value
                            }
                        }
                    }
                }
            }
        }
        p = (*(*p).shape).proto;
        if p.is_null() {
            break;
        }
    }
    if (throw_ref_error != 0) as libc::c_int as libc::c_long != 0 {
        return JS_ThrowReferenceErrorNotDefined(ctx, prop)
    } else {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    };
}
unsafe extern "C" fn JS_ThrowTypeErrorPrivateNotFound(
    mut ctx: *mut JSContext,
    mut atom: JSAtom,
) -> JSValue {
    return __JS_ThrowTypeErrorAtom(
        ctx,
        atom,
        b"private class field '%s' does not exist\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn JS_DefinePrivateField(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut name: JSValue,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prop: JSAtom = 0;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotAnObject(ctx);
    } else if ((name >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_SYMBOL as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotASymbol(ctx);
    } else {
        prop = js_symbol_to_atom(ctx, name);
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        prs = find_own_property(&mut pr, p, prop);
        if !prs.is_null() {
            __JS_ThrowTypeErrorAtom(
                ctx,
                prop,
                b"private class field '%s' already exists\0" as *const u8
                    as *const libc::c_char,
                b"\0" as *const u8 as *const libc::c_char,
            );
        } else {
            pr = add_property(
                ctx,
                p,
                prop,
                (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int,
            );
            if !(pr.is_null() as libc::c_int as libc::c_long != 0) {
                (*pr).u.value = val;
                return 0 as libc::c_int;
            }
        }
    }
    JS_FreeValue(ctx, val);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_GetPrivateField(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut name: JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prop: JSAtom = 0;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if ((name >> 32 as libc::c_int) as libc::c_int != JS_TAG_SYMBOL as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        return JS_ThrowTypeErrorNotASymbol(ctx);
    }
    prop = js_symbol_to_atom(ctx, name);
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property(&mut pr, p, prop);
    if prs.is_null() {
        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_DupValue(ctx, (*pr).u.value);
}
unsafe extern "C" fn JS_SetPrivateField(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut name: JSValue,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prop: JSAtom = 0;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotAnObject(ctx);
    } else if ((name >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_SYMBOL as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotASymbol(ctx);
    } else {
        prop = js_symbol_to_atom(ctx, name);
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        prs = find_own_property(&mut pr, p, prop);
        if prs.is_null() {
            JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
        } else {
            set_value(ctx, &mut (*pr).u.value, val);
            return 0 as libc::c_int;
        }
    }
    JS_FreeValue(ctx, val);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_AddBrand(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut home_obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut brand: JSValue = 0;
    let mut brand_atom: JSAtom = 0;
    if ((home_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    p = home_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property(&mut pr, p, JS_ATOM_Private_brand as libc::c_int as JSAtom);
    if prs.is_null() {
        brand = JS_NewSymbolFromAtom(
            ctx,
            JS_ATOM_brand as libc::c_int as JSAtom,
            JS_ATOM_TYPE_PRIVATE as libc::c_int,
        );
        if JS_IsException(brand) != 0 {
            return -(1 as libc::c_int);
        }
        pr = add_property(
            ctx,
            p,
            JS_ATOM_Private_brand as libc::c_int as JSAtom,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
        if pr.is_null() {
            JS_FreeValue(ctx, brand);
            return -(1 as libc::c_int);
        }
        (*pr).u.value = JS_DupValue(ctx, brand);
    } else {
        brand = JS_DupValue(ctx, (*pr).u.value);
    }
    brand_atom = js_symbol_to_atom(ctx, brand);
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        JS_ThrowTypeErrorNotAnObject(ctx);
        JS_FreeAtom(ctx, brand_atom);
        return -(1 as libc::c_int);
    }
    p1 = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    pr = add_property(
        ctx,
        p1,
        brand_atom,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int,
    );
    JS_FreeAtom(ctx, brand_atom);
    if pr.is_null() {
        return -(1 as libc::c_int);
    }
    (*pr)
        .u
        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_CheckBrand(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut func: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut home_obj: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut brand: JSValue = 0;
    if !(((func >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0)
    {
        p1 = func as intptr_t as *mut libc::c_void as *mut JSObject;
        if !(js_class_has_bytecode(
            (*p1).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID,
        ) == 0)
        {
            home_obj = (*p1).u.func.home_object;
            if !home_obj.is_null() {
                prs = find_own_property(
                    &mut pr,
                    home_obj,
                    JS_ATOM_Private_brand as libc::c_int as JSAtom,
                );
                if prs.is_null() {
                    JS_ThrowTypeError(
                        ctx,
                        b"expecting <brand> private field\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                brand = (*pr).u.value;
                if !(((brand >> 32 as libc::c_int) as libc::c_int
                    != JS_TAG_SYMBOL as libc::c_int) as libc::c_int as libc::c_long != 0)
                {
                    if !(((obj >> 32 as libc::c_int) as libc::c_int
                        != JS_TAG_OBJECT as libc::c_int) as libc::c_int as libc::c_long
                        != 0)
                    {
                        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
                        prs = find_own_property(
                            &mut pr,
                            p,
                            js_symbol_to_atom(ctx, brand),
                        );
                        if prs.is_null() {
                            JS_ThrowTypeError(
                                ctx,
                                b"invalid brand on object\0" as *const u8
                                    as *const libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        }
                        return 0 as libc::c_int;
                    }
                }
            }
        }
    }
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_string_obj_get_length(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> uint32_t {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSString = 0 as *mut JSString;
    let mut len: uint32_t = 0 as libc::c_int as uint32_t;
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if ((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
        == JS_TAG_STRING as libc::c_int
    {
        p1 = (*p).u.object_data as intptr_t as *mut libc::c_void as *mut JSString;
        len = (*p1).len();
    }
    return len;
}
unsafe extern "C" fn num_keys_cmp(
    mut p1: *const libc::c_void,
    mut p2: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut ctx: *mut JSContext = opaque as *mut JSContext;
    let mut atom1: JSAtom = (*(p1 as *const JSPropertyEnum)).atom;
    let mut atom2: JSAtom = (*(p2 as *const JSPropertyEnum)).atom;
    let mut v1: uint32_t = 0;
    let mut v2: uint32_t = 0;
    let mut atom1_is_integer: BOOL = 0;
    let mut atom2_is_integer: BOOL = 0;
    atom1_is_integer = JS_AtomIsArrayIndex(ctx, &mut v1, atom1);
    atom2_is_integer = JS_AtomIsArrayIndex(ctx, &mut v2, atom2);
    assert((atom1_is_integer != 0 && atom2_is_integer != 0) as libc::c_int);
    if v1 < v2 {
        return -(1 as libc::c_int)
    } else if v1 == v2 {
        return 0 as libc::c_int
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn js_free_prop_enum(
    mut ctx: *mut JSContext,
    mut tab: *mut JSPropertyEnum,
    mut len: uint32_t,
) {
    let mut i: uint32_t = 0;
    if !tab.is_null() {
        i = 0 as libc::c_int as uint32_t;
        while i < len {
            JS_FreeAtom(ctx, (*tab.offset(i as isize)).atom);
            i = i.wrapping_add(1);
        }
        js_free(ctx, tab as *mut libc::c_void);
    }
}
unsafe extern "C" fn JS_GetOwnPropertyNamesInternal(
    mut ctx: *mut JSContext,
    mut ptab: *mut *mut JSPropertyEnum,
    mut plen: *mut uint32_t,
    mut p: *mut JSObject,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut tab_atom: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut tab_exotic: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut atom: JSAtom = 0;
    let mut num_keys_count: uint32_t = 0;
    let mut str_keys_count: uint32_t = 0;
    let mut sym_keys_count: uint32_t = 0;
    let mut atom_count: uint32_t = 0;
    let mut num_index: uint32_t = 0;
    let mut str_index: uint32_t = 0;
    let mut sym_index: uint32_t = 0;
    let mut exotic_count: uint32_t = 0;
    let mut exotic_keys_count: uint32_t = 0;
    let mut is_enumerable: BOOL = 0;
    let mut num_sorted: BOOL = 0;
    let mut num_key: uint32_t = 0;
    let mut kind: JSAtomKindEnum = JS_ATOM_KIND_STRING;
    *ptab = 0 as *mut JSPropertyEnum;
    *plen = 0 as libc::c_int as uint32_t;
    num_keys_count = 0 as libc::c_int as uint32_t;
    str_keys_count = 0 as libc::c_int as uint32_t;
    sym_keys_count = 0 as libc::c_int as uint32_t;
    exotic_keys_count = 0 as libc::c_int as uint32_t;
    exotic_count = 0 as libc::c_int as uint32_t;
    tab_exotic = 0 as *mut JSPropertyEnum;
    sh = (*p).shape;
    i = 0 as libc::c_int;
    prs = get_shape_prop(sh);
    while i < (*sh).prop_count {
        atom = (*prs).atom;
        if atom != 0 as libc::c_int as libc::c_uint {
            is_enumerable = ((*prs).flags() as libc::c_int
                & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                as libc::c_int;
            kind = JS_AtomGetKind(ctx, atom);
            if (flags & (1 as libc::c_int) << 4 as libc::c_int == 0
                || is_enumerable != 0)
                && flags >> kind as libc::c_uint & 1 as libc::c_int != 0 as libc::c_int
            {
                if ((*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (2 as libc::c_int) << 4 as libc::c_int) as libc::c_int
                    as libc::c_long != 0
                    && flags
                        & ((1 as libc::c_int) << 5 as libc::c_int
                            | (1 as libc::c_int) << 4 as libc::c_int) != 0
                {
                    let mut var_ref: *mut JSVarRef = (*((*p).prop).offset(i as isize))
                        .u
                        .var_ref;
                    if (JS_IsUninitialized(*(*var_ref).pvalue) != 0) as libc::c_int
                        as libc::c_long != 0
                    {
                        JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
                        return -(1 as libc::c_int);
                    }
                }
                if JS_AtomIsArrayIndex(ctx, &mut num_key, atom) != 0 {
                    num_keys_count = num_keys_count.wrapping_add(1);
                } else if kind as libc::c_uint
                    == JS_ATOM_KIND_STRING as libc::c_int as libc::c_uint
                {
                    str_keys_count = str_keys_count.wrapping_add(1);
                } else {
                    sym_keys_count = sym_keys_count.wrapping_add(1);
                }
            }
        }
        i += 1;
        prs = prs.offset(1);
    }
    if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
        if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
            if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                num_keys_count = (num_keys_count as libc::c_uint)
                    .wrapping_add((*p).u.array.count) as uint32_t as uint32_t;
            }
        } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_STRING as libc::c_int
        {
            if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                num_keys_count = (num_keys_count as libc::c_uint)
                    .wrapping_add(
                        js_string_obj_get_length(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                        ),
                    ) as uint32_t as uint32_t;
            }
        } else {
            let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .exotic;
            if !em.is_null() && ((*em).get_own_property_names).is_some() {
                if ((*em).get_own_property_names)
                    .expect(
                        "non-null function pointer",
                    )(
                    ctx,
                    &mut tab_exotic,
                    &mut exotic_count,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
                i = 0 as libc::c_int;
                while (i as libc::c_uint) < exotic_count {
                    atom = (*tab_exotic.offset(i as isize)).atom;
                    kind = JS_AtomGetKind(ctx, atom);
                    if flags >> kind as libc::c_uint & 1 as libc::c_int
                        != 0 as libc::c_int
                    {
                        is_enumerable = FALSE as libc::c_int;
                        if flags
                            & ((1 as libc::c_int) << 5 as libc::c_int
                                | (1 as libc::c_int) << 4 as libc::c_int) != 0
                        {
                            let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
                                flags: 0,
                                value: 0,
                                getter: 0,
                                setter: 0,
                            };
                            let mut res: libc::c_int = 0;
                            res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, atom);
                            if res < 0 as libc::c_int {
                                js_free_prop_enum(ctx, tab_exotic, exotic_count);
                                return -(1 as libc::c_int);
                            }
                            if res != 0 {
                                is_enumerable = (desc.flags
                                    & (1 as libc::c_int) << 2 as libc::c_int
                                    != 0 as libc::c_int) as libc::c_int;
                                js_free_desc(ctx, &mut desc);
                            }
                            (*tab_exotic.offset(i as isize))
                                .is_enumerable = is_enumerable;
                        }
                        if flags & (1 as libc::c_int) << 4 as libc::c_int == 0
                            || is_enumerable != 0
                        {
                            exotic_keys_count = exotic_keys_count.wrapping_add(1);
                        }
                    }
                    i += 1;
                }
            }
        }
    }
    atom_count = num_keys_count
        .wrapping_add(str_keys_count)
        .wrapping_add(sym_keys_count)
        .wrapping_add(exotic_keys_count);
    tab_atom = js_malloc(
        ctx,
        (::core::mem::size_of::<JSPropertyEnum>() as libc::c_ulong)
            .wrapping_mul(
                max_int(atom_count as libc::c_int, 1 as libc::c_int) as libc::c_ulong,
            ),
    ) as *mut JSPropertyEnum;
    if tab_atom.is_null() {
        js_free_prop_enum(ctx, tab_exotic, exotic_count);
        return -(1 as libc::c_int);
    }
    num_index = 0 as libc::c_int as uint32_t;
    str_index = num_keys_count;
    sym_index = str_index.wrapping_add(str_keys_count);
    num_sorted = TRUE as libc::c_int;
    sh = (*p).shape;
    i = 0 as libc::c_int;
    prs = get_shape_prop(sh);
    while i < (*sh).prop_count {
        atom = (*prs).atom;
        if atom != 0 as libc::c_int as libc::c_uint {
            is_enumerable = ((*prs).flags() as libc::c_int
                & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                as libc::c_int;
            kind = JS_AtomGetKind(ctx, atom);
            if (flags & (1 as libc::c_int) << 4 as libc::c_int == 0
                || is_enumerable != 0)
                && flags >> kind as libc::c_uint & 1 as libc::c_int != 0 as libc::c_int
            {
                if JS_AtomIsArrayIndex(ctx, &mut num_key, atom) != 0 {
                    let fresh217 = num_index;
                    num_index = num_index.wrapping_add(1);
                    j = fresh217 as libc::c_int;
                    num_sorted = FALSE as libc::c_int;
                } else if kind as libc::c_uint
                    == JS_ATOM_KIND_STRING as libc::c_int as libc::c_uint
                {
                    let fresh218 = str_index;
                    str_index = str_index.wrapping_add(1);
                    j = fresh218 as libc::c_int;
                } else {
                    let fresh219 = sym_index;
                    sym_index = sym_index.wrapping_add(1);
                    j = fresh219 as libc::c_int;
                }
                (*tab_atom.offset(j as isize)).atom = JS_DupAtom(ctx, atom);
                (*tab_atom.offset(j as isize)).is_enumerable = is_enumerable;
            }
        }
        i += 1;
        prs = prs.offset(1);
    }
    if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
        let mut len: libc::c_int = 0;
        let mut current_block_131: u64;
        if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
            if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                len = (*p).u.array.count as libc::c_int;
                current_block_131 = 4637910883267864556;
            } else {
                current_block_131 = 10938659635288570931;
            }
        } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_STRING as libc::c_int
        {
            if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                len = js_string_obj_get_length(
                    ctx,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                ) as libc::c_int;
                current_block_131 = 4637910883267864556;
            } else {
                current_block_131 = 10938659635288570931;
            }
        } else {
            i = 0 as libc::c_int;
            while (i as libc::c_uint) < exotic_count {
                atom = (*tab_exotic.offset(i as isize)).atom;
                is_enumerable = (*tab_exotic.offset(i as isize)).is_enumerable;
                kind = JS_AtomGetKind(ctx, atom);
                if (flags & (1 as libc::c_int) << 4 as libc::c_int == 0
                    || is_enumerable != 0)
                    && flags >> kind as libc::c_uint & 1 as libc::c_int
                        != 0 as libc::c_int
                {
                    (*tab_atom.offset(sym_index as isize)).atom = atom;
                    (*tab_atom.offset(sym_index as isize)).is_enumerable = is_enumerable;
                    sym_index = sym_index.wrapping_add(1);
                } else {
                    JS_FreeAtom(ctx, atom);
                }
                i += 1;
            }
            js_free(ctx, tab_exotic as *mut libc::c_void);
            current_block_131 = 10938659635288570931;
        }
        match current_block_131 {
            4637910883267864556 => {
                i = 0 as libc::c_int;
                while i < len {
                    (*tab_atom.offset(num_index as isize))
                        .atom = __JS_AtomFromUInt32(i as uint32_t);
                    if (*tab_atom.offset(num_index as isize)).atom
                        == 0 as libc::c_int as libc::c_uint
                    {
                        js_free_prop_enum(ctx, tab_atom, num_index);
                        return -(1 as libc::c_int);
                    }
                    (*tab_atom.offset(num_index as isize))
                        .is_enumerable = TRUE as libc::c_int;
                    num_index = num_index.wrapping_add(1);
                    i += 1;
                }
            }
            _ => {}
        }
    }
    assert((num_index == num_keys_count) as libc::c_int);
    assert((str_index == num_keys_count.wrapping_add(str_keys_count)) as libc::c_int);
    assert((sym_index == atom_count) as libc::c_int);
    if num_keys_count != 0 as libc::c_int as libc::c_uint && num_sorted == 0 {
        rqsort(
            tab_atom as *mut libc::c_void,
            num_keys_count as size_t,
            ::core::mem::size_of::<JSPropertyEnum>() as libc::c_ulong,
            Some(
                num_keys_cmp
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            ctx as *mut libc::c_void,
        );
    }
    *ptab = tab_atom;
    *plen = atom_count;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetOwnPropertyNames(
    mut ctx: *mut JSContext,
    mut ptab: *mut *mut JSPropertyEnum,
    mut plen: *mut uint32_t,
    mut obj: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    return JS_GetOwnPropertyNamesInternal(
        ctx,
        ptab,
        plen,
        obj as intptr_t as *mut libc::c_void as *mut JSObject,
        flags,
    );
}
unsafe extern "C" fn JS_GetOwnPropertyInternal(
    mut ctx: *mut JSContext,
    mut desc: *mut JSPropertyDescriptor,
    mut p: *mut JSObject,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    loop {
        prs = find_own_property(&mut pr, p, prop);
        if !prs.is_null() {
            if !desc.is_null() {
                (*desc)
                    .flags = (*prs).flags() as libc::c_int
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int);
                (*desc)
                    .getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                (*desc)
                    .setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                (*desc)
                    .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                if ((*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int != 0) as libc::c_int
                    as libc::c_long != 0
                {
                    if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (1 as libc::c_int) << 4 as libc::c_int
                    {
                        (*desc).flags |= (1 as libc::c_int) << 4 as libc::c_int;
                        if !((*pr).u.getset.getter).is_null() {
                            (*desc)
                                .getter = JS_DupValue(
                                ctx,
                                (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | (*pr).u.getset.getter as uintptr_t as libc::c_ulonglong,
                            );
                        }
                        if !((*pr).u.getset.setter).is_null() {
                            (*desc)
                                .setter = JS_DupValue(
                                ctx,
                                (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | (*pr).u.getset.setter as uintptr_t as libc::c_ulonglong,
                            );
                        }
                        break;
                    } else if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (2 as libc::c_int) << 4 as libc::c_int
                    {
                        let mut val: JSValue = *(*(*pr).u.var_ref).pvalue;
                        if (JS_IsUninitialized(val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
                            return -(1 as libc::c_int);
                        }
                        (*desc).value = JS_DupValue(ctx, val);
                        break;
                    } else {
                        if !((*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int
                            == (3 as libc::c_int) << 4 as libc::c_int)
                        {
                            break;
                        }
                        if JS_AutoInitProperty(ctx, p, prop, pr, prs) != 0 {
                            return -(1 as libc::c_int);
                        }
                    }
                } else {
                    (*desc).value = JS_DupValue(ctx, (*pr).u.value);
                    break;
                }
            } else {
                if ((*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (2 as libc::c_int) << 4 as libc::c_int) as libc::c_int
                    as libc::c_long != 0
                {
                    if (JS_IsUninitialized(*(*(*pr).u.var_ref).pvalue) != 0)
                        as libc::c_int as libc::c_long != 0
                    {
                        JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
                        return -(1 as libc::c_int);
                    }
                } else {
                    (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (3 as libc::c_int) << 4 as libc::c_int;
                }
                break;
            }
        } else {
            if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
                if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                    if __JS_AtomIsTaggedInt(prop) != 0 {
                        let mut idx: uint32_t = 0;
                        idx = __JS_AtomToUInt32(prop);
                        if idx < (*p).u.array.count {
                            if !desc.is_null() {
                                (*desc)
                                    .flags = (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int
                                    | (1 as libc::c_int) << 0 as libc::c_int;
                                (*desc)
                                    .getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                (*desc)
                                    .setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                (*desc)
                                    .value = JS_GetPropertyUint32(
                                    ctx,
                                    (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                        << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                                    idx,
                                );
                            }
                            return TRUE as libc::c_int;
                        }
                    }
                } else {
                    let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt)
                        .class_array)
                        .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                        .exotic;
                    if !em.is_null() && ((*em).get_own_property).is_some() {
                        return ((*em).get_own_property)
                            .expect(
                                "non-null function pointer",
                            )(
                            ctx,
                            desc,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int | p as uintptr_t as libc::c_ulonglong,
                            prop,
                        );
                    }
                }
            }
            return FALSE as libc::c_int;
        }
    }
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetOwnProperty(
    mut ctx: *mut JSContext,
    mut desc: *mut JSPropertyDescriptor,
    mut obj: JSValue,
    mut prop: JSAtom,
) -> libc::c_int {
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    return JS_GetOwnPropertyInternal(
        ctx,
        desc,
        obj as intptr_t as *mut libc::c_void as *mut JSObject,
        prop,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsExtensible(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        return js_proxy_isExtensible(ctx, obj)
    } else {
        return ((*p).c2rust_unnamed.c2rust_unnamed).extensible() as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_PreventExtensions(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        return js_proxy_preventExtensions(ctx, obj);
    }
    let ref mut fresh220 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh220).set_extensible(FALSE as libc::c_int as uint8_t);
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_HasProperty(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ret: libc::c_int = 0;
    let mut obj1: JSValue = 0;
    if ((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    loop {
        if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
            let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .exotic;
            if !em.is_null() && ((*em).has_property).is_some() {
                obj1 = JS_DupValue(
                    ctx,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                );
                ret = ((*em).has_property)
                    .expect("non-null function pointer")(ctx, obj1, prop);
                JS_FreeValue(ctx, obj1);
                return ret;
            }
        }
        JS_DupValue(
            ctx,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong,
        );
        ret = JS_GetOwnPropertyInternal(ctx, 0 as *mut JSPropertyDescriptor, p, prop);
        JS_FreeValue(
            ctx,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong,
        );
        if ret != 0 as libc::c_int {
            return ret;
        }
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
        {
            ret = JS_AtomIsNumericIndex(ctx, prop);
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                return FALSE as libc::c_int;
            }
        }
        p = (*(*p).shape).proto;
        if p.is_null() {
            break;
        }
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn js_symbol_to_atom(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSAtom {
    let mut p: *mut JSAtomStruct = val as intptr_t as *mut libc::c_void
        as *mut JSAtomStruct;
    return js_get_atom_index((*ctx).rt, p);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ValueToAtom(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSAtom {
    let mut atom: JSAtom = 0;
    let mut tag: uint32_t = 0;
    tag = (val >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag == JS_TAG_INT as libc::c_int as libc::c_uint
        && val as libc::c_int as uint32_t
            <= ((1 as libc::c_uint) << 31 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint)
    {
        atom = __JS_AtomFromUInt32(val as libc::c_int as uint32_t);
    } else if tag == JS_TAG_SYMBOL as libc::c_int as libc::c_uint {
        let mut p: *mut JSAtomStruct = val as intptr_t as *mut libc::c_void
            as *mut JSAtomStruct;
        atom = JS_DupAtom(ctx, js_get_atom_index((*ctx).rt, p));
    } else {
        let mut str: JSValue = 0;
        str = JS_ToPropertyKey(ctx, val);
        if JS_IsException(str) != 0 {
            return 0 as libc::c_int as JSAtom;
        }
        if (str >> 32 as libc::c_int) as libc::c_int == JS_TAG_SYMBOL as libc::c_int {
            atom = js_symbol_to_atom(ctx, str);
        } else {
            atom = JS_NewAtomStr(
                ctx,
                str as intptr_t as *mut libc::c_void as *mut JSString,
            );
        }
    }
    return atom;
}
unsafe extern "C" fn JS_GetPropertyValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut atom: JSAtom = 0;
    let mut ret: JSValue = 0;
    if ((this_obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int
        && (prop >> 32 as libc::c_int) as libc::c_int == JS_TAG_INT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        let mut p: *mut JSObject = 0 as *mut JSObject;
        let mut idx: uint32_t = 0;
        let mut len: uint32_t = 0;
        p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        idx = prop as libc::c_int as uint32_t;
        len = (*p).u.array.count;
        if !((idx >= len) as libc::c_int as libc::c_long != 0) {
            match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
                2 | 8 => {
                    current_block = 7348046196572511781;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                22 => {
                    current_block = 15881180934339525083;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                21 | 23 => {
                    current_block = 2092246990531660344;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                24 => {
                    current_block = 9952432177831035315;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                25 => {
                    current_block = 13522906371353459941;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                26 => {
                    current_block = 3082884779726829420;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                27 => {
                    current_block = 10224096550418177977;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                28 => {
                    current_block = 10132235548263011923;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                29 => {
                    current_block = 14623775095274227088;
                    match current_block {
                        14623775095274227088 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.double_ptr).offset(idx as isize),
                            );
                        }
                        15881180934339525083 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        2092246990531660344 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint8_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        9952432177831035315 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        13522906371353459941 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.uint16_ptr).offset(idx as isize) as int32_t,
                            );
                        }
                        3082884779726829420 => {
                            return JS_NewInt32(
                                ctx,
                                *((*p).u.array.u.int32_ptr).offset(idx as isize),
                            );
                        }
                        10224096550418177977 => {
                            return JS_NewUint32(
                                ctx,
                                *((*p).u.array.u.uint32_ptr).offset(idx as isize),
                            );
                        }
                        10132235548263011923 => {
                            return __JS_NewFloat64(
                                ctx,
                                *((*p).u.array.u.float_ptr).offset(idx as isize)
                                    as libc::c_double,
                            );
                        }
                        _ => {
                            return JS_DupValue(
                                ctx,
                                *((*p).u.array.u.values).offset(idx as isize),
                            );
                        }
                    }
                }
                _ => {}
            }
        }
    }
    atom = JS_ValueToAtom(ctx, prop);
    JS_FreeValue(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_GetProperty(ctx, this_obj, atom);
    JS_FreeAtom(ctx, atom);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetPropertyUint32(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: uint32_t,
) -> JSValue {
    return JS_GetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx));
}
unsafe extern "C" fn JS_TryGetPropertyInt64(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut idx: int64_t,
    mut pval: *mut JSValue,
) -> libc::c_int {
    let mut val: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut prop: JSAtom = 0;
    let mut present: libc::c_int = 0;
    if (idx as uint64_t
        <= ((1 as libc::c_uint) << 31 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulonglong)
        as libc::c_int as libc::c_long != 0
    {
        present = JS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx as uint32_t));
        if present > 0 as libc::c_int {
            val = JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx as int32_t));
            if (JS_IsException(val) != 0) as libc::c_int as libc::c_long != 0 {
                present = -(1 as libc::c_int);
            }
        }
    } else {
        prop = JS_NewAtomInt64(ctx, idx);
        present = -(1 as libc::c_int);
        if (prop != 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0
        {
            present = JS_HasProperty(ctx, obj, prop);
            if present > 0 as libc::c_int {
                val = JS_GetProperty(ctx, obj, prop);
                if (JS_IsException(val) != 0) as libc::c_int as libc::c_long != 0 {
                    present = -(1 as libc::c_int);
                }
            }
            JS_FreeAtom(ctx, prop);
        }
    }
    *pval = val;
    return present;
}
unsafe extern "C" fn JS_GetPropertyInt64(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut idx: int64_t,
) -> JSValue {
    let mut prop: JSAtom = 0;
    let mut val: JSValue = 0;
    if idx as uint64_t <= 0x7fffffff as libc::c_int as libc::c_ulonglong {
        return JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx as int32_t));
    }
    prop = JS_NewAtomInt64(ctx, idx);
    if prop == 0 as libc::c_int as libc::c_uint {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    val = JS_GetProperty(ctx, obj, prop);
    JS_FreeAtom(ctx, prop);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetPropertyStr(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: *const libc::c_char,
) -> JSValue {
    let mut atom: JSAtom = 0;
    let mut ret: JSValue = 0;
    atom = JS_NewAtom(ctx, prop);
    ret = JS_GetProperty(ctx, this_obj, atom);
    JS_FreeAtom(ctx, atom);
    return ret;
}
unsafe extern "C" fn add_property(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut prop: JSAtom,
    mut prop_flags: libc::c_int,
) -> *mut JSProperty {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut new_sh: *mut JSShape = 0 as *mut JSShape;
    sh = (*p).shape;
    if (*sh).is_hashed != 0 {
        new_sh = find_hashed_shape_prop((*ctx).rt, sh, prop, prop_flags);
        if !new_sh.is_null() {
            if (*new_sh).prop_size != (*sh).prop_size {
                let mut new_prop: *mut JSProperty = 0 as *mut JSProperty;
                new_prop = js_realloc(
                    ctx,
                    (*p).prop as *mut libc::c_void,
                    (::core::mem::size_of::<JSProperty>() as libc::c_ulong)
                        .wrapping_mul((*new_sh).prop_size as libc::c_ulong),
                ) as *mut JSProperty;
                if new_prop.is_null() {
                    return 0 as *mut JSProperty;
                }
                let ref mut fresh221 = (*p).prop;
                *fresh221 = new_prop;
            }
            let ref mut fresh222 = (*p).shape;
            *fresh222 = js_dup_shape(new_sh);
            js_free_shape((*ctx).rt, sh);
            return &mut *((*p).prop)
                .offset(((*new_sh).prop_count - 1 as libc::c_int) as isize)
                as *mut JSProperty;
        } else {
            if (*sh).header.ref_count != 1 as libc::c_int {
                new_sh = js_clone_shape(ctx, sh);
                if new_sh.is_null() {
                    return 0 as *mut JSProperty;
                }
                (*new_sh).is_hashed = TRUE as libc::c_int as uint8_t;
                js_shape_hash_link((*ctx).rt, new_sh);
                js_free_shape((*ctx).rt, (*p).shape);
                let ref mut fresh223 = (*p).shape;
                *fresh223 = new_sh;
            }
        }
    }
    assert(((*(*p).shape).header.ref_count == 1 as libc::c_int) as libc::c_int);
    if add_shape_property(ctx, &mut (*p).shape, p, prop, prop_flags) != 0 {
        return 0 as *mut JSProperty;
    }
    return &mut *((*p).prop)
        .offset(((*(*p).shape).prop_count - 1 as libc::c_int) as isize)
        as *mut JSProperty;
}
#[inline(never)]
unsafe extern "C" fn convert_fast_array_to_array(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
) -> libc::c_int {
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut tab: *mut JSValue = 0 as *mut JSValue;
    let mut i: uint32_t = 0;
    let mut len: uint32_t = 0;
    let mut new_count: uint32_t = 0;
    if js_shape_prepare_update(ctx, p, 0 as *mut *mut JSShapeProperty) != 0 {
        return -(1 as libc::c_int);
    }
    len = (*p).u.array.count;
    sh = (*p).shape;
    new_count = ((*sh).prop_count as libc::c_uint).wrapping_add(len);
    if new_count > (*sh).prop_size as libc::c_uint {
        if resize_properties(ctx, &mut (*p).shape, p, new_count) != 0 {
            return -(1 as libc::c_int);
        }
    }
    tab = (*p).u.array.u.values;
    i = 0 as libc::c_int as uint32_t;
    while i < len {
        pr = add_property(
            ctx,
            p,
            __JS_AtomFromUInt32(i),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
        let fresh224 = tab;
        tab = tab.offset(1);
        (*pr).u.value = *fresh224;
        i = i.wrapping_add(1);
    }
    js_free(ctx, (*p).u.array.u.values as *mut libc::c_void);
    (*p).u.array.count = 0 as libc::c_int as uint32_t;
    let ref mut fresh225 = (*p).u.array.u.values;
    *fresh225 = 0 as *mut JSValue;
    (*p).u.array.u1.size = 0 as libc::c_int as uint32_t;
    let ref mut fresh226 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh226).set_fast_array(0 as libc::c_int as uint8_t);
    return 0 as libc::c_int;
}
unsafe extern "C" fn delete_property(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut lpr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut prop: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr1: *mut JSProperty = 0 as *mut JSProperty;
    let mut lpr_idx: uint32_t = 0;
    let mut h: intptr_t = 0;
    let mut h1: intptr_t = 0;
    loop {
        sh = (*p).shape;
        h1 = (atom & (*sh).prop_hash_mask) as intptr_t;
        h = *(prop_hash_end(sh)).offset((-h1 - 1 as libc::c_int) as isize) as intptr_t;
        prop = get_shape_prop(sh);
        lpr = 0 as *mut JSShapeProperty;
        lpr_idx = 0 as libc::c_int as uint32_t;
        while h != 0 as libc::c_int {
            pr = &mut *prop.offset((h - 1 as libc::c_int) as isize)
                as *mut JSShapeProperty;
            if ((*pr).atom == atom) as libc::c_int as libc::c_long != 0 {
                if (*pr).flags() as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                    == 0
                {
                    return FALSE as libc::c_int;
                }
                if !lpr.is_null() {
                    lpr_idx = lpr.offset_from(get_shape_prop(sh)) as libc::c_long
                        as uint32_t;
                }
                if js_shape_prepare_update(ctx, p, &mut pr) != 0 {
                    return -(1 as libc::c_int);
                }
                sh = (*p).shape;
                if !lpr.is_null() {
                    lpr = (get_shape_prop(sh)).offset(lpr_idx as isize);
                    (*lpr).set_hash_next((*pr).hash_next());
                } else {
                    *(prop_hash_end(sh))
                        .offset((-h1 - 1 as libc::c_int) as isize) = (*pr).hash_next();
                }
                let ref mut fresh227 = (*sh).deleted_prop_count;
                *fresh227 += 1;
                pr1 = &mut *((*p).prop).offset((h - 1 as libc::c_int) as isize)
                    as *mut JSProperty;
                free_property((*ctx).rt, pr1, (*pr).flags() as libc::c_int);
                JS_FreeAtom(ctx, (*pr).atom);
                (*pr).set_flags(0 as libc::c_int as uint32_t);
                (*pr).atom = 0 as libc::c_int as JSAtom;
                (*pr1)
                    .u
                    .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                if (*sh).deleted_prop_count >= 8 as libc::c_int
                    && (*sh).deleted_prop_count as libc::c_uint
                        >= ((*sh).prop_count as libc::c_uint)
                            .wrapping_div(2 as libc::c_int as libc::c_uint)
                {
                    compact_properties(ctx, p);
                }
                return TRUE as libc::c_int;
            }
            lpr = pr;
            h = (*pr).hash_next() as intptr_t;
        }
        if !(((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0) {
            break;
        }
        if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
            let mut idx: uint32_t = 0;
            if !(JS_AtomIsArrayIndex(ctx, &mut idx, atom) != 0
                && idx < (*p).u.array.count)
            {
                break;
            }
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                == JS_CLASS_ARRAY as libc::c_int
                || (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                    == JS_CLASS_ARGUMENTS as libc::c_int
            {
                if idx
                    == ((*p).u.array.count)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                {
                    JS_FreeValue(ctx, *((*p).u.array.u.values).offset(idx as isize));
                    (*p).u.array.count = idx;
                    return TRUE as libc::c_int;
                }
                if convert_fast_array_to_array(ctx, p) != 0 {
                    return -(1 as libc::c_int);
                }
            } else {
                return FALSE as libc::c_int
            }
        } else {
            let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .exotic;
            if !em.is_null() && ((*em).delete_property).is_some() {
                return ((*em).delete_property)
                    .expect(
                        "non-null function pointer",
                    )(
                    ctx,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                    atom,
                );
            }
            break;
        }
    }
    return TRUE as libc::c_int;
}
unsafe extern "C" fn call_setter(
    mut ctx: *mut JSContext,
    mut setter: *mut JSObject,
    mut this_obj: JSValue,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut ret: JSValue = 0;
    let mut func: JSValue = 0;
    if !setter.is_null() as libc::c_int as libc::c_long != 0 {
        func = (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
            | setter as uintptr_t as libc::c_ulonglong;
        func = JS_DupValue(ctx, func);
        ret = JS_CallFree(
            ctx,
            func,
            this_obj,
            1 as libc::c_int,
            &mut val as *mut JSValue,
        );
        JS_FreeValue(ctx, val);
        if JS_IsException(ret) != 0 {
            return -(1 as libc::c_int);
        }
        JS_FreeValue(ctx, ret);
        return TRUE as libc::c_int;
    } else {
        JS_FreeValue(ctx, val);
        if flags & (1 as libc::c_int) << 14 as libc::c_int != 0
            || flags & (1 as libc::c_int) << 15 as libc::c_int != 0
                && is_strict_mode(ctx) != 0
        {
            JS_ThrowTypeError(
                ctx,
                b"no setter for property\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        return FALSE as libc::c_int;
    };
}
unsafe extern "C" fn set_array_length(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut len: uint32_t = 0;
    let mut idx: uint32_t = 0;
    let mut cur_len: uint32_t = 0;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    ret = JS_ToArrayLengthFree(ctx, &mut len, val, FALSE as libc::c_int);
    if ret != 0 {
        return -(1 as libc::c_int);
    }
    if ((*((*(*p).shape).prop).as_mut_ptr().offset(0 as libc::c_int as isize)).flags()
        as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int == 0) as libc::c_int
        as libc::c_long != 0
    {
        return JS_ThrowTypeErrorReadOnly(
            ctx,
            flags,
            JS_ATOM_length as libc::c_int as JSAtom,
        );
    }
    if (((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0) as libc::c_int
        as libc::c_long != 0
    {
        let mut old_len: uint32_t = (*p).u.array.count;
        if len < old_len {
            i = len as libc::c_int;
            while (i as libc::c_uint) < old_len {
                JS_FreeValue(ctx, *((*p).u.array.u.values).offset(i as isize));
                i += 1;
            }
            (*p).u.array.count = len;
        }
        (*((*p).prop).offset(0 as libc::c_int as isize))
            .u
            .value = JS_NewUint32(ctx, len);
    } else {
        JS_ToUint32(
            ctx,
            &mut cur_len,
            (*((*p).prop).offset(0 as libc::c_int as isize)).u.value,
        );
        if len < cur_len {
            let mut d: uint32_t = 0;
            let mut sh: *mut JSShape = 0 as *mut JSShape;
            let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
            d = cur_len.wrapping_sub(len);
            sh = (*p).shape;
            if d <= (*sh).prop_count as libc::c_uint {
                let mut atom: JSAtom = 0;
                while cur_len > len {
                    atom = JS_NewAtomUInt32(
                        ctx,
                        cur_len.wrapping_sub(1 as libc::c_int as libc::c_uint),
                    );
                    ret = delete_property(ctx, p, atom);
                    JS_FreeAtom(ctx, atom);
                    if (ret == 0) as libc::c_int as libc::c_long != 0 {
                        break;
                    }
                    cur_len = cur_len.wrapping_sub(1);
                }
            } else {
                cur_len = len;
                i = 0 as libc::c_int;
                pr = get_shape_prop(sh);
                while i < (*sh).prop_count {
                    if (*pr).atom != 0 as libc::c_int as libc::c_uint
                        && JS_AtomIsArrayIndex(ctx, &mut idx, (*pr).atom) != 0
                    {
                        if idx >= cur_len
                            && (*pr).flags() as libc::c_int
                                & (1 as libc::c_int) << 0 as libc::c_int == 0
                        {
                            cur_len = idx.wrapping_add(1 as libc::c_int as libc::c_uint);
                        }
                    }
                    i += 1;
                    pr = pr.offset(1);
                }
                i = 0 as libc::c_int;
                pr = get_shape_prop(sh);
                while i < (*sh).prop_count {
                    if (*pr).atom != 0 as libc::c_int as libc::c_uint
                        && JS_AtomIsArrayIndex(ctx, &mut idx, (*pr).atom) != 0
                    {
                        if idx >= cur_len {
                            delete_property(ctx, p, (*pr).atom);
                            sh = (*p).shape;
                            pr = (get_shape_prop(sh)).offset(i as isize);
                        }
                    }
                    i += 1;
                    pr = pr.offset(1);
                }
            }
        } else {
            cur_len = len;
        }
        set_value(
            ctx,
            &mut (*((*p).prop).offset(0 as libc::c_int as isize)).u.value,
            JS_NewUint32(ctx, cur_len),
        );
        if (cur_len > len) as libc::c_int as libc::c_long != 0 {
            return JS_ThrowTypeErrorOrFalse(
                ctx,
                flags,
                b"not configurable\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return TRUE as libc::c_int;
}
unsafe extern "C" fn expand_fast_array(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut new_len: uint32_t,
) -> libc::c_int {
    let mut new_size: uint32_t = 0;
    let mut slack: size_t = 0;
    let mut new_array_prop: *mut JSValue = 0 as *mut JSValue;
    new_size = max_int(
        new_len as libc::c_int,
        ((*p).u.array.u1.size)
            .wrapping_mul(3 as libc::c_int as libc::c_uint)
            .wrapping_div(2 as libc::c_int as libc::c_uint) as libc::c_int,
    ) as uint32_t;
    new_array_prop = js_realloc2(
        ctx,
        (*p).u.array.u.values as *mut libc::c_void,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(new_size as libc::c_ulong),
        &mut slack,
    ) as *mut JSValue;
    if new_array_prop.is_null() {
        return -(1 as libc::c_int);
    }
    new_size = (new_size as libc::c_ulong)
        .wrapping_add(
            slack.wrapping_div(::core::mem::size_of::<JSValue>() as libc::c_ulong),
        ) as uint32_t as uint32_t;
    let ref mut fresh228 = (*p).u.array.u.values;
    *fresh228 = new_array_prop;
    (*p).u.array.u1.size = new_size;
    return 0 as libc::c_int;
}
unsafe extern "C" fn add_fast_array_element(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut new_len: uint32_t = 0;
    let mut array_len: uint32_t = 0;
    new_len = ((*p).u.array.count).wrapping_add(1 as libc::c_int as libc::c_uint);
    if (((*((*p).prop).offset(0 as libc::c_int as isize)).u.value >> 32 as libc::c_int)
        as libc::c_int == JS_TAG_INT as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        array_len = (*((*p).prop).offset(0 as libc::c_int as isize)).u.value
            as libc::c_int as uint32_t;
        if new_len > array_len {
            if ((*get_shape_prop((*p).shape)).flags() as libc::c_int
                & (1 as libc::c_int) << 1 as libc::c_int == 0) as libc::c_int
                as libc::c_long != 0
            {
                JS_FreeValue(ctx, val);
                return JS_ThrowTypeErrorReadOnly(
                    ctx,
                    flags,
                    JS_ATOM_length as libc::c_int as JSAtom,
                );
            }
            (*((*p).prop).offset(0 as libc::c_int as isize))
                .u
                .value = JS_NewInt32(ctx, new_len as int32_t);
        }
    }
    if (new_len > (*p).u.array.u1.size) as libc::c_int as libc::c_long != 0 {
        if expand_fast_array(ctx, p, new_len) != 0 {
            JS_FreeValue(ctx, val);
            return -(1 as libc::c_int);
        }
    }
    *((*p).u.array.u.values)
        .offset(new_len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) = val;
    (*p).u.array.count = new_len;
    return TRUE as libc::c_int;
}
unsafe extern "C" fn js_free_desc(
    mut ctx: *mut JSContext,
    mut desc: *mut JSPropertyDescriptor,
) {
    JS_FreeValue(ctx, (*desc).getter);
    JS_FreeValue(ctx, (*desc).setter);
    JS_FreeValue(ctx, (*desc).value);
}
unsafe extern "C" fn JS_SetPropertyGeneric(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut this_obj: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut obj1: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    obj1 = JS_DupValue(ctx, obj);
    loop {
        p = obj1 as intptr_t as *mut libc::c_void as *mut JSObject;
        if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
            let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .exotic;
            if !em.is_null() && ((*em).set_property).is_some() {
                ret = ((*em).set_property)
                    .expect(
                        "non-null function pointer",
                    )(ctx, obj1, prop, val, this_obj, flags);
                JS_FreeValue(ctx, obj1);
                JS_FreeValue(ctx, val);
                return ret;
            }
        }
        ret = JS_GetOwnPropertyInternal(ctx, &mut desc, p, prop);
        if ret < 0 as libc::c_int {
            JS_FreeValue(ctx, obj1);
            JS_FreeValue(ctx, val);
            return ret;
        }
        if ret != 0 {
            if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                let mut setter: *mut JSObject = 0 as *mut JSObject;
                if JS_IsUndefined(desc.setter) != 0 {
                    setter = 0 as *mut JSObject;
                } else {
                    setter = desc.setter as intptr_t as *mut libc::c_void
                        as *mut JSObject;
                }
                ret = call_setter(ctx, setter, this_obj, val, flags);
                JS_FreeValue(ctx, desc.getter);
                JS_FreeValue(ctx, desc.setter);
                JS_FreeValue(ctx, obj1);
                return ret;
            } else {
                JS_FreeValue(ctx, desc.value);
                if !(desc.flags & (1 as libc::c_int) << 1 as libc::c_int == 0) {
                    current_block = 9520865839495247062;
                    break;
                }
                JS_FreeValue(ctx, obj1);
                current_block = 18245429211636315566;
                break;
            }
        } else {
            obj1 = JS_GetPrototypeFree(ctx, obj1);
            if JS_IsNull(obj1) != 0 {
                current_block = 9520865839495247062;
                break;
            }
        }
    }
    match current_block {
        9520865839495247062 => {
            JS_FreeValue(ctx, obj1);
            if JS_IsObject(this_obj) == 0 {
                JS_FreeValue(ctx, val);
                return JS_ThrowTypeErrorOrFalse(
                    ctx,
                    flags,
                    b"receiver is not an object\0" as *const u8 as *const libc::c_char,
                );
            }
            p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
            ret = JS_GetOwnPropertyInternal(ctx, &mut desc, p, prop);
            if ret < 0 as libc::c_int {
                JS_FreeValue(ctx, val);
                return ret;
            }
            if ret != 0 {
                if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                    JS_FreeValue(ctx, desc.getter);
                    JS_FreeValue(ctx, desc.setter);
                    JS_FreeValue(ctx, val);
                    return JS_ThrowTypeErrorOrFalse(
                        ctx,
                        flags,
                        b"setter is forbidden\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    JS_FreeValue(ctx, desc.value);
                    if !(desc.flags & (1 as libc::c_int) << 1 as libc::c_int == 0
                        || (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                            == JS_CLASS_MODULE_NS as libc::c_int)
                    {
                        ret = JS_DefineProperty(
                            ctx,
                            this_obj,
                            prop,
                            val,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            (1 as libc::c_int) << 13 as libc::c_int,
                        );
                        JS_FreeValue(ctx, val);
                        return ret;
                    }
                }
            } else {
                ret = JS_CreateProperty(
                    ctx,
                    p,
                    prop,
                    val,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    flags | (1 as libc::c_int) << 13 as libc::c_int
                        | (1 as libc::c_int) << 10 as libc::c_int
                        | (1 as libc::c_int) << 9 as libc::c_int
                        | (1 as libc::c_int) << 8 as libc::c_int
                        | ((1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int),
                );
                JS_FreeValue(ctx, val);
                return ret;
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, val);
    return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPropertyInternal(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut tag: uint32_t = 0;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut ret: libc::c_int = 0;
    tag = (this_obj >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if (tag != JS_TAG_OBJECT as libc::c_int as libc::c_uint) as libc::c_int
        as libc::c_long != 0
    {
        match tag {
            2 => {
                JS_FreeValue(ctx, val);
                __JS_ThrowTypeErrorAtom(
                    ctx,
                    prop,
                    b"cannot set property '%s' of null\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            3 => {
                JS_FreeValue(ctx, val);
                __JS_ThrowTypeErrorAtom(
                    ctx,
                    prop,
                    b"cannot set property '%s' of undefined\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            _ => {
                p = 0 as *mut JSObject;
                p1 = JS_GetPrototypePrimitive(ctx, this_obj) as intptr_t
                    as *mut libc::c_void as *mut JSObject;
            }
        }
        current_block = 1666541818819435174;
    } else {
        p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        loop {
            prs = find_own_property(&mut pr, p, prop);
            if !prs.is_null() {
                if ((*prs).flags() as libc::c_int
                    & ((3 as libc::c_int) << 4 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 3 as libc::c_int)
                    == (1 as libc::c_int) << 1 as libc::c_int) as libc::c_int
                    as libc::c_long != 0
                {
                    set_value(ctx, &mut (*pr).u.value, val);
                    return TRUE as libc::c_int;
                } else if (*prs).flags() as libc::c_int
                    & (1 as libc::c_int) << 3 as libc::c_int != 0
                {
                    assert(
                        ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                            == JS_CLASS_ARRAY as libc::c_int) as libc::c_int,
                    );
                    assert(
                        (prop == JS_ATOM_length as libc::c_int as libc::c_uint)
                            as libc::c_int,
                    );
                    return set_array_length(ctx, p, val, flags);
                } else if (*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (1 as libc::c_int) << 4 as libc::c_int
                {
                    return call_setter(ctx, (*pr).u.getset.setter, this_obj, val, flags)
                } else if (*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (2 as libc::c_int) << 4 as libc::c_int
                {
                    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                        == JS_CLASS_MODULE_NS as libc::c_int
                    {
                        current_block = 6499223327059635090;
                        break;
                    } else {
                        current_block = 15925075030174552612;
                        break;
                    }
                } else {
                    if !((*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (3 as libc::c_int) << 4 as libc::c_int)
                    {
                        current_block = 6499223327059635090;
                        break;
                    }
                    if JS_AutoInitProperty(ctx, p, prop, pr, prs) != 0 {
                        JS_FreeValue(ctx, val);
                        return -(1 as libc::c_int);
                    }
                }
            } else {
                p1 = p;
                current_block = 9007357115414505193;
                break;
            }
        }
        match current_block {
            6499223327059635090 => {}
            9007357115414505193 => {}
            _ => {
                set_value(ctx, (*(*pr).u.var_ref).pvalue, val);
                return TRUE as libc::c_int;
            }
        }
    }
    loop {
        match current_block {
            1666541818819435174 => {
                if p1.is_null() {
                    break;
                }
                loop {
                    prs = find_own_property(&mut pr, p1, prop);
                    if prs.is_null() {
                        current_block = 9007357115414505193;
                        break;
                    }
                    if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (1 as libc::c_int) << 4 as libc::c_int
                    {
                        return call_setter(
                            ctx,
                            (*pr).u.getset.setter,
                            this_obj,
                            val,
                            flags,
                        )
                    } else if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (3 as libc::c_int) << 4 as libc::c_int
                    {
                        if JS_AutoInitProperty(ctx, p1, prop, pr, prs) != 0 {
                            return -(1 as libc::c_int);
                        }
                    } else if (*prs).flags() as libc::c_int
                        & (1 as libc::c_int) << 1 as libc::c_int == 0
                    {
                        current_block = 6499223327059635090;
                        break;
                    } else {
                        current_block = 9007357115414505193;
                        break;
                    }
                }
            }
            6499223327059635090 => {
                JS_FreeValue(ctx, val);
                return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
            }
            _ => {
                if ((*p1).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
                    if ((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                        if __JS_AtomIsTaggedInt(prop) != 0 {
                            let mut idx: uint32_t = __JS_AtomToUInt32(prop);
                            if idx < (*p1).u.array.count {
                                if !((p == p1) as libc::c_int as libc::c_long != 0) {
                                    break;
                                }
                                return JS_SetPropertyValue(
                                    ctx,
                                    this_obj,
                                    JS_NewInt32(ctx, idx as int32_t),
                                    val,
                                    flags,
                                );
                            } else if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                as libc::c_int >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                                && (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                            {
                                current_block = 6504834440241907210;
                            } else {
                                current_block = 6014157347423944569;
                            }
                        } else if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                            as libc::c_int >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                            && (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                as libc::c_int <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                        {
                            ret = JS_AtomIsNumericIndex(ctx, prop);
                            if ret != 0 as libc::c_int {
                                if ret < 0 as libc::c_int {
                                    JS_FreeValue(ctx, val);
                                    return -(1 as libc::c_int);
                                }
                                current_block = 6504834440241907210;
                            } else {
                                current_block = 6014157347423944569;
                            }
                        } else {
                            current_block = 6014157347423944569;
                        }
                        match current_block {
                            6014157347423944569 => {}
                            _ => {
                                val = JS_ToNumberFree(ctx, val);
                                JS_FreeValue(ctx, val);
                                if JS_IsException(val) != 0 {
                                    return -(1 as libc::c_int);
                                }
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                        }
                    } else {
                        let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt)
                            .class_array)
                            .offset(
                                (*p1).c2rust_unnamed.c2rust_unnamed.class_id as isize,
                            ))
                            .exotic;
                        if !em.is_null() {
                            let mut obj1: JSValue = 0;
                            if ((*em).set_property).is_some() {
                                obj1 = JS_DupValue(
                                    ctx,
                                    (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                        << 32 as libc::c_int | p1 as uintptr_t as libc::c_ulonglong,
                                );
                                ret = ((*em).set_property)
                                    .expect(
                                        "non-null function pointer",
                                    )(ctx, obj1, prop, val, this_obj, flags);
                                JS_FreeValue(ctx, obj1);
                                JS_FreeValue(ctx, val);
                                return ret;
                            }
                            if ((*em).get_own_property).is_some() {
                                obj1 = JS_DupValue(
                                    ctx,
                                    (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                        << 32 as libc::c_int | p1 as uintptr_t as libc::c_ulonglong,
                                );
                                ret = ((*em).get_own_property)
                                    .expect(
                                        "non-null function pointer",
                                    )(ctx, &mut desc, obj1, prop);
                                JS_FreeValue(ctx, obj1);
                                if ret < 0 as libc::c_int {
                                    JS_FreeValue(ctx, val);
                                    return ret;
                                }
                                if ret != 0 {
                                    if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0
                                    {
                                        let mut setter: *mut JSObject = 0 as *mut JSObject;
                                        if JS_IsUndefined(desc.setter) != 0 {
                                            setter = 0 as *mut JSObject;
                                        } else {
                                            setter = desc.setter as intptr_t as *mut libc::c_void
                                                as *mut JSObject;
                                        }
                                        ret = call_setter(ctx, setter, this_obj, val, flags);
                                        JS_FreeValue(ctx, desc.getter);
                                        JS_FreeValue(ctx, desc.setter);
                                        return ret;
                                    } else {
                                        JS_FreeValue(ctx, desc.value);
                                        if desc.flags & (1 as libc::c_int) << 1 as libc::c_int == 0
                                        {
                                            current_block = 6499223327059635090;
                                            continue;
                                        }
                                        if !((p == p1) as libc::c_int as libc::c_long != 0) {
                                            break;
                                        }
                                        ret = JS_DefineProperty(
                                            ctx,
                                            this_obj,
                                            prop,
                                            val,
                                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                            (1 as libc::c_int) << 13 as libc::c_int,
                                        );
                                        JS_FreeValue(ctx, val);
                                        return ret;
                                    }
                                }
                            }
                        }
                    }
                }
                p1 = (*(*p1).shape).proto;
                current_block = 1666541818819435174;
            }
        }
    }
    if (flags & (1 as libc::c_int) << 16 as libc::c_int != 0) as libc::c_int
        as libc::c_long != 0
    {
        JS_FreeValue(ctx, val);
        JS_ThrowReferenceErrorNotDefined(ctx, prop);
        return -(1 as libc::c_int);
    }
    if p.is_null() as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorOrFalse(
            ctx,
            flags,
            b"not an object\0" as *const u8 as *const libc::c_char,
        );
    }
    if (((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0) as libc::c_int
        as libc::c_long != 0
    {
        JS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorOrFalse(
            ctx,
            flags,
            b"object is not extensible\0" as *const u8 as *const libc::c_char,
        );
    }
    if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARRAY as libc::c_int
            && ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
            && __JS_AtomIsTaggedInt(prop) != 0
        {
            let mut idx_0: uint32_t = __JS_AtomToUInt32(prop);
            if idx_0 == (*p).u.array.count {
                return add_fast_array_element(ctx, p, val, flags);
            }
        }
        ret = JS_CreateProperty(
            ctx,
            p,
            prop,
            val,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            flags | (1 as libc::c_int) << 13 as libc::c_int
                | (1 as libc::c_int) << 10 as libc::c_int
                | (1 as libc::c_int) << 9 as libc::c_int
                | (1 as libc::c_int) << 8 as libc::c_int
                | ((1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int),
        );
        JS_FreeValue(ctx, val);
        return ret;
    }
    pr = add_property(
        ctx,
        p,
        prop,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int,
    );
    if pr.is_null() as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, val);
        return -(1 as libc::c_int);
    }
    (*pr).u.value = val;
    return TRUE as libc::c_int;
}
unsafe extern "C" fn JS_SetPropertyValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSValue,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    let mut current_block: u64;
    if ((this_obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int
        && (prop >> 32 as libc::c_int) as libc::c_int == JS_TAG_INT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        let mut p: *mut JSObject = 0 as *mut JSObject;
        let mut idx: uint32_t = 0;
        let mut d: libc::c_double = 0.;
        let mut v: int32_t = 0;
        p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        idx = prop as libc::c_int as uint32_t;
        match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
            2 => {
                current_block = 16276610134255000815;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            8 => {
                current_block = 8133612514536980483;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            21 => {
                current_block = 1410280584896686465;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            22 | 23 => {
                current_block = 13713065119802208519;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            24 | 25 => {
                current_block = 8813360826226618456;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            26 | 27 => {
                current_block = 97198592208672704;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            28 => {
                current_block = 9192658053450452446;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            29 => {
                current_block = 16593358110156835856;
                match current_block {
                    16593358110156835856 => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.double_ptr).offset(idx as isize) = d;
                            current_block = 9353995356876505083;
                        }
                    }
                    97198592208672704 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint32_ptr)
                                .offset(idx as isize) = v as uint32_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8813360826226618456 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint16_ptr)
                                .offset(idx as isize) = v as uint16_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    13713065119802208519 => {
                        if JS_ToInt32Free(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    1410280584896686465 => {
                        if JS_ToUint8ClampFree(ctx, &mut v, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.uint8_ptr)
                                .offset(idx as isize) = v as uint8_t;
                            current_block = 9353995356876505083;
                        }
                    }
                    8133612514536980483 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 2020708458761279539;
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    16276610134255000815 => {
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            let mut p1: *mut JSObject = 0 as *mut JSObject;
                            let mut sh1: *mut JSShape = 0 as *mut JSShape;
                            if idx != (*p).u.array.count
                                || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
                                || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                            {
                                current_block = 2020708458761279539;
                            } else {
                                p1 = (*(*p).shape).proto;
                                loop {
                                    if p1.is_null() {
                                        current_block = 12124785117276362961;
                                        break;
                                    }
                                    sh1 = (*p1).shape;
                                    if (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int == JS_CLASS_ARRAY as libc::c_int
                                    {
                                        if (((*p1).c2rust_unnamed.c2rust_unnamed).fast_array() == 0)
                                            as libc::c_int as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    } else {
                                        if !((*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int == JS_CLASS_OBJECT as libc::c_int)
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                        if ((*sh1).has_small_array_index != 0) as libc::c_int
                                            as libc::c_long != 0
                                        {
                                            current_block = 2020708458761279539;
                                            break;
                                        }
                                    }
                                    p1 = (*sh1).proto;
                                }
                                match current_block {
                                    2020708458761279539 => {}
                                    _ => return add_fast_array_element(ctx, p, val, flags),
                                }
                            }
                        } else {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                val,
                            );
                            current_block = 9353995356876505083;
                        }
                    }
                    _ => {
                        if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if (idx >= (*p).u.array.count) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 11144947645655438383;
                        } else {
                            *((*p).u.array.u.float_ptr)
                                .offset(idx as isize) = d as libc::c_float;
                            current_block = 9353995356876505083;
                        }
                    }
                }
                match current_block {
                    2020708458761279539 => {}
                    _ => {
                        match current_block {
                            11144947645655438383 => {
                                return JS_ThrowTypeErrorOrFalse(
                                    ctx,
                                    flags,
                                    b"out-of-bound numeric index\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            _ => return TRUE as libc::c_int,
                        }
                    }
                }
            }
            _ => {}
        }
    } else {
        atom = 0;
        ret = 0;
    }
    atom = JS_ValueToAtom(ctx, prop);
    JS_FreeValue(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, val);
        return -(1 as libc::c_int);
    }
    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, flags);
    JS_FreeAtom(ctx, atom);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPropertyUint32(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: uint32_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_SetPropertyValue(
        ctx,
        this_obj,
        JS_NewUint32(ctx, idx),
        val,
        (1 as libc::c_int) << 14 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPropertyInt64(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: int64_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut prop: JSAtom = 0;
    let mut res: libc::c_int = 0;
    if idx as uint64_t <= 0x7fffffff as libc::c_int as libc::c_ulonglong {
        return JS_SetPropertyValue(
            ctx,
            this_obj,
            JS_NewInt32(ctx, idx as int32_t),
            val,
            (1 as libc::c_int) << 14 as libc::c_int,
        );
    }
    prop = JS_NewAtomInt64(ctx, idx);
    if prop == 0 as libc::c_int as libc::c_uint {
        JS_FreeValue(ctx, val);
        return -(1 as libc::c_int);
    }
    res = JS_SetProperty(ctx, this_obj, prop, val);
    JS_FreeAtom(ctx, prop);
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPropertyStr(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: *const libc::c_char,
    mut val: JSValue,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    atom = JS_NewAtom(ctx, prop);
    ret = JS_SetPropertyInternal(
        ctx,
        this_obj,
        atom,
        val,
        (1 as libc::c_int) << 14 as libc::c_int,
    );
    JS_FreeAtom(ctx, atom);
    return ret;
}
unsafe extern "C" fn get_prop_flags(
    mut flags: libc::c_int,
    mut def_flags: libc::c_int,
) -> libc::c_int {
    let mut mask: libc::c_int = 0;
    mask = flags >> 8 as libc::c_int
        & ((1 as libc::c_int) << 0 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int);
    return flags & mask | def_flags & !mask;
}
unsafe extern "C" fn JS_CreateProperty(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut prop: JSAtom,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut plen: *mut JSProperty = 0 as *mut JSProperty;
    let mut pslen: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut current_block: u64;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut ret: libc::c_int = 0;
    let mut prop_flags: libc::c_int = 0;
    if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARRAY as libc::c_int
        {
            let mut idx: uint32_t = 0;
            let mut len: uint32_t = 0;
            if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                if __JS_AtomIsTaggedInt(prop) != 0 {
                    idx = __JS_AtomToUInt32(prop);
                    if idx == (*p).u.array.count {
                        if ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0 {
                            current_block = 4814793984204979109;
                        } else if flags
                            & ((1 as libc::c_int) << 11 as libc::c_int
                                | (1 as libc::c_int) << 12 as libc::c_int) != 0
                        {
                            current_block = 10415743199524978582;
                        } else {
                            prop_flags = get_prop_flags(flags, 0 as libc::c_int);
                            if prop_flags
                                != (1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int
                            {
                                current_block = 10415743199524978582;
                            } else {
                                return add_fast_array_element(
                                    ctx,
                                    p,
                                    JS_DupValue(ctx, val),
                                    flags,
                                )
                            }
                        }
                    } else {
                        current_block = 10415743199524978582;
                    }
                } else if JS_AtomIsArrayIndex(ctx, &mut idx, prop) != 0 {
                    current_block = 10415743199524978582;
                } else {
                    current_block = 10399321362245223758;
                }
                match current_block {
                    10399321362245223758 => {}
                    4814793984204979109 => {}
                    _ => {
                        if convert_fast_array_to_array(ctx, p) != 0 {
                            return -(1 as libc::c_int);
                        }
                        current_block = 8697746047902031847;
                    }
                }
            } else if JS_AtomIsArrayIndex(ctx, &mut idx, prop) != 0 {
                plen = 0 as *mut JSProperty;
                pslen = 0 as *mut JSShapeProperty;
                current_block = 8697746047902031847;
            } else {
                current_block = 10399321362245223758;
            }
            match current_block {
                10399321362245223758 => {}
                4814793984204979109 => {}
                _ => {
                    plen = &mut *((*p).prop).offset(0 as libc::c_int as isize)
                        as *mut JSProperty;
                    JS_ToUint32(ctx, &mut len, (*plen).u.value);
                    if idx.wrapping_add(1 as libc::c_int as libc::c_uint) > len {
                        pslen = get_shape_prop((*p).shape);
                        if ((*pslen).flags() as libc::c_int
                            & (1 as libc::c_int) << 1 as libc::c_int == 0) as libc::c_int
                            as libc::c_long != 0
                        {
                            return JS_ThrowTypeErrorReadOnly(
                                ctx,
                                flags,
                                JS_ATOM_length as libc::c_int as JSAtom,
                            );
                        }
                        len = idx.wrapping_add(1 as libc::c_int as libc::c_uint);
                        set_value(ctx, &mut (*plen).u.value, JS_NewUint32(ctx, len));
                    }
                    current_block = 10399321362245223758;
                }
            }
        } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
        {
            ret = JS_AtomIsNumericIndex(ctx, prop);
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                return JS_ThrowTypeErrorOrFalse(
                    ctx,
                    flags,
                    b"cannot create numeric index in typed array\0" as *const u8
                        as *const libc::c_char,
                );
            }
            current_block = 10399321362245223758;
        } else if flags & (1 as libc::c_int) << 17 as libc::c_int == 0 {
            let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .exotic;
            if !em.is_null() {
                if ((*em).define_own_property).is_some() {
                    return ((*em).define_own_property)
                        .expect(
                            "non-null function pointer",
                        )(
                        ctx,
                        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                            | p as uintptr_t as libc::c_ulonglong,
                        prop,
                        val,
                        getter,
                        setter,
                        flags,
                    );
                }
                ret = JS_IsExtensible(
                    ctx,
                    (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                        | p as uintptr_t as libc::c_ulonglong,
                );
                if ret < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                if ret == 0 {
                    current_block = 4814793984204979109;
                } else {
                    current_block = 10399321362245223758;
                }
            } else {
                current_block = 10399321362245223758;
            }
        } else {
            current_block = 10399321362245223758;
        }
    } else {
        current_block = 10399321362245223758;
    }
    match current_block {
        10399321362245223758 => {
            if !(((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0) {
                if flags
                    & ((1 as libc::c_int) << 11 as libc::c_int
                        | (1 as libc::c_int) << 12 as libc::c_int) != 0
                {
                    prop_flags = flags
                        & ((1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int)
                        | (1 as libc::c_int) << 4 as libc::c_int;
                } else {
                    prop_flags = flags
                        & ((1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int);
                }
                pr = add_property(ctx, p, prop, prop_flags);
                if pr.is_null() as libc::c_int as libc::c_long != 0 {
                    return -(1 as libc::c_int);
                }
                if flags
                    & ((1 as libc::c_int) << 11 as libc::c_int
                        | (1 as libc::c_int) << 12 as libc::c_int) != 0
                {
                    let ref mut fresh229 = (*pr).u.getset.getter;
                    *fresh229 = 0 as *mut JSObject;
                    if flags & (1 as libc::c_int) << 11 as libc::c_int != 0
                        && JS_IsFunction(ctx, getter) != 0
                    {
                        let ref mut fresh230 = (*pr).u.getset.getter;
                        *fresh230 = JS_DupValue(ctx, getter) as intptr_t
                            as *mut libc::c_void as *mut JSObject;
                    }
                    let ref mut fresh231 = (*pr).u.getset.setter;
                    *fresh231 = 0 as *mut JSObject;
                    if flags & (1 as libc::c_int) << 12 as libc::c_int != 0
                        && JS_IsFunction(ctx, setter) != 0
                    {
                        let ref mut fresh232 = (*pr).u.getset.setter;
                        *fresh232 = JS_DupValue(ctx, setter) as intptr_t
                            as *mut libc::c_void as *mut JSObject;
                    }
                } else if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                    (*pr).u.value = JS_DupValue(ctx, val);
                } else {
                    (*pr)
                        .u
                        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                return TRUE as libc::c_int;
            }
        }
        _ => {}
    }
    return JS_ThrowTypeErrorOrFalse(
        ctx,
        flags,
        b"object is not extensible\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn check_define_prop_flags(
    mut prop_flags: libc::c_int,
    mut flags: libc::c_int,
) -> BOOL {
    let mut has_accessor: BOOL = 0;
    let mut is_getset: BOOL = 0;
    if prop_flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
        if flags
            & ((1 as libc::c_int) << 8 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int)
            == (1 as libc::c_int) << 8 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int
        {
            return FALSE as libc::c_int;
        }
        if flags & (1 as libc::c_int) << 10 as libc::c_int != 0
            && flags & (1 as libc::c_int) << 2 as libc::c_int
                != prop_flags & (1 as libc::c_int) << 2 as libc::c_int
        {
            return FALSE as libc::c_int;
        }
    }
    if flags
        & ((1 as libc::c_int) << 13 as libc::c_int
            | (1 as libc::c_int) << 9 as libc::c_int
            | (1 as libc::c_int) << 11 as libc::c_int
            | (1 as libc::c_int) << 12 as libc::c_int) != 0
    {
        if prop_flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
            has_accessor = (flags
                & ((1 as libc::c_int) << 11 as libc::c_int
                    | (1 as libc::c_int) << 12 as libc::c_int) != 0 as libc::c_int)
                as libc::c_int;
            is_getset = (prop_flags & (3 as libc::c_int) << 4 as libc::c_int
                == (1 as libc::c_int) << 4 as libc::c_int) as libc::c_int;
            if has_accessor != is_getset {
                return FALSE as libc::c_int;
            }
            if has_accessor == 0 && is_getset == 0
                && prop_flags & (1 as libc::c_int) << 1 as libc::c_int == 0
            {
                if flags
                    & ((1 as libc::c_int) << 9 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int)
                    == (1 as libc::c_int) << 9 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                {
                    return FALSE as libc::c_int;
                }
            }
        }
    }
    return TRUE as libc::c_int;
}
unsafe extern "C" fn js_shape_prepare_update(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut pprs: *mut *mut JSShapeProperty,
) -> libc::c_int {
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut idx: uint32_t = 0 as libc::c_int as uint32_t;
    sh = (*p).shape;
    if (*sh).is_hashed != 0 {
        if (*sh).header.ref_count != 1 as libc::c_int {
            if !pprs.is_null() {
                idx = (*pprs).offset_from(get_shape_prop(sh)) as libc::c_long
                    as uint32_t;
            }
            sh = js_clone_shape(ctx, sh);
            if sh.is_null() {
                return -(1 as libc::c_int);
            }
            js_free_shape((*ctx).rt, (*p).shape);
            let ref mut fresh233 = (*p).shape;
            *fresh233 = sh;
            if !pprs.is_null() {
                *pprs = (get_shape_prop(sh)).offset(idx as isize);
            }
        } else {
            js_shape_hash_unlink((*ctx).rt, sh);
            (*sh).is_hashed = FALSE as libc::c_int as uint8_t;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_update_property_flags(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut pprs: *mut *mut JSShapeProperty,
    mut flags: libc::c_int,
) -> libc::c_int {
    if flags != (**pprs).flags() as libc::c_int {
        if js_shape_prepare_update(ctx, p, pprs) != 0 {
            return -(1 as libc::c_int);
        }
        (**pprs).set_flags(flags as uint32_t);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefineProperty(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut mask: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    if (this_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    loop {
        prs = find_own_property(&mut pr, p, prop);
        if !prs.is_null() {
            if (*prs).flags() as libc::c_int & (1 as libc::c_int) << 3 as libc::c_int
                != 0 && flags & (1 as libc::c_int) << 13 as libc::c_int != 0
            {
                let mut array_length: uint32_t = 0;
                if JS_ToArrayLengthFree(
                    ctx,
                    &mut array_length,
                    JS_DupValue(ctx, val),
                    FALSE as libc::c_int,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
                val = JS_NewUint32(ctx, array_length);
                prs = find_own_property(&mut pr, p, prop);
                assert(
                    (prs != 0 as *mut libc::c_void as *mut JSShapeProperty)
                        as libc::c_int,
                );
            }
            if check_define_prop_flags((*prs).flags() as libc::c_int, flags) == 0 {
                current_block = 18272504207421784931;
                break;
            }
            if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                == (3 as libc::c_int) << 4 as libc::c_int
            {
                if JS_AutoInitProperty(ctx, p, prop, pr, prs) != 0 {
                    return -(1 as libc::c_int);
                }
            } else if flags
                & ((1 as libc::c_int) << 13 as libc::c_int
                    | (1 as libc::c_int) << 9 as libc::c_int
                    | (1 as libc::c_int) << 11 as libc::c_int
                    | (1 as libc::c_int) << 12 as libc::c_int) != 0
            {
                current_block = 2668756484064249700;
                break;
            } else {
                current_block = 12543410360505780601;
                break;
            }
        } else {
            if !(((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0) {
                current_block = 13479157322803929894;
                break;
            }
            let mut idx: uint32_t = 0;
            let mut prop_flags: uint32_t = 0;
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                == JS_CLASS_ARRAY as libc::c_int
            {
                if !(__JS_AtomIsTaggedInt(prop) != 0) {
                    current_block = 13479157322803929894;
                    break;
                }
                idx = __JS_AtomToUInt32(prop);
                if !(idx < (*p).u.array.count) {
                    current_block = 13479157322803929894;
                    break;
                }
                prop_flags = get_prop_flags(
                    flags,
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                ) as uint32_t;
                if !(prop_flags
                    != ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int) as libc::c_uint)
                {
                    if !(flags
                        & ((1 as libc::c_int) << 11 as libc::c_int
                            | (1 as libc::c_int) << 12 as libc::c_int) != 0)
                    {
                        if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                            set_value(
                                ctx,
                                &mut *((*p).u.array.u.values).offset(idx as isize),
                                JS_DupValue(ctx, val),
                            );
                        }
                        return TRUE as libc::c_int;
                    }
                }
                if !(convert_fast_array_to_array(ctx, p) != 0) {
                    continue;
                }
                return -(1 as libc::c_int);
            } else {
                if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                    >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                    && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                        <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                {
                    's_840: {
                        let mut current_block_137: u64;
                        let mut num: JSValue = 0;
                        let mut ret: libc::c_int = 0;
                        if __JS_AtomIsTaggedInt(prop) == 0 {
                            num = JS_AtomIsNumericIndex1(ctx, prop);
                            if JS_IsUndefined(num) != 0 {
                                break 's_840;
                            } else {
                                if JS_IsException(num) != 0 {
                                    return -(1 as libc::c_int);
                                }
                                ret = JS_NumberIsInteger(ctx, num);
                                if ret < 0 as libc::c_int {
                                    JS_FreeValue(ctx, num);
                                    return -(1 as libc::c_int);
                                }
                                if ret == 0 {
                                    JS_FreeValue(ctx, num);
                                    return JS_ThrowTypeErrorOrFalse(
                                        ctx,
                                        flags,
                                        b"non integer index in typed array\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                                ret = JS_NumberIsNegativeOrMinusZero(ctx, num);
                                JS_FreeValue(ctx, num);
                                if ret != 0 {
                                    return JS_ThrowTypeErrorOrFalse(
                                        ctx,
                                        flags,
                                        b"negative index in typed array\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                                if __JS_AtomIsTaggedInt(prop) == 0 {
                                    current_block_137 = 15510740783154968303;
                                } else {
                                    current_block_137 = 5388205036907793036;
                                }
                            }
                        } else {
                            current_block_137 = 5388205036907793036;
                        }
                        match current_block_137 {
                            5388205036907793036 => {
                                idx = __JS_AtomToUInt32(prop);
                                if !(idx >= typed_array_get_length(ctx, p)) {
                                    prop_flags = get_prop_flags(
                                        flags,
                                        (1 as libc::c_int) << 2 as libc::c_int
                                            | (1 as libc::c_int) << 1 as libc::c_int
                                            | (1 as libc::c_int) << 0 as libc::c_int,
                                    ) as uint32_t;
                                    if flags
                                        & ((1 as libc::c_int) << 11 as libc::c_int
                                            | (1 as libc::c_int) << 12 as libc::c_int) != 0
                                        || prop_flags
                                            != ((1 as libc::c_int) << 2 as libc::c_int
                                                | (1 as libc::c_int) << 1 as libc::c_int
                                                | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
                                    {
                                        return JS_ThrowTypeErrorOrFalse(
                                            ctx,
                                            flags,
                                            b"invalid descriptor flags\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                    }
                                    if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                                        return JS_SetPropertyValue(
                                            ctx,
                                            this_obj,
                                            JS_NewInt32(ctx, idx as int32_t),
                                            JS_DupValue(ctx, val),
                                            flags,
                                        );
                                    }
                                    return TRUE as libc::c_int;
                                }
                            }
                            _ => {}
                        }
                        return JS_ThrowTypeErrorOrFalse(
                            ctx,
                            flags,
                            b"out-of-bound index in typed array\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
                current_block = 13479157322803929894;
                break;
            }
        }
    }
    match current_block {
        2668756484064249700 => {
            if flags
                & ((1 as libc::c_int) << 11 as libc::c_int
                    | (1 as libc::c_int) << 12 as libc::c_int) != 0
            {
                let mut new_getter: *mut JSObject = 0 as *mut JSObject;
                let mut new_setter: *mut JSObject = 0 as *mut JSObject;
                if JS_IsFunction(ctx, getter) != 0 {
                    new_getter = getter as intptr_t as *mut libc::c_void
                        as *mut JSObject;
                } else {
                    new_getter = 0 as *mut JSObject;
                }
                if JS_IsFunction(ctx, setter) != 0 {
                    new_setter = setter as intptr_t as *mut libc::c_void
                        as *mut JSObject;
                } else {
                    new_setter = 0 as *mut JSObject;
                }
                if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                    != (1 as libc::c_int) << 4 as libc::c_int
                {
                    if js_shape_prepare_update(ctx, p, &mut prs) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if (*prs).flags() as libc::c_int
                        & (3 as libc::c_int) << 4 as libc::c_int
                        == (2 as libc::c_int) << 4 as libc::c_int
                    {
                        free_var_ref((*ctx).rt, (*pr).u.var_ref);
                    } else {
                        JS_FreeValue(ctx, (*pr).u.value);
                    }
                    (*prs)
                        .set_flags(
                            ((*prs).flags() as libc::c_int
                                & ((1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int)
                                | (1 as libc::c_int) << 4 as libc::c_int) as uint32_t,
                        );
                    let ref mut fresh234 = (*pr).u.getset.getter;
                    *fresh234 = 0 as *mut JSObject;
                    let ref mut fresh235 = (*pr).u.getset.setter;
                    *fresh235 = 0 as *mut JSObject;
                    current_block = 13460095289871124136;
                } else if (*prs).flags() as libc::c_int
                    & (1 as libc::c_int) << 0 as libc::c_int == 0
                {
                    if flags & (1 as libc::c_int) << 11 as libc::c_int != 0
                        && new_getter != (*pr).u.getset.getter
                    {
                        current_block = 18272504207421784931;
                    } else if flags & (1 as libc::c_int) << 12 as libc::c_int != 0
                        && new_setter != (*pr).u.getset.setter
                    {
                        current_block = 18272504207421784931;
                    } else {
                        current_block = 13460095289871124136;
                    }
                } else {
                    current_block = 13460095289871124136;
                }
                match current_block {
                    18272504207421784931 => {}
                    _ => {
                        if flags & (1 as libc::c_int) << 11 as libc::c_int != 0 {
                            if !((*pr).u.getset.getter).is_null() {
                                JS_FreeValue(
                                    ctx,
                                    (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | (*pr).u.getset.getter as uintptr_t as libc::c_ulonglong,
                                );
                            }
                            if !new_getter.is_null() {
                                JS_DupValue(ctx, getter);
                            }
                            let ref mut fresh236 = (*pr).u.getset.getter;
                            *fresh236 = new_getter;
                        }
                        if flags & (1 as libc::c_int) << 12 as libc::c_int != 0 {
                            if !((*pr).u.getset.setter).is_null() {
                                JS_FreeValue(
                                    ctx,
                                    (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | (*pr).u.getset.setter as uintptr_t as libc::c_ulonglong,
                                );
                            }
                            if !new_setter.is_null() {
                                JS_DupValue(ctx, setter);
                            }
                            let ref mut fresh237 = (*pr).u.getset.setter;
                            *fresh237 = new_setter;
                        }
                        current_block = 12543410360505780601;
                    }
                }
            } else {
                if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                    == (1 as libc::c_int) << 4 as libc::c_int
                {
                    if js_shape_prepare_update(ctx, p, &mut prs) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if !((*pr).u.getset.getter).is_null() {
                        JS_FreeValue(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | (*pr).u.getset.getter as uintptr_t as libc::c_ulonglong,
                        );
                    }
                    if !((*pr).u.getset.setter).is_null() {
                        JS_FreeValue(
                            ctx,
                            (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | (*pr).u.getset.setter as uintptr_t as libc::c_ulonglong,
                        );
                    }
                    (*prs)
                        .set_flags(
                            (*prs).flags()
                                & !((3 as libc::c_int) << 4 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int) as uint32_t,
                        );
                    (*pr)
                        .u
                        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block = 7318352876044315808;
                } else if (*prs).flags() as libc::c_int
                    & (3 as libc::c_int) << 4 as libc::c_int
                    == (2 as libc::c_int) << 4 as libc::c_int
                {
                    current_block = 7318352876044315808;
                } else if (*prs).flags() as libc::c_int
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int) == 0 as libc::c_int
                    && flags & (1 as libc::c_int) << 13 as libc::c_int != 0
                {
                    if js_same_value(ctx, val, (*pr).u.value) == 0 {
                        current_block = 18272504207421784931;
                    } else {
                        return TRUE as libc::c_int
                    }
                } else {
                    current_block = 7318352876044315808;
                }
                match current_block {
                    18272504207421784931 => {}
                    _ => {
                        if (*prs).flags() as libc::c_int
                            & (3 as libc::c_int) << 4 as libc::c_int
                            == (2 as libc::c_int) << 4 as libc::c_int
                        {
                            if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                                if (*p).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int == JS_CLASS_MODULE_NS as libc::c_int
                                {
                                    if js_same_value(ctx, val, *(*(*pr).u.var_ref).pvalue) == 0
                                    {
                                        current_block = 18272504207421784931;
                                    } else {
                                        current_block = 14648606000749551097;
                                    }
                                } else {
                                    current_block = 14648606000749551097;
                                }
                                match current_block {
                                    18272504207421784931 => {}
                                    _ => {
                                        set_value(
                                            ctx,
                                            (*(*pr).u.var_ref).pvalue,
                                            JS_DupValue(ctx, val),
                                        );
                                        current_block = 15855550149339537395;
                                    }
                                }
                            } else {
                                current_block = 15855550149339537395;
                            }
                            match current_block {
                                18272504207421784931 => {}
                                _ => {
                                    if flags
                                        & ((1 as libc::c_int) << 9 as libc::c_int
                                            | (1 as libc::c_int) << 1 as libc::c_int)
                                        == (1 as libc::c_int) << 9 as libc::c_int
                                    {
                                        let mut val1: JSValue = 0;
                                        if js_shape_prepare_update(ctx, p, &mut prs) != 0 {
                                            return -(1 as libc::c_int);
                                        }
                                        val1 = JS_DupValue(ctx, *(*(*pr).u.var_ref).pvalue);
                                        free_var_ref((*ctx).rt, (*pr).u.var_ref);
                                        (*pr).u.value = val1;
                                        (*prs)
                                            .set_flags(
                                                (*prs).flags()
                                                    & !((3 as libc::c_int) << 4 as libc::c_int
                                                        | (1 as libc::c_int) << 1 as libc::c_int) as uint32_t,
                                            );
                                    }
                                    current_block = 12543410360505780601;
                                }
                            }
                        } else {
                            if (*prs).flags() as libc::c_int
                                & (1 as libc::c_int) << 3 as libc::c_int != 0
                            {
                                if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                                    res = set_array_length(
                                        ctx,
                                        p,
                                        JS_DupValue(ctx, val),
                                        flags,
                                    );
                                } else {
                                    res = TRUE as libc::c_int;
                                }
                                if flags
                                    & ((1 as libc::c_int) << 9 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int)
                                    == (1 as libc::c_int) << 9 as libc::c_int
                                {
                                    prs = get_shape_prop((*p).shape);
                                    if js_update_property_flags(
                                        ctx,
                                        p,
                                        &mut prs,
                                        (*prs).flags() as libc::c_int
                                            & !((1 as libc::c_int) << 1 as libc::c_int),
                                    ) != 0
                                    {
                                        return -(1 as libc::c_int);
                                    }
                                }
                                return res;
                            } else {
                                if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                                    JS_FreeValue(ctx, (*pr).u.value);
                                    (*pr).u.value = JS_DupValue(ctx, val);
                                }
                                if flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
                                    if js_update_property_flags(
                                        ctx,
                                        p,
                                        &mut prs,
                                        (*prs).flags() as libc::c_int
                                            & !((1 as libc::c_int) << 1 as libc::c_int)
                                            | flags & (1 as libc::c_int) << 1 as libc::c_int,
                                    ) != 0
                                    {
                                        return -(1 as libc::c_int);
                                    }
                                }
                            }
                            current_block = 12543410360505780601;
                        }
                    }
                }
            }
        }
        13479157322803929894 => {
            return JS_CreateProperty(ctx, p, prop, val, getter, setter, flags);
        }
        _ => {}
    }
    match current_block {
        18272504207421784931 => {
            return JS_ThrowTypeErrorOrFalse(
                ctx,
                flags,
                b"property is not configurable\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            mask = 0 as libc::c_int;
            if flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                mask |= (1 as libc::c_int) << 0 as libc::c_int;
            }
            if flags & (1 as libc::c_int) << 10 as libc::c_int != 0 {
                mask |= (1 as libc::c_int) << 2 as libc::c_int;
            }
            if js_update_property_flags(
                ctx,
                p,
                &mut prs,
                (*prs).flags() as libc::c_int & !mask | flags & mask,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            return TRUE as libc::c_int;
        }
    };
}
unsafe extern "C" fn JS_DefineAutoInitProperty(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut id: JSAutoInitIDEnum,
    mut opaque: *mut libc::c_void,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    if (this_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if !(find_own_property(&mut pr, p, prop)).is_null() {
        abort();
    }
    pr = add_property(
        ctx,
        p,
        prop,
        flags
            & ((1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int)
            | (3 as libc::c_int) << 4 as libc::c_int,
    );
    if pr.is_null() as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    (*pr).u.init.realm_and_id = JS_DupContext(ctx) as uintptr_t;
    assert(
        ((*pr).u.init.realm_and_id & 3 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint) as libc::c_int,
    );
    assert((id as libc::c_uint <= 3 as libc::c_int as libc::c_uint) as libc::c_int);
    let ref mut fresh238 = (*pr).u.init.realm_and_id;
    *fresh238 |= id as libc::c_uint;
    let ref mut fresh239 = (*pr).u.init.opaque;
    *fresh239 = opaque;
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    ret = JS_DefineProperty(
        ctx,
        this_obj,
        prop,
        val,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        flags | (1 as libc::c_int) << 13 as libc::c_int
            | (1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 9 as libc::c_int
            | (1 as libc::c_int) << 10 as libc::c_int,
    );
    JS_FreeValue(ctx, val);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyValueValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSValue,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    atom = JS_ValueToAtom(ctx, prop);
    JS_FreeValue(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, val);
        return -(1 as libc::c_int);
    }
    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
    JS_FreeAtom(ctx, atom);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyValueUint32(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: uint32_t,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    return JS_DefinePropertyValueValue(
        ctx,
        this_obj,
        JS_NewUint32(ctx, idx),
        val,
        flags,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyValueInt64(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: int64_t,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx), val, flags);
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyValueStr(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: *const libc::c_char,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    atom = JS_NewAtom(ctx, prop);
    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
    JS_FreeAtom(ctx, atom);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DefinePropertyGetSet(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    ret = JS_DefineProperty(
        ctx,
        this_obj,
        prop,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        getter,
        setter,
        flags | (1 as libc::c_int) << 11 as libc::c_int
            | (1 as libc::c_int) << 12 as libc::c_int
            | (1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 10 as libc::c_int,
    );
    JS_FreeValue(ctx, getter);
    JS_FreeValue(ctx, setter);
    return ret;
}
unsafe extern "C" fn JS_CreateDataPropertyUint32(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut idx: int64_t,
    mut val: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    return JS_DefinePropertyValueValue(
        ctx,
        this_obj,
        JS_NewInt64(ctx, idx),
        val,
        flags | (1 as libc::c_int) << 0 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int,
    );
}
unsafe extern "C" fn js_object_has_name(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> BOOL {
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut val: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    prs = find_own_property(
        &mut pr,
        obj as intptr_t as *mut libc::c_void as *mut JSObject,
        JS_ATOM_name as libc::c_int as JSAtom,
    );
    if prs.is_null() {
        return FALSE as libc::c_int;
    }
    if (*prs).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
        != (0 as libc::c_int) << 4 as libc::c_int
    {
        return TRUE as libc::c_int;
    }
    val = (*pr).u.value;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int {
        return TRUE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    return ((*p).len() as libc::c_int != 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn JS_DefineObjectName(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut name: JSAtom,
    mut flags: libc::c_int,
) -> libc::c_int {
    if name != 0 as libc::c_int as libc::c_uint && JS_IsObject(obj) != 0
        && js_object_has_name(ctx, obj) == 0
        && JS_DefinePropertyValue(
            ctx,
            obj,
            JS_ATOM_name as libc::c_int as JSAtom,
            JS_AtomToString(ctx, name),
            flags,
        ) < 0 as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_DefineObjectNameComputed(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut str: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    if JS_IsObject(obj) != 0 && js_object_has_name(ctx, obj) == 0 {
        let mut prop: JSAtom = 0;
        let mut name_str: JSValue = 0;
        prop = JS_ValueToAtom(ctx, str);
        if prop == 0 as libc::c_int as libc::c_uint {
            return -(1 as libc::c_int);
        }
        name_str = js_get_function_name(ctx, prop);
        JS_FreeAtom(ctx, prop);
        if JS_IsException(name_str) != 0 {
            return -(1 as libc::c_int);
        }
        if JS_DefinePropertyValue(
            ctx,
            obj,
            JS_ATOM_name as libc::c_int as JSAtom,
            name_str,
            flags,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_ThrowSyntaxErrorVarRedeclaration(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
) -> JSValue {
    return __JS_ThrowSyntaxErrorAtom(
        ctx,
        prop,
        b"redeclaration of '%s'\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn JS_CheckDefineGlobalVar(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    p = (*ctx).global_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property1(p, prop);
    if flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        if !prs.is_null()
            && (*prs).flags() as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                == 0
        {
            current_block = 17875959270957244750;
        } else {
            current_block = 3512920355445576850;
        }
    } else {
        's_68: {
            let mut current_block_3: u64;
            if !(prs.is_null() && ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0)
            {
                if flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                    if !prs.is_null() {
                        if (*prs).flags() as libc::c_int
                            & (1 as libc::c_int) << 0 as libc::c_int == 0
                            && ((*prs).flags() as libc::c_int
                                & (3 as libc::c_int) << 4 as libc::c_int
                                == (1 as libc::c_int) << 4 as libc::c_int
                                || (*prs).flags() as libc::c_int
                                    & ((1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int)
                                    != (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int)
                        {
                            current_block_3 = 2359662140730260068;
                        } else {
                            current_block_3 = 13586036798005543211;
                        }
                    } else {
                        current_block_3 = 13586036798005543211;
                    }
                } else {
                    current_block_3 = 13586036798005543211;
                }
                match current_block_3 {
                    2359662140730260068 => {}
                    _ => {
                        break 's_68;
                    }
                }
            }
            __JS_ThrowTypeErrorAtom(
                ctx,
                prop,
                b"cannot define variable '%s'\0" as *const u8 as *const libc::c_char,
                b"\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        current_block = 3512920355445576850;
    }
    match current_block {
        3512920355445576850 => {
            p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
            prs = find_own_property1(p, prop);
            if prs.is_null() {
                return 0 as libc::c_int;
            }
        }
        _ => {}
    }
    JS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_DefineGlobalVar(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut def_flags: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut val: JSValue = 0;
    let mut flags: libc::c_int = 0;
    if def_flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        flags = (1 as libc::c_int) << 2 as libc::c_int
            | def_flags & (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 0 as libc::c_int;
        val = (JS_TAG_UNINITIALIZED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        p = (*ctx).global_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        flags = (1 as libc::c_int) << 2 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int
            | def_flags & (1 as libc::c_int) << 0 as libc::c_int;
        val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    prs = find_own_property1(p, prop);
    if !prs.is_null() {
        return 0 as libc::c_int;
    }
    if ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0 {
        return 0 as libc::c_int;
    }
    pr = add_property(ctx, p, prop, flags);
    if pr.is_null() as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    (*pr).u.value = val;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_DefineGlobalFunction(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut func: JSValue,
    mut def_flags: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut flags: libc::c_int = 0;
    p = (*ctx).global_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property1(p, prop);
    flags = (1 as libc::c_int) << 13 as libc::c_int
        | (1 as libc::c_int) << 14 as libc::c_int;
    if prs.is_null()
        || (*prs).flags() as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
    {
        flags
            |= (1 as libc::c_int) << 2 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int | def_flags
                | (1 as libc::c_int) << 8 as libc::c_int
                | (1 as libc::c_int) << 9 as libc::c_int
                | (1 as libc::c_int) << 10 as libc::c_int;
    }
    if JS_DefineProperty(
        ctx,
        (*ctx).global_obj,
        prop,
        func,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        flags,
    ) < 0 as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_GetGlobalVar(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut throw_ref_error: BOOL,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property(&mut pr, p, prop);
    if !prs.is_null() {
        if (JS_IsUninitialized((*pr).u.value) != 0) as libc::c_int as libc::c_long != 0 {
            return JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
        }
        return JS_DupValue(ctx, (*pr).u.value);
    }
    return JS_GetPropertyInternal(
        ctx,
        (*ctx).global_obj,
        prop,
        (*ctx).global_obj,
        throw_ref_error,
    );
}
unsafe extern "C" fn JS_GetGlobalVarRef(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property(&mut pr, p, prop);
    if !prs.is_null() {
        if (JS_IsUninitialized((*pr).u.value) != 0) as libc::c_int as libc::c_long != 0 {
            JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
            return -(1 as libc::c_int);
        }
        if ((*prs).flags() as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int == 0)
            as libc::c_int as libc::c_long != 0
        {
            return JS_ThrowTypeErrorReadOnly(
                ctx,
                (1 as libc::c_int) << 14 as libc::c_int,
                prop,
            );
        }
        *sp.offset(0 as libc::c_int as isize) = JS_DupValue(ctx, (*ctx).global_var_obj);
    } else {
        let mut ret: libc::c_int = 0;
        ret = JS_HasProperty(ctx, (*ctx).global_obj, prop);
        if ret < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if ret != 0 {
            *sp.offset(0 as libc::c_int as isize) = JS_DupValue(ctx, (*ctx).global_obj);
        } else {
            *sp
                .offset(
                    0 as libc::c_int as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    *sp.offset(1 as libc::c_int as isize) = JS_AtomToValue(ctx, prop);
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_CheckGlobalVar(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut ret: libc::c_int = 0;
    p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property1(p, prop);
    if !prs.is_null() {
        ret = TRUE as libc::c_int;
    } else {
        ret = JS_HasProperty(ctx, (*ctx).global_obj, prop);
        if ret < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
    }
    return ret;
}
unsafe extern "C" fn JS_SetGlobalVar(
    mut ctx: *mut JSContext,
    mut prop: JSAtom,
    mut val: JSValue,
    mut flag: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut flags: libc::c_int = 0;
    p = (*ctx).global_var_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property(&mut pr, p, prop);
    if !prs.is_null() {
        if flag != 1 as libc::c_int {
            if (JS_IsUninitialized((*pr).u.value) != 0) as libc::c_int as libc::c_long
                != 0
            {
                JS_FreeValue(ctx, val);
                JS_ThrowReferenceErrorUninitialized(ctx, (*prs).atom);
                return -(1 as libc::c_int);
            }
            if ((*prs).flags() as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
                == 0) as libc::c_int as libc::c_long != 0
            {
                JS_FreeValue(ctx, val);
                return JS_ThrowTypeErrorReadOnly(
                    ctx,
                    (1 as libc::c_int) << 14 as libc::c_int,
                    prop,
                );
            }
        }
        set_value(ctx, &mut (*pr).u.value, val);
        return 0 as libc::c_int;
    }
    flags = (1 as libc::c_int) << 15 as libc::c_int;
    if is_strict_mode(ctx) != 0 {
        flags |= (1 as libc::c_int) << 16 as libc::c_int;
    }
    return JS_SetPropertyInternal(ctx, (*ctx).global_obj, prop, val, flags);
}
#[no_mangle]
pub unsafe extern "C" fn JS_DeleteProperty(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut obj1: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut res: libc::c_int = 0;
    obj1 = JS_ToObject(ctx, obj);
    if JS_IsException(obj1) != 0 {
        return -(1 as libc::c_int);
    }
    p = obj1 as intptr_t as *mut libc::c_void as *mut JSObject;
    res = delete_property(ctx, p, prop);
    JS_FreeValue(ctx, obj1);
    if res != FALSE as libc::c_int {
        return res;
    }
    if flags & (1 as libc::c_int) << 14 as libc::c_int != 0
        || flags & (1 as libc::c_int) << 15 as libc::c_int != 0
            && is_strict_mode(ctx) != 0
    {
        JS_ThrowTypeError(
            ctx,
            b"could not delete property\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    return FALSE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_DeletePropertyInt64(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut idx: int64_t,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut prop: JSAtom = 0;
    let mut res: libc::c_int = 0;
    if idx as uint64_t
        <= ((1 as libc::c_uint) << 31 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulonglong
    {
        return JS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx as uint32_t), flags);
    }
    prop = JS_NewAtomInt64(ctx, idx);
    if prop == 0 as libc::c_int as libc::c_uint {
        return -(1 as libc::c_int);
    }
    res = JS_DeleteProperty(ctx, obj, prop, flags);
    JS_FreeAtom(ctx, prop);
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsFunction(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
        13 => return TRUE as libc::c_int,
        41 => return (*(*p).u.proxy_data).is_func as libc::c_int,
        _ => {
            return ((*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .call)
                .is_some() as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsCFunction(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut func: Option::<JSCFunction>,
    mut magic: libc::c_int,
) -> BOOL {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_C_FUNCTION as libc::c_int
    {
        return ((*p).u.cfunc.c_function.generic == func
            && (*p).u.cfunc.magic as libc::c_int == magic) as libc::c_int
    } else {
        return FALSE as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsConstructor(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    return ((*p).c2rust_unnamed.c2rust_unnamed).is_constructor() as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetConstructorBit(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut val: BOOL,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (func_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh240 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh240).set_is_constructor(val as uint8_t);
    return TRUE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsError(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    return ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_ERROR as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsUncatchableError(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> BOOL {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    return ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_ERROR as libc::c_int
        && ((*p).c2rust_unnamed.c2rust_unnamed).is_uncatchable_error() as libc::c_int
            != 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetUncatchableError(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut flag: BOOL,
) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_ERROR as libc::c_int
    {
        let ref mut fresh241 = (*p).c2rust_unnamed.c2rust_unnamed;
        (*fresh241).set_is_uncatchable_error(flag as uint8_t);
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_ResetUncatchableError(mut ctx: *mut JSContext) {
    JS_SetUncatchableError(ctx, (*(*ctx).rt).current_exception, FALSE as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetOpaque(mut obj: JSValue, mut opaque: *mut libc::c_void) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        let ref mut fresh242 = (*p).u.opaque;
        *fresh242 = opaque;
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetOpaque(
    mut obj: JSValue,
    mut class_id: JSClassID,
) -> *mut libc::c_void {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return 0 as *mut libc::c_void;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_uint != class_id {
        return 0 as *mut libc::c_void;
    }
    return (*p).u.opaque;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetOpaque2(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut class_id: JSClassID,
) -> *mut libc::c_void {
    let mut p: *mut libc::c_void = JS_GetOpaque(obj, class_id);
    if p.is_null() as libc::c_int as libc::c_long != 0 {
        JS_ThrowTypeErrorInvalidClass(ctx, class_id as libc::c_int);
    }
    return p;
}
unsafe extern "C" fn JS_ToPrimitiveFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut hint: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut force_ordinary: BOOL = 0;
    let mut method_name: JSAtom = 0;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return val;
    }
    force_ordinary = hint & (1 as libc::c_int) << 4 as libc::c_int;
    hint &= !((1 as libc::c_int) << 4 as libc::c_int);
    if force_ordinary == 0 {
        method = JS_GetProperty(
            ctx,
            val,
            JS_ATOM_Symbol_toPrimitive as libc::c_int as JSAtom,
        );
        if JS_IsException(method) != 0 {
            current_block = 15446955057728179307;
        } else if JS_IsUndefined(method) == 0 && JS_IsNull(method) == 0 {
            let mut atom: JSAtom = 0;
            let mut arg: JSValue = 0;
            match hint {
                0 => {
                    atom = JS_ATOM_string as libc::c_int as JSAtom;
                }
                1 => {
                    atom = JS_ATOM_number as libc::c_int as JSAtom;
                }
                2 | _ => {
                    atom = JS_ATOM_default as libc::c_int as JSAtom;
                }
            }
            arg = JS_AtomToString(ctx, atom);
            ret = JS_CallFree(
                ctx,
                method,
                val,
                1 as libc::c_int,
                &mut arg as *mut JSValue,
            );
            JS_FreeValue(ctx, arg);
            if JS_IsException(ret) != 0 {
                current_block = 15446955057728179307;
            } else {
                JS_FreeValue(ctx, val);
                if (ret >> 32 as libc::c_int) as libc::c_int
                    != JS_TAG_OBJECT as libc::c_int
                {
                    return ret;
                }
                JS_FreeValue(ctx, ret);
                return JS_ThrowTypeError(
                    ctx,
                    b"toPrimitive\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            current_block = 18386322304582297246;
        }
    } else {
        current_block = 18386322304582297246;
    }
    match current_block {
        18386322304582297246 => {
            if hint != 0 as libc::c_int {
                hint = 1 as libc::c_int;
            }
            i = 0 as libc::c_int;
            loop {
                if !(i < 2 as libc::c_int) {
                    current_block = 1434579379687443766;
                    break;
                }
                if i ^ hint == 0 as libc::c_int {
                    method_name = JS_ATOM_toString as libc::c_int as JSAtom;
                } else {
                    method_name = JS_ATOM_valueOf as libc::c_int as JSAtom;
                }
                method = JS_GetProperty(ctx, val, method_name);
                if JS_IsException(method) != 0 {
                    current_block = 15446955057728179307;
                    break;
                }
                if JS_IsFunction(ctx, method) != 0 {
                    ret = JS_CallFree(
                        ctx,
                        method,
                        val,
                        0 as libc::c_int,
                        0 as *mut JSValue,
                    );
                    if JS_IsException(ret) != 0 {
                        current_block = 15446955057728179307;
                        break;
                    }
                    if (ret >> 32 as libc::c_int) as libc::c_int
                        != JS_TAG_OBJECT as libc::c_int
                    {
                        JS_FreeValue(ctx, val);
                        return ret;
                    }
                    JS_FreeValue(ctx, ret);
                } else {
                    JS_FreeValue(ctx, method);
                }
                i += 1;
            }
            match current_block {
                15446955057728179307 => {}
                _ => {
                    JS_ThrowTypeError(
                        ctx,
                        b"toPrimitive\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ToPrimitive(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut hint: libc::c_int,
) -> JSValue {
    return JS_ToPrimitiveFree(ctx, JS_DupValue(ctx, val), hint);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetIsHTMLDDA(mut ctx: *mut JSContext, mut obj: JSValue) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh243 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh243).set_is_HTMLDDA(TRUE as libc::c_int as uint8_t);
}
#[inline]
unsafe extern "C" fn JS_IsHTMLDDA(mut ctx: *mut JSContext, mut obj: JSValue) -> BOOL {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return FALSE as libc::c_int;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    return ((*p).c2rust_unnamed.c2rust_unnamed).is_HTMLDDA() as BOOL;
}
unsafe extern "C" fn JS_ToBoolFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = (val >> 32 as libc::c_int) as libc::c_int as uint32_t;
    match tag {
        0 => return (val as libc::c_int != 0 as libc::c_int) as libc::c_int,
        1 | 2 | 3 => return val as libc::c_int,
        6 => return -(1 as libc::c_int),
        4294967289 => {
            let mut ret: BOOL = ((*(val as intptr_t as *mut libc::c_void
                as *mut JSString))
                .len() as libc::c_int != 0 as libc::c_int) as libc::c_int;
            JS_FreeValue(ctx, val);
            return ret;
        }
        4294967295 => {
            let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void
                as *mut JSObject;
            let mut ret_0: BOOL = 0;
            ret_0 = (((*p).c2rust_unnamed.c2rust_unnamed).is_HTMLDDA() == 0)
                as libc::c_int;
            JS_FreeValue(ctx, val);
            return ret_0;
        }
        _ => {
            if tag.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
                >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int)
                    as libc::c_uint
            {
                let mut d: libc::c_double = JS_VALUE_GET_FLOAT64(val);
                return (isnan(d) == 0 && d != 0 as libc::c_int as libc::c_double)
                    as libc::c_int;
            } else {
                JS_FreeValue(ctx, val);
                return TRUE as libc::c_int;
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToBool(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToBoolFree(ctx, JS_DupValue(ctx, val));
}
unsafe extern "C" fn skip_spaces(mut pc: *const libc::c_char) -> libc::c_int {
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut p_next: *const uint8_t = 0 as *const uint8_t;
    let mut p_start: *const uint8_t = 0 as *const uint8_t;
    let mut c: uint32_t = 0;
    p_start = pc as *const uint8_t;
    p = p_start;
    loop {
        c = *p as uint32_t;
        if c < 128 as libc::c_int as libc::c_uint {
            if !(c >= 0x9 as libc::c_int as libc::c_uint
                && c <= 0xd as libc::c_int as libc::c_uint
                || c == 0x20 as libc::c_int as libc::c_uint)
            {
                break;
            }
            p = p.offset(1);
        } else {
            c = unicode_from_utf8(p, 6 as libc::c_int, &mut p_next) as uint32_t;
            if lre_is_space(c as libc::c_int) == 0 {
                break;
            }
            p = p_next;
        }
    }
    return p.offset_from(p_start) as libc::c_long as libc::c_int;
}
#[inline]
unsafe extern "C" fn to_digit(mut c: libc::c_int) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        return c - '0' as i32
    } else if c >= 'A' as i32 && c <= 'Z' as i32 {
        return c - 'A' as i32 + 10 as libc::c_int
    } else if c >= 'a' as i32 && c <= 'z' as i32 {
        return c - 'a' as i32 + 10 as libc::c_int
    } else {
        return 36 as libc::c_int
    };
}
unsafe extern "C" fn js_strtod(
    mut p: *const libc::c_char,
    mut radix: libc::c_int,
    mut is_float: BOOL,
) -> libc::c_double {
    let mut d: libc::c_double = 0.;
    let mut c: libc::c_int = 0;
    if is_float == 0 || radix != 10 as libc::c_int {
        let mut n_max: uint64_t = 0;
        let mut n: uint64_t = 0;
        let mut int_exp: libc::c_int = 0;
        let mut is_neg: libc::c_int = 0;
        is_neg = 0 as libc::c_int;
        if *p as libc::c_int == '-' as i32 {
            is_neg = 1 as libc::c_int;
            p = p.offset(1);
        }
        while *p as libc::c_int == '0' as i32 {
            p = p.offset(1);
        }
        n = 0 as libc::c_int as uint64_t;
        if radix == 10 as libc::c_int {
            n_max = (-(1 as libc::c_int) as uint64_t)
                .wrapping_sub(9 as libc::c_int as libc::c_ulonglong)
                .wrapping_div(10 as libc::c_int as libc::c_ulonglong);
        } else {
            n_max = (-(1 as libc::c_int) as uint64_t)
                .wrapping_sub((radix - 1 as libc::c_int) as libc::c_ulonglong)
                .wrapping_div(radix as libc::c_ulonglong);
        }
        int_exp = 0 as libc::c_int;
        while *p as libc::c_int != '\0' as i32 {
            c = to_digit(*p as uint8_t as libc::c_int);
            if c >= radix {
                break;
            }
            if n <= n_max {
                n = n
                    .wrapping_mul(radix as libc::c_ulonglong)
                    .wrapping_add(c as libc::c_ulonglong);
            } else {
                int_exp += 1;
            }
            p = p.offset(1);
        }
        d = n as libc::c_double;
        if int_exp != 0 as libc::c_int {
            d *= pow(radix as libc::c_double, int_exp as libc::c_double);
        }
        if is_neg != 0 {
            d = -d;
        }
    } else {
        d = strtod(p, 0 as *mut *mut libc::c_char);
    }
    return d;
}
unsafe extern "C" fn js_atof(
    mut ctx: *mut JSContext,
    mut str: *const libc::c_char,
    mut pp: *mut *const libc::c_char,
    mut radix: libc::c_int,
    mut flags: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut p_start: *const libc::c_char = 0 as *const libc::c_char;
    let mut sep: libc::c_int = 0;
    let mut is_neg: libc::c_int = 0;
    let mut is_float: BOOL = 0;
    let mut has_legacy_octal: BOOL = 0;
    let mut atod_type: libc::c_int = flags & (3 as libc::c_int) << 7 as libc::c_int;
    let mut buf1: [libc::c_char; 64] = [0; 64];
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut buf_allocated: BOOL = FALSE as libc::c_int;
    let mut val: JSValue = 0;
    sep = if flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        '_' as i32
    } else {
        256 as libc::c_int
    };
    has_legacy_octal = FALSE as libc::c_int;
    p = str;
    p_start = p;
    is_neg = 0 as libc::c_int;
    if *p.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32 {
        p = p.offset(1);
        p_start = p_start.offset(1);
        if flags & (1 as libc::c_int) << 10 as libc::c_int == 0 {
            current_block = 5214118336743509411;
        } else {
            current_block = 5689001924483802034;
        }
    } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        p = p.offset(1);
        p_start = p_start.offset(1);
        is_neg = 1 as libc::c_int;
        if flags & (1 as libc::c_int) << 10 as libc::c_int == 0 {
            current_block = 5214118336743509411;
        } else {
            current_block = 5689001924483802034;
        }
    } else {
        current_block = 5689001924483802034;
    }
    match current_block {
        5689001924483802034 => {
            if *p.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32 {
                if (*p.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
                    || *p.offset(1 as libc::c_int as isize) as libc::c_int == 'X' as i32)
                    && (radix == 0 as libc::c_int || radix == 16 as libc::c_int)
                {
                    p = p.offset(2 as libc::c_int as isize);
                    radix = 16 as libc::c_int;
                    current_block = 9007357115414505193;
                } else if (*p.offset(1 as libc::c_int as isize) as libc::c_int
                    == 'o' as i32
                    || *p.offset(1 as libc::c_int as isize) as libc::c_int == 'O' as i32)
                    && radix == 0 as libc::c_int
                    && flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                {
                    p = p.offset(2 as libc::c_int as isize);
                    radix = 8 as libc::c_int;
                    current_block = 9007357115414505193;
                } else if (*p.offset(1 as libc::c_int as isize) as libc::c_int
                    == 'b' as i32
                    || *p.offset(1 as libc::c_int as isize) as libc::c_int == 'B' as i32)
                    && radix == 0 as libc::c_int
                    && flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                {
                    p = p.offset(2 as libc::c_int as isize);
                    radix = 2 as libc::c_int;
                    current_block = 9007357115414505193;
                } else if *p.offset(1 as libc::c_int as isize) as libc::c_int
                    >= '0' as i32
                    && *p.offset(1 as libc::c_int as isize) as libc::c_int <= '9' as i32
                    && radix == 0 as libc::c_int
                    && flags & (1 as libc::c_int) << 4 as libc::c_int != 0
                {
                    let mut i_0: libc::c_int = 0;
                    has_legacy_octal = TRUE as libc::c_int;
                    sep = 256 as libc::c_int;
                    i_0 = 1 as libc::c_int;
                    while *p.offset(i_0 as isize) as libc::c_int >= '0' as i32
                        && *p.offset(i_0 as isize) as libc::c_int <= '7' as i32
                    {
                        i_0 += 1;
                    }
                    if *p.offset(i_0 as isize) as libc::c_int == '8' as i32
                        || *p.offset(i_0 as isize) as libc::c_int == '9' as i32
                    {
                        current_block = 3689906465960840878;
                    } else {
                        p = p.offset(1 as libc::c_int as isize);
                        radix = 8 as libc::c_int;
                        current_block = 9007357115414505193;
                    }
                } else {
                    current_block = 3689906465960840878;
                }
                match current_block {
                    3689906465960840878 => {}
                    _ => {
                        if to_digit(*p as uint8_t as libc::c_int) >= radix {
                            current_block = 9725864330820782896;
                        } else {
                            current_block = 3689906465960840878;
                        }
                    }
                }
            } else {
                current_block = 5214118336743509411;
            }
        }
        _ => {}
    }
    match current_block {
        5214118336743509411 => {
            if flags & (1 as libc::c_int) << 0 as libc::c_int == 0
                && (atod_type == (0 as libc::c_int) << 7 as libc::c_int
                    || atod_type == (2 as libc::c_int) << 7 as libc::c_int)
                && strstart(p, b"Infinity\0" as *const u8 as *const libc::c_char, &mut p)
                    != 0
            {
                let mut d: libc::c_double = 1.0f64 / 0.0f64;
                if is_neg != 0 {
                    d = -d;
                }
                val = JS_NewFloat64(ctx, d);
                current_block = 10987478406730725146;
            } else {
                current_block = 3689906465960840878;
            }
        }
        _ => {}
    }
    match current_block {
        3689906465960840878 => {
            if radix == 0 as libc::c_int {
                radix = 10 as libc::c_int;
            }
            is_float = FALSE as libc::c_int;
            p_start = p;
            while to_digit(*p as uint8_t as libc::c_int) < radix
                || *p as libc::c_int == sep
                    && (radix != 10 as libc::c_int
                        || p != p_start.offset(1 as libc::c_int as isize)
                        || *p.offset(-(1 as libc::c_int) as isize) as libc::c_int
                            != '0' as i32)
                    && to_digit(
                        *p.offset(1 as libc::c_int as isize) as uint8_t as libc::c_int,
                    ) < radix
            {
                p = p.offset(1);
            }
            if flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                if *p as libc::c_int == '.' as i32
                    && (p > p_start
                        || to_digit(
                            *p.offset(1 as libc::c_int as isize) as uint8_t
                                as libc::c_int,
                        ) < radix)
                {
                    is_float = TRUE as libc::c_int;
                    p = p.offset(1);
                    if *p as libc::c_int == sep {
                        current_block = 9725864330820782896;
                    } else {
                        while to_digit(*p as uint8_t as libc::c_int) < radix
                            || *p as libc::c_int == sep
                                && to_digit(
                                    *p.offset(1 as libc::c_int as isize) as uint8_t
                                        as libc::c_int,
                                ) < radix
                        {
                            p = p.offset(1);
                        }
                        current_block = 14001958660280927786;
                    }
                } else {
                    current_block = 14001958660280927786;
                }
                match current_block {
                    9725864330820782896 => {}
                    _ => {
                        if p > p_start
                            && ((*p as libc::c_int == 'e' as i32
                                || *p as libc::c_int == 'E' as i32)
                                && radix == 10 as libc::c_int
                                || (*p as libc::c_int == 'p' as i32
                                    || *p as libc::c_int == 'P' as i32)
                                    && (radix == 2 as libc::c_int || radix == 8 as libc::c_int
                                        || radix == 16 as libc::c_int))
                        {
                            let mut p1: *const libc::c_char = p
                                .offset(1 as libc::c_int as isize);
                            is_float = TRUE as libc::c_int;
                            if *p1 as libc::c_int == '+' as i32 {
                                p1 = p1.offset(1);
                            } else if *p1 as libc::c_int == '-' as i32 {
                                p1 = p1.offset(1);
                            }
                            if is_digit(*p1 as uint8_t as libc::c_int) != 0 {
                                p = p1.offset(1 as libc::c_int as isize);
                                while is_digit(*p as uint8_t as libc::c_int) != 0
                                    || *p as libc::c_int == sep
                                        && is_digit(
                                            *p.offset(1 as libc::c_int as isize) as uint8_t
                                                as libc::c_int,
                                        ) != 0
                                {
                                    p = p.offset(1);
                                }
                            }
                        }
                        current_block = 15514718523126015390;
                    }
                }
            } else {
                current_block = 15514718523126015390;
            }
            match current_block {
                9725864330820782896 => {}
                _ => {
                    if p == p_start {
                        current_block = 9725864330820782896;
                    } else {
                        buf = buf1.as_mut_ptr();
                        buf_allocated = FALSE as libc::c_int;
                        len = p.offset_from(p_start) as libc::c_long as libc::c_int;
                        if ((len + 2 as libc::c_int) as libc::c_ulong
                            > ::core::mem::size_of::<[libc::c_char; 64]>()
                                as libc::c_ulong) as libc::c_int as libc::c_long != 0
                        {
                            buf = js_malloc_rt(
                                (*ctx).rt,
                                (len + 2 as libc::c_int) as size_t,
                            ) as *mut libc::c_char;
                            if buf.is_null() {
                                val = JS_ThrowOutOfMemory(ctx);
                                current_block = 10987478406730725146;
                            } else {
                                buf_allocated = TRUE as libc::c_int;
                                current_block = 14329534724295951598;
                            }
                        } else {
                            current_block = 14329534724295951598;
                        }
                        match current_block {
                            10987478406730725146 => {}
                            _ => {
                                j = 0 as libc::c_int;
                                if is_neg != 0 {
                                    let fresh244 = j;
                                    j = j + 1;
                                    *buf.offset(fresh244 as isize) = '-' as i32 as libc::c_char;
                                }
                                i = 0 as libc::c_int;
                                while i < len {
                                    if *p_start.offset(i as isize) as libc::c_int != '_' as i32
                                    {
                                        let fresh245 = j;
                                        j = j + 1;
                                        *buf
                                            .offset(fresh245 as isize) = *p_start.offset(i as isize);
                                    }
                                    i += 1;
                                }
                                *buf.offset(j as isize) = '\0' as i32 as libc::c_char;
                                let mut d_0: libc::c_double = 0.;
                                if is_float != 0 && radix != 10 as libc::c_int {
                                    current_block = 9725864330820782896;
                                } else {
                                    d_0 = js_strtod(buf, radix, is_float);
                                    val = JS_NewFloat64(ctx, d_0);
                                    current_block = 10987478406730725146;
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        9725864330820782896 => {
            val = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
                .wrapping_sub(
                    ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                        + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
                );
        }
        _ => {}
    }
    if buf_allocated != 0 {
        js_free_rt((*ctx).rt, buf as *mut libc::c_void);
    }
    if !pp.is_null() {
        *pp = p;
    }
    return val;
}
unsafe extern "C" fn JS_ToNumberHintFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut flag: JSToNumberHintEnum,
) -> JSValue {
    let mut tag: uint32_t = 0;
    let mut ret: JSValue = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            7 | 0 | 6 => {
                ret = val;
                break;
            }
            1 | 2 => {
                ret = JS_NewInt32(ctx, val as libc::c_int);
                break;
            }
            3 => {
                ret = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
                    .wrapping_sub(
                        ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                            + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
                    );
                break;
            }
            4294967295 => {
                val = JS_ToPrimitiveFree(ctx, val, 1 as libc::c_int);
                if JS_IsException(val) != 0 {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
            }
            4294967289 => {
                let mut str: *const libc::c_char = 0 as *const libc::c_char;
                let mut p: *const libc::c_char = 0 as *const libc::c_char;
                let mut len: size_t = 0;
                str = JS_ToCStringLen(ctx, &mut len, val);
                JS_FreeValue(ctx, val);
                if str.is_null() {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                p = str;
                p = p.offset(skip_spaces(p) as isize);
                if p.offset_from(str) as libc::c_long as libc::c_ulong == len {
                    ret = JS_NewInt32(ctx, 0 as libc::c_int);
                } else {
                    let mut flags: libc::c_int = (1 as libc::c_int) << 2 as libc::c_int;
                    ret = js_atof(ctx, p, &mut p, 0 as libc::c_int, flags);
                    if JS_IsException(ret) == 0 {
                        p = p.offset(skip_spaces(p) as isize);
                        if p.offset_from(str) as libc::c_long as libc::c_ulong != len {
                            JS_FreeValue(ctx, ret);
                            ret = (0x7ff8000000000000 as libc::c_longlong
                                as libc::c_ulonglong)
                                .wrapping_sub(
                                    ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                                        + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
                                );
                        }
                    }
                }
                JS_FreeCString(ctx, str);
                break;
            }
            4294967288 => {
                JS_FreeValue(ctx, val);
                return JS_ThrowTypeError(
                    ctx,
                    b"cannot convert symbol to number\0" as *const u8
                        as *const libc::c_char,
                );
            }
            _ => {
                JS_FreeValue(ctx, val);
                ret = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
                    .wrapping_sub(
                        ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                            + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
                    );
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn JS_ToNumberFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);
}
unsafe extern "C" fn JS_ToNumericFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);
}
unsafe extern "C" fn JS_ToNumeric(mut ctx: *mut JSContext, mut val: JSValue) -> JSValue {
    return JS_ToNumericFree(ctx, JS_DupValue(ctx, val));
}
unsafe extern "C" fn __JS_ToFloat64Free(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_double,
    mut val: JSValue,
) -> libc::c_int {
    let mut d: libc::c_double = 0.;
    let mut tag: uint32_t = 0;
    val = JS_ToNumberFree(ctx, val);
    if JS_IsException(val) != 0 {
        *pres = 9999.9999f64;
        return -(1 as libc::c_int);
    }
    tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
    match tag {
        0 => {
            d = val as libc::c_int as libc::c_double;
        }
        7 => {
            d = JS_VALUE_GET_FLOAT64(val);
        }
        _ => {
            abort();
        }
    }
    *pres = d;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn JS_ToFloat64Free(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_double,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    tag = (val >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag <= JS_TAG_NULL as libc::c_int as libc::c_uint {
        *pres = val as libc::c_int as libc::c_double;
        return 0 as libc::c_int;
    } else if tag.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
        >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int) as libc::c_uint
    {
        *pres = JS_VALUE_GET_FLOAT64(val);
        return 0 as libc::c_int;
    } else {
        return __JS_ToFloat64Free(ctx, pres, val)
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToFloat64(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_double,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToFloat64Free(ctx, pres, JS_DupValue(ctx, val));
}
unsafe extern "C" fn JS_ToNumber(mut ctx: *mut JSContext, mut val: JSValue) -> JSValue {
    return JS_ToNumberFree(ctx, JS_DupValue(ctx, val));
}
unsafe extern "C" fn JS_ToInt32SatFree(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_int,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    let mut ret: libc::c_int = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            0 | 1 | 2 | 3 => {
                ret = val as libc::c_int;
                break;
            }
            6 => {
                *pres = 0 as libc::c_int;
                return -(1 as libc::c_int);
            }
            7 => {
                let mut d: libc::c_double = JS_VALUE_GET_FLOAT64(val);
                if isnan(d) != 0 {
                    ret = 0 as libc::c_int;
                } else if d < 0x80000000 as libc::c_uint as libc::c_double {
                    ret = 0x80000000 as libc::c_uint as libc::c_int;
                } else if d > 0x7fffffff as libc::c_int as libc::c_double {
                    ret = 0x7fffffff as libc::c_int;
                } else {
                    ret = d as libc::c_int;
                }
                break;
            }
            _ => {
                val = JS_ToNumberFree(ctx, val);
                if JS_IsException(val) != 0 {
                    *pres = 0 as libc::c_int;
                    return -(1 as libc::c_int);
                }
            }
        }
    }
    *pres = ret;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt32Sat(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_int,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt32Clamp(
    mut ctx: *mut JSContext,
    mut pres: *mut libc::c_int,
    mut val: JSValue,
    mut min: libc::c_int,
    mut max: libc::c_int,
    mut min_offset: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));
    if res == 0 as libc::c_int {
        if *pres < min {
            *pres += min_offset;
            if *pres < min {
                *pres = min;
            }
        } else if *pres > max {
            *pres = max;
        }
    }
    return res;
}
unsafe extern "C" fn JS_ToInt64SatFree(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            0 | 1 | 2 | 3 => {
                *pres = val as libc::c_int as int64_t;
                return 0 as libc::c_int;
            }
            6 => {
                *pres = 0 as libc::c_int as int64_t;
                return -(1 as libc::c_int);
            }
            7 => {
                let mut d: libc::c_double = JS_VALUE_GET_FLOAT64(val);
                if isnan(d) != 0 {
                    *pres = 0 as libc::c_int as int64_t;
                } else if d < 0x8000000000000000 as libc::c_ulonglong as libc::c_double {
                    *pres = 0x8000000000000000 as libc::c_ulonglong as int64_t;
                } else if d > 0x7fffffffffffffff as libc::c_longlong as libc::c_double {
                    *pres = 0x7fffffffffffffff as libc::c_longlong;
                } else {
                    *pres = d as int64_t;
                }
                return 0 as libc::c_int;
            }
            _ => {
                val = JS_ToNumberFree(ctx, val);
                if JS_IsException(val) != 0 {
                    *pres = 0 as libc::c_int as int64_t;
                    return -(1 as libc::c_int);
                }
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt64Sat(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt64Clamp(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
    mut min: int64_t,
    mut max: int64_t,
    mut neg_offset: int64_t,
) -> libc::c_int {
    let mut res: libc::c_int = JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));
    if res == 0 as libc::c_int {
        if *pres < 0 as libc::c_int as libc::c_longlong {
            *pres += neg_offset;
        }
        if *pres < min {
            *pres = min;
        } else if *pres > max {
            *pres = max;
        }
    }
    return res;
}
unsafe extern "C" fn JS_ToInt64Free(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    let mut ret: int64_t = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            0 | 1 | 2 | 3 => {
                ret = val as libc::c_int as int64_t;
                break;
            }
            7 => {
                let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
                let mut d: libc::c_double = 0.;
                let mut e: libc::c_int = 0;
                d = JS_VALUE_GET_FLOAT64(val);
                u.d = d;
                e = (u.u64_0 >> 52 as libc::c_int
                    & 0x7ff as libc::c_int as libc::c_ulonglong) as libc::c_int;
                if (e <= 1023 as libc::c_int + 62 as libc::c_int) as libc::c_int
                    as libc::c_long != 0
                {
                    ret = d as int64_t;
                } else if e
                    <= 1023 as libc::c_int + 62 as libc::c_int + 53 as libc::c_int
                {
                    let mut v: uint64_t = 0;
                    v = u.u64_0
                        & ((1 as libc::c_int as uint64_t) << 52 as libc::c_int)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulonglong)
                        | (1 as libc::c_int as uint64_t) << 52 as libc::c_int;
                    ret = (v << e - 1023 as libc::c_int - 52 as libc::c_int) as int64_t;
                    if u.u64_0 >> 63 as libc::c_int != 0 {
                        ret = -ret;
                    }
                } else {
                    ret = 0 as libc::c_int as int64_t;
                }
                break;
            }
            _ => {
                val = JS_ToNumberFree(ctx, val);
                if JS_IsException(val) != 0 {
                    *pres = 0 as libc::c_int as int64_t;
                    return -(1 as libc::c_int);
                }
            }
        }
    }
    *pres = ret;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt64(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt64Free(ctx, pres, JS_DupValue(ctx, val));
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt64Ext(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    if JS_IsBigInt(ctx, val) != 0 {
        return JS_ToBigInt64(ctx, pres, val)
    } else {
        return JS_ToInt64(ctx, pres, val)
    };
}
unsafe extern "C" fn JS_ToInt32Free(
    mut ctx: *mut JSContext,
    mut pres: *mut int32_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    let mut ret: int32_t = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            0 | 1 | 2 | 3 => {
                ret = val as libc::c_int;
                break;
            }
            7 => {
                let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
                let mut d: libc::c_double = 0.;
                let mut e: libc::c_int = 0;
                d = JS_VALUE_GET_FLOAT64(val);
                u.d = d;
                e = (u.u64_0 >> 52 as libc::c_int
                    & 0x7ff as libc::c_int as libc::c_ulonglong) as libc::c_int;
                if (e <= 1023 as libc::c_int + 30 as libc::c_int) as libc::c_int
                    as libc::c_long != 0
                {
                    ret = d as int32_t;
                } else if e
                    <= 1023 as libc::c_int + 30 as libc::c_int + 53 as libc::c_int
                {
                    let mut v: uint64_t = 0;
                    v = u.u64_0
                        & ((1 as libc::c_int as uint64_t) << 52 as libc::c_int)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulonglong)
                        | (1 as libc::c_int as uint64_t) << 52 as libc::c_int;
                    v = v
                        << e - 1023 as libc::c_int - 52 as libc::c_int
                            + 32 as libc::c_int;
                    ret = (v >> 32 as libc::c_int) as int32_t;
                    if u.u64_0 >> 63 as libc::c_int != 0 {
                        ret = -ret;
                    }
                } else {
                    ret = 0 as libc::c_int;
                }
                break;
            }
            _ => {
                val = JS_ToNumberFree(ctx, val);
                if JS_IsException(val) != 0 {
                    *pres = 0 as libc::c_int;
                    return -(1 as libc::c_int);
                }
            }
        }
    }
    *pres = ret;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToInt32(
    mut ctx: *mut JSContext,
    mut pres: *mut int32_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt32Free(ctx, pres, JS_DupValue(ctx, val));
}
#[inline]
unsafe extern "C" fn JS_ToUint32Free(
    mut ctx: *mut JSContext,
    mut pres: *mut uint32_t,
    mut val: JSValue,
) -> libc::c_int {
    return JS_ToInt32Free(ctx, pres as *mut int32_t, val);
}
unsafe extern "C" fn JS_ToUint8ClampFree(
    mut ctx: *mut JSContext,
    mut pres: *mut int32_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut tag: uint32_t = 0;
    let mut res: libc::c_int = 0;
    loop {
        tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
        match tag {
            0 | 1 | 2 | 3 => {
                res = val as libc::c_int;
                res = max_int(0 as libc::c_int, min_int(255 as libc::c_int, res));
                break;
            }
            7 => {
                let mut d: libc::c_double = JS_VALUE_GET_FLOAT64(val);
                if isnan(d) != 0 {
                    res = 0 as libc::c_int;
                } else if d < 0 as libc::c_int as libc::c_double {
                    res = 0 as libc::c_int;
                } else if d > 255 as libc::c_int as libc::c_double {
                    res = 255 as libc::c_int;
                } else {
                    res = lrint(d) as libc::c_int;
                }
                break;
            }
            _ => {
                val = JS_ToNumberFree(ctx, val);
                if JS_IsException(val) != 0 {
                    *pres = 0 as libc::c_int;
                    return -(1 as libc::c_int);
                }
            }
        }
    }
    *pres = res;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_ToArrayLengthFree(
    mut ctx: *mut JSContext,
    mut plen: *mut uint32_t,
    mut val: JSValue,
    mut is_array_ctor: BOOL,
) -> libc::c_int {
    let mut len1: uint32_t = 0;
    let mut current_block: u64;
    let mut tag: uint32_t = 0;
    let mut len: uint32_t = 0;
    tag = (val >> 32 as libc::c_int) as libc::c_int as uint32_t;
    match tag {
        0 | 1 | 2 => {
            let mut v: libc::c_int = 0;
            v = val as libc::c_int;
            if v < 0 as libc::c_int {
                current_block = 7452196606062742386;
            } else {
                len = v as uint32_t;
                current_block = 18377268871191777778;
            }
        }
        _ => {
            if tag.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
                >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int)
                    as libc::c_uint
            {
                let mut d: libc::c_double = 0.;
                d = JS_VALUE_GET_FLOAT64(val);
                len = d as uint32_t;
                if len as libc::c_double != d {
                    current_block = 7452196606062742386;
                } else {
                    current_block = 18377268871191777778;
                }
            } else {
                len1 = 0;
                if is_array_ctor != 0 {
                    val = JS_ToNumberFree(ctx, val);
                    if JS_IsException(val) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if JS_ToArrayLengthFree(ctx, &mut len, val, TRUE as libc::c_int) != 0
                    {
                        return -(1 as libc::c_int);
                    }
                    current_block = 18377268871191777778;
                } else {
                    if JS_ToUint32(ctx, &mut len, val) != 0 {
                        JS_FreeValue(ctx, val);
                        return -(1 as libc::c_int);
                    }
                    val = JS_ToNumberFree(ctx, val);
                    if JS_IsException(val) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if JS_ToArrayLengthFree(ctx, &mut len1, val, FALSE as libc::c_int)
                        != 0
                    {
                        return -(1 as libc::c_int);
                    }
                    if len1 != len {
                        current_block = 7452196606062742386;
                    } else {
                        current_block = 18377268871191777778;
                    }
                }
            }
        }
    }
    match current_block {
        18377268871191777778 => {
            *plen = len;
            return 0 as libc::c_int;
        }
        _ => {
            JS_ThrowRangeError(
                ctx,
                b"invalid array length\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn is_safe_integer(mut d: libc::c_double) -> BOOL {
    return (isfinite(d) != 0 && floor(d) == d
        && fabs(d)
            <= (((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong) as libc::c_double)
        as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToIndex(
    mut ctx: *mut JSContext,
    mut plen: *mut uint64_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut v: int64_t = 0;
    if JS_ToInt64Sat(ctx, &mut v, val) != 0 {
        return -(1 as libc::c_int);
    }
    if v < 0 as libc::c_int as libc::c_longlong
        || v
            > ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong
    {
        JS_ThrowRangeError(
            ctx,
            b"invalid array index\0" as *const u8 as *const libc::c_char,
        );
        *plen = 0 as libc::c_int as uint64_t;
        return -(1 as libc::c_int);
    }
    *plen = v as uint64_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_ToLengthFree(
    mut ctx: *mut JSContext,
    mut plen: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    let mut res: libc::c_int = JS_ToInt64Clamp(
        ctx,
        plen,
        val,
        0 as libc::c_int as int64_t,
        ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
            - 1 as libc::c_int as libc::c_longlong,
        0 as libc::c_int as int64_t,
    );
    JS_FreeValue(ctx, val);
    return res;
}
unsafe extern "C" fn JS_NumberIsInteger(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut d: libc::c_double = 0.;
    if JS_IsNumber(val) == 0 {
        return FALSE as libc::c_int;
    }
    if (JS_ToFloat64(ctx, &mut d, val) != 0) as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    return (isfinite(d) != 0 && floor(d) == d) as libc::c_int;
}
unsafe extern "C" fn JS_NumberIsNegativeOrMinusZero(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> BOOL {
    let mut tag: uint32_t = 0;
    tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
    match tag {
        0 => {
            let mut v: libc::c_int = 0;
            v = val as libc::c_int;
            return (v < 0 as libc::c_int) as libc::c_int;
        }
        7 => {
            let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
            u.d = JS_VALUE_GET_FLOAT64(val);
            return (u.u64_0 >> 63 as libc::c_int) as BOOL;
        }
        _ => return FALSE as libc::c_int,
    };
}
unsafe extern "C" fn i64toa(
    mut buf_end: *mut libc::c_char,
    mut n: int64_t,
    mut base: libc::c_uint,
) -> *mut libc::c_char {
    let mut q: *mut libc::c_char = buf_end;
    let mut digit: libc::c_int = 0;
    let mut is_neg: libc::c_int = 0;
    is_neg = 0 as libc::c_int;
    if n < 0 as libc::c_int as libc::c_longlong {
        is_neg = 1 as libc::c_int;
        n = -n;
    }
    q = q.offset(-1);
    *q = '\0' as i32 as libc::c_char;
    loop {
        digit = (n as uint64_t).wrapping_rem(base as libc::c_ulonglong) as libc::c_int;
        n = (n as uint64_t).wrapping_div(base as libc::c_ulonglong) as int64_t;
        if digit < 10 as libc::c_int {
            digit += '0' as i32;
        } else {
            digit += 'a' as i32 - 10 as libc::c_int;
        }
        q = q.offset(-1);
        *q = digit as libc::c_char;
        if !(n != 0 as libc::c_int as libc::c_longlong) {
            break;
        }
    }
    if is_neg != 0 {
        q = q.offset(-1);
        *q = '-' as i32 as libc::c_char;
    }
    return q;
}
unsafe extern "C" fn js_ecvt1(
    mut d: libc::c_double,
    mut n_digits: libc::c_int,
    mut decpt: *mut libc::c_int,
    mut sign: *mut libc::c_int,
    mut buf: *mut libc::c_char,
    mut rounding_mode: libc::c_int,
    mut buf1: *mut libc::c_char,
    mut buf1_size: libc::c_int,
) {
    if rounding_mode != 1 as libc::c_int {
        fesetround(rounding_mode);
    }
    snprintf(
        buf1,
        buf1_size as libc::c_ulong,
        b"%+.*e\0" as *const u8 as *const libc::c_char,
        n_digits - 1 as libc::c_int,
        d,
    );
    if rounding_mode != 1 as libc::c_int {
        fesetround(1 as libc::c_int);
    }
    *sign = (*buf1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32)
        as libc::c_int;
    *buf.offset(0 as libc::c_int as isize) = *buf1.offset(1 as libc::c_int as isize);
    if n_digits > 1 as libc::c_int {
        memcpy(
            buf.offset(1 as libc::c_int as isize) as *mut libc::c_void,
            buf1.offset(3 as libc::c_int as isize) as *const libc::c_void,
            (n_digits - 1 as libc::c_int) as libc::c_ulong,
        );
    }
    *buf.offset(n_digits as isize) = '\0' as i32 as libc::c_char;
    *decpt = atoi(
        buf1
            .offset(n_digits as isize)
            .offset(2 as libc::c_int as isize)
            .offset((n_digits > 1 as libc::c_int) as libc::c_int as isize),
    ) + 1 as libc::c_int;
}
unsafe extern "C" fn js_ecvt(
    mut d: libc::c_double,
    mut n_digits: libc::c_int,
    mut decpt: *mut libc::c_int,
    mut sign: *mut libc::c_int,
    mut buf: *mut libc::c_char,
    mut is_fixed: BOOL,
) -> libc::c_int {
    let mut rounding_mode: libc::c_int = 0;
    let mut buf_tmp: [libc::c_char; 128] = [0; 128];
    if is_fixed == 0 {
        let mut n_digits_min: libc::c_uint = 0;
        let mut n_digits_max: libc::c_uint = 0;
        n_digits_min = 1 as libc::c_int as libc::c_uint;
        n_digits_max = 17 as libc::c_int as libc::c_uint;
        while n_digits_min < n_digits_max {
            n_digits = n_digits_min
                .wrapping_add(n_digits_max)
                .wrapping_div(2 as libc::c_int as libc::c_uint) as libc::c_int;
            js_ecvt1(
                d,
                n_digits,
                decpt,
                sign,
                buf,
                1 as libc::c_int,
                buf_tmp.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
                    as libc::c_int,
            );
            if strtod(buf_tmp.as_mut_ptr(), 0 as *mut *mut libc::c_char) == d {
                while n_digits >= 2 as libc::c_int
                    && *buf.offset((n_digits - 1 as libc::c_int) as isize) as libc::c_int
                        == '0' as i32
                {
                    n_digits -= 1;
                }
                n_digits_max = n_digits as libc::c_uint;
            } else {
                n_digits_min = (n_digits + 1 as libc::c_int) as libc::c_uint;
            }
        }
        n_digits = n_digits_max as libc::c_int;
        rounding_mode = 1 as libc::c_int;
    } else {
        rounding_mode = 1 as libc::c_int;
        let mut buf1: [libc::c_char; 128] = [0; 128];
        let mut buf2: [libc::c_char; 128] = [0; 128];
        let mut decpt1: libc::c_int = 0;
        let mut sign1: libc::c_int = 0;
        let mut decpt2: libc::c_int = 0;
        let mut sign2: libc::c_int = 0;
        js_ecvt1(
            d,
            n_digits + 1 as libc::c_int,
            &mut decpt1,
            &mut sign1,
            buf1.as_mut_ptr(),
            1 as libc::c_int,
            buf_tmp.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong as libc::c_int,
        );
        if buf1[n_digits as usize] as libc::c_int == '5' as i32 {
            js_ecvt1(
                d,
                n_digits + 1 as libc::c_int,
                &mut decpt1,
                &mut sign1,
                buf1.as_mut_ptr(),
                2 as libc::c_int,
                buf_tmp.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
                    as libc::c_int,
            );
            js_ecvt1(
                d,
                n_digits + 1 as libc::c_int,
                &mut decpt2,
                &mut sign2,
                buf2.as_mut_ptr(),
                3 as libc::c_int,
                buf_tmp.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
                    as libc::c_int,
            );
            if memcmp(
                buf1.as_mut_ptr() as *const libc::c_void,
                buf2.as_mut_ptr() as *const libc::c_void,
                (n_digits + 1 as libc::c_int) as libc::c_ulong,
            ) == 0 as libc::c_int && decpt1 == decpt2
            {
                if sign1 != 0 {
                    rounding_mode = 2 as libc::c_int;
                } else {
                    rounding_mode = 3 as libc::c_int;
                }
            }
        }
    }
    js_ecvt1(
        d,
        n_digits,
        decpt,
        sign,
        buf,
        rounding_mode,
        buf_tmp.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong as libc::c_int,
    );
    return n_digits;
}
unsafe extern "C" fn js_fcvt1(
    mut buf: *mut libc::c_char,
    mut buf_size: libc::c_int,
    mut d: libc::c_double,
    mut n_digits: libc::c_int,
    mut rounding_mode: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    if rounding_mode != 1 as libc::c_int {
        fesetround(rounding_mode);
    }
    n = snprintf(
        buf,
        buf_size as libc::c_ulong,
        b"%.*f\0" as *const u8 as *const libc::c_char,
        n_digits,
        d,
    );
    if rounding_mode != 1 as libc::c_int {
        fesetround(1 as libc::c_int);
    }
    assert((n < buf_size) as libc::c_int);
    return n;
}
unsafe extern "C" fn js_fcvt(
    mut buf: *mut libc::c_char,
    mut buf_size: libc::c_int,
    mut d: libc::c_double,
    mut n_digits: libc::c_int,
) {
    let mut rounding_mode: libc::c_int = 0;
    rounding_mode = 1 as libc::c_int;
    let mut n1: libc::c_int = 0;
    let mut n2: libc::c_int = 0;
    let mut buf1: [libc::c_char; 128] = [0; 128];
    let mut buf2: [libc::c_char; 128] = [0; 128];
    n1 = js_fcvt1(
        buf1.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong as libc::c_int,
        d,
        n_digits + 1 as libc::c_int,
        1 as libc::c_int,
    );
    rounding_mode = 1 as libc::c_int;
    if buf1[(n1 - 1 as libc::c_int) as usize] as libc::c_int == '5' as i32 {
        n1 = js_fcvt1(
            buf1.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
                as libc::c_int,
            d,
            n_digits + 1 as libc::c_int,
            2 as libc::c_int,
        );
        n2 = js_fcvt1(
            buf2.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
                as libc::c_int,
            d,
            n_digits + 1 as libc::c_int,
            3 as libc::c_int,
        );
        if n1 == n2
            && memcmp(
                buf1.as_mut_ptr() as *const libc::c_void,
                buf2.as_mut_ptr() as *const libc::c_void,
                n1 as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if buf1[0 as libc::c_int as usize] as libc::c_int == '-' as i32 {
                rounding_mode = 2 as libc::c_int;
            } else {
                rounding_mode = 3 as libc::c_int;
            }
        }
    }
    js_fcvt1(buf, buf_size, d, n_digits, rounding_mode);
}
unsafe extern "C" fn js_dtoa1(
    mut buf: *mut libc::c_char,
    mut d: libc::c_double,
    mut radix: libc::c_int,
    mut n_digits: libc::c_int,
    mut flags: libc::c_int,
) {
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    if isfinite(d) == 0 {
        if isnan(d) != 0 {
            strcpy(buf, b"NaN\0" as *const u8 as *const libc::c_char);
        } else {
            q = buf;
            if d < 0 as libc::c_int as libc::c_double {
                let fresh246 = q;
                q = q.offset(1);
                *fresh246 = '-' as i32 as libc::c_char;
            }
            strcpy(q, b"Infinity\0" as *const u8 as *const libc::c_char);
        }
    } else {
        let mut buf1_0: [libc::c_char; 128] = [0; 128];
        let mut sign: libc::c_int = 0;
        let mut decpt: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut n: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut p: libc::c_int = 0;
        let mut n_max: libc::c_int = 0;
        let mut is_fixed: BOOL = 0;
        let mut current_block_64: u64;
        if flags == (0 as libc::c_int) << 0 as libc::c_int {
            let mut i64: int64_t = 0;
            let mut buf1: [libc::c_char; 70] = [0; 70];
            let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
            i64 = d as int64_t;
            if d != i64 as libc::c_double
                || i64
                    > ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                        - 1 as libc::c_int as libc::c_longlong
                || i64
                    < -(((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                        - 1 as libc::c_int as libc::c_longlong)
            {
                current_block_64 = 3421249662423776657;
            } else {
                ptr = i64toa(
                    buf1
                        .as_mut_ptr()
                        .offset(
                            ::core::mem::size_of::<[libc::c_char; 70]>() as libc::c_ulong
                                as isize,
                        ),
                    i64,
                    radix as libc::c_uint,
                );
                strcpy(buf, ptr);
                current_block_64 = 5684854171168229155;
            }
        } else {
            if d == 0.0f64 {
                d = 0.0f64;
            }
            if flags == (2 as libc::c_int) << 0 as libc::c_int {
                js_fcvt(buf, 128 as libc::c_int, d, n_digits);
                current_block_64 = 5684854171168229155;
            } else {
                buf1_0 = [0; 128];
                sign = 0;
                decpt = 0;
                k = 0;
                n = 0;
                i = 0;
                p = 0;
                n_max = 0;
                is_fixed = 0;
                current_block_64 = 3421249662423776657;
            }
        }
        match current_block_64 {
            3421249662423776657 => {
                is_fixed = (flags & 3 as libc::c_int
                    == (1 as libc::c_int) << 0 as libc::c_int) as libc::c_int;
                if is_fixed != 0 {
                    n_max = n_digits;
                } else {
                    n_max = 21 as libc::c_int;
                }
                k = js_ecvt(
                    d,
                    n_digits,
                    &mut decpt,
                    &mut sign,
                    buf1_0.as_mut_ptr(),
                    is_fixed,
                );
                n = decpt;
                q = buf;
                if sign != 0 {
                    let fresh247 = q;
                    q = q.offset(1);
                    *fresh247 = '-' as i32 as libc::c_char;
                }
                if flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
                    current_block_64 = 1876885015018357422;
                } else if n >= 1 as libc::c_int && n <= n_max {
                    if k <= n {
                        memcpy(
                            q as *mut libc::c_void,
                            buf1_0.as_mut_ptr() as *const libc::c_void,
                            k as libc::c_ulong,
                        );
                        q = q.offset(k as isize);
                        i = 0 as libc::c_int;
                        while i < n - k {
                            let fresh248 = q;
                            q = q.offset(1);
                            *fresh248 = '0' as i32 as libc::c_char;
                            i += 1;
                        }
                        *q = '\0' as i32 as libc::c_char;
                    } else {
                        memcpy(
                            q as *mut libc::c_void,
                            buf1_0.as_mut_ptr() as *const libc::c_void,
                            n as libc::c_ulong,
                        );
                        q = q.offset(n as isize);
                        let fresh249 = q;
                        q = q.offset(1);
                        *fresh249 = '.' as i32 as libc::c_char;
                        i = 0 as libc::c_int;
                        while i < k - n {
                            let fresh250 = q;
                            q = q.offset(1);
                            *fresh250 = buf1_0[(n + i) as usize];
                            i += 1;
                        }
                        *q = '\0' as i32 as libc::c_char;
                    }
                    current_block_64 = 5684854171168229155;
                } else if n >= -(5 as libc::c_int) && n <= 0 as libc::c_int {
                    let fresh251 = q;
                    q = q.offset(1);
                    *fresh251 = '0' as i32 as libc::c_char;
                    let fresh252 = q;
                    q = q.offset(1);
                    *fresh252 = '.' as i32 as libc::c_char;
                    i = 0 as libc::c_int;
                    while i < -n {
                        let fresh253 = q;
                        q = q.offset(1);
                        *fresh253 = '0' as i32 as libc::c_char;
                        i += 1;
                    }
                    memcpy(
                        q as *mut libc::c_void,
                        buf1_0.as_mut_ptr() as *const libc::c_void,
                        k as libc::c_ulong,
                    );
                    q = q.offset(k as isize);
                    *q = '\0' as i32 as libc::c_char;
                    current_block_64 = 5684854171168229155;
                } else {
                    current_block_64 = 1876885015018357422;
                }
                match current_block_64 {
                    5684854171168229155 => {}
                    _ => {
                        let fresh254 = q;
                        q = q.offset(1);
                        *fresh254 = buf1_0[0 as libc::c_int as usize];
                        if k > 1 as libc::c_int {
                            let fresh255 = q;
                            q = q.offset(1);
                            *fresh255 = '.' as i32 as libc::c_char;
                            i = 1 as libc::c_int;
                            while i < k {
                                let fresh256 = q;
                                q = q.offset(1);
                                *fresh256 = buf1_0[i as usize];
                                i += 1;
                            }
                        }
                        let fresh257 = q;
                        q = q.offset(1);
                        *fresh257 = 'e' as i32 as libc::c_char;
                        p = n - 1 as libc::c_int;
                        if p >= 0 as libc::c_int {
                            let fresh258 = q;
                            q = q.offset(1);
                            *fresh258 = '+' as i32 as libc::c_char;
                        }
                        sprintf(q, b"%d\0" as *const u8 as *const libc::c_char, p);
                    }
                }
            }
            _ => {}
        }
    };
}
unsafe extern "C" fn js_dtoa(
    mut ctx: *mut JSContext,
    mut d: libc::c_double,
    mut radix: libc::c_int,
    mut n_digits: libc::c_int,
    mut flags: libc::c_int,
) -> JSValue {
    let mut buf: [libc::c_char; 128] = [0; 128];
    js_dtoa1(buf.as_mut_ptr(), d, radix, n_digits, flags);
    return JS_NewString(ctx, buf.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToStringInternal(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut is_ToPropertyKey: BOOL,
) -> JSValue {
    let mut tag: uint32_t = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut buf: [libc::c_char; 32] = [0; 32];
    tag = JS_VALUE_GET_NORM_TAG(val) as uint32_t;
    match tag {
        4294967289 => return JS_DupValue(ctx, val),
        0 => {
            snprintf(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                val as libc::c_int,
            );
            str = buf.as_mut_ptr();
        }
        1 => {
            return JS_AtomToString(
                ctx,
                (if val as libc::c_int != 0 {
                    JS_ATOM_true as libc::c_int
                } else {
                    JS_ATOM_false as libc::c_int
                }) as JSAtom,
            );
        }
        2 => return JS_AtomToString(ctx, JS_ATOM_null as libc::c_int as JSAtom),
        3 => return JS_AtomToString(ctx, JS_ATOM_undefined as libc::c_int as JSAtom),
        6 => {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        4294967295 => {
            let mut val1: JSValue = 0;
            let mut ret: JSValue = 0;
            val1 = JS_ToPrimitive(ctx, val, 0 as libc::c_int);
            if JS_IsException(val1) != 0 {
                return val1;
            }
            ret = JS_ToStringInternal(ctx, val1, is_ToPropertyKey);
            JS_FreeValue(ctx, val1);
            return ret;
        }
        4294967294 => {
            str = b"[function bytecode]\0" as *const u8 as *const libc::c_char;
        }
        4294967288 => {
            if is_ToPropertyKey != 0 {
                return JS_DupValue(ctx, val)
            } else {
                return JS_ThrowTypeError(
                    ctx,
                    b"cannot convert symbol to string\0" as *const u8
                        as *const libc::c_char,
                )
            }
        }
        7 => {
            return js_dtoa(
                ctx,
                JS_VALUE_GET_FLOAT64(val),
                10 as libc::c_int,
                0 as libc::c_int,
                (0 as libc::c_int) << 0 as libc::c_int,
            );
        }
        _ => {
            str = b"[unsupported type]\0" as *const u8 as *const libc::c_char;
        }
    }
    return JS_NewString(ctx, str);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToString(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    return JS_ToStringInternal(ctx, val, FALSE as libc::c_int);
}
unsafe extern "C" fn JS_ToStringFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    let mut ret: JSValue = 0;
    ret = JS_ToString(ctx, val);
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn JS_ToLocaleStringFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    if JS_IsUndefined(val) != 0 || JS_IsNull(val) != 0 {
        return JS_ToStringFree(ctx, val);
    }
    return JS_InvokeFree(
        ctx,
        val,
        JS_ATOM_toLocaleString as libc::c_int as JSAtom,
        0 as libc::c_int,
        0 as *mut JSValue,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToPropertyKey(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    return JS_ToStringInternal(ctx, val, TRUE as libc::c_int);
}
unsafe extern "C" fn JS_ToStringCheckObject(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    let mut tag: uint32_t = (val >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag == JS_TAG_NULL as libc::c_int as libc::c_uint
        || tag == JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
    {
        return JS_ThrowTypeError(
            ctx,
            b"null or undefined are forbidden\0" as *const u8 as *const libc::c_char,
        );
    }
    return JS_ToString(ctx, val);
}
unsafe extern "C" fn JS_ToQuotedString(
    mut ctx: *mut JSContext,
    mut val1: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut c: uint32_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut buf: [libc::c_char; 16] = [0; 16];
    val = JS_ToStringCheckObject(ctx, val1);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    if !(string_buffer_init(ctx, b, (*p).len() as libc::c_int + 2 as libc::c_int) != 0) {
        if !(string_buffer_putc8(b, '"' as i32 as uint32_t) != 0) {
            i = 0 as libc::c_int;
            loop {
                if !(i < (*p).len() as libc::c_int) {
                    current_block = 3275366147856559585;
                    break;
                }
                c = string_getc(p, &mut i) as uint32_t;
                match c {
                    9 => {
                        c = 't' as i32 as uint32_t;
                    }
                    13 => {
                        c = 'r' as i32 as uint32_t;
                    }
                    10 => {
                        c = 'n' as i32 as uint32_t;
                    }
                    8 => {
                        c = 'b' as i32 as uint32_t;
                    }
                    12 => {
                        c = 'f' as i32 as uint32_t;
                    }
                    34 | 92 => {}
                    _ => {
                        if c < 32 as libc::c_int as libc::c_uint
                            || c >= 0xd800 as libc::c_int as libc::c_uint
                                && c < 0xe000 as libc::c_int as libc::c_uint
                        {
                            snprintf(
                                buf.as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_char; 16]>()
                                    as libc::c_ulong,
                                b"\\u%04x\0" as *const u8 as *const libc::c_char,
                                c,
                            );
                            if string_buffer_puts8(b, buf.as_mut_ptr()) != 0 {
                                current_block = 6176397590850349065;
                                break;
                            } else {
                                continue;
                            }
                        } else if string_buffer_putc(b, c) != 0 {
                            current_block = 6176397590850349065;
                            break;
                        } else {
                            continue;
                        }
                    }
                }
                if string_buffer_putc8(b, '\\' as i32 as uint32_t) != 0 {
                    current_block = 6176397590850349065;
                    break;
                }
                if string_buffer_putc8(b, c) != 0 {
                    current_block = 6176397590850349065;
                    break;
                }
            }
            match current_block {
                6176397590850349065 => {}
                _ => {
                    if !(string_buffer_putc8(b, '"' as i32 as uint32_t) != 0) {
                        JS_FreeValue(ctx, val);
                        return string_buffer_end(b);
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, val);
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_IsArray(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        p = val as intptr_t as *mut libc::c_void as *mut JSObject;
        if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
        {
            return js_proxy_isArray(ctx, val)
        } else {
            return ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                == JS_CLASS_ARRAY as libc::c_int) as libc::c_int
        }
    } else {
        return FALSE as libc::c_int
    };
}
unsafe extern "C" fn js_pow(
    mut a: libc::c_double,
    mut b: libc::c_double,
) -> libc::c_double {
    if (isfinite(b) == 0) as libc::c_int as libc::c_long != 0
        && fabs(a) == 1 as libc::c_int as libc::c_double
    {
        return 9999.9999f64
    } else {
        return pow(a, b)
    };
}
unsafe extern "C" fn JS_ThrowUnsupportedBigint(mut ctx: *mut JSContext) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"bigint is not supported\0" as *const u8 as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewBigInt64(
    mut ctx: *mut JSContext,
    mut v: int64_t,
) -> JSValue {
    return JS_ThrowUnsupportedBigint(ctx);
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewBigUint64(
    mut ctx: *mut JSContext,
    mut v: uint64_t,
) -> JSValue {
    return JS_ThrowUnsupportedBigint(ctx);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ToBigInt64(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut val: JSValue,
) -> libc::c_int {
    JS_ThrowUnsupportedBigint(ctx);
    *pres = 0 as libc::c_int as int64_t;
    return -(1 as libc::c_int);
}
#[inline(never)]
unsafe extern "C" fn js_unary_arith_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut op: OPCodeEnum,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut d: libc::c_double = 0.;
    op1 = *sp.offset(-(1 as libc::c_int) as isize);
    if (JS_ToFloat64Free(ctx, &mut d, op1) != 0) as libc::c_int as libc::c_long != 0 {
        *sp
            .offset(
                -(1 as libc::c_int) as isize,
            ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        return -(1 as libc::c_int);
    }
    match op as libc::c_uint {
        143 => {
            d += 1.;
        }
        142 => {
            d -= 1.;
        }
        141 => {}
        140 => {
            d = -d;
        }
        _ => {
            abort();
        }
    }
    *sp.offset(-(1 as libc::c_int) as isize) = JS_NewFloat64(ctx, d);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_post_inc_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut op: OPCodeEnum,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut d: libc::c_double = 0.;
    let mut r: libc::c_double = 0.;
    op1 = *sp.offset(-(1 as libc::c_int) as isize);
    if (JS_ToFloat64Free(ctx, &mut d, op1) != 0) as libc::c_int as libc::c_long != 0 {
        *sp
            .offset(
                -(1 as libc::c_int) as isize,
            ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        return -(1 as libc::c_int);
    }
    r = d
        + (2 as libc::c_int as libc::c_uint)
            .wrapping_mul(
                (op as libc::c_uint)
                    .wrapping_sub(OP_post_dec as libc::c_int as libc::c_uint),
            ) as libc::c_double - 1 as libc::c_int as libc::c_double;
    *sp.offset(0 as libc::c_int as isize) = JS_NewFloat64(ctx, r);
    *sp.offset(-(1 as libc::c_int) as isize) = JS_NewFloat64(ctx, d);
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn js_binary_arith_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut op: OPCodeEnum,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut d1: libc::c_double = 0.;
    let mut d2: libc::c_double = 0.;
    let mut r: libc::c_double = 0.;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    if (JS_ToFloat64Free(ctx, &mut d1, op1) != 0) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, op2);
    } else if !((JS_ToFloat64Free(ctx, &mut d2, op2) != 0) as libc::c_int as libc::c_long
        != 0)
    {
        match op as libc::c_uint {
            158 => {
                r = d1 - d2;
            }
            154 => {
                r = d1 * d2;
            }
            155 => {
                r = d1 / d2;
            }
            156 => {
                r = fmod(d1, d2);
            }
            159 => {
                r = js_pow(d1, d2);
            }
            _ => {
                abort();
            }
        }
        *sp.offset(-(2 as libc::c_int) as isize) = JS_NewFloat64(ctx, r);
        return 0 as libc::c_int;
    }
    *sp
        .offset(
            -(2 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return -(1 as libc::c_int);
}
#[inline(never)]
unsafe extern "C" fn js_add_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut d1: libc::c_double = 0.;
    let mut d2: libc::c_double = 0.;
    let mut current_block: u64;
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut tag1: uint32_t = 0;
    let mut tag2: uint32_t = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    tag1 = (op1 >> 32 as libc::c_int) as libc::c_int as uint32_t;
    tag2 = (op2 >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if (tag1 == JS_TAG_INT as libc::c_int as libc::c_uint
        || tag1.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
            >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int)
                as libc::c_uint)
        && (tag2 == JS_TAG_INT as libc::c_int as libc::c_uint
            || tag2.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
                >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int)
                    as libc::c_uint)
    {
        current_block = 1710861196817715608;
    } else {
        op1 = JS_ToPrimitiveFree(ctx, op1, 2 as libc::c_int);
        if JS_IsException(op1) != 0 {
            JS_FreeValue(ctx, op2);
            current_block = 14241481745035602227;
        } else {
            op2 = JS_ToPrimitiveFree(ctx, op2, 2 as libc::c_int);
            if JS_IsException(op2) != 0 {
                JS_FreeValue(ctx, op1);
                current_block = 14241481745035602227;
            } else {
                tag1 = (op1 >> 32 as libc::c_int) as libc::c_int as uint32_t;
                tag2 = (op2 >> 32 as libc::c_int) as libc::c_int as uint32_t;
                if tag1 == JS_TAG_STRING as libc::c_int as libc::c_uint
                    || tag2 == JS_TAG_STRING as libc::c_int as libc::c_uint
                {
                    *sp
                        .offset(
                            -(2 as libc::c_int) as isize,
                        ) = JS_ConcatString(ctx, op1, op2);
                    if JS_IsException(*sp.offset(-(2 as libc::c_int) as isize)) != 0 {
                        current_block = 14241481745035602227;
                    } else {
                        current_block = 9828876828309294594;
                    }
                } else {
                    d1 = 0.;
                    d2 = 0.;
                    current_block = 1710861196817715608;
                }
            }
        }
    }
    match current_block {
        1710861196817715608 => {
            if JS_ToFloat64Free(ctx, &mut d1, op1) != 0 {
                JS_FreeValue(ctx, op2);
                current_block = 14241481745035602227;
            } else if JS_ToFloat64Free(ctx, &mut d2, op2) != 0 {
                current_block = 14241481745035602227;
            } else {
                *sp.offset(-(2 as libc::c_int) as isize) = JS_NewFloat64(ctx, d1 + d2);
                current_block = 9828876828309294594;
            }
        }
        _ => {}
    }
    match current_block {
        9828876828309294594 => return 0 as libc::c_int,
        _ => {
            *sp
                .offset(
                    -(2 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            *sp
                .offset(
                    -(1 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            return -(1 as libc::c_int);
        }
    };
}
#[inline(never)]
unsafe extern "C" fn js_binary_logic_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut op: OPCodeEnum,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut v1: uint32_t = 0;
    let mut v2: uint32_t = 0;
    let mut r: uint32_t = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    if (JS_ToInt32Free(ctx, &mut v1 as *mut uint32_t as *mut int32_t, op1) != 0)
        as libc::c_int as libc::c_long != 0
    {
        JS_FreeValue(ctx, op2);
    } else if !((JS_ToInt32Free(ctx, &mut v2 as *mut uint32_t as *mut int32_t, op2) != 0)
        as libc::c_int as libc::c_long != 0)
    {
        match op as libc::c_uint {
            160 => {
                r = v1 << (v2 & 0x1f as libc::c_int as libc::c_uint);
            }
            161 => {
                r = (v1 as libc::c_int >> (v2 & 0x1f as libc::c_int as libc::c_uint))
                    as uint32_t;
            }
            173 => {
                r = v1 & v2;
            }
            175 => {
                r = v1 | v2;
            }
            174 => {
                r = v1 ^ v2;
            }
            _ => {
                abort();
            }
        }
        *sp.offset(-(2 as libc::c_int) as isize) = JS_NewInt32(ctx, r as int32_t);
        return 0 as libc::c_int;
    }
    *sp
        .offset(
            -(2 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return -(1 as libc::c_int);
}
#[inline(never)]
unsafe extern "C" fn js_not_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut v1: int32_t = 0;
    if (JS_ToInt32Free(ctx, &mut v1, *sp.offset(-(1 as libc::c_int) as isize)) != 0)
        as libc::c_int as libc::c_long != 0
    {
        *sp
            .offset(
                -(1 as libc::c_int) as isize,
            ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        return -(1 as libc::c_int);
    }
    *sp.offset(-(1 as libc::c_int) as isize) = JS_NewInt32(ctx, !v1);
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn js_relational_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut op: OPCodeEnum,
) -> libc::c_int {
    let mut current_block: u64;
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut res: libc::c_int = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    op1 = JS_ToPrimitiveFree(ctx, op1, 1 as libc::c_int);
    if JS_IsException(op1) != 0 {
        JS_FreeValue(ctx, op2);
    } else {
        op2 = JS_ToPrimitiveFree(ctx, op2, 1 as libc::c_int);
        if JS_IsException(op2) != 0 {
            JS_FreeValue(ctx, op1);
        } else {
            if (op1 >> 32 as libc::c_int) as libc::c_int == JS_TAG_STRING as libc::c_int
                && (op2 >> 32 as libc::c_int) as libc::c_int
                    == JS_TAG_STRING as libc::c_int
            {
                let mut p1: *mut JSString = 0 as *mut JSString;
                let mut p2: *mut JSString = 0 as *mut JSString;
                p1 = op1 as intptr_t as *mut libc::c_void as *mut JSString;
                p2 = op2 as intptr_t as *mut libc::c_void as *mut JSString;
                res = js_string_compare(ctx, p1, p2);
                JS_FreeValue(ctx, op1);
                JS_FreeValue(ctx, op2);
                match op as libc::c_uint {
                    163 => {
                        res = (res < 0 as libc::c_int) as libc::c_int;
                    }
                    164 => {
                        res = (res <= 0 as libc::c_int) as libc::c_int;
                    }
                    165 => {
                        res = (res > 0 as libc::c_int) as libc::c_int;
                    }
                    166 | _ => {
                        res = (res >= 0 as libc::c_int) as libc::c_int;
                    }
                }
                current_block = 14832935472441733737;
            } else {
                let mut d1: libc::c_double = 0.;
                let mut d2: libc::c_double = 0.;
                if JS_ToFloat64Free(ctx, &mut d1, op1) != 0 {
                    JS_FreeValue(ctx, op2);
                    current_block = 3200103409603251050;
                } else if JS_ToFloat64Free(ctx, &mut d2, op2) != 0 {
                    current_block = 3200103409603251050;
                } else {
                    match op as libc::c_uint {
                        163 => {
                            res = (d1 < d2) as libc::c_int;
                        }
                        164 => {
                            res = (d1 <= d2) as libc::c_int;
                        }
                        165 => {
                            res = (d1 > d2) as libc::c_int;
                        }
                        166 | _ => {
                            res = (d1 >= d2) as libc::c_int;
                        }
                    }
                    current_block = 14832935472441733737;
                }
            }
            match current_block {
                3200103409603251050 => {}
                _ => {
                    *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, res);
                    return 0 as libc::c_int;
                }
            }
        }
    }
    *sp
        .offset(
            -(2 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return -(1 as libc::c_int);
}
#[inline(never)]
unsafe extern "C" fn js_eq_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut is_neq: BOOL,
) -> libc::c_int {
    let mut d1: libc::c_double = 0.;
    let mut d2: libc::c_double = 0.;
    let mut current_block: u64;
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut tag1: libc::c_int = 0;
    let mut tag2: libc::c_int = 0;
    let mut res: BOOL = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    loop {
        tag1 = JS_VALUE_GET_NORM_TAG(op1);
        tag2 = JS_VALUE_GET_NORM_TAG(op2);
        if tag1 == tag2
            || tag1 == JS_TAG_INT as libc::c_int && tag2 == JS_TAG_FLOAT64 as libc::c_int
            || tag2 == JS_TAG_INT as libc::c_int && tag1 == JS_TAG_FLOAT64 as libc::c_int
        {
            res = js_strict_eq(ctx, op1, op2);
            current_block = 3934796541983872331;
            break;
        } else if tag1 == JS_TAG_NULL as libc::c_int
            && tag2 == JS_TAG_UNDEFINED as libc::c_int
            || tag2 == JS_TAG_NULL as libc::c_int
                && tag1 == JS_TAG_UNDEFINED as libc::c_int
        {
            res = TRUE as libc::c_int;
            current_block = 3934796541983872331;
            break;
        } else if tag1 == JS_TAG_STRING as libc::c_int
            && (tag2 == JS_TAG_INT as libc::c_int
                || tag2 == JS_TAG_FLOAT64 as libc::c_int)
            || tag2 == JS_TAG_STRING as libc::c_int
                && (tag1 == JS_TAG_INT as libc::c_int
                    || tag1 == JS_TAG_FLOAT64 as libc::c_int)
        {
            d1 = 0.;
            d2 = 0.;
            if JS_ToFloat64Free(ctx, &mut d1, op1) != 0 {
                current_block = 1856101646708284338;
                break;
            } else {
                current_block = 12349973810996921269;
                break;
            }
        } else if tag1 == JS_TAG_BOOL as libc::c_int {
            op1 = JS_NewInt32(ctx, op1 as libc::c_int);
        } else if tag2 == JS_TAG_BOOL as libc::c_int {
            op2 = JS_NewInt32(ctx, op2 as libc::c_int);
        } else if tag1 == JS_TAG_OBJECT as libc::c_int
            && (tag2 == JS_TAG_INT as libc::c_int
                || tag2 == JS_TAG_FLOAT64 as libc::c_int
                || tag2 == JS_TAG_STRING as libc::c_int
                || tag2 == JS_TAG_SYMBOL as libc::c_int)
        {
            op1 = JS_ToPrimitiveFree(ctx, op1, 2 as libc::c_int);
            if !(JS_IsException(op1) != 0) {
                continue;
            }
            JS_FreeValue(ctx, op2);
            current_block = 8975867271229727749;
            break;
        } else if tag2 == JS_TAG_OBJECT as libc::c_int
            && (tag1 == JS_TAG_INT as libc::c_int
                || tag1 == JS_TAG_FLOAT64 as libc::c_int
                || tag1 == JS_TAG_STRING as libc::c_int
                || tag1 == JS_TAG_SYMBOL as libc::c_int)
        {
            op2 = JS_ToPrimitiveFree(ctx, op2, 2 as libc::c_int);
            if !(JS_IsException(op2) != 0) {
                continue;
            }
            JS_FreeValue(ctx, op1);
            current_block = 8975867271229727749;
            break;
        } else {
            if JS_IsHTMLDDA(ctx, op1) != 0
                && (tag2 == JS_TAG_NULL as libc::c_int
                    || tag2 == JS_TAG_UNDEFINED as libc::c_int)
                || JS_IsHTMLDDA(ctx, op2) != 0
                    && (tag1 == JS_TAG_NULL as libc::c_int
                        || tag1 == JS_TAG_UNDEFINED as libc::c_int)
            {
                res = TRUE as libc::c_int;
            } else {
                res = FALSE as libc::c_int;
            }
            JS_FreeValue(ctx, op1);
            JS_FreeValue(ctx, op2);
            current_block = 3934796541983872331;
            break;
        }
    }
    match current_block {
        12349973810996921269 => {
            if JS_ToFloat64Free(ctx, &mut d2, op2) != 0 {
                current_block = 8975867271229727749;
            } else {
                res = (d1 == d2) as libc::c_int;
                current_block = 3934796541983872331;
            }
        }
        1856101646708284338 => {
            JS_FreeValue(ctx, op2);
            current_block = 8975867271229727749;
        }
        _ => {}
    }
    match current_block {
        8975867271229727749 => {
            *sp
                .offset(
                    -(2 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            *sp
                .offset(
                    -(1 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            return -(1 as libc::c_int);
        }
        _ => {
            *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, res ^ is_neq);
            return 0 as libc::c_int;
        }
    };
}
#[inline(never)]
unsafe extern "C" fn js_shr_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut v1: uint32_t = 0;
    let mut v2: uint32_t = 0;
    let mut r: uint32_t = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    if (JS_ToUint32Free(ctx, &mut v1, op1) != 0) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, op2);
    } else if !((JS_ToUint32Free(ctx, &mut v2, op2) != 0) as libc::c_int as libc::c_long
        != 0)
    {
        r = v1 >> (v2 & 0x1f as libc::c_int as libc::c_uint);
        *sp.offset(-(2 as libc::c_int) as isize) = JS_NewUint32(ctx, r);
        return 0 as libc::c_int;
    }
    *sp
        .offset(
            -(2 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_strict_eq2(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
    mut op2: JSValue,
    mut eq_mode: JSStrictEqModeEnum,
) -> BOOL {
    let mut current_block: u64;
    let mut res: BOOL = 0;
    let mut tag1: libc::c_int = 0;
    let mut tag2: libc::c_int = 0;
    let mut d1: libc::c_double = 0.;
    let mut d2: libc::c_double = 0.;
    tag1 = JS_VALUE_GET_NORM_TAG(op1);
    tag2 = JS_VALUE_GET_NORM_TAG(op2);
    match tag1 {
        1 => {
            if tag1 != tag2 {
                res = FALSE as libc::c_int;
                current_block = 13707613154239713890;
            } else {
                res = (op1 as libc::c_int == op2 as libc::c_int) as libc::c_int;
                current_block = 14006186821961145908;
            }
        }
        2 | 3 => {
            res = (tag1 == tag2) as libc::c_int;
            current_block = 13707613154239713890;
        }
        -7 => {
            let mut p1: *mut JSString = 0 as *mut JSString;
            let mut p2: *mut JSString = 0 as *mut JSString;
            if tag1 != tag2 {
                res = FALSE as libc::c_int;
            } else {
                p1 = op1 as intptr_t as *mut libc::c_void as *mut JSString;
                p2 = op2 as intptr_t as *mut libc::c_void as *mut JSString;
                res = (js_string_compare(ctx, p1, p2) == 0 as libc::c_int)
                    as libc::c_int;
            }
            current_block = 13707613154239713890;
        }
        -8 => {
            let mut p1_0: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
            let mut p2_0: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
            if tag1 != tag2 {
                res = FALSE as libc::c_int;
            } else {
                p1_0 = op1 as intptr_t as *mut libc::c_void as *mut JSAtomStruct;
                p2_0 = op2 as intptr_t as *mut libc::c_void as *mut JSAtomStruct;
                res = (p1_0 == p2_0) as libc::c_int;
            }
            current_block = 13707613154239713890;
        }
        -1 => {
            if tag1 != tag2 {
                res = FALSE as libc::c_int;
            } else {
                res = (op1 as intptr_t as *mut libc::c_void as *mut JSObject
                    == op2 as intptr_t as *mut libc::c_void as *mut JSObject)
                    as libc::c_int;
            }
            current_block = 13707613154239713890;
        }
        0 => {
            d1 = op1 as libc::c_int as libc::c_double;
            if tag2 == JS_TAG_INT as libc::c_int {
                d2 = op2 as libc::c_int as libc::c_double;
                current_block = 16690795261058884340;
            } else if tag2 == JS_TAG_FLOAT64 as libc::c_int {
                d2 = JS_VALUE_GET_FLOAT64(op2);
                current_block = 16690795261058884340;
            } else {
                res = FALSE as libc::c_int;
                current_block = 13707613154239713890;
            }
        }
        7 => {
            d1 = JS_VALUE_GET_FLOAT64(op1);
            if tag2 == JS_TAG_FLOAT64 as libc::c_int {
                d2 = JS_VALUE_GET_FLOAT64(op2);
                current_block = 16690795261058884340;
            } else if tag2 == JS_TAG_INT as libc::c_int {
                d2 = op2 as libc::c_int as libc::c_double;
                current_block = 16690795261058884340;
            } else {
                res = FALSE as libc::c_int;
                current_block = 13707613154239713890;
            }
        }
        _ => {
            res = FALSE as libc::c_int;
            current_block = 13707613154239713890;
        }
    }
    match current_block {
        13707613154239713890 => {
            JS_FreeValue(ctx, op1);
            JS_FreeValue(ctx, op2);
        }
        16690795261058884340 => {
            if (eq_mode as libc::c_uint
                >= JS_EQ_SAME_VALUE as libc::c_int as libc::c_uint) as libc::c_int
                as libc::c_long != 0
            {
                let mut u1: JSFloat64Union = JSFloat64Union { d: 0. };
                let mut u2: JSFloat64Union = JSFloat64Union { d: 0. };
                if isnan(d1) != 0 || isnan(d2) != 0 {
                    res = (isnan(d1) == isnan(d2)) as libc::c_int;
                } else if eq_mode as libc::c_uint
                    == JS_EQ_SAME_VALUE_ZERO as libc::c_int as libc::c_uint
                {
                    res = (d1 == d2) as libc::c_int;
                } else {
                    u1.d = d1;
                    u2.d = d2;
                    res = (u1.u64_0 == u2.u64_0) as libc::c_int;
                }
            } else {
                res = (d1 == d2) as libc::c_int;
            }
        }
        _ => {}
    }
    return res;
}
unsafe extern "C" fn js_strict_eq(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
    mut op2: JSValue,
) -> BOOL {
    return js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
}
unsafe extern "C" fn js_same_value(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
    mut op2: JSValue,
) -> BOOL {
    return js_strict_eq2(
        ctx,
        JS_DupValue(ctx, op1),
        JS_DupValue(ctx, op2),
        JS_EQ_SAME_VALUE,
    );
}
unsafe extern "C" fn js_same_value_zero(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
    mut op2: JSValue,
) -> BOOL {
    return js_strict_eq2(
        ctx,
        JS_DupValue(ctx, op1),
        JS_DupValue(ctx, op2),
        JS_EQ_SAME_VALUE_ZERO,
    );
}
#[inline(never)]
unsafe extern "C" fn js_strict_eq_slow(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut is_neq: BOOL,
) -> libc::c_int {
    let mut res: BOOL = 0;
    res = js_strict_eq(
        ctx,
        *sp.offset(-(2 as libc::c_int) as isize),
        *sp.offset(-(1 as libc::c_int) as isize),
    );
    *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, res ^ is_neq);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_operator_in(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    if (op2 >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        JS_ThrowTypeError(
            ctx,
            b"invalid 'in' operand\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    atom = JS_ValueToAtom(ctx, op1);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    ret = JS_HasProperty(ctx, op2, atom);
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    JS_FreeValue(ctx, op1);
    JS_FreeValue(ctx, op2);
    *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, ret);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_has_unscopable(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut arr: JSValue = 0;
    let mut val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    arr = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_unscopables as libc::c_int as JSAtom);
    if JS_IsException(arr) != 0 {
        return -(1 as libc::c_int);
    }
    ret = 0 as libc::c_int;
    if JS_IsObject(arr) != 0 {
        val = JS_GetProperty(ctx, arr, atom);
        ret = JS_ToBoolFree(ctx, val);
    }
    JS_FreeValue(ctx, arr);
    return ret;
}
unsafe extern "C" fn js_operator_instanceof(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut ret: BOOL = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    ret = JS_IsInstanceOf(ctx, op1, op2);
    if ret < 0 as libc::c_int {
        return ret;
    }
    JS_FreeValue(ctx, op1);
    JS_FreeValue(ctx, op2);
    *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, ret);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_operator_typeof(
    mut ctx: *mut JSContext,
    mut op1: JSValue,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    let mut tag: uint32_t = 0;
    tag = JS_VALUE_GET_NORM_TAG(op1) as uint32_t;
    let mut current_block_10: u64;
    match tag {
        0 | 7 => {
            atom = JS_ATOM_number as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
        3 => {
            atom = JS_ATOM_undefined as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
        1 => {
            atom = JS_ATOM_boolean as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
        4294967289 => {
            atom = JS_ATOM_string as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
        4294967295 => {
            let mut p: *mut JSObject = 0 as *mut JSObject;
            p = op1 as intptr_t as *mut libc::c_void as *mut JSObject;
            if (((*p).c2rust_unnamed.c2rust_unnamed).is_HTMLDDA() != 0) as libc::c_int
                as libc::c_long != 0
            {
                atom = JS_ATOM_undefined as libc::c_int as JSAtom;
                current_block_10 = 15089075282327824602;
            } else if JS_IsFunction(ctx, op1) != 0 {
                atom = JS_ATOM_function as libc::c_int as JSAtom;
                current_block_10 = 15089075282327824602;
            } else {
                current_block_10 = 13226217046118304493;
            }
        }
        2 => {
            current_block_10 = 13226217046118304493;
        }
        4294967288 => {
            atom = JS_ATOM_symbol as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
        _ => {
            atom = JS_ATOM_unknown as libc::c_int as JSAtom;
            current_block_10 = 15089075282327824602;
        }
    }
    match current_block_10 {
        13226217046118304493 => {
            atom = JS_ATOM_object as libc::c_int as JSAtom;
        }
        _ => {}
    }
    return atom as libc::c_int;
}
unsafe extern "C" fn js_operator_delete(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut op2: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    op1 = *sp.offset(-(2 as libc::c_int) as isize);
    op2 = *sp.offset(-(1 as libc::c_int) as isize);
    atom = JS_ValueToAtom(ctx, op2);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    ret = JS_DeleteProperty(ctx, op1, atom, (1 as libc::c_int) << 15 as libc::c_int);
    JS_FreeAtom(ctx, atom);
    if (ret < 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        return -(1 as libc::c_int);
    }
    JS_FreeValue(ctx, op1);
    JS_FreeValue(ctx, op2);
    *sp.offset(-(2 as libc::c_int) as isize) = JS_NewBool(ctx, ret);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_throw_type_error(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"invalid property access\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn js_function_proto_caller(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut b: *mut JSFunctionBytecode = JS_GetFunctionBytecode(this_val);
    if b.is_null()
        || (*b).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
        || (*b).has_prototype() == 0
    {
        return js_throw_type_error(ctx, this_val, 0 as libc::c_int, 0 as *mut JSValue);
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_function_proto_fileName(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut b: *mut JSFunctionBytecode = JS_GetFunctionBytecode(this_val);
    if !b.is_null() && (*b).has_debug() as libc::c_int != 0 {
        return JS_AtomToString(ctx, (*b).debug.filename);
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_function_proto_lineNumber(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut b: *mut JSFunctionBytecode = JS_GetFunctionBytecode(this_val);
    if !b.is_null() && (*b).has_debug() as libc::c_int != 0 {
        return JS_NewInt32(ctx, (*b).debug.line_num);
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_arguments_define_own_property(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut idx: uint32_t = 0;
    p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
        && JS_AtomIsArrayIndex(ctx, &mut idx, prop) != 0 && idx < (*p).u.array.count
    {
        if convert_fast_array_to_array(ctx, p) != 0 {
            return -(1 as libc::c_int);
        }
    }
    return JS_DefineProperty(
        ctx,
        this_obj,
        prop,
        val,
        getter,
        setter,
        flags | (1 as libc::c_int) << 17 as libc::c_int,
    );
}
static mut js_arguments_exotic_methods: JSClassExoticMethods = unsafe {
    {
        let mut init = JSClassExoticMethods {
            get_own_property: None,
            get_own_property_names: None,
            delete_property: None,
            define_own_property: Some(
                js_arguments_define_own_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                        JSValue,
                        JSValue,
                        JSValue,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            has_property: None,
            get_property: None,
            set_property: None,
        };
        init
    }
};
unsafe extern "C" fn js_build_arguments(
    mut ctx: *mut JSContext,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut tab: *mut JSValue = 0 as *mut JSValue;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut i: libc::c_int = 0;
    val = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_ARGUMENTS as libc::c_int as JSClassID,
    );
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    pr = add_property(
        ctx,
        p,
        JS_ATOM_length as libc::c_int as JSAtom,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*pr).u.value = JS_NewInt32(ctx, argc);
    tab = 0 as *mut JSValue;
    if argc > 0 as libc::c_int {
        tab = js_malloc(
            ctx,
            (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                .wrapping_mul(argc as libc::c_ulong),
        ) as *mut JSValue;
        if tab.is_null() {
            JS_FreeValue(ctx, val);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i = 0 as libc::c_int;
        while i < argc {
            *tab.offset(i as isize) = JS_DupValue(ctx, *argv.offset(i as isize));
            i += 1;
        }
    }
    let ref mut fresh259 = (*p).u.array.u.values;
    *fresh259 = tab;
    (*p).u.array.count = argc as uint32_t;
    JS_DefinePropertyValue(
        ctx,
        val,
        JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
        JS_DupValue(ctx, (*ctx).array_proto_values),
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int,
    );
    JS_DefineProperty(
        ctx,
        val,
        JS_ATOM_callee as libc::c_int as JSAtom,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        (*ctx).throw_type_error,
        (*ctx).throw_type_error,
        (1 as libc::c_int) << 11 as libc::c_int | (1 as libc::c_int) << 12 as libc::c_int,
    );
    return val;
}
unsafe extern "C" fn js_build_mapped_arguments(
    mut ctx: *mut JSContext,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut sf: *mut JSStackFrame,
    mut arg_count: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut i: libc::c_int = 0;
    val = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_MAPPED_ARGUMENTS as libc::c_int as JSClassID,
    );
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    pr = add_property(
        ctx,
        p,
        JS_ATOM_length as libc::c_int as JSAtom,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*pr).u.value = JS_NewInt32(ctx, argc);
    i = 0 as libc::c_int;
    loop {
        if !(i < arg_count) {
            current_block = 15976848397966268834;
            break;
        }
        let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
        var_ref = get_var_ref(ctx, sf, i, TRUE as libc::c_int);
        if var_ref.is_null() {
            current_block = 14022944307470732226;
            break;
        }
        pr = add_property(
            ctx,
            p,
            __JS_AtomFromUInt32(i as uint32_t),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int
                | (2 as libc::c_int) << 4 as libc::c_int,
        );
        if pr.is_null() {
            free_var_ref((*ctx).rt, var_ref);
            current_block = 14022944307470732226;
            break;
        } else {
            let ref mut fresh260 = (*pr).u.var_ref;
            *fresh260 = var_ref;
            i += 1;
        }
    }
    match current_block {
        15976848397966268834 => {
            i = arg_count;
            loop {
                if !(i < argc) {
                    current_block = 11584701595673473500;
                    break;
                }
                if JS_DefinePropertyValueUint32(
                    ctx,
                    val,
                    i as uint32_t,
                    JS_DupValue(ctx, *argv.offset(i as isize)),
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                ) < 0 as libc::c_int
                {
                    current_block = 14022944307470732226;
                    break;
                }
                i += 1;
            }
            match current_block {
                14022944307470732226 => {}
                _ => {
                    JS_DefinePropertyValue(
                        ctx,
                        val,
                        JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
                        JS_DupValue(ctx, (*ctx).array_proto_values),
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int,
                    );
                    JS_DefinePropertyValue(
                        ctx,
                        val,
                        JS_ATOM_callee as libc::c_int as JSAtom,
                        JS_DupValue(ctx, (*(*(*ctx).rt).current_stack_frame).cur_func),
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int,
                    );
                    return val;
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_build_rest(
    mut ctx: *mut JSContext,
    mut first: libc::c_int,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    val = JS_NewArray(ctx);
    if JS_IsException(val) != 0 {
        return val;
    }
    i = first;
    while i < argc {
        ret = JS_DefinePropertyValueUint32(
            ctx,
            val,
            (i - first) as uint32_t,
            JS_DupValue(ctx, *argv.offset(i as isize)),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
        if ret < 0 as libc::c_int {
            JS_FreeValue(ctx, val);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i += 1;
    }
    return val;
}
unsafe extern "C" fn build_for_in_iterator(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut tab_atom: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut i: libc::c_int = 0;
    let mut enum_obj: JSValue = 0;
    let mut obj1: JSValue = 0;
    let mut it: *mut JSForInIterator = 0 as *mut JSForInIterator;
    let mut tag: uint32_t = 0;
    let mut tab_atom_count: uint32_t = 0;
    tag = (obj >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag != JS_TAG_OBJECT as libc::c_int as libc::c_uint
        && tag != JS_TAG_NULL as libc::c_int as libc::c_uint
        && tag != JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
    {
        obj = JS_ToObjectFree(ctx, obj);
    }
    it = js_malloc(ctx, ::core::mem::size_of::<JSForInIterator>() as libc::c_ulong)
        as *mut JSForInIterator;
    if it.is_null() {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    enum_obj = JS_NewObjectProtoClass(
        ctx,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        JS_CLASS_FOR_IN_ITERATOR as libc::c_int as JSClassID,
    );
    if JS_IsException(enum_obj) != 0 {
        js_free(ctx, it as *mut libc::c_void);
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*it).is_array = FALSE as libc::c_int;
    (*it).obj = obj;
    (*it).idx = 0 as libc::c_int as uint32_t;
    p = enum_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh261 = (*p).u.for_in_iterator;
    *fresh261 = it;
    if tag == JS_TAG_NULL as libc::c_int as libc::c_uint
        || tag == JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
    {
        return enum_obj;
    }
    obj1 = JS_DupValue(ctx, obj);
    loop {
        obj1 = JS_GetPrototypeFree(ctx, obj1);
        if JS_IsNull(obj1) != 0 {
            current_block = 10692455896603418738;
            break;
        }
        if JS_IsException(obj1) != 0 {
            current_block = 16289568616126885062;
            break;
        }
        if JS_GetOwnPropertyNamesInternal(
            ctx,
            &mut tab_atom,
            &mut tab_atom_count,
            obj1 as intptr_t as *mut libc::c_void as *mut JSObject,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 4 as libc::c_int,
        ) != 0
        {
            JS_FreeValue(ctx, obj1);
            current_block = 16289568616126885062;
            break;
        } else {
            js_free_prop_enum(ctx, tab_atom, tab_atom_count);
            if tab_atom_count != 0 as libc::c_int as libc::c_uint {
                JS_FreeValue(ctx, obj1);
                current_block = 9848972595360527639;
                break;
            } else {
                if !(js_poll_interrupts(ctx) != 0) {
                    continue;
                }
                JS_FreeValue(ctx, obj1);
                current_block = 16289568616126885062;
                break;
            }
        }
    }
    match current_block {
        10692455896603418738 => {
            p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            if ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() != 0 {
                let mut sh: *mut JSShape = 0 as *mut JSShape;
                let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
                sh = (*p).shape;
                i = 0 as libc::c_int;
                prs = get_shape_prop(sh);
                loop {
                    if !(i < (*sh).prop_count) {
                        current_block = 1847472278776910194;
                        break;
                    }
                    if (*prs).flags() as libc::c_int
                        & (1 as libc::c_int) << 2 as libc::c_int != 0
                    {
                        current_block = 13451924946633538697;
                        break;
                    }
                    i += 1;
                    prs = prs.offset(1);
                }
                match current_block {
                    13451924946633538697 => {}
                    _ => {
                        (*it).is_array = TRUE as libc::c_int;
                        (*it).array_length = (*p).u.array.count;
                        current_block = 8151474771948790331;
                    }
                }
            } else {
                current_block = 13451924946633538697;
            }
            match current_block {
                13451924946633538697 => {
                    if JS_GetOwnPropertyNamesInternal(
                        ctx,
                        &mut tab_atom,
                        &mut tab_atom_count,
                        p,
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 4 as libc::c_int,
                    ) != 0
                    {
                        current_block = 16289568616126885062;
                    } else {
                        i = 0 as libc::c_int;
                        while (i as libc::c_uint) < tab_atom_count {
                            JS_SetPropertyInternal(
                                ctx,
                                enum_obj,
                                (*tab_atom.offset(i as isize)).atom,
                                (JS_TAG_NULL as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                0 as libc::c_int,
                            );
                            i += 1;
                        }
                        js_free_prop_enum(ctx, tab_atom, tab_atom_count);
                        current_block = 8151474771948790331;
                    }
                }
                _ => {}
            }
            match current_block {
                16289568616126885062 => {}
                _ => return enum_obj,
            }
        }
        9848972595360527639 => {
            obj1 = JS_DupValue(ctx, obj);
            loop {
                if JS_GetOwnPropertyNamesInternal(
                    ctx,
                    &mut tab_atom,
                    &mut tab_atom_count,
                    obj1 as intptr_t as *mut libc::c_void as *mut JSObject,
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 5 as libc::c_int,
                ) != 0
                {
                    JS_FreeValue(ctx, obj1);
                    current_block = 16289568616126885062;
                    break;
                } else {
                    i = 0 as libc::c_int;
                    while (i as libc::c_uint) < tab_atom_count {
                        JS_DefinePropertyValue(
                            ctx,
                            enum_obj,
                            (*tab_atom.offset(i as isize)).atom,
                            (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            if (*tab_atom.offset(i as isize)).is_enumerable != 0 {
                                (1 as libc::c_int) << 2 as libc::c_int
                            } else {
                                0 as libc::c_int
                            },
                        );
                        i += 1;
                    }
                    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
                    obj1 = JS_GetPrototypeFree(ctx, obj1);
                    if JS_IsNull(obj1) != 0 {
                        current_block = 13484060386966298149;
                        break;
                    }
                    if JS_IsException(obj1) != 0 {
                        current_block = 16289568616126885062;
                        break;
                    }
                    if !(js_poll_interrupts(ctx) != 0) {
                        continue;
                    }
                    JS_FreeValue(ctx, obj1);
                    current_block = 16289568616126885062;
                    break;
                }
            }
            match current_block {
                16289568616126885062 => {}
                _ => return enum_obj,
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, enum_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_for_in_start(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = build_for_in_iterator(ctx, *sp.offset(-(1 as libc::c_int) as isize));
    if JS_IsException(*sp.offset(-(1 as libc::c_int) as isize)) != 0 {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_for_in_next(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut enum_obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prop: JSAtom = 0;
    let mut it: *mut JSForInIterator = 0 as *mut JSForInIterator;
    let mut ret: libc::c_int = 0;
    enum_obj = *sp.offset(-(1 as libc::c_int) as isize);
    if !((enum_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
    {
        p = enum_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if !((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_FOR_IN_ITERATOR as libc::c_int)
        {
            it = (*p).u.for_in_iterator;
            loop {
                if (*it).is_array != 0 {
                    if (*it).idx >= (*it).array_length {
                        current_block = 16542308269469310957;
                        break;
                    }
                    prop = __JS_AtomFromUInt32((*it).idx);
                    let ref mut fresh262 = (*it).idx;
                    *fresh262 = (*fresh262).wrapping_add(1);
                } else {
                    let mut sh: *mut JSShape = (*p).shape;
                    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
                    if (*it).idx >= (*sh).prop_count as libc::c_uint {
                        current_block = 16542308269469310957;
                        break;
                    }
                    prs = (get_shape_prop(sh)).offset((*it).idx as isize);
                    prop = (*prs).atom;
                    let ref mut fresh263 = (*it).idx;
                    *fresh263 = (*fresh263).wrapping_add(1);
                    if prop == 0 as libc::c_int as libc::c_uint
                        || (*prs).flags() as libc::c_int
                            & (1 as libc::c_int) << 2 as libc::c_int == 0
                    {
                        continue;
                    }
                }
                ret = JS_HasProperty(ctx, (*it).obj, prop);
                if ret < 0 as libc::c_int {
                    return ret;
                }
                if ret != 0 {
                    current_block = 17478428563724192186;
                    break;
                }
            }
            match current_block {
                16542308269469310957 => {}
                _ => {
                    *sp.offset(0 as libc::c_int as isize) = JS_AtomToValue(ctx, prop);
                    *sp
                        .offset(
                            1 as libc::c_int as isize,
                        ) = (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    return 0 as libc::c_int;
                }
            }
        }
    }
    *sp
        .offset(
            0 as libc::c_int as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            1 as libc::c_int as isize,
        ) = (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_GetIterator2(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut method: JSValue,
) -> JSValue {
    let mut enum_obj: JSValue = 0;
    enum_obj = JS_Call(ctx, method, obj, 0 as libc::c_int, 0 as *mut JSValue);
    if JS_IsException(enum_obj) != 0 {
        return enum_obj;
    }
    if JS_IsObject(enum_obj) == 0 {
        JS_FreeValue(ctx, enum_obj);
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    return enum_obj;
}
unsafe extern "C" fn JS_GetIterator(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut is_async: BOOL,
) -> JSValue {
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut sync_iter: JSValue = 0;
    if is_async != 0 {
        method = JS_GetProperty(
            ctx,
            obj,
            JS_ATOM_Symbol_asyncIterator as libc::c_int as JSAtom,
        );
        if JS_IsException(method) != 0 {
            return method;
        }
        if JS_IsUndefined(method) != 0 || JS_IsNull(method) != 0 {
            method = JS_GetProperty(
                ctx,
                obj,
                JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
            );
            if JS_IsException(method) != 0 {
                return method;
            }
            sync_iter = JS_GetIterator2(ctx, obj, method);
            JS_FreeValue(ctx, method);
            if JS_IsException(sync_iter) != 0 {
                return sync_iter;
            }
            ret = JS_CreateAsyncFromSyncIterator(ctx, sync_iter);
            JS_FreeValue(ctx, sync_iter);
            return ret;
        }
    } else {
        method = JS_GetProperty(
            ctx,
            obj,
            JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
        );
        if JS_IsException(method) != 0 {
            return method;
        }
    }
    if JS_IsFunction(ctx, method) == 0 {
        JS_FreeValue(ctx, method);
        return JS_ThrowTypeError(
            ctx,
            b"value is not iterable\0" as *const u8 as *const libc::c_char,
        );
    }
    ret = JS_GetIterator2(ctx, obj, method);
    JS_FreeValue(ctx, method);
    return ret;
}
unsafe extern "C" fn JS_IteratorNext2(
    mut ctx: *mut JSContext,
    mut enum_obj: JSValue,
    mut method: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    if JS_IsObject(method) != 0 {
        let mut p: *mut JSObject = method as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_C_FUNCTION as libc::c_int
            && (*p).u.cfunc.cproto as libc::c_int
                == JS_CFUNC_iterator_next as libc::c_int
        {
            let mut func: JSCFunctionType = JSCFunctionType { generic: None };
            let mut args: [JSValue; 1] = [0; 1];
            if argc == 0 as libc::c_int {
                args[0 as libc::c_int
                    as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                argv = args.as_mut_ptr();
            }
            func = (*p).u.cfunc.c_function;
            return (func.iterator_next)
                .expect(
                    "non-null function pointer",
                )(ctx, enum_obj, argc, argv, pdone, (*p).u.cfunc.magic as libc::c_int);
        }
    }
    obj = JS_Call(ctx, method, enum_obj, argc, argv);
    if !(JS_IsException(obj) != 0) {
        if JS_IsObject(obj) == 0 {
            JS_FreeValue(ctx, obj);
            JS_ThrowTypeError(
                ctx,
                b"iterator must return an object\0" as *const u8 as *const libc::c_char,
            );
        } else {
            *pdone = 2 as libc::c_int;
            return obj;
        }
    }
    *pdone = FALSE as libc::c_int;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_IteratorNext(
    mut ctx: *mut JSContext,
    mut enum_obj: JSValue,
    mut method: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut value: JSValue = 0;
    let mut done_val: JSValue = 0;
    let mut done: libc::c_int = 0;
    obj = JS_IteratorNext2(ctx, enum_obj, method, argc, argv, &mut done);
    if !(JS_IsException(obj) != 0) {
        if done != 2 as libc::c_int {
            *pdone = done;
            return obj;
        } else {
            done_val = JS_GetProperty(ctx, obj, JS_ATOM_done as libc::c_int as JSAtom);
            if !(JS_IsException(done_val) != 0) {
                *pdone = JS_ToBoolFree(ctx, done_val);
                value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                if *pdone == 0 {
                    value = JS_GetProperty(
                        ctx,
                        obj,
                        JS_ATOM_value as libc::c_int as JSAtom,
                    );
                }
                JS_FreeValue(ctx, obj);
                return value;
            }
        }
    }
    JS_FreeValue(ctx, obj);
    *pdone = FALSE as libc::c_int;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_IteratorClose(
    mut ctx: *mut JSContext,
    mut enum_obj: JSValue,
    mut is_exception_pending: BOOL,
) -> libc::c_int {
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut ex_obj: JSValue = 0;
    let mut res: libc::c_int = 0;
    if is_exception_pending != 0 {
        ex_obj = (*(*ctx).rt).current_exception;
        (*(*ctx).rt)
            .current_exception = (JS_TAG_NULL as libc::c_int as uint64_t)
            << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        res = -(1 as libc::c_int);
    } else {
        ex_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        res = 0 as libc::c_int;
    }
    method = JS_GetProperty(ctx, enum_obj, JS_ATOM_return as libc::c_int as JSAtom);
    if JS_IsException(method) != 0 {
        res = -(1 as libc::c_int);
    } else if !(JS_IsUndefined(method) != 0 || JS_IsNull(method) != 0) {
        ret = JS_CallFree(ctx, method, enum_obj, 0 as libc::c_int, 0 as *mut JSValue);
        if is_exception_pending == 0 {
            if JS_IsException(ret) != 0 {
                res = -(1 as libc::c_int);
            } else if JS_IsObject(ret) == 0 {
                JS_ThrowTypeErrorNotAnObject(ctx);
                res = -(1 as libc::c_int);
            }
        }
        JS_FreeValue(ctx, ret);
    }
    if is_exception_pending != 0 {
        JS_Throw(ctx, ex_obj);
    }
    return res;
}
unsafe extern "C" fn js_for_of_start(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut is_async: BOOL,
) -> libc::c_int {
    let mut op1: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut method: JSValue = 0;
    op1 = *sp.offset(-(1 as libc::c_int) as isize);
    obj = JS_GetIterator(ctx, op1, is_async);
    if JS_IsException(obj) != 0 {
        return -(1 as libc::c_int);
    }
    JS_FreeValue(ctx, op1);
    *sp.offset(-(1 as libc::c_int) as isize) = obj;
    method = JS_GetProperty(ctx, obj, JS_ATOM_next as libc::c_int as JSAtom);
    if JS_IsException(method) != 0 {
        return -(1 as libc::c_int);
    }
    *sp.offset(0 as libc::c_int as isize) = method;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_for_of_next(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut offset: libc::c_int,
) -> libc::c_int {
    let mut value: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut done: libc::c_int = 1 as libc::c_int;
    if (JS_IsUndefined(*sp.offset(offset as isize)) == 0) as libc::c_int as libc::c_long
        != 0
    {
        value = JS_IteratorNext(
            ctx,
            *sp.offset(offset as isize),
            *sp.offset((offset + 1 as libc::c_int) as isize),
            0 as libc::c_int,
            0 as *mut JSValue,
            &mut done,
        );
        if JS_IsException(value) != 0 {
            done = -(1 as libc::c_int);
        }
        if done != 0 {
            JS_FreeValue(ctx, *sp.offset(offset as isize));
            *sp
                .offset(
                    offset as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if done < 0 as libc::c_int {
                return -(1 as libc::c_int)
            } else {
                JS_FreeValue(ctx, value);
                value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    *sp.offset(0 as libc::c_int as isize) = value;
    *sp.offset(1 as libc::c_int as isize) = JS_NewBool(ctx, done);
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_IteratorGetCompleteValue(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut pdone: *mut BOOL,
) -> JSValue {
    let mut done_val: JSValue = 0;
    let mut value: JSValue = 0;
    let mut done: BOOL = 0;
    done_val = JS_GetProperty(ctx, obj, JS_ATOM_done as libc::c_int as JSAtom);
    if !(JS_IsException(done_val) != 0) {
        done = JS_ToBoolFree(ctx, done_val);
        value = JS_GetProperty(ctx, obj, JS_ATOM_value as libc::c_int as JSAtom);
        if !(JS_IsException(value) != 0) {
            *pdone = done;
            return value;
        }
    }
    *pdone = FALSE as libc::c_int;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_iterator_get_value_done(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut obj: JSValue = 0;
    let mut value: JSValue = 0;
    let mut done: BOOL = 0;
    obj = *sp.offset(-(1 as libc::c_int) as isize);
    if JS_IsObject(obj) == 0 {
        JS_ThrowTypeError(
            ctx,
            b"iterator must return an object\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    value = JS_IteratorGetCompleteValue(ctx, obj, &mut done);
    if JS_IsException(value) != 0 {
        return -(1 as libc::c_int);
    }
    JS_FreeValue(ctx, obj);
    *sp.offset(-(1 as libc::c_int) as isize) = value;
    *sp.offset(0 as libc::c_int as isize) = JS_NewBool(ctx, done);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_create_iterator_result(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut done: BOOL,
) -> JSValue {
    let mut obj: JSValue = 0;
    obj = JS_NewObject(ctx);
    if JS_IsException(obj) != 0 {
        JS_FreeValue(ctx, val);
        return obj;
    }
    if !(JS_DefinePropertyValue(
        ctx,
        obj,
        JS_ATOM_value as libc::c_int as JSAtom,
        val,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int,
    ) < 0 as libc::c_int)
    {
        if !(JS_DefinePropertyValue(
            ctx,
            obj,
            JS_ATOM_done as libc::c_int as JSAtom,
            JS_NewBool(ctx, done),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        ) < 0 as libc::c_int)
        {
            return obj;
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_is_fast_array(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> BOOL {
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARRAY as libc::c_int
            && ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
        {
            return TRUE as libc::c_int;
        }
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn js_get_fast_array(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut arrpp: *mut *mut JSValue,
    mut countp: *mut uint32_t,
) -> BOOL {
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARRAY as libc::c_int
            && ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
        {
            *countp = (*p).u.array.count;
            *arrpp = (*p).u.array.u.values;
            return TRUE as libc::c_int;
        }
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn js_append_enumerate(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut iterator: JSValue = 0;
    let mut enumobj: JSValue = 0;
    let mut method: JSValue = 0;
    let mut value: JSValue = 0;
    let mut is_array_iterator: libc::c_int = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut i: uint32_t = 0;
    let mut count32: uint32_t = 0;
    let mut pos: uint32_t = 0;
    if (*sp.offset(-(2 as libc::c_int) as isize) >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_INT as libc::c_int
    {
        JS_ThrowInternalError(
            ctx,
            b"invalid index for append\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    pos = *sp.offset(-(2 as libc::c_int) as isize) as libc::c_int as uint32_t;
    iterator = JS_GetProperty(
        ctx,
        *sp.offset(-(1 as libc::c_int) as isize),
        JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
    );
    if JS_IsException(iterator) != 0 {
        return -(1 as libc::c_int);
    }
    is_array_iterator = JS_IsCFunction(
        ctx,
        iterator,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
            >,
            Option::<JSCFunction>,
        >(
            Some(
                js_create_array_iterator
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            ),
        ),
        JS_ITERATOR_KIND_VALUE as libc::c_int,
    );
    JS_FreeValue(ctx, iterator);
    enumobj = JS_GetIterator(
        ctx,
        *sp.offset(-(1 as libc::c_int) as isize),
        FALSE as libc::c_int,
    );
    if JS_IsException(enumobj) != 0 {
        return -(1 as libc::c_int);
    }
    method = JS_GetProperty(ctx, enumobj, JS_ATOM_next as libc::c_int as JSAtom);
    if JS_IsException(method) != 0 {
        JS_FreeValue(ctx, enumobj);
        return -(1 as libc::c_int);
    }
    if is_array_iterator != 0
        && JS_IsCFunction(
            ctx,
            method,
            ::core::mem::transmute::<
                Option::<
                    unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        *mut BOOL,
                        libc::c_int,
                    ) -> JSValue,
                >,
                Option::<JSCFunction>,
            >(
                Some(
                    js_array_iterator_next
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            JSValue,
                            libc::c_int,
                            *mut JSValue,
                            *mut BOOL,
                            libc::c_int,
                        ) -> JSValue,
                ),
            ),
            0 as libc::c_int,
        ) != 0
        && js_get_fast_array(
            ctx,
            *sp.offset(-(1 as libc::c_int) as isize),
            &mut arrp,
            &mut count32,
        ) != 0
    {
        let mut len: uint32_t = 0;
        if js_get_length32(ctx, &mut len, *sp.offset(-(1 as libc::c_int) as isize)) != 0
        {
            current_block = 9845837827466409867;
        } else if len != count32 {
            current_block = 7056779235015430508;
        } else {
            i = 0 as libc::c_int as uint32_t;
            loop {
                if !(i < count32) {
                    current_block = 18153031941552419006;
                    break;
                }
                let fresh264 = pos;
                pos = pos.wrapping_add(1);
                if JS_DefinePropertyValueUint32(
                    ctx,
                    *sp.offset(-(3 as libc::c_int) as isize),
                    fresh264,
                    JS_DupValue(ctx, *arrp.offset(i as isize)),
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                ) < 0 as libc::c_int
                {
                    current_block = 9845837827466409867;
                    break;
                }
                i = i.wrapping_add(1);
            }
        }
    } else {
        current_block = 7056779235015430508;
    }
    loop {
        match current_block {
            7056779235015430508 => {
                let mut done: BOOL = 0;
                value = JS_IteratorNext(
                    ctx,
                    enumobj,
                    method,
                    0 as libc::c_int,
                    0 as *mut JSValue,
                    &mut done,
                );
                if JS_IsException(value) != 0 {
                    current_block = 9845837827466409867;
                    continue;
                }
                if done != 0 {
                    current_block = 18153031941552419006;
                    continue;
                }
                let fresh265 = pos;
                pos = pos.wrapping_add(1);
                if JS_DefinePropertyValueUint32(
                    ctx,
                    *sp.offset(-(3 as libc::c_int) as isize),
                    fresh265,
                    value,
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                ) < 0 as libc::c_int
                {
                    current_block = 9845837827466409867;
                } else {
                    current_block = 7056779235015430508;
                }
            }
            9845837827466409867 => {
                JS_IteratorClose(ctx, enumobj, TRUE as libc::c_int);
                JS_FreeValue(ctx, enumobj);
                JS_FreeValue(ctx, method);
                return -(1 as libc::c_int);
            }
            _ => {
                *sp
                    .offset(
                        -(2 as libc::c_int) as isize,
                    ) = JS_NewInt32(ctx, pos as int32_t);
                JS_FreeValue(ctx, enumobj);
                JS_FreeValue(ctx, method);
                return 0 as libc::c_int;
            }
        }
    };
}
unsafe extern "C" fn JS_CopyDataProperties(
    mut ctx: *mut JSContext,
    mut target: JSValue,
    mut source: JSValue,
    mut excluded: JSValue,
    mut setprop: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut tab_atom: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut val: JSValue = 0;
    let mut i: uint32_t = 0;
    let mut tab_atom_count: uint32_t = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut pexcl: *mut JSObject = 0 as *mut JSObject;
    let mut ret: libc::c_int = 0;
    let mut gpn_flags: libc::c_int = 0;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut is_enumerable: BOOL = 0;
    if (source >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return 0 as libc::c_int;
    }
    if (excluded >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        pexcl = excluded as intptr_t as *mut libc::c_void as *mut JSObject;
    }
    p = source as intptr_t as *mut libc::c_void as *mut JSObject;
    gpn_flags = (1 as libc::c_int) << 0 as libc::c_int
        | (1 as libc::c_int) << 1 as libc::c_int
        | (1 as libc::c_int) << 4 as libc::c_int;
    if ((*p).c2rust_unnamed.c2rust_unnamed).is_exotic() != 0 {
        let mut em: *const JSClassExoticMethods = (*((*(*ctx).rt).class_array)
            .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
            .exotic;
        if !em.is_null() && ((*em).get_own_property_names).is_some() {
            gpn_flags &= !((1 as libc::c_int) << 4 as libc::c_int);
        }
    }
    if JS_GetOwnPropertyNamesInternal(
        ctx,
        &mut tab_atom,
        &mut tab_atom_count,
        p,
        gpn_flags,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int as uint32_t;
    loop {
        if !(i < tab_atom_count) {
            current_block = 5529461102203738653;
            break;
        }
        if !pexcl.is_null() {
            ret = JS_GetOwnPropertyInternal(
                ctx,
                0 as *mut JSPropertyDescriptor,
                pexcl,
                (*tab_atom.offset(i as isize)).atom,
            );
            if ret != 0 {
                if ret < 0 as libc::c_int {
                    current_block = 6395326038043875052;
                    break;
                }
                current_block = 17833034027772472439;
            } else {
                current_block = 11194104282611034094;
            }
        } else {
            current_block = 11194104282611034094;
        }
        match current_block {
            11194104282611034094 => {
                if gpn_flags & (1 as libc::c_int) << 4 as libc::c_int == 0 {
                    ret = JS_GetOwnPropertyInternal(
                        ctx,
                        &mut desc,
                        p,
                        (*tab_atom.offset(i as isize)).atom,
                    );
                    if ret < 0 as libc::c_int {
                        current_block = 6395326038043875052;
                        break;
                    }
                    if ret == 0 {
                        current_block = 17833034027772472439;
                    } else {
                        is_enumerable = (desc.flags
                            & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                            as libc::c_int;
                        js_free_desc(ctx, &mut desc);
                        if is_enumerable == 0 {
                            current_block = 17833034027772472439;
                        } else {
                            current_block = 15897653523371991391;
                        }
                    }
                } else {
                    current_block = 15897653523371991391;
                }
                match current_block {
                    17833034027772472439 => {}
                    _ => {
                        val = JS_GetProperty(
                            ctx,
                            source,
                            (*tab_atom.offset(i as isize)).atom,
                        );
                        if JS_IsException(val) != 0 {
                            current_block = 6395326038043875052;
                            break;
                        }
                        if setprop != 0 {
                            ret = JS_SetProperty(
                                ctx,
                                target,
                                (*tab_atom.offset(i as isize)).atom,
                                val,
                            );
                        } else {
                            ret = JS_DefinePropertyValue(
                                ctx,
                                target,
                                (*tab_atom.offset(i as isize)).atom,
                                val,
                                (1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int,
                            );
                        }
                        if ret < 0 as libc::c_int {
                            current_block = 6395326038043875052;
                            break;
                        }
                    }
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
    }
    match current_block {
        6395326038043875052 => {
            js_free_prop_enum(ctx, tab_atom, tab_atom_count);
            return -(1 as libc::c_int);
        }
        _ => {
            js_free_prop_enum(ctx, tab_atom, tab_atom_count);
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn JS_GetActiveFunction(mut ctx: *mut JSContext) -> JSValue {
    return (*(*(*ctx).rt).current_stack_frame).cur_func;
}
unsafe extern "C" fn get_var_ref(
    mut ctx: *mut JSContext,
    mut sf: *mut JSStackFrame,
    mut var_idx: libc::c_int,
    mut is_arg: BOOL,
) -> *mut JSVarRef {
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    let mut el: *mut list_head = 0 as *mut list_head;
    el = (*sf).var_ref_list.next;
    while el != &mut (*sf).var_ref_list as *mut list_head {
        var_ref = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSVarRef;
        if (*var_ref).c2rust_unnamed.c2rust_unnamed.var_idx as libc::c_int == var_idx
            && ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_arg() as libc::c_int
                == is_arg
        {
            let ref mut fresh266 = (*var_ref).c2rust_unnamed.header.ref_count;
            *fresh266 += 1;
            return var_ref;
        }
        el = (*el).next;
    }
    var_ref = js_malloc(ctx, ::core::mem::size_of::<JSVarRef>() as libc::c_ulong)
        as *mut JSVarRef;
    if var_ref.is_null() {
        return 0 as *mut JSVarRef;
    }
    (*var_ref).c2rust_unnamed.header.ref_count = 1 as libc::c_int;
    let ref mut fresh267 = (*var_ref).c2rust_unnamed.c2rust_unnamed;
    (*fresh267).set_is_detached(FALSE as libc::c_int as uint8_t);
    let ref mut fresh268 = (*var_ref).c2rust_unnamed.c2rust_unnamed;
    (*fresh268).set_is_arg(is_arg as uint8_t);
    (*var_ref).c2rust_unnamed.c2rust_unnamed.var_idx = var_idx as uint16_t;
    list_add_tail(&mut (*var_ref).c2rust_unnamed.header.link, &mut (*sf).var_ref_list);
    if is_arg != 0 {
        let ref mut fresh269 = (*var_ref).pvalue;
        *fresh269 = &mut *((*sf).arg_buf).offset(var_idx as isize) as *mut JSValue;
    } else {
        let ref mut fresh270 = (*var_ref).pvalue;
        *fresh270 = &mut *((*sf).var_buf).offset(var_idx as isize) as *mut JSValue;
    }
    (*var_ref)
        .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return var_ref;
}
unsafe extern "C" fn js_closure2(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut b: *mut JSFunctionBytecode,
    mut cur_var_refs: *mut *mut JSVarRef,
    mut sf: *mut JSStackFrame,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut i: libc::c_int = 0;
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh271 = (*p).u.func.function_bytecode;
    *fresh271 = b;
    let ref mut fresh272 = (*p).u.func.home_object;
    *fresh272 = 0 as *mut JSObject;
    let ref mut fresh273 = (*p).u.func.var_refs;
    *fresh273 = 0 as *mut *mut JSVarRef;
    if (*b).closure_var_count != 0 {
        var_refs = js_mallocz(
            ctx,
            (::core::mem::size_of::<*mut JSVarRef>() as libc::c_ulong)
                .wrapping_mul((*b).closure_var_count as libc::c_ulong),
        ) as *mut *mut JSVarRef;
        if var_refs.is_null() {
            current_block = 7910257505189106710;
        } else {
            let ref mut fresh274 = (*p).u.func.var_refs;
            *fresh274 = var_refs;
            i = 0 as libc::c_int;
            loop {
                if !(i < (*b).closure_var_count) {
                    current_block = 4808432441040389987;
                    break;
                }
                let mut cv: *mut JSClosureVar = &mut *((*b).closure_var)
                    .offset(i as isize) as *mut JSClosureVar;
                let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
                if (*cv).is_local() != 0 {
                    var_ref = get_var_ref(
                        ctx,
                        sf,
                        (*cv).var_idx as libc::c_int,
                        (*cv).is_arg() as BOOL,
                    );
                    if var_ref.is_null() {
                        current_block = 7910257505189106710;
                        break;
                    }
                } else {
                    var_ref = *cur_var_refs.offset((*cv).var_idx as isize);
                    let ref mut fresh275 = (*var_ref).c2rust_unnamed.header.ref_count;
                    *fresh275 += 1;
                }
                let ref mut fresh276 = *var_refs.offset(i as isize);
                *fresh276 = var_ref;
                i += 1;
            }
        }
        match current_block {
            4808432441040389987 => {}
            _ => {
                JS_FreeValue(ctx, func_obj);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    return func_obj;
}
unsafe extern "C" fn js_instantiate_prototype(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut atom: JSAtom,
    mut opaque: *mut libc::c_void,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut this_val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    this_val = (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
        | p as uintptr_t as libc::c_ulonglong;
    obj = JS_NewObject(ctx);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    set_cycle_flag(ctx, obj);
    set_cycle_flag(ctx, this_val);
    ret = JS_DefinePropertyValue(
        ctx,
        obj,
        JS_ATOM_constructor as libc::c_int as JSAtom,
        JS_DupValue(ctx, this_val),
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    if ret < 0 as libc::c_int {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return obj;
}
static mut func_kind_to_class_id: [uint16_t; 4] = [
    JS_CLASS_BYTECODE_FUNCTION as libc::c_int as uint16_t,
    JS_CLASS_GENERATOR_FUNCTION as libc::c_int as uint16_t,
    JS_CLASS_ASYNC_FUNCTION as libc::c_int as uint16_t,
    JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as uint16_t,
];
unsafe extern "C" fn js_closure(
    mut ctx: *mut JSContext,
    mut bfunc: JSValue,
    mut cur_var_refs: *mut *mut JSVarRef,
    mut sf: *mut JSStackFrame,
) -> JSValue {
    let mut current_block: u64;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut func_obj: JSValue = 0;
    let mut name_atom: JSAtom = 0;
    b = bfunc as intptr_t as *mut libc::c_void as *mut JSFunctionBytecode;
    func_obj = JS_NewObjectClass(
        ctx,
        func_kind_to_class_id[(*b).func_kind() as usize] as libc::c_int,
    );
    if JS_IsException(func_obj) != 0 {
        JS_FreeValue(ctx, bfunc);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    func_obj = js_closure2(ctx, func_obj, b, cur_var_refs, sf);
    if !(JS_IsException(func_obj) != 0) {
        name_atom = (*b).func_name;
        if name_atom == 0 as libc::c_int as libc::c_uint {
            name_atom = JS_ATOM_empty_string as libc::c_int as JSAtom;
        }
        js_function_set_properties(
            ctx,
            func_obj,
            name_atom,
            (*b).defined_arg_count as libc::c_int,
        );
        if (*b).func_kind() as libc::c_int & JS_FUNC_GENERATOR as libc::c_int != 0 {
            let mut proto: JSValue = 0;
            let mut proto_class_id: libc::c_int = 0;
            if (*b).func_kind() as libc::c_int == JS_FUNC_ASYNC_GENERATOR as libc::c_int
            {
                proto_class_id = JS_CLASS_ASYNC_GENERATOR as libc::c_int;
            } else {
                proto_class_id = JS_CLASS_GENERATOR as libc::c_int;
            }
            proto = JS_NewObjectProto(
                ctx,
                *((*ctx).class_proto).offset(proto_class_id as isize),
            );
            if JS_IsException(proto) != 0 {
                current_block = 4930873641238309402;
            } else {
                JS_DefinePropertyValue(
                    ctx,
                    func_obj,
                    JS_ATOM_prototype as libc::c_int as JSAtom,
                    proto,
                    (1 as libc::c_int) << 1 as libc::c_int,
                );
                current_block = 10043043949733653460;
            }
        } else {
            if (*b).has_prototype() != 0 {
                JS_SetConstructorBit(ctx, func_obj, TRUE as libc::c_int);
                JS_DefineAutoInitProperty(
                    ctx,
                    func_obj,
                    JS_ATOM_prototype as libc::c_int as JSAtom,
                    JS_AUTOINIT_ID_PROTOTYPE,
                    0 as *mut libc::c_void,
                    (1 as libc::c_int) << 1 as libc::c_int,
                );
            }
            current_block = 10043043949733653460;
        }
        match current_block {
            4930873641238309402 => {}
            _ => return func_obj,
        }
    }
    JS_FreeValue(ctx, func_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_op_define_class(
    mut ctx: *mut JSContext,
    mut sp: *mut JSValue,
    mut class_name: JSAtom,
    mut class_flags: libc::c_int,
    mut cur_var_refs: *mut *mut JSVarRef,
    mut sf: *mut JSStackFrame,
    mut is_computed_name: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut bfunc: JSValue = 0;
    let mut parent_class: JSValue = 0;
    let mut proto: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut ctor: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut parent_proto: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    parent_class = *sp.offset(-(2 as libc::c_int) as isize);
    bfunc = *sp.offset(-(1 as libc::c_int) as isize);
    if class_flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        if JS_IsNull(parent_class) != 0 {
            parent_proto = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            parent_class = JS_DupValue(ctx, (*ctx).function_proto);
            current_block = 6057473163062296781;
        } else if JS_IsConstructor(ctx, parent_class) == 0 {
            JS_ThrowTypeError(
                ctx,
                b"parent class must be constructor\0" as *const u8 as *const libc::c_char,
            );
            current_block = 15068650954138672645;
        } else {
            parent_proto = JS_GetProperty(
                ctx,
                parent_class,
                JS_ATOM_prototype as libc::c_int as JSAtom,
            );
            if JS_IsException(parent_proto) != 0 {
                current_block = 15068650954138672645;
            } else if JS_IsNull(parent_proto) == 0 && JS_IsObject(parent_proto) == 0 {
                JS_ThrowTypeError(
                    ctx,
                    b"parent prototype must be an object or null\0" as *const u8
                        as *const libc::c_char,
                );
                current_block = 15068650954138672645;
            } else {
                current_block = 6057473163062296781;
            }
        }
    } else {
        parent_proto = JS_DupValue(
            ctx,
            *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        );
        parent_class = JS_DupValue(ctx, (*ctx).function_proto);
        current_block = 6057473163062296781;
    }
    match current_block {
        6057473163062296781 => {
            proto = JS_NewObjectProto(ctx, parent_proto);
            if !(JS_IsException(proto) != 0) {
                b = bfunc as intptr_t as *mut libc::c_void as *mut JSFunctionBytecode;
                assert(
                    ((*b).func_kind() as libc::c_int == JS_FUNC_NORMAL as libc::c_int)
                        as libc::c_int,
                );
                ctor = JS_NewObjectProtoClass(
                    ctx,
                    parent_class,
                    JS_CLASS_BYTECODE_FUNCTION as libc::c_int as JSClassID,
                );
                if !(JS_IsException(ctor) != 0) {
                    ctor = js_closure2(ctx, ctor, b, cur_var_refs, sf);
                    bfunc = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    if !(JS_IsException(ctor) != 0) {
                        js_method_set_home_object(ctx, ctor, proto);
                        JS_SetConstructorBit(ctx, ctor, TRUE as libc::c_int);
                        JS_DefinePropertyValue(
                            ctx,
                            ctor,
                            JS_ATOM_length as libc::c_int as JSAtom,
                            JS_NewInt32(ctx, (*b).defined_arg_count as int32_t),
                            (1 as libc::c_int) << 0 as libc::c_int,
                        );
                        if is_computed_name != 0 {
                            if JS_DefineObjectNameComputed(
                                ctx,
                                ctor,
                                *sp.offset(-(3 as libc::c_int) as isize),
                                (1 as libc::c_int) << 0 as libc::c_int,
                            ) < 0 as libc::c_int
                            {
                                current_block = 15068650954138672645;
                            } else {
                                current_block = 9853141518545631134;
                            }
                        } else if JS_DefineObjectName(
                            ctx,
                            ctor,
                            class_name,
                            (1 as libc::c_int) << 0 as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            current_block = 15068650954138672645;
                        } else {
                            current_block = 9853141518545631134;
                        }
                        match current_block {
                            15068650954138672645 => {}
                            _ => {
                                if !(JS_DefinePropertyValue(
                                    ctx,
                                    proto,
                                    JS_ATOM_constructor as libc::c_int as JSAtom,
                                    JS_DupValue(ctx, ctor),
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int)
                                {
                                    if !(JS_DefinePropertyValue(
                                        ctx,
                                        ctor,
                                        JS_ATOM_prototype as libc::c_int as JSAtom,
                                        JS_DupValue(ctx, proto),
                                        (1 as libc::c_int) << 14 as libc::c_int,
                                    ) < 0 as libc::c_int)
                                    {
                                        set_cycle_flag(ctx, ctor);
                                        set_cycle_flag(ctx, proto);
                                        JS_FreeValue(ctx, parent_proto);
                                        JS_FreeValue(ctx, parent_class);
                                        *sp.offset(-(2 as libc::c_int) as isize) = ctor;
                                        *sp.offset(-(1 as libc::c_int) as isize) = proto;
                                        return 0 as libc::c_int;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, parent_class);
    JS_FreeValue(ctx, parent_proto);
    JS_FreeValue(ctx, bfunc);
    JS_FreeValue(ctx, proto);
    JS_FreeValue(ctx, ctor);
    *sp
        .offset(
            -(2 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    *sp
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn close_var_refs(mut rt: *mut JSRuntime, mut sf: *mut JSStackFrame) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    let mut var_idx: libc::c_int = 0;
    el = (*sf).var_ref_list.next;
    el1 = (*el).next;
    while el != &mut (*sf).var_ref_list as *mut list_head {
        var_ref = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSVarRef;
        var_idx = (*var_ref).c2rust_unnamed.c2rust_unnamed.var_idx as libc::c_int;
        if ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_arg() != 0 {
            (*var_ref)
                .value = JS_DupValueRT(rt, *((*sf).arg_buf).offset(var_idx as isize));
        } else {
            (*var_ref)
                .value = JS_DupValueRT(rt, *((*sf).var_buf).offset(var_idx as isize));
        }
        let ref mut fresh277 = (*var_ref).pvalue;
        *fresh277 = &mut (*var_ref).value;
        let ref mut fresh278 = (*var_ref).c2rust_unnamed.c2rust_unnamed;
        (*fresh278).set_is_detached(TRUE as libc::c_int as uint8_t);
        add_gc_object(rt, &mut (*var_ref).c2rust_unnamed.header, JS_GC_OBJ_TYPE_VAR_REF);
        el = el1;
        el1 = (*el).next;
    }
}
unsafe extern "C" fn close_lexical_var(
    mut ctx: *mut JSContext,
    mut sf: *mut JSStackFrame,
    mut idx: libc::c_int,
    mut is_arg: libc::c_int,
) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    let mut var_idx: libc::c_int = idx;
    el = (*sf).var_ref_list.next;
    el1 = (*el).next;
    while el != &mut (*sf).var_ref_list as *mut list_head {
        var_ref = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSVarRef;
        if var_idx == (*var_ref).c2rust_unnamed.c2rust_unnamed.var_idx as libc::c_int
            && ((*var_ref).c2rust_unnamed.c2rust_unnamed).is_arg() as libc::c_int
                == is_arg
        {
            (*var_ref)
                .value = JS_DupValue(ctx, *((*sf).var_buf).offset(var_idx as isize));
            let ref mut fresh279 = (*var_ref).pvalue;
            *fresh279 = &mut (*var_ref).value;
            list_del(&mut (*var_ref).c2rust_unnamed.header.link);
            let ref mut fresh280 = (*var_ref).c2rust_unnamed.c2rust_unnamed;
            (*fresh280).set_is_detached(TRUE as libc::c_int as uint8_t);
            add_gc_object(
                (*ctx).rt,
                &mut (*var_ref).c2rust_unnamed.header,
                JS_GC_OBJ_TYPE_VAR_REF,
            );
        }
        el = el1;
        el1 = (*el).next;
    }
}
unsafe extern "C" fn js_call_c_function(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut func: JSCFunctionType = JSCFunctionType { generic: None };
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut sf_s: JSStackFrame = JSStackFrame {
        prev_frame: 0 as *mut JSStackFrame,
        cur_func: 0,
        arg_buf: 0 as *mut JSValue,
        var_buf: 0 as *mut JSValue,
        var_ref_list: list_head {
            prev: 0 as *mut list_head,
            next: 0 as *mut list_head,
        },
        cur_pc: 0 as *const uint8_t,
        arg_count: 0,
        js_mode: 0,
        cur_sp: 0 as *mut JSValue,
    };
    let mut sf: *mut JSStackFrame = &mut sf_s;
    let mut prev_sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut ret_val: JSValue = 0;
    let mut arg_buf: *mut JSValue = 0 as *mut JSValue;
    let mut arg_count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut cproto: JSCFunctionEnum = JS_CFUNC_generic;
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    cproto = (*p).u.cfunc.cproto as JSCFunctionEnum;
    arg_count = (*p).u.cfunc.length as libc::c_int;
    if js_check_stack_overflow(
        rt,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(arg_count as libc::c_ulong),
    ) != 0
    {
        return JS_ThrowStackOverflow(ctx);
    }
    prev_sf = (*rt).current_stack_frame;
    let ref mut fresh281 = (*sf).prev_frame;
    *fresh281 = prev_sf;
    let ref mut fresh282 = (*rt).current_stack_frame;
    *fresh282 = sf;
    ctx = (*p).u.cfunc.realm;
    (*sf).js_mode = 0 as libc::c_int;
    (*sf).cur_func = func_obj;
    (*sf).arg_count = argc;
    arg_buf = argv;
    if (argc < arg_count) as libc::c_int as libc::c_long != 0 {
        arg_buf = alloca(
            (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                .wrapping_mul(arg_count as libc::c_ulong),
        ) as *mut JSValue;
        i = 0 as libc::c_int;
        while i < argc {
            *arg_buf.offset(i as isize) = *argv.offset(i as isize);
            i += 1;
        }
        i = argc;
        while i < arg_count {
            *arg_buf
                .offset(
                    i as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            i += 1;
        }
        (*sf).arg_count = arg_count;
    }
    let ref mut fresh283 = (*sf).arg_buf;
    *fresh283 = arg_buf;
    func = (*p).u.cfunc.c_function;
    let mut current_block_46: u64;
    match cproto as libc::c_uint {
        2 | 4 => {
            if flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                if cproto as libc::c_uint
                    == JS_CFUNC_constructor as libc::c_int as libc::c_uint
                {
                    current_block_46 = 12936261764148168459;
                } else {
                    this_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block_46 = 18395719385608038613;
                }
            } else {
                current_block_46 = 18395719385608038613;
            }
        }
        0 => {
            current_block_46 = 18395719385608038613;
        }
        3 | 5 => {
            if flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                if cproto as libc::c_uint
                    == JS_CFUNC_constructor_magic as libc::c_int as libc::c_uint
                {
                    current_block_46 = 12936261764148168459;
                } else {
                    this_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block_46 = 6252765015528925724;
                }
            } else {
                current_block_46 = 6252765015528925724;
            }
        }
        1 => {
            current_block_46 = 6252765015528925724;
        }
        8 => {
            ret_val = (func.getter).expect("non-null function pointer")(ctx, this_obj);
            current_block_46 = 10512632378975961025;
        }
        9 => {
            ret_val = (func.setter)
                .expect(
                    "non-null function pointer",
                )(ctx, this_obj, *arg_buf.offset(0 as libc::c_int as isize));
            current_block_46 = 10512632378975961025;
        }
        10 => {
            ret_val = (func.getter_magic)
                .expect(
                    "non-null function pointer",
                )(ctx, this_obj, (*p).u.cfunc.magic as libc::c_int);
            current_block_46 = 10512632378975961025;
        }
        11 => {
            ret_val = (func.setter_magic)
                .expect(
                    "non-null function pointer",
                )(
                ctx,
                this_obj,
                *arg_buf.offset(0 as libc::c_int as isize),
                (*p).u.cfunc.magic as libc::c_int,
            );
            current_block_46 = 10512632378975961025;
        }
        6 => {
            let mut d1: libc::c_double = 0.;
            if (JS_ToFloat64(ctx, &mut d1, *arg_buf.offset(0 as libc::c_int as isize))
                != 0) as libc::c_int as libc::c_long != 0
            {
                ret_val = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                ret_val = JS_NewFloat64(
                    ctx,
                    (func.f_f).expect("non-null function pointer")(d1),
                );
            }
            current_block_46 = 10512632378975961025;
        }
        7 => {
            let mut d1_0: libc::c_double = 0.;
            let mut d2: libc::c_double = 0.;
            if (JS_ToFloat64(ctx, &mut d1_0, *arg_buf.offset(0 as libc::c_int as isize))
                != 0) as libc::c_int as libc::c_long != 0
            {
                ret_val = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else if (JS_ToFloat64(
                ctx,
                &mut d2,
                *arg_buf.offset(1 as libc::c_int as isize),
            ) != 0) as libc::c_int as libc::c_long != 0
            {
                ret_val = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                ret_val = JS_NewFloat64(
                    ctx,
                    (func.f_f_f).expect("non-null function pointer")(d1_0, d2),
                );
            }
            current_block_46 = 10512632378975961025;
        }
        12 => {
            let mut done: libc::c_int = 0;
            ret_val = (func.iterator_next)
                .expect(
                    "non-null function pointer",
                )(
                ctx,
                this_obj,
                argc,
                arg_buf,
                &mut done,
                (*p).u.cfunc.magic as libc::c_int,
            );
            if JS_IsException(ret_val) == 0 && done != 2 as libc::c_int {
                ret_val = js_create_iterator_result(ctx, ret_val, done);
            }
            current_block_46 = 10512632378975961025;
        }
        _ => {
            abort();
        }
    }
    match current_block_46 {
        18395719385608038613 => {
            ret_val = (func.generic)
                .expect("non-null function pointer")(ctx, this_obj, argc, arg_buf);
        }
        6252765015528925724 => {
            ret_val = (func.generic_magic)
                .expect(
                    "non-null function pointer",
                )(ctx, this_obj, argc, arg_buf, (*p).u.cfunc.magic as libc::c_int);
        }
        12936261764148168459 => {
            ret_val = JS_ThrowTypeError(
                ctx,
                b"must be called with new\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {}
    }
    let ref mut fresh284 = (*rt).current_stack_frame;
    *fresh284 = (*sf).prev_frame;
    return ret_val;
}
unsafe extern "C" fn js_call_bound_function(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut bf: *mut JSBoundFunction = 0 as *mut JSBoundFunction;
    let mut arg_buf: *mut JSValue = 0 as *mut JSValue;
    let mut new_target: JSValue = 0;
    let mut arg_count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    bf = (*p).u.bound_function;
    arg_count = (*bf).argc + argc;
    if js_check_stack_overflow(
        (*ctx).rt,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(arg_count as libc::c_ulong),
    ) != 0
    {
        return JS_ThrowStackOverflow(ctx);
    }
    arg_buf = alloca(
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(arg_count as libc::c_ulong),
    ) as *mut JSValue;
    i = 0 as libc::c_int;
    while i < (*bf).argc {
        *arg_buf.offset(i as isize) = *((*bf).argv).as_mut_ptr().offset(i as isize);
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < argc {
        *arg_buf.offset(((*bf).argc + i) as isize) = *argv.offset(i as isize);
        i += 1;
    }
    if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        new_target = this_obj;
        if js_same_value(ctx, func_obj, new_target) != 0 {
            new_target = (*bf).func_obj;
        }
        return JS_CallConstructor2(ctx, (*bf).func_obj, new_target, arg_count, arg_buf);
    } else {
        return JS_Call(ctx, (*bf).func_obj, (*bf).this_val, arg_count, arg_buf)
    };
}
unsafe extern "C" fn JS_CallInternal(
    mut caller_ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut call_func: Option::<JSClassCall> = None;
    let mut ops: [JSValue; 2] = [0; 2];
    let mut current_block: u64;
    let mut rt: *mut JSRuntime = (*caller_ctx).rt;
    let mut ctx: *mut JSContext = 0 as *mut JSContext;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut sf_s: JSStackFrame = JSStackFrame {
        prev_frame: 0 as *mut JSStackFrame,
        cur_func: 0,
        arg_buf: 0 as *mut JSValue,
        var_buf: 0 as *mut JSValue,
        var_ref_list: list_head {
            prev: 0 as *mut list_head,
            next: 0 as *mut list_head,
        },
        cur_pc: 0 as *const uint8_t,
        arg_count: 0,
        js_mode: 0,
        cur_sp: 0 as *mut JSValue,
    };
    let mut sf: *mut JSStackFrame = &mut sf_s;
    let mut pc: *const uint8_t = 0 as *const uint8_t;
    let mut opcode: libc::c_int = 0;
    let mut arg_allocated_size: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut local_buf: *mut JSValue = 0 as *mut JSValue;
    let mut stack_buf: *mut JSValue = 0 as *mut JSValue;
    let mut var_buf: *mut JSValue = 0 as *mut JSValue;
    let mut arg_buf: *mut JSValue = 0 as *mut JSValue;
    let mut sp: *mut JSValue = 0 as *mut JSValue;
    let mut ret_val: JSValue = 0;
    let mut pval: *mut JSValue = 0 as *mut JSValue;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut alloca_size: size_t = 0;
    if js_poll_interrupts(caller_ctx) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if ((func_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0
    {
        if flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            let mut s: *mut JSAsyncFunctionState = func_obj as intptr_t
                as *mut libc::c_void as *mut JSAsyncFunctionState;
            sf = &mut (*s).frame;
            p = (*sf).cur_func as intptr_t as *mut libc::c_void as *mut JSObject;
            b = (*p).u.func.function_bytecode;
            ctx = (*b).realm;
            var_refs = (*p).u.func.var_refs;
            arg_buf = (*sf).arg_buf;
            local_buf = arg_buf;
            var_buf = (*sf).var_buf;
            stack_buf = ((*sf).var_buf).offset((*b).var_count as libc::c_int as isize);
            sp = (*sf).cur_sp;
            let ref mut fresh285 = (*sf).cur_sp;
            *fresh285 = 0 as *mut JSValue;
            pc = (*sf).cur_pc;
            let ref mut fresh286 = (*sf).prev_frame;
            *fresh286 = (*rt).current_stack_frame;
            let ref mut fresh287 = (*rt).current_stack_frame;
            *fresh287 = sf;
            if (*s).throw_flag != 0 {
                current_block = 8007106047927066893;
            } else {
                current_block = 307447392441238883;
            }
        } else {
            current_block = 13915329540119377959;
        }
    } else {
        p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_BYTECODE_FUNCTION as libc::c_int) as libc::c_int as libc::c_long
            != 0
        {
            call_func = None;
            call_func = (*((*rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .call;
            if call_func.is_none() {
                current_block = 13915329540119377959;
            } else {
                return call_func
                    .expect(
                        "non-null function pointer",
                    )(caller_ctx, func_obj, this_obj, argc, argv, flags)
            }
        } else {
            b = (*p).u.func.function_bytecode;
            if (argc < (*b).arg_count as libc::c_int
                || flags & (1 as libc::c_int) << 1 as libc::c_int != 0) as libc::c_int
                as libc::c_long != 0
            {
                arg_allocated_size = (*b).arg_count as libc::c_int;
            } else {
                arg_allocated_size = 0 as libc::c_int;
            }
            alloca_size = (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                .wrapping_mul(
                    (arg_allocated_size + (*b).var_count as libc::c_int
                        + (*b).stack_size as libc::c_int) as libc::c_ulong,
                );
            if js_check_stack_overflow(rt, alloca_size) != 0 {
                return JS_ThrowStackOverflow(caller_ctx);
            }
            (*sf).js_mode = (*b).js_mode as libc::c_int;
            arg_buf = argv;
            (*sf).arg_count = argc;
            (*sf).cur_func = func_obj;
            init_list_head(&mut (*sf).var_ref_list);
            var_refs = (*p).u.func.var_refs;
            local_buf = alloca(alloca_size) as *mut JSValue;
            if (arg_allocated_size != 0) as libc::c_int as libc::c_long != 0 {
                let mut n: libc::c_int = min_int(argc, (*b).arg_count as libc::c_int);
                arg_buf = local_buf;
                i = 0 as libc::c_int;
                while i < n {
                    *arg_buf
                        .offset(
                            i as isize,
                        ) = JS_DupValue(caller_ctx, *argv.offset(i as isize));
                    i += 1;
                }
                while i < (*b).arg_count as libc::c_int {
                    *arg_buf
                        .offset(
                            i as isize,
                        ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    i += 1;
                }
                (*sf).arg_count = (*b).arg_count as libc::c_int;
            }
            var_buf = local_buf.offset(arg_allocated_size as isize);
            let ref mut fresh288 = (*sf).var_buf;
            *fresh288 = var_buf;
            let ref mut fresh289 = (*sf).arg_buf;
            *fresh289 = arg_buf;
            i = 0 as libc::c_int;
            while i < (*b).var_count as libc::c_int {
                *var_buf
                    .offset(
                        i as isize,
                    ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                i += 1;
            }
            stack_buf = var_buf.offset((*b).var_count as libc::c_int as isize);
            sp = stack_buf;
            pc = (*b).byte_code_buf;
            let ref mut fresh290 = (*sf).prev_frame;
            *fresh290 = (*rt).current_stack_frame;
            let ref mut fresh291 = (*rt).current_stack_frame;
            *fresh291 = sf;
            ctx = (*b).realm;
            current_block = 307447392441238883;
        }
    }
    match current_block {
        13915329540119377959 => {
            return JS_ThrowTypeError(
                caller_ctx,
                b"not a function\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {}
    }
    's_327: loop {
        match current_block {
            307447392441238883 => {
                let mut call_argc: libc::c_int = 0;
                let mut call_argv: *mut JSValue = 0 as *mut JSValue;
                let fresh292 = pc;
                pc = pc.offset(1);
                opcode = *fresh292 as libc::c_int;
                match opcode {
                    1 => {
                        let fresh293 = sp;
                        sp = sp.offset(1);
                        *fresh293 = JS_NewInt32(ctx, get_u32(pc) as int32_t);
                        pc = pc.offset(4 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    2 => {
                        let fresh294 = sp;
                        sp = sp.offset(1);
                        *fresh294 = JS_DupValue(
                            ctx,
                            *((*b).cpool).offset(get_u32(pc) as isize),
                        );
                        pc = pc.offset(4 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 => {
                        let fresh295 = sp;
                        sp = sp.offset(1);
                        *fresh295 = JS_NewInt32(ctx, opcode - OP_push_0 as libc::c_int);
                        current_block = 307447392441238883;
                        continue;
                    }
                    187 => {
                        let fresh296 = sp;
                        sp = sp.offset(1);
                        *fresh296 = JS_NewInt32(ctx, get_i8(pc));
                        pc = pc.offset(1 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    188 => {
                        let fresh297 = sp;
                        sp = sp.offset(1);
                        *fresh297 = JS_NewInt32(ctx, get_i16(pc));
                        pc = pc.offset(2 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    189 => {
                        let fresh298 = pc;
                        pc = pc.offset(1);
                        let fresh299 = sp;
                        sp = sp.offset(1);
                        *fresh299 = JS_DupValue(
                            ctx,
                            *((*b).cpool).offset(*fresh298 as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    190 => {
                        let fresh300 = pc;
                        pc = pc.offset(1);
                        let fresh301 = sp;
                        sp = sp.offset(1);
                        *fresh301 = js_closure(
                            ctx,
                            JS_DupValue(ctx, *((*b).cpool).offset(*fresh300 as isize)),
                            var_refs,
                            sf,
                        );
                        if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    191 => {
                        let fresh302 = sp;
                        sp = sp.offset(1);
                        *fresh302 = JS_AtomToString(
                            ctx,
                            JS_ATOM_empty_string as libc::c_int as JSAtom,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    231 => {
                        let mut val: JSValue = 0;
                        val = JS_GetProperty(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            JS_ATOM_length as libc::c_int as JSAtom,
                        );
                        if (JS_IsException(val) != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    4 => {
                        let fresh303 = sp;
                        sp = sp.offset(1);
                        *fresh303 = JS_AtomToValue(ctx, get_u32(pc));
                        pc = pc.offset(4 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    6 => {
                        let fresh304 = sp;
                        sp = sp.offset(1);
                        *fresh304 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 307447392441238883;
                        continue;
                    }
                    7 => {
                        let fresh305 = sp;
                        sp = sp.offset(1);
                        *fresh305 = (JS_TAG_NULL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 307447392441238883;
                        continue;
                    }
                    8 => {
                        let mut val_0: JSValue = 0;
                        if (*b).js_mode as libc::c_int
                            & (1 as libc::c_int) << 0 as libc::c_int == 0
                        {
                            let mut tag: uint32_t = (this_obj >> 32 as libc::c_int)
                                as libc::c_int as uint32_t;
                            if (tag == JS_TAG_OBJECT as libc::c_int as libc::c_uint)
                                as libc::c_int as libc::c_long != 0
                            {
                                current_block = 17550051846666823558;
                            } else {
                                if tag == JS_TAG_NULL as libc::c_int as libc::c_uint
                                    || tag == JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                                {
                                    val_0 = JS_DupValue(ctx, (*ctx).global_obj);
                                } else {
                                    val_0 = JS_ToObject(ctx, this_obj);
                                    if JS_IsException(val_0) != 0 {
                                        current_block = 8007106047927066893;
                                        continue;
                                    }
                                }
                                current_block = 10863493864285401582;
                            }
                        } else {
                            current_block = 17550051846666823558;
                        }
                        match current_block {
                            17550051846666823558 => {
                                val_0 = JS_DupValue(ctx, this_obj);
                            }
                            _ => {}
                        }
                        let fresh306 = sp;
                        sp = sp.offset(1);
                        *fresh306 = val_0;
                        current_block = 307447392441238883;
                        continue;
                    }
                    9 => {
                        let fresh307 = sp;
                        sp = sp.offset(1);
                        *fresh307 = (JS_TAG_BOOL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 307447392441238883;
                        continue;
                    }
                    10 => {
                        let fresh308 = sp;
                        sp = sp.offset(1);
                        *fresh308 = (JS_TAG_BOOL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 307447392441238883;
                        continue;
                    }
                    11 => {
                        let fresh309 = sp;
                        sp = sp.offset(1);
                        *fresh309 = JS_NewObject(ctx);
                        if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    12 => {
                        let fresh310 = pc;
                        pc = pc.offset(1);
                        let mut arg: libc::c_int = *fresh310 as libc::c_int;
                        match arg {
                            0 => {
                                let fresh311 = sp;
                                sp = sp.offset(1);
                                *fresh311 = js_build_arguments(ctx, argc, argv);
                                if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                                    != 0) as libc::c_int as libc::c_long != 0
                                {
                                    current_block = 8007106047927066893;
                                    continue;
                                } else {
                                    current_block = 307447392441238883;
                                    continue;
                                }
                            }
                            1 => {
                                let fresh312 = sp;
                                sp = sp.offset(1);
                                *fresh312 = js_build_mapped_arguments(
                                    ctx,
                                    argc,
                                    argv,
                                    sf,
                                    min_int(argc, (*b).arg_count as libc::c_int),
                                );
                                if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                                    != 0) as libc::c_int as libc::c_long != 0
                                {
                                    current_block = 8007106047927066893;
                                    continue;
                                } else {
                                    current_block = 307447392441238883;
                                    continue;
                                }
                            }
                            2 => {
                                let fresh313 = sp;
                                sp = sp.offset(1);
                                *fresh313 = JS_DupValue(ctx, (*sf).cur_func);
                                current_block = 307447392441238883;
                                continue;
                            }
                            3 => {
                                let fresh314 = sp;
                                sp = sp.offset(1);
                                *fresh314 = JS_DupValue(ctx, new_target);
                                current_block = 307447392441238883;
                                continue;
                            }
                            4 => {
                                let mut p1: *mut JSObject = 0 as *mut JSObject;
                                p1 = (*p).u.func.home_object;
                                if p1.is_null() as libc::c_int as libc::c_long != 0 {
                                    let fresh315 = sp;
                                    sp = sp.offset(1);
                                    *fresh315 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                } else {
                                    let fresh316 = sp;
                                    sp = sp.offset(1);
                                    *fresh316 = JS_DupValue(
                                        ctx,
                                        (JS_TAG_OBJECT as libc::c_int as uint64_t)
                                            << 32 as libc::c_int | p1 as uintptr_t as libc::c_ulonglong,
                                    );
                                }
                                current_block = 307447392441238883;
                                continue;
                            }
                            5 => {
                                let fresh317 = sp;
                                sp = sp.offset(1);
                                *fresh317 = JS_NewObjectProto(
                                    ctx,
                                    (JS_TAG_NULL as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                );
                                if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                                    != 0) as libc::c_int as libc::c_long != 0
                                {
                                    current_block = 8007106047927066893;
                                    continue;
                                } else {
                                    current_block = 307447392441238883;
                                    continue;
                                }
                            }
                            6 => {
                                let fresh318 = sp;
                                sp = sp.offset(1);
                                *fresh318 = js_import_meta(ctx);
                                if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                                    != 0) as libc::c_int as libc::c_long != 0
                                {
                                    current_block = 8007106047927066893;
                                    continue;
                                } else {
                                    current_block = 307447392441238883;
                                    continue;
                                }
                            }
                            _ => {
                                abort();
                            }
                        }
                    }
                    13 => {
                        let mut first: libc::c_int = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        let fresh319 = sp;
                        sp = sp.offset(1);
                        *fresh319 = js_build_rest(ctx, first, argc, argv);
                        if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    14 => {
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    15 => {
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    16 => {
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    17 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    19 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                        );
                        *sp
                            .offset(
                                1 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(2 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    20 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                        );
                        *sp
                            .offset(
                                1 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                        );
                        *sp
                            .offset(
                                2 as libc::c_int as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(3 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    18 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = JS_DupValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                        );
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    21 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = JS_DupValue(ctx, *sp.offset(0 as libc::c_int as isize));
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    22 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = JS_DupValue(ctx, *sp.offset(0 as libc::c_int as isize));
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    23 => {
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(4 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(4 as libc::c_int) as isize,
                            ) = JS_DupValue(ctx, *sp.offset(0 as libc::c_int as isize));
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    24 => {
                        let mut tmp: JSValue = 0;
                        tmp = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp.offset(-(3 as libc::c_int) as isize) = tmp;
                        current_block = 307447392441238883;
                        continue;
                    }
                    29 => {
                        let mut tmp_0: JSValue = 0;
                        tmp_0 = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp.offset(-(1 as libc::c_int) as isize) = tmp_0;
                        current_block = 307447392441238883;
                        continue;
                    }
                    31 => {
                        let mut tmp_1: JSValue = 0;
                        tmp_1 = *sp.offset(-(4 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(4 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp.offset(-(1 as libc::c_int) as isize) = tmp_1;
                        current_block = 307447392441238883;
                        continue;
                    }
                    32 => {
                        let mut tmp_2: JSValue = 0;
                        tmp_2 = *sp.offset(-(5 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(5 as libc::c_int) as isize,
                            ) = *sp.offset(-(4 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(4 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp.offset(-(1 as libc::c_int) as isize) = tmp_2;
                        current_block = 307447392441238883;
                        continue;
                    }
                    30 => {
                        let mut tmp_3: JSValue = 0;
                        tmp_3 = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp.offset(-(3 as libc::c_int) as isize) = tmp_3;
                        current_block = 307447392441238883;
                        continue;
                    }
                    25 => {
                        let mut tmp_4: JSValue = 0;
                        tmp_4 = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(4 as libc::c_int) as isize);
                        *sp.offset(-(4 as libc::c_int) as isize) = tmp_4;
                        current_block = 307447392441238883;
                        continue;
                    }
                    26 => {
                        let mut tmp_5: JSValue = 0;
                        tmp_5 = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(4 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(4 as libc::c_int) as isize,
                            ) = *sp.offset(-(5 as libc::c_int) as isize);
                        *sp.offset(-(5 as libc::c_int) as isize) = tmp_5;
                        current_block = 307447392441238883;
                        continue;
                    }
                    27 => {
                        let mut tmp_6: JSValue = 0;
                        tmp_6 = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp.offset(-(1 as libc::c_int) as isize) = tmp_6;
                        current_block = 307447392441238883;
                        continue;
                    }
                    28 => {
                        let mut tmp1: JSValue = 0;
                        let mut tmp2: JSValue = 0;
                        tmp1 = *sp.offset(-(4 as libc::c_int) as isize);
                        tmp2 = *sp.offset(-(3 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(4 as libc::c_int) as isize,
                            ) = *sp.offset(-(2 as libc::c_int) as isize);
                        *sp
                            .offset(
                                -(3 as libc::c_int) as isize,
                            ) = *sp.offset(-(1 as libc::c_int) as isize);
                        *sp.offset(-(2 as libc::c_int) as isize) = tmp1;
                        *sp.offset(-(1 as libc::c_int) as isize) = tmp2;
                        current_block = 307447392441238883;
                        continue;
                    }
                    3 => {
                        let mut bfunc: JSValue = JS_DupValue(
                            ctx,
                            *((*b).cpool).offset(get_u32(pc) as isize),
                        );
                        pc = pc.offset(4 as libc::c_int as isize);
                        let fresh320 = sp;
                        sp = sp.offset(1);
                        *fresh320 = js_closure(ctx, bfunc, var_refs, sf);
                        if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    236 | 237 | 238 | 239 => {
                        call_argc = opcode - OP_call0 as libc::c_int;
                        current_block = 11480460372531506238;
                    }
                    34 | 35 => {
                        call_argc = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        current_block = 11480460372531506238;
                    }
                    33 => {
                        call_argc = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        call_argv = sp.offset(-(call_argc as isize));
                        let ref mut fresh323 = (*sf).cur_pc;
                        *fresh323 = pc;
                        ret_val = JS_CallConstructorInternal(
                            ctx,
                            *call_argv.offset(-(2 as libc::c_int) as isize),
                            *call_argv.offset(-(1 as libc::c_int) as isize),
                            call_argc,
                            call_argv,
                            0 as libc::c_int,
                        );
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        i = -(2 as libc::c_int);
                        while i < call_argc {
                            JS_FreeValue(ctx, *call_argv.offset(i as isize));
                            i += 1;
                        }
                        sp = sp.offset(-((call_argc + 2 as libc::c_int) as isize));
                        let fresh324 = sp;
                        sp = sp.offset(1);
                        *fresh324 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    36 | 37 => {
                        call_argc = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        call_argv = sp.offset(-(call_argc as isize));
                        let ref mut fresh325 = (*sf).cur_pc;
                        *fresh325 = pc;
                        ret_val = JS_CallInternal(
                            ctx,
                            *call_argv.offset(-(1 as libc::c_int) as isize),
                            *call_argv.offset(-(2 as libc::c_int) as isize),
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            call_argc,
                            call_argv,
                            0 as libc::c_int,
                        );
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if opcode == OP_tail_call_method as libc::c_int {
                            current_block = 4040560332375280485;
                            break;
                        }
                        i = -(2 as libc::c_int);
                        while i < call_argc {
                            JS_FreeValue(ctx, *call_argv.offset(i as isize));
                            i += 1;
                        }
                        sp = sp.offset(-((call_argc + 2 as libc::c_int) as isize));
                        let fresh326 = sp;
                        sp = sp.offset(1);
                        *fresh326 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    38 => {
                        let mut i_0: libc::c_int = 0;
                        let mut ret: libc::c_int = 0;
                        call_argc = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        ret_val = JS_NewArray(ctx);
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        call_argv = sp.offset(-(call_argc as isize));
                        i_0 = 0 as libc::c_int;
                        while i_0 < call_argc {
                            ret = JS_DefinePropertyValue(
                                ctx,
                                ret_val,
                                __JS_AtomFromUInt32(i_0 as uint32_t),
                                *call_argv.offset(i_0 as isize),
                                (1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int
                                    | (1 as libc::c_int) << 14 as libc::c_int,
                            );
                            *call_argv
                                .offset(
                                    i_0 as isize,
                                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                            if ret < 0 as libc::c_int {
                                JS_FreeValue(ctx, ret_val);
                                current_block = 8007106047927066893;
                                continue 's_327;
                            } else {
                                i_0 += 1;
                            }
                        }
                        sp = sp.offset(-(call_argc as isize));
                        let fresh327 = sp;
                        sp = sp.offset(1);
                        *fresh327 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    39 => {
                        let mut magic: libc::c_int = 0;
                        magic = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        ret_val = js_function_apply(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            2 as libc::c_int,
                            &mut *sp.offset(-(2 as libc::c_int) as isize)
                                as *mut JSValue,
                            magic,
                        );
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-(3 as libc::c_int as isize));
                        let fresh328 = sp;
                        sp = sp.offset(1);
                        *fresh328 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    40 => {
                        sp = sp.offset(-1);
                        ret_val = *sp;
                        current_block = 4040560332375280485;
                        break;
                    }
                    41 => {
                        ret_val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 4040560332375280485;
                        break;
                    }
                    42 => {
                        if JS_IsObject(*sp.offset(-(1 as libc::c_int) as isize)) == 0 {
                            if JS_IsUndefined(*sp.offset(-(1 as libc::c_int) as isize))
                                == 0
                            {
                                JS_ThrowTypeError(
                                    caller_ctx,
                                    b"derived class constructor must return an object or undefined\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 8007106047927066893;
                                continue;
                            } else {
                                *sp
                                    .offset(
                                        0 as libc::c_int as isize,
                                    ) = (JS_TAG_BOOL as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
                            }
                        } else {
                            *sp
                                .offset(
                                    0 as libc::c_int as isize,
                                ) = (JS_TAG_BOOL as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        }
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    43 => {
                        if !(JS_IsUndefined(new_target) != 0) {
                            current_block = 307447392441238883;
                            continue;
                        }
                        JS_ThrowTypeError(
                            ctx,
                            b"class constructors must be invoked with 'new'\0"
                                as *const u8 as *const libc::c_char,
                        );
                        current_block = 8007106047927066893;
                        continue;
                    }
                    44 => {
                        if JS_CheckBrand(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        ) < 0 as libc::c_int
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    45 => {
                        if JS_AddBrand(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        ) < 0 as libc::c_int
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-(2 as libc::c_int as isize));
                        current_block = 307447392441238883;
                        continue;
                    }
                    47 => {
                        sp = sp.offset(-1);
                        JS_Throw(ctx, *sp);
                        current_block = 8007106047927066893;
                        continue;
                    }
                    48 => {
                        let mut atom: JSAtom = 0;
                        let mut type_0: libc::c_int = 0;
                        atom = get_u32(pc);
                        type_0 = *pc.offset(4 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(5 as libc::c_int as isize);
                        if type_0 == 0 as libc::c_int {
                            JS_ThrowTypeErrorReadOnly(
                                ctx,
                                (1 as libc::c_int) << 14 as libc::c_int,
                                atom,
                            );
                        } else if type_0 == 1 as libc::c_int {
                            JS_ThrowSyntaxErrorVarRedeclaration(ctx, atom);
                        } else if type_0 == 2 as libc::c_int {
                            JS_ThrowReferenceErrorUninitialized(ctx, atom);
                        } else if type_0 == 3 as libc::c_int {
                            JS_ThrowReferenceError(
                                ctx,
                                b"unsupported reference to 'super'\0" as *const u8
                                    as *const libc::c_char,
                            );
                        } else if type_0 == 4 as libc::c_int {
                            JS_ThrowTypeError(
                                ctx,
                                b"iterator does not have a throw method\0" as *const u8
                                    as *const libc::c_char,
                            );
                        } else {
                            JS_ThrowInternalError(
                                ctx,
                                b"invalid throw var type %d\0" as *const u8
                                    as *const libc::c_char,
                                type_0,
                            );
                        }
                        current_block = 8007106047927066893;
                        continue;
                    }
                    49 => {
                        let mut obj: JSValue = 0;
                        let mut scope_idx: libc::c_int = 0;
                        call_argc = get_u16(pc) as libc::c_int;
                        scope_idx = (get_u16(pc.offset(2 as libc::c_int as isize)))
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as libc::c_int;
                        pc = pc.offset(4 as libc::c_int as isize);
                        call_argv = sp.offset(-(call_argc as isize));
                        let ref mut fresh329 = (*sf).cur_pc;
                        *fresh329 = pc;
                        if js_same_value(
                            ctx,
                            *call_argv.offset(-(1 as libc::c_int) as isize),
                            (*ctx).eval_obj,
                        ) != 0
                        {
                            if call_argc >= 1 as libc::c_int {
                                obj = *call_argv.offset(0 as libc::c_int as isize);
                            } else {
                                obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                            }
                            ret_val = JS_EvalObject(
                                ctx,
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                obj,
                                (2 as libc::c_int) << 0 as libc::c_int,
                                scope_idx,
                            );
                        } else {
                            ret_val = JS_CallInternal(
                                ctx,
                                *call_argv.offset(-(1 as libc::c_int) as isize),
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                call_argc,
                                call_argv,
                                0 as libc::c_int,
                            );
                        }
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        i = -(1 as libc::c_int);
                        while i < call_argc {
                            JS_FreeValue(ctx, *call_argv.offset(i as isize));
                            i += 1;
                        }
                        sp = sp.offset(-((call_argc + 1 as libc::c_int) as isize));
                        let fresh330 = sp;
                        sp = sp.offset(1);
                        *fresh330 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    50 => {
                        let mut scope_idx_0: libc::c_int = 0;
                        let mut len: uint32_t = 0;
                        let mut tab: *mut JSValue = 0 as *mut JSValue;
                        let mut obj_0: JSValue = 0;
                        scope_idx_0 = (get_u16(pc))
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        tab = build_arg_list(
                            ctx,
                            &mut len,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if tab.is_null() {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if js_same_value(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            (*ctx).eval_obj,
                        ) != 0
                        {
                            if len >= 1 as libc::c_int as libc::c_uint {
                                obj_0 = *tab.offset(0 as libc::c_int as isize);
                            } else {
                                obj_0 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                            }
                            ret_val = JS_EvalObject(
                                ctx,
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                obj_0,
                                (2 as libc::c_int) << 0 as libc::c_int,
                                scope_idx_0,
                            );
                        } else {
                            ret_val = JS_Call(
                                ctx,
                                *sp.offset(-(2 as libc::c_int) as isize),
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                len as libc::c_int,
                                tab,
                            );
                        }
                        free_arg_list(ctx, tab, len);
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-(2 as libc::c_int as isize));
                        let fresh331 = sp;
                        sp = sp.offset(1);
                        *fresh331 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    51 => {
                        *sp
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = js_regexp_constructor_internal(
                            ctx,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    52 => {
                        let mut proto: JSValue = 0;
                        proto = JS_GetPrototype(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if JS_IsException(proto) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = proto;
                        current_block = 307447392441238883;
                        continue;
                    }
                    53 => {
                        let mut val_1: JSValue = 0;
                        val_1 = js_dynamic_import(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if JS_IsException(val_1) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = val_1;
                        current_block = 307447392441238883;
                        continue;
                    }
                    54 => {
                        let mut ret_0: libc::c_int = 0;
                        let mut atom_0: JSAtom = 0;
                        atom_0 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_0 = JS_CheckGlobalVar(ctx, atom_0);
                        if ret_0 < 0 as libc::c_int {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        let fresh332 = sp;
                        sp = sp.offset(1);
                        *fresh332 = JS_NewBool(ctx, ret_0);
                        current_block = 307447392441238883;
                        continue;
                    }
                    55 | 56 => {
                        let mut val_2: JSValue = 0;
                        let mut atom_1: JSAtom = 0;
                        atom_1 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        val_2 = JS_GetGlobalVar(
                            ctx,
                            atom_1,
                            opcode - OP_get_var_undef as libc::c_int,
                        );
                        if (JS_IsException(val_2) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        let fresh333 = sp;
                        sp = sp.offset(1);
                        *fresh333 = val_2;
                        current_block = 307447392441238883;
                        continue;
                    }
                    57 | 58 => {
                        let mut ret_1: libc::c_int = 0;
                        let mut atom_2: JSAtom = 0;
                        atom_2 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_1 = JS_SetGlobalVar(
                            ctx,
                            atom_2,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            opcode - OP_put_var as libc::c_int,
                        );
                        sp = sp.offset(-1);
                        if (ret_1 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    59 => {
                        let mut ret_2: libc::c_int = 0;
                        let mut atom_3: JSAtom = 0;
                        atom_3 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        if (*sp.offset(-(2 as libc::c_int) as isize) as libc::c_int == 0)
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorNotDefined(ctx, atom_3);
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            ret_2 = JS_SetGlobalVar(
                                ctx,
                                atom_3,
                                *sp.offset(-(1 as libc::c_int) as isize),
                                2 as libc::c_int,
                            );
                            sp = sp.offset(-(2 as libc::c_int as isize));
                            if (ret_2 < 0 as libc::c_int) as libc::c_int as libc::c_long
                                != 0
                            {
                                current_block = 8007106047927066893;
                                continue;
                            } else {
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                    }
                    63 => {
                        let mut atom_4: JSAtom = 0;
                        let mut flags_0: libc::c_int = 0;
                        atom_4 = get_u32(pc);
                        flags_0 = *pc.offset(4 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(5 as libc::c_int as isize);
                        if JS_CheckDefineGlobalVar(ctx, atom_4, flags_0) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    62 => {
                        let mut atom_5: JSAtom = 0;
                        let mut flags_1: libc::c_int = 0;
                        atom_5 = get_u32(pc);
                        flags_1 = *pc.offset(4 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(5 as libc::c_int as isize);
                        if JS_DefineGlobalVar(ctx, atom_5, flags_1) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    64 => {
                        let mut atom_6: JSAtom = 0;
                        let mut flags_2: libc::c_int = 0;
                        atom_6 = get_u32(pc);
                        flags_2 = *pc.offset(4 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(5 as libc::c_int as isize);
                        if JS_DefineGlobalFunction(
                            ctx,
                            atom_6,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            flags_2,
                        ) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    88 => {
                        let mut idx: libc::c_int = 0;
                        idx = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_DupValue(ctx, *var_buf.offset(idx as isize));
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    89 => {
                        let mut idx_0: libc::c_int = 0;
                        idx_0 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(idx_0 as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    90 => {
                        let mut idx_1: libc::c_int = 0;
                        idx_1 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(idx_1 as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    91 => {
                        let mut idx_2: libc::c_int = 0;
                        idx_2 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_DupValue(ctx, *arg_buf.offset(idx_2 as isize));
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    92 => {
                        let mut idx_3: libc::c_int = 0;
                        idx_3 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(idx_3 as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    93 => {
                        let mut idx_4: libc::c_int = 0;
                        idx_4 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(idx_4 as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    192 => {
                        let fresh334 = pc;
                        pc = pc.offset(1);
                        let fresh335 = sp;
                        sp = sp.offset(1);
                        *fresh335 = JS_DupValue(
                            ctx,
                            *var_buf.offset(*fresh334 as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    193 => {
                        let fresh336 = pc;
                        pc = pc.offset(1);
                        sp = sp.offset(-1);
                        set_value(ctx, &mut *var_buf.offset(*fresh336 as isize), *sp);
                        current_block = 307447392441238883;
                        continue;
                    }
                    194 => {
                        let fresh337 = pc;
                        pc = pc.offset(1);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(*fresh337 as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    195 => {
                        let fresh338 = sp;
                        sp = sp.offset(1);
                        *fresh338 = JS_DupValue(
                            ctx,
                            *var_buf.offset(0 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    196 => {
                        let fresh339 = sp;
                        sp = sp.offset(1);
                        *fresh339 = JS_DupValue(
                            ctx,
                            *var_buf.offset(1 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    197 => {
                        let fresh340 = sp;
                        sp = sp.offset(1);
                        *fresh340 = JS_DupValue(
                            ctx,
                            *var_buf.offset(2 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    198 => {
                        let fresh341 = sp;
                        sp = sp.offset(1);
                        *fresh341 = JS_DupValue(
                            ctx,
                            *var_buf.offset(3 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    199 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(0 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    200 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(1 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    201 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(2 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    202 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(3 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    203 => {
                        set_value(
                            ctx,
                            &mut *var_buf.offset(0 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    204 => {
                        set_value(
                            ctx,
                            &mut *var_buf.offset(1 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    205 => {
                        set_value(
                            ctx,
                            &mut *var_buf.offset(2 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    206 => {
                        set_value(
                            ctx,
                            &mut *var_buf.offset(3 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    207 => {
                        let fresh342 = sp;
                        sp = sp.offset(1);
                        *fresh342 = JS_DupValue(
                            ctx,
                            *arg_buf.offset(0 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    208 => {
                        let fresh343 = sp;
                        sp = sp.offset(1);
                        *fresh343 = JS_DupValue(
                            ctx,
                            *arg_buf.offset(1 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    209 => {
                        let fresh344 = sp;
                        sp = sp.offset(1);
                        *fresh344 = JS_DupValue(
                            ctx,
                            *arg_buf.offset(2 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    210 => {
                        let fresh345 = sp;
                        sp = sp.offset(1);
                        *fresh345 = JS_DupValue(
                            ctx,
                            *arg_buf.offset(3 as libc::c_int as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    211 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(0 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    212 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(1 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    213 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(2 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    214 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(3 as libc::c_int as isize),
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    215 => {
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(0 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    216 => {
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(1 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    217 => {
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(2 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    218 => {
                        set_value(
                            ctx,
                            &mut *arg_buf.offset(3 as libc::c_int as isize),
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    219 => {
                        let fresh346 = sp;
                        sp = sp.offset(1);
                        *fresh346 = JS_DupValue(
                            ctx,
                            *(**var_refs.offset(0 as libc::c_int as isize)).pvalue,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    220 => {
                        let fresh347 = sp;
                        sp = sp.offset(1);
                        *fresh347 = JS_DupValue(
                            ctx,
                            *(**var_refs.offset(1 as libc::c_int as isize)).pvalue,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    221 => {
                        let fresh348 = sp;
                        sp = sp.offset(1);
                        *fresh348 = JS_DupValue(
                            ctx,
                            *(**var_refs.offset(2 as libc::c_int as isize)).pvalue,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    222 => {
                        let fresh349 = sp;
                        sp = sp.offset(1);
                        *fresh349 = JS_DupValue(
                            ctx,
                            *(**var_refs.offset(3 as libc::c_int as isize)).pvalue,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    223 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            (**var_refs.offset(0 as libc::c_int as isize)).pvalue,
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    224 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            (**var_refs.offset(1 as libc::c_int as isize)).pvalue,
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    225 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            (**var_refs.offset(2 as libc::c_int as isize)).pvalue,
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    226 => {
                        sp = sp.offset(-1);
                        set_value(
                            ctx,
                            (**var_refs.offset(3 as libc::c_int as isize)).pvalue,
                            *sp,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    227 => {
                        set_value(
                            ctx,
                            (**var_refs.offset(0 as libc::c_int as isize)).pvalue,
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    228 => {
                        set_value(
                            ctx,
                            (**var_refs.offset(1 as libc::c_int as isize)).pvalue,
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    229 => {
                        set_value(
                            ctx,
                            (**var_refs.offset(2 as libc::c_int as isize)).pvalue,
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    230 => {
                        set_value(
                            ctx,
                            (**var_refs.offset(3 as libc::c_int as isize)).pvalue,
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    94 => {
                        let mut idx_5: libc::c_int = 0;
                        let mut val_3: JSValue = 0;
                        idx_5 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        val_3 = *(**var_refs.offset(idx_5 as isize)).pvalue;
                        *sp.offset(0 as libc::c_int as isize) = JS_DupValue(ctx, val_3);
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    95 => {
                        let mut idx_6: libc::c_int = 0;
                        idx_6 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            (**var_refs.offset(idx_6 as isize)).pvalue,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    96 => {
                        let mut idx_7: libc::c_int = 0;
                        idx_7 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            (**var_refs.offset(idx_7 as isize)).pvalue,
                            JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    101 => {
                        let mut idx_8: libc::c_int = 0;
                        let mut val_4: JSValue = 0;
                        idx_8 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        val_4 = *(**var_refs.offset(idx_8 as isize)).pvalue;
                        if (JS_IsUninitialized(val_4) != 0) as libc::c_int
                            as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorUninitialized2(
                                ctx,
                                b,
                                idx_8,
                                TRUE as libc::c_int,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            *sp
                                .offset(
                                    0 as libc::c_int as isize,
                                ) = JS_DupValue(ctx, val_4);
                            sp = sp.offset(1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    102 => {
                        let mut idx_9: libc::c_int = 0;
                        idx_9 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        if (JS_IsUninitialized(
                            *(**var_refs.offset(idx_9 as isize)).pvalue,
                        ) != 0) as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorUninitialized2(
                                ctx,
                                b,
                                idx_9,
                                TRUE as libc::c_int,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            set_value(
                                ctx,
                                (**var_refs.offset(idx_9 as isize)).pvalue,
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    103 => {
                        let mut idx_10: libc::c_int = 0;
                        idx_10 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        if (JS_IsUninitialized(
                            *(**var_refs.offset(idx_10 as isize)).pvalue,
                        ) == 0) as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorUninitialized2(
                                ctx,
                                b,
                                idx_10,
                                TRUE as libc::c_int,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            set_value(
                                ctx,
                                (**var_refs.offset(idx_10 as isize)).pvalue,
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    97 => {
                        let mut idx_11: libc::c_int = 0;
                        idx_11 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        set_value(
                            ctx,
                            &mut *var_buf.offset(idx_11 as isize),
                            (JS_TAG_UNINITIALIZED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    98 => {
                        let mut idx_12: libc::c_int = 0;
                        idx_12 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        if (JS_IsUninitialized(*var_buf.offset(idx_12 as isize)) != 0)
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorUninitialized2(
                                ctx,
                                b,
                                idx_12,
                                FALSE as libc::c_int,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            *sp
                                .offset(
                                    0 as libc::c_int as isize,
                                ) = JS_DupValue(ctx, *var_buf.offset(idx_12 as isize));
                            sp = sp.offset(1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    99 => {
                        let mut idx_13: libc::c_int = 0;
                        idx_13 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        if (JS_IsUninitialized(*var_buf.offset(idx_13 as isize)) != 0)
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceErrorUninitialized2(
                                ctx,
                                b,
                                idx_13,
                                FALSE as libc::c_int,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            set_value(
                                ctx,
                                &mut *var_buf.offset(idx_13 as isize),
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    100 => {
                        let mut idx_14: libc::c_int = 0;
                        idx_14 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        if (JS_IsUninitialized(*var_buf.offset(idx_14 as isize)) == 0)
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowReferenceError(
                                ctx,
                                b"'this' can be initialized only once\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            set_value(
                                ctx,
                                &mut *var_buf.offset(idx_14 as isize),
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    104 => {
                        let mut idx_15: libc::c_int = 0;
                        idx_15 = get_u16(pc) as libc::c_int;
                        pc = pc.offset(2 as libc::c_int as isize);
                        close_lexical_var(ctx, sf, idx_15, FALSE as libc::c_int);
                        current_block = 307447392441238883;
                        continue;
                    }
                    120 | 121 | 122 => {
                        let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
                        let mut pr: *mut JSProperty = 0 as *mut JSProperty;
                        let mut atom_7: JSAtom = 0;
                        let mut idx_16: libc::c_int = 0;
                        atom_7 = get_u32(pc);
                        idx_16 = get_u16(pc.offset(4 as libc::c_int as isize))
                            as libc::c_int;
                        pc = pc.offset(6 as libc::c_int as isize);
                        let fresh350 = sp;
                        sp = sp.offset(1);
                        *fresh350 = JS_NewObjectProto(
                            ctx,
                            (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        );
                        if (JS_IsException(*sp.offset(-(1 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if opcode == OP_make_var_ref_ref as libc::c_int {
                            var_ref = *var_refs.offset(idx_16 as isize);
                            let ref mut fresh351 = (*var_ref)
                                .c2rust_unnamed
                                .header
                                .ref_count;
                            *fresh351 += 1;
                        } else {
                            var_ref = get_var_ref(
                                ctx,
                                sf,
                                idx_16,
                                (opcode == OP_make_arg_ref as libc::c_int) as libc::c_int,
                            );
                            if var_ref.is_null() {
                                current_block = 8007106047927066893;
                                continue;
                            }
                        }
                        pr = add_property(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize) as intptr_t
                                as *mut libc::c_void as *mut JSObject,
                            atom_7,
                            (1 as libc::c_int) << 1 as libc::c_int
                                | (2 as libc::c_int) << 4 as libc::c_int,
                        );
                        if pr.is_null() {
                            free_var_ref(rt, var_ref);
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            let ref mut fresh352 = (*pr).u.var_ref;
                            *fresh352 = var_ref;
                            let fresh353 = sp;
                            sp = sp.offset(1);
                            *fresh353 = JS_AtomToValue(ctx, atom_7);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    123 => {
                        let mut atom_8: JSAtom = 0;
                        atom_8 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        if JS_GetGlobalVarRef(ctx, atom_8, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(2 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    107 => {
                        pc = pc.offset(get_u32(pc) as int32_t as isize);
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    235 => {
                        pc = pc.offset(get_u16(pc) as int16_t as libc::c_int as isize);
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    234 => {
                        pc = pc
                            .offset(
                                *pc.offset(0 as libc::c_int as isize) as int8_t
                                    as libc::c_int as isize,
                            );
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    106 => {
                        let mut res: libc::c_int = 0;
                        let mut op1: JSValue = 0;
                        op1 = *sp.offset(-(1 as libc::c_int) as isize);
                        pc = pc.offset(4 as libc::c_int as isize);
                        if (op1 >> 32 as libc::c_int) as libc::c_int as uint32_t
                            <= JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                        {
                            res = op1 as libc::c_int;
                        } else {
                            res = JS_ToBoolFree(ctx, op1);
                        }
                        sp = sp.offset(-1);
                        if res != 0 {
                            pc = pc
                                .offset(
                                    (get_u32(pc.offset(-(4 as libc::c_int as isize))) as int32_t
                                        - 4 as libc::c_int) as isize,
                                );
                        }
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    105 => {
                        let mut res_0: libc::c_int = 0;
                        let mut op1_0: JSValue = 0;
                        op1_0 = *sp.offset(-(1 as libc::c_int) as isize);
                        pc = pc.offset(4 as libc::c_int as isize);
                        if (op1_0 >> 32 as libc::c_int) as libc::c_int as uint32_t
                            <= JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                        {
                            res_0 = op1_0 as libc::c_int;
                        } else {
                            res_0 = JS_ToBoolFree(ctx, op1_0);
                        }
                        sp = sp.offset(-1);
                        if res_0 == 0 {
                            pc = pc
                                .offset(
                                    (get_u32(pc.offset(-(4 as libc::c_int as isize))) as int32_t
                                        - 4 as libc::c_int) as isize,
                                );
                        }
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    233 => {
                        let mut res_1: libc::c_int = 0;
                        let mut op1_1: JSValue = 0;
                        op1_1 = *sp.offset(-(1 as libc::c_int) as isize);
                        pc = pc.offset(1 as libc::c_int as isize);
                        if (op1_1 >> 32 as libc::c_int) as libc::c_int as uint32_t
                            <= JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                        {
                            res_1 = op1_1 as libc::c_int;
                        } else {
                            res_1 = JS_ToBoolFree(ctx, op1_1);
                        }
                        sp = sp.offset(-1);
                        if res_1 != 0 {
                            pc = pc
                                .offset(
                                    (*pc.offset(-(1 as libc::c_int) as isize) as int8_t
                                        as libc::c_int - 1 as libc::c_int) as isize,
                                );
                        }
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    232 => {
                        let mut res_2: libc::c_int = 0;
                        let mut op1_2: JSValue = 0;
                        op1_2 = *sp.offset(-(1 as libc::c_int) as isize);
                        pc = pc.offset(1 as libc::c_int as isize);
                        if (op1_2 >> 32 as libc::c_int) as libc::c_int as uint32_t
                            <= JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                        {
                            res_2 = op1_2 as libc::c_int;
                        } else {
                            res_2 = JS_ToBoolFree(ctx, op1_2);
                        }
                        sp = sp.offset(-1);
                        if res_2 == 0 {
                            pc = pc
                                .offset(
                                    (*pc.offset(-(1 as libc::c_int) as isize) as int8_t
                                        as libc::c_int - 1 as libc::c_int) as isize,
                                );
                        }
                        if (js_poll_interrupts(ctx) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    108 => {
                        let mut diff: int32_t = 0;
                        diff = get_u32(pc) as int32_t;
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_NewCatchOffset(
                            ctx,
                            pc.offset(diff as isize).offset_from((*b).byte_code_buf)
                                as libc::c_long as int32_t,
                        );
                        sp = sp.offset(1);
                        pc = pc.offset(4 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    109 => {
                        let mut diff_0: int32_t = 0;
                        diff_0 = get_u32(pc) as int32_t;
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_NewInt32(
                            ctx,
                            pc
                                .offset(4 as libc::c_int as isize)
                                .offset_from((*b).byte_code_buf) as libc::c_long as int32_t,
                        );
                        sp = sp.offset(1);
                        pc = pc.offset(diff_0 as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    110 => {
                        let mut op1_3: JSValue = 0;
                        let mut pos: uint32_t = 0;
                        op1_3 = *sp.offset(-(1 as libc::c_int) as isize);
                        if !(((op1_3 >> 32 as libc::c_int) as libc::c_int
                            != JS_TAG_INT as libc::c_int) as libc::c_int as libc::c_long
                            != 0)
                        {
                            pos = op1_3 as libc::c_int as uint32_t;
                            if !((pos >= (*b).byte_code_len as libc::c_uint)
                                as libc::c_int as libc::c_long != 0)
                            {
                                sp = sp.offset(-1);
                                pc = ((*b).byte_code_buf).offset(pos as isize);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                        JS_ThrowInternalError(
                            ctx,
                            b"invalid ret value\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 8007106047927066893;
                        continue;
                    }
                    124 => {
                        if js_for_in_start(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    127 => {
                        if js_for_in_next(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(2 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    125 => {
                        if js_for_of_start(ctx, sp, FALSE as libc::c_int) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(1 as libc::c_int as isize);
                        let fresh354 = sp;
                        sp = sp.offset(1);
                        *fresh354 = JS_NewCatchOffset(ctx, 0 as libc::c_int);
                        current_block = 307447392441238883;
                        continue;
                    }
                    128 => {
                        let mut offset: libc::c_int = -(3 as libc::c_int)
                            - *pc.offset(0 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(1 as libc::c_int as isize);
                        if js_for_of_next(ctx, sp, offset) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(2 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    126 => {
                        if js_for_of_start(ctx, sp, TRUE as libc::c_int) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(1 as libc::c_int as isize);
                        let fresh355 = sp;
                        sp = sp.offset(1);
                        *fresh355 = JS_NewCatchOffset(ctx, 0 as libc::c_int);
                        current_block = 307447392441238883;
                        continue;
                    }
                    130 => {
                        if js_iterator_get_value_done(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(1 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    129 => {
                        if !((JS_IsObject(*sp.offset(-(1 as libc::c_int) as isize)) == 0)
                            as libc::c_int as libc::c_long != 0)
                        {
                            current_block = 307447392441238883;
                            continue;
                        }
                        JS_ThrowTypeError(
                            ctx,
                            b"iterator must return an object\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 8007106047927066893;
                        continue;
                    }
                    131 => {
                        sp = sp.offset(-1);
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-1);
                        if JS_IsUndefined(*sp.offset(-(1 as libc::c_int) as isize)) == 0
                        {
                            if JS_IteratorClose(
                                ctx,
                                *sp.offset(-(1 as libc::c_int) as isize),
                                FALSE as libc::c_int,
                            ) != 0
                            {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    132 => {
                        let mut ret_val_0: JSValue = 0;
                        sp = sp.offset(-1);
                        ret_val_0 = *sp;
                        while sp > stack_buf
                            && (*sp.offset(-(1 as libc::c_int) as isize)
                                >> 32 as libc::c_int) as libc::c_int
                                != JS_TAG_CATCH_OFFSET as libc::c_int
                        {
                            sp = sp.offset(-1);
                            JS_FreeValue(ctx, *sp);
                        }
                        if (sp < stack_buf.offset(3 as libc::c_int as isize))
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowInternalError(
                                ctx,
                                b"iterator_close_return\0" as *const u8
                                    as *const libc::c_char,
                            );
                            JS_FreeValue(ctx, ret_val_0);
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            *sp
                                .offset(
                                    0 as libc::c_int as isize,
                                ) = *sp.offset(-(1 as libc::c_int) as isize);
                            *sp
                                .offset(
                                    -(1 as libc::c_int) as isize,
                                ) = *sp.offset(-(2 as libc::c_int) as isize);
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = *sp.offset(-(3 as libc::c_int) as isize);
                            *sp.offset(-(3 as libc::c_int) as isize) = ret_val_0;
                            sp = sp.offset(1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    133 => {
                        let mut ret_3: JSValue = 0;
                        ret_3 = JS_Call(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            *sp.offset(-(4 as libc::c_int) as isize),
                            1 as libc::c_int,
                            sp.offset(-(1 as libc::c_int as isize)),
                        );
                        if JS_IsException(ret_3) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = ret_3;
                        current_block = 307447392441238883;
                        continue;
                    }
                    134 => {
                        let mut method: JSValue = 0;
                        let mut ret_4: JSValue = 0;
                        let mut ret_flag: BOOL = 0;
                        let mut flags_3: libc::c_int = 0;
                        let fresh356 = pc;
                        pc = pc.offset(1);
                        flags_3 = *fresh356 as libc::c_int;
                        method = JS_GetProperty(
                            ctx,
                            *sp.offset(-(4 as libc::c_int) as isize),
                            (if flags_3 & 1 as libc::c_int != 0 {
                                JS_ATOM_throw as libc::c_int
                            } else {
                                JS_ATOM_return as libc::c_int
                            }) as JSAtom,
                        );
                        if JS_IsException(method) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if JS_IsUndefined(method) != 0 || JS_IsNull(method) != 0 {
                            ret_flag = TRUE as libc::c_int;
                        } else {
                            if flags_3 & 2 as libc::c_int != 0 {
                                ret_4 = JS_CallFree(
                                    ctx,
                                    method,
                                    *sp.offset(-(4 as libc::c_int) as isize),
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                );
                            } else {
                                ret_4 = JS_CallFree(
                                    ctx,
                                    method,
                                    *sp.offset(-(4 as libc::c_int) as isize),
                                    1 as libc::c_int,
                                    sp.offset(-(1 as libc::c_int as isize)),
                                );
                            }
                            if JS_IsException(ret_4) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                            *sp.offset(-(1 as libc::c_int) as isize) = ret_4;
                            ret_flag = FALSE as libc::c_int;
                        }
                        *sp
                            .offset(
                                0 as libc::c_int as isize,
                            ) = JS_NewBool(ctx, ret_flag);
                        sp = sp.offset(1 as libc::c_int as isize);
                        current_block = 307447392441238883;
                        continue;
                    }
                    150 => {
                        let mut res_3: libc::c_int = 0;
                        let mut op1_4: JSValue = 0;
                        op1_4 = *sp.offset(-(1 as libc::c_int) as isize);
                        if (op1_4 >> 32 as libc::c_int) as libc::c_int as uint32_t
                            <= JS_TAG_UNDEFINED as libc::c_int as libc::c_uint
                        {
                            res_3 = (op1_4 as libc::c_int != 0 as libc::c_int)
                                as libc::c_int;
                        } else {
                            res_3 = JS_ToBoolFree(ctx, op1_4);
                        }
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = JS_NewBool(ctx, (res_3 == 0) as libc::c_int);
                        current_block = 307447392441238883;
                        continue;
                    }
                    65 => {
                        let mut val_5: JSValue = 0;
                        let mut atom_9: JSAtom = 0;
                        atom_9 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        val_5 = JS_GetProperty(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            atom_9,
                        );
                        if (JS_IsException(val_5) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = val_5;
                        current_block = 307447392441238883;
                        continue;
                    }
                    66 => {
                        let mut val_6: JSValue = 0;
                        let mut atom_10: JSAtom = 0;
                        atom_10 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        val_6 = JS_GetProperty(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            atom_10,
                        );
                        if (JS_IsException(val_6) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        let fresh357 = sp;
                        sp = sp.offset(1);
                        *fresh357 = val_6;
                        current_block = 307447392441238883;
                        continue;
                    }
                    67 => {
                        let mut ret_5: libc::c_int = 0;
                        let mut atom_11: JSAtom = 0;
                        atom_11 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_5 = JS_SetPropertyInternal(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            atom_11,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            (1 as libc::c_int) << 15 as libc::c_int,
                        );
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        sp = sp.offset(-(2 as libc::c_int as isize));
                        if (ret_5 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    5 => {
                        let mut atom_12: JSAtom = 0;
                        let mut val_7: JSValue = 0;
                        atom_12 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        val_7 = JS_NewSymbolFromAtom(
                            ctx,
                            atom_12,
                            JS_ATOM_TYPE_PRIVATE as libc::c_int,
                        );
                        if JS_IsException(val_7) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        let fresh358 = sp;
                        sp = sp.offset(1);
                        *fresh358 = val_7;
                        current_block = 307447392441238883;
                        continue;
                    }
                    68 => {
                        let mut val_8: JSValue = 0;
                        val_8 = JS_GetPrivateField(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        *sp.offset(-(2 as libc::c_int) as isize) = val_8;
                        sp = sp.offset(-1);
                        if (JS_IsException(val_8) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    69 => {
                        let mut ret_6: libc::c_int = 0;
                        ret_6 = JS_SetPrivateField(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                        );
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-(3 as libc::c_int as isize));
                        if (ret_6 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    70 => {
                        let mut ret_7: libc::c_int = 0;
                        ret_7 = JS_DefinePrivateField(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        sp = sp.offset(-(2 as libc::c_int as isize));
                        if (ret_7 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    76 => {
                        let mut ret_8: libc::c_int = 0;
                        let mut atom_13: JSAtom = 0;
                        atom_13 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_8 = JS_DefinePropertyValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            atom_13,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 2 as libc::c_int
                                | (1 as libc::c_int) << 14 as libc::c_int,
                        );
                        sp = sp.offset(-1);
                        if (ret_8 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    77 => {
                        let mut ret_9: libc::c_int = 0;
                        let mut atom_14: JSAtom = 0;
                        atom_14 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_9 = JS_DefineObjectName(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            atom_14,
                            (1 as libc::c_int) << 0 as libc::c_int,
                        );
                        if (ret_9 < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    78 => {
                        let mut ret_10: libc::c_int = 0;
                        ret_10 = JS_DefineObjectNameComputed(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                            (1 as libc::c_int) << 0 as libc::c_int,
                        );
                        if (ret_10 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    79 => {
                        let mut proto_0: JSValue = 0;
                        proto_0 = *sp.offset(-(1 as libc::c_int) as isize);
                        if JS_IsObject(proto_0) != 0 || JS_IsNull(proto_0) != 0 {
                            if JS_SetPrototypeInternal(
                                ctx,
                                *sp.offset(-(2 as libc::c_int) as isize),
                                proto_0,
                                TRUE as libc::c_int,
                            ) < 0 as libc::c_int
                            {
                                current_block = 8007106047927066893;
                                continue;
                            }
                        }
                        JS_FreeValue(ctx, proto_0);
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    80 => {
                        js_method_set_home_object(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                        );
                        current_block = 307447392441238883;
                        continue;
                    }
                    84 | 85 => {
                        let mut getter: JSValue = 0;
                        let mut setter: JSValue = 0;
                        let mut value: JSValue = 0;
                        let mut obj_1: JSValue = 0;
                        let mut atom_15: JSAtom = 0;
                        let mut flags_4: libc::c_int = 0;
                        let mut ret_11: libc::c_int = 0;
                        let mut op_flags: libc::c_int = 0;
                        let mut is_computed: BOOL = 0;
                        is_computed = (opcode
                            == OP_define_method_computed as libc::c_int) as libc::c_int;
                        if is_computed != 0 {
                            atom_15 = JS_ValueToAtom(
                                ctx,
                                *sp.offset(-(2 as libc::c_int) as isize),
                            );
                            if (atom_15 == 0 as libc::c_int as libc::c_uint)
                                as libc::c_int as libc::c_long != 0
                            {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            opcode
                                += OP_define_method as libc::c_int
                                    - OP_define_method_computed as libc::c_int;
                        } else {
                            atom_15 = get_u32(pc);
                            pc = pc.offset(4 as libc::c_int as isize);
                        }
                        let fresh359 = pc;
                        pc = pc.offset(1);
                        op_flags = *fresh359 as libc::c_int;
                        obj_1 = *sp.offset((-(2 as libc::c_int) - is_computed) as isize);
                        flags_4 = (1 as libc::c_int) << 8 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 10 as libc::c_int
                            | (1 as libc::c_int) << 14 as libc::c_int;
                        if op_flags & 4 as libc::c_int != 0 {
                            flags_4 |= (1 as libc::c_int) << 2 as libc::c_int;
                        }
                        op_flags &= 3 as libc::c_int;
                        value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        if op_flags == 0 as libc::c_int {
                            value = *sp.offset(-(1 as libc::c_int) as isize);
                            flags_4
                                |= (1 as libc::c_int) << 13 as libc::c_int
                                    | (1 as libc::c_int) << 9 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int;
                        } else if op_flags == 1 as libc::c_int {
                            getter = *sp.offset(-(1 as libc::c_int) as isize);
                            flags_4 |= (1 as libc::c_int) << 11 as libc::c_int;
                        } else {
                            setter = *sp.offset(-(1 as libc::c_int) as isize);
                            flags_4 |= (1 as libc::c_int) << 12 as libc::c_int;
                        }
                        ret_11 = js_method_set_properties(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            atom_15,
                            flags_4,
                            obj_1,
                        );
                        if ret_11 >= 0 as libc::c_int {
                            ret_11 = JS_DefineProperty(
                                ctx,
                                obj_1,
                                atom_15,
                                value,
                                getter,
                                setter,
                                flags_4,
                            );
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        if is_computed != 0 {
                            JS_FreeAtom(ctx, atom_15);
                            JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        }
                        sp = sp.offset(-((1 as libc::c_int + is_computed) as isize));
                        if (ret_11 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    86 | 87 => {
                        let mut class_flags: libc::c_int = 0;
                        let mut atom_16: JSAtom = 0;
                        atom_16 = get_u32(pc);
                        class_flags = *pc.offset(4 as libc::c_int as isize)
                            as libc::c_int;
                        pc = pc.offset(5 as libc::c_int as isize);
                        if js_op_define_class(
                            ctx,
                            sp,
                            atom_16,
                            class_flags,
                            var_refs,
                            sf,
                            (opcode == OP_define_class_computed as libc::c_int)
                                as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    71 => {
                        let mut val_9: JSValue = 0;
                        val_9 = JS_GetPropertyValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        *sp.offset(-(2 as libc::c_int) as isize) = val_9;
                        sp = sp.offset(-1);
                        if (JS_IsException(val_9) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    72 => {
                        let mut val_10: JSValue = 0;
                        val_10 = JS_GetPropertyValue(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        *sp.offset(-(1 as libc::c_int) as isize) = val_10;
                        if (JS_IsException(val_10) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    60 => {
                        let mut val_11: JSValue = 0;
                        if (JS_IsUndefined(*sp.offset(-(2 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            let mut atom_17: JSAtom = JS_ValueToAtom(
                                ctx,
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            if atom_17 != 0 as libc::c_int as libc::c_uint {
                                JS_ThrowReferenceErrorNotDefined(ctx, atom_17);
                                JS_FreeAtom(ctx, atom_17);
                            }
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            val_11 = JS_GetPropertyValue(
                                ctx,
                                *sp.offset(-(2 as libc::c_int) as isize),
                                JS_DupValue(ctx, *sp.offset(-(1 as libc::c_int) as isize)),
                            );
                            if (JS_IsException(val_11) != 0) as libc::c_int
                                as libc::c_long != 0
                            {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            *sp.offset(0 as libc::c_int as isize) = val_11;
                            sp = sp.offset(1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    74 => {
                        let mut val_12: JSValue = 0;
                        let mut atom_18: JSAtom = 0;
                        atom_18 = JS_ValueToAtom(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if (atom_18 == 0 as libc::c_int as libc::c_uint) as libc::c_int
                            as libc::c_long != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        val_12 = JS_GetPropertyInternal(
                            ctx,
                            *sp.offset(-(2 as libc::c_int) as isize),
                            atom_18,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            FALSE as libc::c_int,
                        );
                        JS_FreeAtom(ctx, atom_18);
                        if (JS_IsException(val_12) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        *sp.offset(-(3 as libc::c_int) as isize) = val_12;
                        sp = sp.offset(-(2 as libc::c_int as isize));
                        current_block = 307447392441238883;
                        continue;
                    }
                    73 => {
                        let mut ret_12: libc::c_int = 0;
                        ret_12 = JS_SetPropertyValue(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                            (1 as libc::c_int) << 15 as libc::c_int,
                        );
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        sp = sp.offset(-(3 as libc::c_int as isize));
                        if (ret_12 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    61 => {
                        let mut ret_13: libc::c_int = 0;
                        let mut flags_5: libc::c_int = 0;
                        flags_5 = (1 as libc::c_int) << 15 as libc::c_int;
                        if (JS_IsUndefined(*sp.offset(-(3 as libc::c_int) as isize))
                            != 0) as libc::c_int as libc::c_long != 0
                        {
                            if is_strict_mode(ctx) != 0 {
                                let mut atom_19: JSAtom = JS_ValueToAtom(
                                    ctx,
                                    *sp.offset(-(2 as libc::c_int) as isize),
                                );
                                if atom_19 != 0 as libc::c_int as libc::c_uint {
                                    JS_ThrowReferenceErrorNotDefined(ctx, atom_19);
                                    JS_FreeAtom(ctx, atom_19);
                                }
                                current_block = 8007106047927066893;
                                continue;
                            } else {
                                *sp
                                    .offset(
                                        -(3 as libc::c_int) as isize,
                                    ) = JS_DupValue(ctx, (*ctx).global_obj);
                            }
                        } else if is_strict_mode(ctx) != 0 {
                            flags_5 |= (1 as libc::c_int) << 16 as libc::c_int;
                        }
                        ret_13 = JS_SetPropertyValue(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            *sp.offset(-(2 as libc::c_int) as isize),
                            *sp.offset(-(1 as libc::c_int) as isize),
                            flags_5,
                        );
                        JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                        sp = sp.offset(-(3 as libc::c_int as isize));
                        if (ret_13 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    75 => {
                        let mut ret_14: libc::c_int = 0;
                        let mut atom_20: JSAtom = 0;
                        if (*sp.offset(-(3 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                            != JS_TAG_OBJECT as libc::c_int
                        {
                            JS_ThrowTypeErrorNotAnObject(ctx);
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            atom_20 = JS_ValueToAtom(
                                ctx,
                                *sp.offset(-(2 as libc::c_int) as isize),
                            );
                            if (atom_20 == 0 as libc::c_int as libc::c_uint)
                                as libc::c_int as libc::c_long != 0
                            {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            ret_14 = JS_SetPropertyGeneric(
                                ctx,
                                *sp.offset(-(3 as libc::c_int) as isize),
                                atom_20,
                                *sp.offset(-(1 as libc::c_int) as isize),
                                *sp.offset(-(4 as libc::c_int) as isize),
                                (1 as libc::c_int) << 15 as libc::c_int,
                            );
                            JS_FreeAtom(ctx, atom_20);
                            JS_FreeValue(ctx, *sp.offset(-(4 as libc::c_int) as isize));
                            JS_FreeValue(ctx, *sp.offset(-(3 as libc::c_int) as isize));
                            JS_FreeValue(ctx, *sp.offset(-(2 as libc::c_int) as isize));
                            sp = sp.offset(-(4 as libc::c_int as isize));
                            if ret_14 < 0 as libc::c_int {
                                current_block = 8007106047927066893;
                                continue;
                            } else {
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                    }
                    81 => {
                        let mut ret_15: libc::c_int = 0;
                        ret_15 = JS_DefinePropertyValueValue(
                            ctx,
                            *sp.offset(-(3 as libc::c_int) as isize),
                            JS_DupValue(ctx, *sp.offset(-(2 as libc::c_int) as isize)),
                            *sp.offset(-(1 as libc::c_int) as isize),
                            (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 2 as libc::c_int
                                | (1 as libc::c_int) << 14 as libc::c_int,
                        );
                        sp = sp.offset(-(1 as libc::c_int as isize));
                        if (ret_15 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    82 => {
                        if js_append_enumerate(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        JS_FreeValue(ctx, *sp);
                        current_block = 307447392441238883;
                        continue;
                    }
                    83 => {
                        let mut mask: libc::c_int = 0;
                        let fresh360 = pc;
                        pc = pc.offset(1);
                        mask = *fresh360 as libc::c_int;
                        if JS_CopyDataProperties(
                            ctx,
                            *sp
                                .offset(
                                    (-(1 as libc::c_int) - (mask & 3 as libc::c_int)) as isize,
                                ),
                            *sp
                                .offset(
                                    (-(1 as libc::c_int)
                                        - (mask >> 2 as libc::c_int & 7 as libc::c_int)) as isize,
                                ),
                            *sp
                                .offset(
                                    (-(1 as libc::c_int)
                                        - (mask >> 5 as libc::c_int & 7 as libc::c_int)) as isize,
                                ),
                            0 as libc::c_int,
                        ) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    157 => {
                        let mut op1_5: JSValue = 0;
                        let mut op2: JSValue = 0;
                        op1_5 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_5 >> 32 as libc::c_int) as libc::c_int
                            | (op2 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut r: int64_t = 0;
                            r = op1_5 as libc::c_int as int64_t
                                + op2 as libc::c_int as libc::c_longlong;
                            if !((r as libc::c_int as libc::c_longlong != r)
                                as libc::c_int as libc::c_long != 0)
                            {
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, r as int32_t);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else if ((op1_5 >> 32 as libc::c_int) as libc::c_int
                            - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            >= (JS_TAG_FLOAT64 as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            && ((op2 >> 32 as libc::c_int) as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                                >= (JS_TAG_FLOAT64 as libc::c_int
                                    - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = __JS_NewFloat64(
                                ctx,
                                JS_VALUE_GET_FLOAT64(op1_5) + JS_VALUE_GET_FLOAT64(op2),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                        if js_add_slow(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    148 => {
                        let mut pv: *mut JSValue = 0 as *mut JSValue;
                        let mut idx_17: libc::c_int = 0;
                        idx_17 = *pc as libc::c_int;
                        pc = pc.offset(1 as libc::c_int as isize);
                        pv = &mut *var_buf.offset(idx_17 as isize) as *mut JSValue;
                        if ((*pv >> 32 as libc::c_int) as libc::c_int
                            | (*sp.offset(-(1 as libc::c_int) as isize)
                                >> 32 as libc::c_int) as libc::c_int == 0 as libc::c_int)
                            as libc::c_int as libc::c_long != 0
                        {
                            let mut r_0: int64_t = 0;
                            r_0 = *pv as libc::c_int as int64_t
                                + *sp.offset(-(1 as libc::c_int) as isize) as libc::c_int
                                    as libc::c_longlong;
                            if !((r_0 as libc::c_int as libc::c_longlong != r_0)
                                as libc::c_int as libc::c_long != 0)
                            {
                                *pv = JS_NewInt32(ctx, r_0 as int32_t);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else if (*pv >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_STRING as libc::c_int
                        {
                            let mut op1_6: JSValue = 0;
                            op1_6 = *sp.offset(-(1 as libc::c_int) as isize);
                            sp = sp.offset(-1);
                            op1_6 = JS_ToPrimitiveFree(ctx, op1_6, 2 as libc::c_int);
                            if JS_IsException(op1_6) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            op1_6 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op1_6);
                            if JS_IsException(op1_6) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            set_value(ctx, pv, op1_6);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            ops = [0; 2];
                        }
                        ops[0 as libc::c_int as usize] = JS_DupValue(ctx, *pv);
                        ops[1 as libc::c_int
                            as usize] = *sp.offset(-(1 as libc::c_int) as isize);
                        sp = sp.offset(-1);
                        if js_add_slow(
                            ctx,
                            ops.as_mut_ptr().offset(2 as libc::c_int as isize),
                        ) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        set_value(ctx, pv, ops[0 as libc::c_int as usize]);
                        current_block = 307447392441238883;
                        continue;
                    }
                    158 => {
                        let mut op1_7: JSValue = 0;
                        let mut op2_0: JSValue = 0;
                        op1_7 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_0 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_7 >> 32 as libc::c_int) as libc::c_int
                            | (op2_0 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut r_1: int64_t = 0;
                            r_1 = op1_7 as libc::c_int as int64_t
                                - op2_0 as libc::c_int as libc::c_longlong;
                            if !((r_1 as libc::c_int as libc::c_longlong != r_1)
                                as libc::c_int as libc::c_long != 0)
                            {
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, r_1 as int32_t);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else if ((op1_7 >> 32 as libc::c_int) as libc::c_int
                            - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            >= (JS_TAG_FLOAT64 as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            && ((op2_0 >> 32 as libc::c_int) as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                                >= (JS_TAG_FLOAT64 as libc::c_int
                                    - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = __JS_NewFloat64(
                                ctx,
                                JS_VALUE_GET_FLOAT64(op1_7) - JS_VALUE_GET_FLOAT64(op2_0),
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                        current_block = 1496146210456907939;
                    }
                    154 => {
                        let mut op1_8: JSValue = 0;
                        let mut op2_1: JSValue = 0;
                        let mut d: libc::c_double = 0.;
                        op1_8 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_1 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_8 >> 32 as libc::c_int) as libc::c_int
                            | (op2_1 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v1: int32_t = 0;
                            let mut v2: int32_t = 0;
                            let mut r_2: int64_t = 0;
                            v1 = op1_8 as libc::c_int;
                            v2 = op2_1 as libc::c_int;
                            r_2 = v1 as int64_t * v2 as libc::c_longlong;
                            if (r_2 as libc::c_int as libc::c_longlong != r_2)
                                as libc::c_int as libc::c_long != 0
                            {
                                d = r_2 as libc::c_double;
                            } else if (r_2 == 0 as libc::c_int as libc::c_longlong
                                && v1 | v2 < 0 as libc::c_int) as libc::c_int
                                as libc::c_long != 0
                            {
                                d = -0.0f64;
                            } else {
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, r_2 as int32_t);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                            current_block = 17652868979836417633;
                        } else if ((op1_8 >> 32 as libc::c_int) as libc::c_int
                            - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            >= (JS_TAG_FLOAT64 as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                            && ((op2_1 >> 32 as libc::c_int) as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                                >= (JS_TAG_FLOAT64 as libc::c_int
                                    - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                        {
                            d = JS_VALUE_GET_FLOAT64(op1_8)
                                * JS_VALUE_GET_FLOAT64(op2_1);
                            current_block = 17652868979836417633;
                        } else {
                            current_block = 1496146210456907939;
                        }
                        match current_block {
                            1496146210456907939 => {}
                            _ => {
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = __JS_NewFloat64(ctx, d);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                    }
                    155 => {
                        let mut op1_9: JSValue = 0;
                        let mut op2_2: JSValue = 0;
                        op1_9 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_2 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_9 >> 32 as libc::c_int) as libc::c_int
                            | (op2_2 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v1_0: libc::c_int = 0;
                            let mut v2_0: libc::c_int = 0;
                            if ((*sf).js_mode & (1 as libc::c_int) << 2 as libc::c_int
                                != 0) as libc::c_int as libc::c_long != 0
                            {
                                current_block = 1496146210456907939;
                            } else {
                                v1_0 = op1_9 as libc::c_int;
                                v2_0 = op2_2 as libc::c_int;
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = JS_NewFloat64(
                                    ctx,
                                    v1_0 as libc::c_double / v2_0 as libc::c_double,
                                );
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else {
                            current_block = 1496146210456907939;
                        }
                    }
                    156 => {
                        let mut op1_10: JSValue = 0;
                        let mut op2_3: JSValue = 0;
                        op1_10 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_3 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_10 >> 32 as libc::c_int) as libc::c_int
                            | (op2_3 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v1_1: libc::c_int = 0;
                            let mut v2_1: libc::c_int = 0;
                            let mut r_3: libc::c_int = 0;
                            v1_1 = op1_10 as libc::c_int;
                            v2_1 = op2_3 as libc::c_int;
                            if (v1_1 < 0 as libc::c_int || v2_1 <= 0 as libc::c_int)
                                as libc::c_int as libc::c_long != 0
                            {
                                current_block = 1496146210456907939;
                            } else {
                                r_3 = v1_1 % v2_1;
                                *sp
                                    .offset(
                                        -(2 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, r_3);
                                sp = sp.offset(-1);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else {
                            current_block = 1496146210456907939;
                        }
                    }
                    159 => {
                        current_block = 1496146210456907939;
                    }
                    141 => {
                        let mut op1_11: JSValue = 0;
                        let mut tag_0: uint32_t = 0;
                        op1_11 = *sp.offset(-(1 as libc::c_int) as isize);
                        tag_0 = (op1_11 >> 32 as libc::c_int) as libc::c_int as uint32_t;
                        if tag_0 == JS_TAG_INT as libc::c_int as libc::c_uint
                            || tag_0
                                .wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
                                >= (JS_TAG_FLOAT64 as libc::c_int
                                    - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                        {
                            current_block = 307447392441238883;
                            continue;
                        }
                        if js_unary_arith_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    140 => {
                        let mut op1_12: JSValue = 0;
                        let mut tag_1: uint32_t = 0;
                        let mut val_13: libc::c_int = 0;
                        let mut d_0: libc::c_double = 0.;
                        op1_12 = *sp.offset(-(1 as libc::c_int) as isize);
                        tag_1 = (op1_12 >> 32 as libc::c_int) as libc::c_int as uint32_t;
                        if tag_1 == JS_TAG_INT as libc::c_int as libc::c_uint {
                            val_13 = op1_12 as libc::c_int;
                            if (val_13 == 0 as libc::c_int) as libc::c_int
                                as libc::c_long != 0
                            {
                                d_0 = -0.0f64;
                            } else if (val_13 as libc::c_uint
                                == 0x80000000 as libc::c_uint) as libc::c_int
                                as libc::c_long != 0
                            {
                                d_0 = -(val_13 as libc::c_double);
                            } else {
                                *sp
                                    .offset(
                                        -(1 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, -val_13);
                                current_block = 307447392441238883;
                                continue;
                            }
                        } else if tag_1
                            .wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
                            >= (JS_TAG_FLOAT64 as libc::c_int
                                - JS_TAG_FIRST as libc::c_int) as libc::c_uint
                        {
                            d_0 = -JS_VALUE_GET_FLOAT64(op1_12);
                        } else if js_unary_arith_slow(ctx, sp, opcode as OPCodeEnum) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = __JS_NewFloat64(ctx, d_0);
                        current_block = 307447392441238883;
                        continue;
                    }
                    143 => {
                        let mut op1_13: JSValue = 0;
                        let mut val_14: libc::c_int = 0;
                        op1_13 = *sp.offset(-(1 as libc::c_int) as isize);
                        if (op1_13 >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_INT as libc::c_int
                        {
                            val_14 = op1_13 as libc::c_int;
                            if !((val_14 == 0x7fffffff as libc::c_int) as libc::c_int
                                as libc::c_long != 0)
                            {
                                *sp
                                    .offset(
                                        -(1 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, val_14 + 1 as libc::c_int);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                        if js_unary_arith_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    142 => {
                        let mut op1_14: JSValue = 0;
                        let mut val_15: libc::c_int = 0;
                        op1_14 = *sp.offset(-(1 as libc::c_int) as isize);
                        if (op1_14 >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_INT as libc::c_int
                        {
                            val_15 = op1_14 as libc::c_int;
                            if !((val_15 as libc::c_uint == 0x80000000 as libc::c_uint)
                                as libc::c_int as libc::c_long != 0)
                            {
                                *sp
                                    .offset(
                                        -(1 as libc::c_int) as isize,
                                    ) = JS_NewInt32(ctx, val_15 - 1 as libc::c_int);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                        if js_unary_arith_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    145 | 144 => {
                        if js_post_inc_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    147 => {
                        let mut op1_15: JSValue = 0;
                        let mut val_16: libc::c_int = 0;
                        let mut idx_18: libc::c_int = 0;
                        idx_18 = *pc as libc::c_int;
                        pc = pc.offset(1 as libc::c_int as isize);
                        op1_15 = *var_buf.offset(idx_18 as isize);
                        if (op1_15 >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_INT as libc::c_int
                        {
                            val_16 = op1_15 as libc::c_int;
                            if !((val_16 == 0x7fffffff as libc::c_int) as libc::c_int
                                as libc::c_long != 0)
                            {
                                *var_buf
                                    .offset(
                                        idx_18 as isize,
                                    ) = JS_NewInt32(ctx, val_16 + 1 as libc::c_int);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                        op1_15 = JS_DupValue(ctx, op1_15);
                        if js_unary_arith_slow(
                            ctx,
                            (&mut op1_15 as *mut JSValue)
                                .offset(1 as libc::c_int as isize),
                            OP_inc,
                        ) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        set_value(ctx, &mut *var_buf.offset(idx_18 as isize), op1_15);
                        current_block = 307447392441238883;
                        continue;
                    }
                    146 => {
                        let mut op1_16: JSValue = 0;
                        let mut val_17: libc::c_int = 0;
                        let mut idx_19: libc::c_int = 0;
                        idx_19 = *pc as libc::c_int;
                        pc = pc.offset(1 as libc::c_int as isize);
                        op1_16 = *var_buf.offset(idx_19 as isize);
                        if (op1_16 >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_INT as libc::c_int
                        {
                            val_17 = op1_16 as libc::c_int;
                            if !((val_17 as libc::c_uint == 0x80000000 as libc::c_uint)
                                as libc::c_int as libc::c_long != 0)
                            {
                                *var_buf
                                    .offset(
                                        idx_19 as isize,
                                    ) = JS_NewInt32(ctx, val_17 - 1 as libc::c_int);
                                current_block = 307447392441238883;
                                continue;
                            }
                        }
                        op1_16 = JS_DupValue(ctx, op1_16);
                        if js_unary_arith_slow(
                            ctx,
                            (&mut op1_16 as *mut JSValue)
                                .offset(1 as libc::c_int as isize),
                            OP_dec,
                        ) != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        set_value(ctx, &mut *var_buf.offset(idx_19 as isize), op1_16);
                        current_block = 307447392441238883;
                        continue;
                    }
                    149 => {
                        let mut op1_17: JSValue = 0;
                        op1_17 = *sp.offset(-(1 as libc::c_int) as isize);
                        if (op1_17 >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_INT as libc::c_int
                        {
                            *sp
                                .offset(
                                    -(1 as libc::c_int) as isize,
                                ) = JS_NewInt32(ctx, !(op1_17 as libc::c_int));
                            current_block = 307447392441238883;
                            continue;
                        } else if js_not_slow(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    160 => {
                        let mut op1_18: JSValue = 0;
                        let mut op2_4: JSValue = 0;
                        op1_18 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_4 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_18 >> 32 as libc::c_int) as libc::c_int
                            | (op2_4 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v1_2: uint32_t = 0;
                            let mut v2_2: uint32_t = 0;
                            v1_2 = op1_18 as libc::c_int as uint32_t;
                            v2_2 = op2_4 as libc::c_int as uint32_t;
                            v2_2 &= 0x1f as libc::c_int as libc::c_uint;
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewInt32(ctx, (v1_2 << v2_2) as int32_t);
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_binary_logic_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    162 => {
                        let mut op1_19: JSValue = 0;
                        let mut op2_5: JSValue = 0;
                        op1_19 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_5 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_19 >> 32 as libc::c_int) as libc::c_int
                            | (op2_5 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v2_3: uint32_t = 0;
                            v2_3 = op2_5 as libc::c_int as uint32_t;
                            v2_3 &= 0x1f as libc::c_int as libc::c_uint;
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewUint32(
                                ctx,
                                op1_19 as libc::c_int as uint32_t >> v2_3,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_shr_slow(ctx, sp) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    161 => {
                        let mut op1_20: JSValue = 0;
                        let mut op2_6: JSValue = 0;
                        op1_20 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_6 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_20 >> 32 as libc::c_int) as libc::c_int
                            | (op2_6 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            let mut v2_4: uint32_t = 0;
                            v2_4 = op2_6 as libc::c_int as uint32_t;
                            v2_4 &= 0x1f as libc::c_int as libc::c_uint;
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewInt32(ctx, op1_20 as libc::c_int >> v2_4);
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_binary_logic_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    173 => {
                        let mut op1_21: JSValue = 0;
                        let mut op2_7: JSValue = 0;
                        op1_21 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_7 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_21 >> 32 as libc::c_int) as libc::c_int
                            | (op2_7 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewInt32(
                                ctx,
                                op1_21 as libc::c_int & op2_7 as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_binary_logic_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    175 => {
                        let mut op1_22: JSValue = 0;
                        let mut op2_8: JSValue = 0;
                        op1_22 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_8 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_22 >> 32 as libc::c_int) as libc::c_int
                            | (op2_8 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewInt32(
                                ctx,
                                op1_22 as libc::c_int | op2_8 as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_binary_logic_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    174 => {
                        let mut op1_23: JSValue = 0;
                        let mut op2_9: JSValue = 0;
                        op1_23 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_9 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_23 >> 32 as libc::c_int) as libc::c_int
                            | (op2_9 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewInt32(
                                ctx,
                                op1_23 as libc::c_int ^ op2_9 as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_binary_logic_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    163 => {
                        let mut op1_24: JSValue = 0;
                        let mut op2_10: JSValue = 0;
                        op1_24 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_10 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_24 >> 32 as libc::c_int) as libc::c_int
                            | (op2_10 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                ((op1_24 as libc::c_int) < op2_10 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_relational_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    164 => {
                        let mut op1_25: JSValue = 0;
                        let mut op2_11: JSValue = 0;
                        op1_25 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_11 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_25 >> 32 as libc::c_int) as libc::c_int
                            | (op2_11 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_25 as libc::c_int <= op2_11 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_relational_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    165 => {
                        let mut op1_26: JSValue = 0;
                        let mut op2_12: JSValue = 0;
                        op1_26 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_12 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_26 >> 32 as libc::c_int) as libc::c_int
                            | (op2_12 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_26 as libc::c_int > op2_12 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_relational_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    166 => {
                        let mut op1_27: JSValue = 0;
                        let mut op2_13: JSValue = 0;
                        op1_27 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_13 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_27 >> 32 as libc::c_int) as libc::c_int
                            | (op2_13 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_27 as libc::c_int >= op2_13 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_relational_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    169 => {
                        let mut op1_28: JSValue = 0;
                        let mut op2_14: JSValue = 0;
                        op1_28 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_14 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_28 >> 32 as libc::c_int) as libc::c_int
                            | (op2_14 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_28 as libc::c_int == op2_14 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_eq_slow(ctx, sp, 0 as libc::c_int) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    170 => {
                        let mut op1_29: JSValue = 0;
                        let mut op2_15: JSValue = 0;
                        op1_29 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_15 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_29 >> 32 as libc::c_int) as libc::c_int
                            | (op2_15 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_29 as libc::c_int != op2_15 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_eq_slow(ctx, sp, 1 as libc::c_int) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    171 => {
                        let mut op1_30: JSValue = 0;
                        let mut op2_16: JSValue = 0;
                        op1_30 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_16 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_30 >> 32 as libc::c_int) as libc::c_int
                            | (op2_16 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_30 as libc::c_int == op2_16 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_strict_eq_slow(ctx, sp, 0 as libc::c_int) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    172 => {
                        let mut op1_31: JSValue = 0;
                        let mut op2_17: JSValue = 0;
                        op1_31 = *sp.offset(-(2 as libc::c_int) as isize);
                        op2_17 = *sp.offset(-(1 as libc::c_int) as isize);
                        if ((op1_31 >> 32 as libc::c_int) as libc::c_int
                            | (op2_17 >> 32 as libc::c_int) as libc::c_int
                            == 0 as libc::c_int) as libc::c_int as libc::c_long != 0
                        {
                            *sp
                                .offset(
                                    -(2 as libc::c_int) as isize,
                                ) = JS_NewBool(
                                ctx,
                                (op1_31 as libc::c_int != op2_17 as libc::c_int)
                                    as libc::c_int,
                            );
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        } else {
                            if js_strict_eq_slow(ctx, sp, 1 as libc::c_int) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            sp = sp.offset(-1);
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    168 => {
                        if js_operator_in(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    167 => {
                        if js_operator_instanceof(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    151 => {
                        let mut op1_32: JSValue = 0;
                        let mut atom_21: JSAtom = 0;
                        op1_32 = *sp.offset(-(1 as libc::c_int) as isize);
                        atom_21 = js_operator_typeof(ctx, op1_32) as JSAtom;
                        JS_FreeValue(ctx, op1_32);
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = JS_AtomToString(ctx, atom_21);
                        current_block = 307447392441238883;
                        continue;
                    }
                    152 => {
                        if js_operator_delete(ctx, sp) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    153 => {
                        let mut atom_22: JSAtom = 0;
                        let mut ret_16: libc::c_int = 0;
                        atom_22 = get_u32(pc);
                        pc = pc.offset(4 as libc::c_int as isize);
                        ret_16 = JS_DeleteProperty(
                            ctx,
                            (*ctx).global_obj,
                            atom_22,
                            0 as libc::c_int,
                        );
                        if (ret_16 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        let fresh361 = sp;
                        sp = sp.offset(1);
                        *fresh361 = JS_NewBool(ctx, ret_16);
                        current_block = 307447392441238883;
                        continue;
                    }
                    111 => {
                        if !((*sp.offset(-(1 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                            != JS_TAG_OBJECT as libc::c_int)
                        {
                            current_block = 307447392441238883;
                            continue;
                        }
                        ret_val = JS_ToObject(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if JS_IsException(ret_val) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    112 => {
                        match (*sp.offset(-(1 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                        {
                            0 | -7 | -8 => {
                                current_block = 307447392441238883;
                                continue;
                            }
                            _ => {}
                        }
                        ret_val = JS_ToPropertyKey(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        );
                        if JS_IsException(ret_val) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp.offset(-(1 as libc::c_int) as isize) = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    113 => {
                        if (JS_IsUndefined(*sp.offset(-(2 as libc::c_int) as isize)) != 0
                            || JS_IsNull(*sp.offset(-(2 as libc::c_int) as isize)) != 0)
                            as libc::c_int as libc::c_long != 0
                        {
                            JS_ThrowTypeError(
                                ctx,
                                b"value has no property\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 8007106047927066893;
                            continue;
                        } else {
                            match (*sp.offset(-(1 as libc::c_int) as isize)
                                >> 32 as libc::c_int) as libc::c_int
                            {
                                0 | -7 | -8 => {
                                    current_block = 307447392441238883;
                                    continue;
                                }
                                _ => {}
                            }
                            ret_val = JS_ToPropertyKey(
                                ctx,
                                *sp.offset(-(1 as libc::c_int) as isize),
                            );
                            if JS_IsException(ret_val) != 0 {
                                current_block = 8007106047927066893;
                                continue;
                            }
                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                            *sp.offset(-(1 as libc::c_int) as isize) = ret_val;
                            current_block = 307447392441238883;
                            continue;
                        }
                    }
                    114 | 115 | 116 | 117 | 118 | 119 => {
                        let mut atom_23: JSAtom = 0;
                        let mut diff_1: int32_t = 0;
                        let mut obj_2: JSValue = 0;
                        let mut val_18: JSValue = 0;
                        let mut ret_17: libc::c_int = 0;
                        let mut is_with: libc::c_int = 0;
                        atom_23 = get_u32(pc);
                        diff_1 = get_u32(pc.offset(4 as libc::c_int as isize))
                            as int32_t;
                        is_with = *pc.offset(8 as libc::c_int as isize) as libc::c_int;
                        pc = pc.offset(9 as libc::c_int as isize);
                        obj_2 = *sp.offset(-(1 as libc::c_int) as isize);
                        ret_17 = JS_HasProperty(ctx, obj_2, atom_23);
                        if (ret_17 < 0 as libc::c_int) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if ret_17 != 0 {
                            if is_with != 0 {
                                ret_17 = js_has_unscopable(ctx, obj_2, atom_23);
                                if (ret_17 < 0 as libc::c_int) as libc::c_int
                                    as libc::c_long != 0
                                {
                                    current_block = 8007106047927066893;
                                    continue;
                                }
                                if ret_17 != 0 {
                                    current_block = 12962096149734148762;
                                } else {
                                    current_block = 7022146168712304380;
                                }
                            } else {
                                current_block = 7022146168712304380;
                            }
                            match current_block {
                                12962096149734148762 => {}
                                _ => {
                                    match opcode {
                                        114 => {
                                            val_18 = JS_GetProperty(ctx, obj_2, atom_23);
                                            if (JS_IsException(val_18) != 0) as libc::c_int
                                                as libc::c_long != 0
                                            {
                                                current_block = 8007106047927066893;
                                                continue;
                                            }
                                            set_value(
                                                ctx,
                                                &mut *sp.offset(-(1 as libc::c_int) as isize),
                                                val_18,
                                            );
                                        }
                                        115 => {
                                            ret_17 = JS_SetPropertyInternal(
                                                ctx,
                                                obj_2,
                                                atom_23,
                                                *sp.offset(-(2 as libc::c_int) as isize),
                                                (1 as libc::c_int) << 15 as libc::c_int,
                                            );
                                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                                            sp = sp.offset(-(2 as libc::c_int as isize));
                                            if (ret_17 < 0 as libc::c_int) as libc::c_int
                                                as libc::c_long != 0
                                            {
                                                current_block = 8007106047927066893;
                                                continue;
                                            }
                                        }
                                        116 => {
                                            ret_17 = JS_DeleteProperty(
                                                ctx,
                                                obj_2,
                                                atom_23,
                                                0 as libc::c_int,
                                            );
                                            if (ret_17 < 0 as libc::c_int) as libc::c_int
                                                as libc::c_long != 0
                                            {
                                                current_block = 8007106047927066893;
                                                continue;
                                            }
                                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                                            *sp
                                                .offset(
                                                    -(1 as libc::c_int) as isize,
                                                ) = JS_NewBool(ctx, ret_17);
                                        }
                                        117 => {
                                            let fresh362 = sp;
                                            sp = sp.offset(1);
                                            *fresh362 = JS_AtomToValue(ctx, atom_23);
                                        }
                                        118 => {
                                            val_18 = JS_GetProperty(ctx, obj_2, atom_23);
                                            if (JS_IsException(val_18) != 0) as libc::c_int
                                                as libc::c_long != 0
                                            {
                                                current_block = 8007106047927066893;
                                                continue;
                                            }
                                            let fresh363 = sp;
                                            sp = sp.offset(1);
                                            *fresh363 = val_18;
                                        }
                                        119 => {
                                            val_18 = JS_GetProperty(ctx, obj_2, atom_23);
                                            if (JS_IsException(val_18) != 0) as libc::c_int
                                                as libc::c_long != 0
                                            {
                                                current_block = 8007106047927066893;
                                                continue;
                                            }
                                            JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                                            *sp
                                                .offset(
                                                    -(1 as libc::c_int) as isize,
                                                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                            let fresh364 = sp;
                                            sp = sp.offset(1);
                                            *fresh364 = val_18;
                                        }
                                        _ => {}
                                    }
                                    pc = pc.offset((diff_1 - 5 as libc::c_int) as isize);
                                    current_block = 307447392441238883;
                                    continue;
                                }
                            }
                        }
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    139 => {
                        ret_val = JS_NewInt32(ctx, 0 as libc::c_int);
                        current_block = 12348143141253470563;
                        break;
                    }
                    136 => {
                        ret_val = JS_NewInt32(ctx, 1 as libc::c_int);
                        current_block = 12348143141253470563;
                        break;
                    }
                    137 | 138 => {
                        ret_val = JS_NewInt32(ctx, 2 as libc::c_int);
                        current_block = 12348143141253470563;
                        break;
                    }
                    46 | 135 => {
                        ret_val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 12348143141253470563;
                        break;
                    }
                    177 => {
                        current_block = 307447392441238883;
                        continue;
                    }
                    176 => {
                        if (*sp.offset(-(1 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_UNDEFINED as libc::c_int
                            || (*sp.offset(-(1 as libc::c_int) as isize)
                                >> 32 as libc::c_int) as libc::c_int
                                == JS_TAG_NULL as libc::c_int
                        {
                            current_block = 14537325084018676057;
                        } else {
                            current_block = 6450413071126300293;
                        }
                    }
                    240 => {
                        if (*sp.offset(-(1 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_UNDEFINED as libc::c_int
                        {
                            current_block = 14537325084018676057;
                        } else {
                            current_block = 6450413071126300293;
                        }
                    }
                    241 => {
                        if (*sp.offset(-(1 as libc::c_int) as isize)
                            >> 32 as libc::c_int) as libc::c_int
                            == JS_TAG_NULL as libc::c_int
                        {
                            current_block = 14537325084018676057;
                        } else {
                            current_block = 6450413071126300293;
                        }
                    }
                    242 => {
                        if js_operator_typeof(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        ) == JS_ATOM_undefined as libc::c_int
                        {
                            current_block = 14905748573742151963;
                        } else {
                            current_block = 6450413071126300293;
                        }
                    }
                    243 => {
                        if js_operator_typeof(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                        ) == JS_ATOM_function as libc::c_int
                        {
                            current_block = 14905748573742151963;
                        } else {
                            current_block = 6450413071126300293;
                        }
                    }
                    0 | _ => {
                        JS_ThrowInternalError(
                            ctx,
                            b"invalid opcode: pc=%u opcode=0x%02x\0" as *const u8
                                as *const libc::c_char,
                            (pc.offset_from((*b).byte_code_buf) as libc::c_long
                                - 1 as libc::c_int as libc::c_long) as libc::c_int,
                            opcode,
                        );
                        current_block = 8007106047927066893;
                        continue;
                    }
                }
                match current_block {
                    6450413071126300293 => {
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        *sp
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = (JS_TAG_BOOL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 307447392441238883;
                        continue;
                    }
                    1496146210456907939 => {
                        if js_binary_arith_slow(ctx, sp, opcode as OPCodeEnum) != 0 {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        sp = sp.offset(-1);
                        current_block = 307447392441238883;
                        continue;
                    }
                    11480460372531506238 => {
                        call_argv = sp.offset(-(call_argc as isize));
                        let ref mut fresh321 = (*sf).cur_pc;
                        *fresh321 = pc;
                        ret_val = JS_CallInternal(
                            ctx,
                            *call_argv.offset(-(1 as libc::c_int) as isize),
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            call_argc,
                            call_argv,
                            0 as libc::c_int,
                        );
                        if (JS_IsException(ret_val) != 0) as libc::c_int as libc::c_long
                            != 0
                        {
                            current_block = 8007106047927066893;
                            continue;
                        }
                        if opcode == OP_tail_call as libc::c_int {
                            current_block = 4040560332375280485;
                            break;
                        }
                        i = -(1 as libc::c_int);
                        while i < call_argc {
                            JS_FreeValue(ctx, *call_argv.offset(i as isize));
                            i += 1;
                        }
                        sp = sp.offset(-((call_argc + 1 as libc::c_int) as isize));
                        let fresh322 = sp;
                        sp = sp.offset(1);
                        *fresh322 = ret_val;
                        current_block = 307447392441238883;
                        continue;
                    }
                    14905748573742151963 => {
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                    }
                    _ => {}
                }
                *sp
                    .offset(
                        -(1 as libc::c_int) as isize,
                    ) = (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
                current_block = 307447392441238883;
            }
            _ => {
                if is_backtrace_needed(ctx, (*rt).current_exception) != 0 {
                    let ref mut fresh365 = (*sf).cur_pc;
                    *fresh365 = pc;
                    build_backtrace(
                        ctx,
                        (*rt).current_exception,
                        0 as *const libc::c_char,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                if !(JS_IsUncatchableError(ctx, (*rt).current_exception) == 0) {
                    current_block = 15523270711184200380;
                    break;
                }
                loop {
                    if !(sp > stack_buf) {
                        current_block = 15523270711184200380;
                        break 's_327;
                    }
                    sp = sp.offset(-1);
                    let mut val_19: JSValue = *sp;
                    JS_FreeValue(ctx, val_19);
                    if !((val_19 >> 32 as libc::c_int) as libc::c_int
                        == JS_TAG_CATCH_OFFSET as libc::c_int)
                    {
                        continue;
                    }
                    let mut pos_0: libc::c_int = val_19 as libc::c_int;
                    if pos_0 == 0 as libc::c_int {
                        JS_FreeValue(ctx, *sp.offset(-(1 as libc::c_int) as isize));
                        sp = sp.offset(-1);
                        JS_IteratorClose(
                            ctx,
                            *sp.offset(-(1 as libc::c_int) as isize),
                            TRUE as libc::c_int,
                        );
                    } else {
                        let fresh366 = sp;
                        sp = sp.offset(1);
                        *fresh366 = (*rt).current_exception;
                        (*rt)
                            .current_exception = (JS_TAG_NULL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        pc = ((*b).byte_code_buf).offset(pos_0 as isize);
                        current_block = 307447392441238883;
                        break;
                    }
                }
            }
        }
    }
    match current_block {
        15523270711184200380 => {
            ret_val = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if (*b).func_kind() as libc::c_int != JS_FUNC_NORMAL as libc::c_int {
                current_block = 12348143141253470563;
            } else {
                current_block = 4040560332375280485;
            }
        }
        _ => {}
    }
    match current_block {
        4040560332375280485 => {
            if (list_empty(&mut (*sf).var_ref_list) == 0) as libc::c_int as libc::c_long
                != 0
            {
                close_var_refs(rt, sf);
            }
            pval = local_buf;
            while pval < sp {
                JS_FreeValue(ctx, *pval);
                pval = pval.offset(1);
            }
        }
        _ => {
            let ref mut fresh367 = (*sf).cur_pc;
            *fresh367 = pc;
            let ref mut fresh368 = (*sf).cur_sp;
            *fresh368 = sp;
        }
    }
    let ref mut fresh369 = (*rt).current_stack_frame;
    *fresh369 = (*sf).prev_frame;
    return ret_val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_Call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_CallInternal(
        ctx,
        func_obj,
        this_obj,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        argc,
        argv,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
}
unsafe extern "C" fn JS_CallFree(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut res: JSValue = JS_CallInternal(
        ctx,
        func_obj,
        this_obj,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        argc,
        argv,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    JS_FreeValue(ctx, func_obj);
    return res;
}
unsafe extern "C" fn JS_GetFunctionRealm(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
) -> *mut JSContext {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut realm: *mut JSContext = 0 as *mut JSContext;
    if (func_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return ctx;
    }
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
        12 => {
            realm = (*p).u.cfunc.realm;
        }
        13 | 16 | 45 | 49 => {
            let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
            b = (*p).u.func.function_bytecode;
            realm = (*b).realm;
        }
        41 => {
            let mut s: *mut JSProxyData = (*p).u.opaque as *mut JSProxyData;
            if s.is_null() {
                return ctx;
            }
            if (*s).is_revoked != 0 {
                JS_ThrowTypeErrorRevokedProxy(ctx);
                return 0 as *mut JSContext;
            } else {
                realm = JS_GetFunctionRealm(ctx, (*s).target);
            }
        }
        14 => {
            let mut bf: *mut JSBoundFunction = (*p).u.bound_function;
            realm = JS_GetFunctionRealm(ctx, (*bf).func_obj);
        }
        _ => {
            realm = ctx;
        }
    }
    return realm;
}
unsafe extern "C" fn js_create_from_ctor(
    mut ctx: *mut JSContext,
    mut ctor: JSValue,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut proto: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut realm: *mut JSContext = 0 as *mut JSContext;
    if JS_IsUndefined(ctor) != 0 {
        proto = JS_DupValue(ctx, *((*ctx).class_proto).offset(class_id as isize));
    } else {
        proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype as libc::c_int as JSAtom);
        if JS_IsException(proto) != 0 {
            return proto;
        }
        if JS_IsObject(proto) == 0 {
            JS_FreeValue(ctx, proto);
            realm = JS_GetFunctionRealm(ctx, ctor);
            if realm.is_null() {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            proto = JS_DupValue(ctx, *((*realm).class_proto).offset(class_id as isize));
        }
    }
    obj = JS_NewObjectProtoClass(ctx, proto, class_id as JSClassID);
    JS_FreeValue(ctx, proto);
    return obj;
}
unsafe extern "C" fn JS_CallConstructorInternal(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut call_func: Option::<JSClassCall> = None;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    if js_poll_interrupts(ctx) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    flags |= (1 as libc::c_int) << 0 as libc::c_int;
    if !(((func_obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
        as libc::c_int as libc::c_long != 0)
    {
        p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if (((*p).c2rust_unnamed.c2rust_unnamed).is_constructor() == 0) as libc::c_int
            as libc::c_long != 0
        {
            return JS_ThrowTypeError(
                ctx,
                b"not a constructor\0" as *const u8 as *const libc::c_char,
            );
        }
        if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_BYTECODE_FUNCTION as libc::c_int) as libc::c_int as libc::c_long
            != 0
        {
            call_func = None;
            call_func = (*((*(*ctx).rt).class_array)
                .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                .call;
            if !call_func.is_none() {
                return call_func
                    .expect(
                        "non-null function pointer",
                    )(ctx, func_obj, new_target, argc, argv, flags);
            }
        } else {
            b = (*p).u.func.function_bytecode;
            if (*b).is_derived_class_constructor() != 0 {
                return JS_CallInternal(
                    ctx,
                    func_obj,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    new_target,
                    argc,
                    argv,
                    flags,
                )
            } else {
                let mut obj: JSValue = 0;
                let mut ret: JSValue = 0;
                obj = js_create_from_ctor(
                    ctx,
                    new_target,
                    JS_CLASS_OBJECT as libc::c_int,
                );
                if JS_IsException(obj) != 0 {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                ret = JS_CallInternal(ctx, func_obj, obj, new_target, argc, argv, flags);
                if (ret >> 32 as libc::c_int) as libc::c_int
                    == JS_TAG_OBJECT as libc::c_int || JS_IsException(ret) != 0
                {
                    JS_FreeValue(ctx, obj);
                    return ret;
                } else {
                    JS_FreeValue(ctx, ret);
                    return obj;
                }
            }
        }
    }
    return JS_ThrowTypeError(
        ctx,
        b"not a function\0" as *const u8 as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_CallConstructor2(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_CallConstructorInternal(
        ctx,
        func_obj,
        new_target,
        argc,
        argv,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_CallConstructor(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_CallConstructorInternal(
        ctx,
        func_obj,
        func_obj,
        argc,
        argv,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_Invoke(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut atom: JSAtom,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut func_obj: JSValue = 0;
    func_obj = JS_GetProperty(ctx, this_val, atom);
    if JS_IsException(func_obj) != 0 {
        return func_obj;
    }
    return JS_CallFree(ctx, func_obj, this_val, argc, argv);
}
unsafe extern "C" fn JS_InvokeFree(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut atom: JSAtom,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut res: JSValue = JS_Invoke(ctx, this_val, atom, argc, argv);
    JS_FreeValue(ctx, this_val);
    return res;
}
unsafe extern "C" fn async_func_init(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncFunctionState,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut local_count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut arg_buf_len: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    sf = &mut (*s).frame;
    init_list_head(&mut (*sf).var_ref_list);
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    b = (*p).u.func.function_bytecode;
    (*sf).js_mode = (*b).js_mode as libc::c_int;
    let ref mut fresh370 = (*sf).cur_pc;
    *fresh370 = (*b).byte_code_buf;
    arg_buf_len = max_int((*b).arg_count as libc::c_int, argc);
    local_count = arg_buf_len + (*b).var_count as libc::c_int
        + (*b).stack_size as libc::c_int;
    let ref mut fresh371 = (*sf).arg_buf;
    *fresh371 = js_malloc(
        ctx,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(max_int(local_count, 1 as libc::c_int) as libc::c_ulong),
    ) as *mut JSValue;
    if ((*sf).arg_buf).is_null() {
        return -(1 as libc::c_int);
    }
    (*sf).cur_func = JS_DupValue(ctx, func_obj);
    (*s).this_val = JS_DupValue(ctx, this_obj);
    (*s).argc = argc;
    (*sf).arg_count = arg_buf_len;
    let ref mut fresh372 = (*sf).var_buf;
    *fresh372 = ((*sf).arg_buf).offset(arg_buf_len as isize);
    let ref mut fresh373 = (*sf).cur_sp;
    *fresh373 = ((*sf).var_buf).offset((*b).var_count as libc::c_int as isize);
    i = 0 as libc::c_int;
    while i < argc {
        *((*sf).arg_buf).offset(i as isize) = JS_DupValue(ctx, *argv.offset(i as isize));
        i += 1;
    }
    n = arg_buf_len + (*b).var_count as libc::c_int;
    i = argc;
    while i < n {
        *((*sf).arg_buf)
            .offset(
                i as isize,
            ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn async_func_mark(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncFunctionState,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut sp: *mut JSValue = 0 as *mut JSValue;
    sf = &mut (*s).frame;
    JS_MarkValue(rt, (*sf).cur_func, mark_func);
    JS_MarkValue(rt, (*s).this_val, mark_func);
    if !((*sf).cur_sp).is_null() {
        sp = (*sf).arg_buf;
        while sp < (*sf).cur_sp {
            JS_MarkValue(rt, *sp, mark_func);
            sp = sp.offset(1);
        }
    }
}
unsafe extern "C" fn async_func_free(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncFunctionState,
) {
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut sp: *mut JSValue = 0 as *mut JSValue;
    sf = &mut (*s).frame;
    close_var_refs(rt, sf);
    if !((*sf).arg_buf).is_null() {
        assert(((*sf).cur_sp != 0 as *mut libc::c_void as *mut JSValue) as libc::c_int);
        sp = (*sf).arg_buf;
        while sp < (*sf).cur_sp {
            JS_FreeValueRT(rt, *sp);
            sp = sp.offset(1);
        }
        js_free_rt(rt, (*sf).arg_buf as *mut libc::c_void);
    }
    JS_FreeValueRT(rt, (*sf).cur_func);
    JS_FreeValueRT(rt, (*s).this_val);
}
unsafe extern "C" fn async_func_resume(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncFunctionState,
) -> JSValue {
    let mut func_obj: JSValue = 0;
    if js_check_stack_overflow((*ctx).rt, 0 as libc::c_int as size_t) != 0 {
        return JS_ThrowStackOverflow(ctx);
    }
    func_obj = (JS_TAG_INT as libc::c_int as uint64_t) << 32 as libc::c_int
        | s as uintptr_t as libc::c_ulonglong;
    return JS_CallInternal(
        ctx,
        func_obj,
        (*s).this_val,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        (*s).argc,
        (*s).frame.arg_buf,
        (1 as libc::c_int) << 2 as libc::c_int,
    );
}
unsafe extern "C" fn free_generator_stack_rt(
    mut rt: *mut JSRuntime,
    mut s: *mut JSGeneratorData,
) {
    if (*s).state as libc::c_uint
        == JS_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint
    {
        return;
    }
    async_func_free(rt, &mut (*s).func_state);
    (*s).state = JS_GENERATOR_STATE_COMPLETED;
}
unsafe extern "C" fn js_generator_finalizer(mut rt: *mut JSRuntime, mut obj: JSValue) {
    let mut s: *mut JSGeneratorData = JS_GetOpaque(
        obj,
        JS_CLASS_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSGeneratorData;
    if !s.is_null() {
        free_generator_stack_rt(rt, s);
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn free_generator_stack(
    mut ctx: *mut JSContext,
    mut s: *mut JSGeneratorData,
) {
    free_generator_stack_rt((*ctx).rt, s);
}
unsafe extern "C" fn js_generator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut s: *mut JSGeneratorData = (*p).u.generator_data;
    if s.is_null()
        || (*s).state as libc::c_uint
            == JS_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint
    {
        return;
    }
    async_func_mark(rt, &mut (*s).func_state, mark_func);
}
unsafe extern "C" fn js_generator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSGeneratorData = JS_GetOpaque(
        this_val,
        JS_CLASS_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSGeneratorData;
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut ret: JSValue = 0;
    let mut func_ret: JSValue = 0;
    *pdone = TRUE as libc::c_int;
    if s.is_null() {
        return JS_ThrowTypeError(
            ctx,
            b"not a generator\0" as *const u8 as *const libc::c_char,
        );
    }
    sf = &mut (*s).func_state.frame;
    let mut current_block_39: u64;
    match (*s).state as libc::c_uint {
        2 | 1 => {
            ret = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
            if magic == 2 as libc::c_int
                && (*s).state as libc::c_uint
                    == JS_GENERATOR_STATE_SUSPENDED_YIELD as libc::c_int as libc::c_uint
            {
                JS_Throw(ctx, ret);
                (*s).func_state.throw_flag = TRUE as libc::c_int;
                current_block_39 = 2838571290723028321;
            } else {
                *((*sf).cur_sp).offset(-(1 as libc::c_int) as isize) = ret;
                *((*sf).cur_sp)
                    .offset(0 as libc::c_int as isize) = JS_NewInt32(ctx, magic);
                let ref mut fresh374 = (*sf).cur_sp;
                *fresh374 = (*fresh374).offset(1);
                current_block_39 = 7584244320563836019;
            }
        }
        4 => {
            current_block_39 = 10501436103940631302;
        }
        3 => {
            ret = JS_ThrowTypeError(
                ctx,
                b"cannot invoke a running generator\0" as *const u8
                    as *const libc::c_char,
            );
            current_block_39 = 16738040538446813684;
        }
        0 | _ => {
            if magic == 0 as libc::c_int {
                current_block_39 = 7584244320563836019;
            } else {
                free_generator_stack(ctx, s);
                current_block_39 = 10501436103940631302;
            }
        }
    }
    match current_block_39 {
        10501436103940631302 => {
            match magic {
                1 => {
                    ret = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
                }
                2 => {
                    ret = JS_Throw(
                        ctx,
                        JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                    );
                }
                0 | _ => {
                    ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
            }
            current_block_39 = 16738040538446813684;
        }
        7584244320563836019 => {
            (*s).func_state.throw_flag = FALSE as libc::c_int;
            current_block_39 = 2838571290723028321;
        }
        _ => {}
    }
    match current_block_39 {
        2838571290723028321 => {
            (*s).state = JS_GENERATOR_STATE_EXECUTING;
            func_ret = async_func_resume(ctx, &mut (*s).func_state);
            (*s).state = JS_GENERATOR_STATE_SUSPENDED_YIELD;
            if JS_IsException(func_ret) != 0 {
                free_generator_stack(ctx, s);
                return func_ret;
            }
            if (func_ret >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_INT as libc::c_int
            {
                ret = *((*sf).cur_sp).offset(-(1 as libc::c_int) as isize);
                *((*sf).cur_sp)
                    .offset(
                        -(1 as libc::c_int) as isize,
                    ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                if func_ret as libc::c_int == 2 as libc::c_int {
                    (*s).state = JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
                    *pdone = 2 as libc::c_int;
                } else {
                    *pdone = FALSE as libc::c_int;
                }
            } else {
                ret = *((*sf).cur_sp).offset(-(1 as libc::c_int) as isize);
                *((*sf).cur_sp)
                    .offset(
                        -(1 as libc::c_int) as isize,
                    ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                JS_FreeValue(ctx, func_ret);
                free_generator_stack(ctx, s);
            }
        }
        _ => {}
    }
    return ret;
}
unsafe extern "C" fn js_generator_function_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut func_ret: JSValue = 0;
    let mut s: *mut JSGeneratorData = 0 as *mut JSGeneratorData;
    s = js_mallocz(ctx, ::core::mem::size_of::<JSGeneratorData>() as libc::c_ulong)
        as *mut JSGeneratorData;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).state = JS_GENERATOR_STATE_SUSPENDED_START;
    if async_func_init(ctx, &mut (*s).func_state, func_obj, this_obj, argc, argv) != 0 {
        (*s).state = JS_GENERATOR_STATE_COMPLETED;
    } else {
        func_ret = async_func_resume(ctx, &mut (*s).func_state);
        if !(JS_IsException(func_ret) != 0) {
            JS_FreeValue(ctx, func_ret);
            obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_GENERATOR as libc::c_int);
            if !(JS_IsException(obj) != 0) {
                JS_SetOpaque(obj, s as *mut libc::c_void);
                return obj;
            }
        }
    }
    free_generator_stack_rt((*ctx).rt, s);
    js_free(ctx, s as *mut libc::c_void);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_async_function_terminate(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncFunctionData,
) {
    if (*s).is_active != 0 {
        async_func_free(rt, &mut (*s).func_state);
        (*s).is_active = FALSE as libc::c_int;
    }
}
unsafe extern "C" fn js_async_function_free0(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncFunctionData,
) {
    js_async_function_terminate(rt, s);
    JS_FreeValueRT(rt, (*s).resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValueRT(rt, (*s).resolving_funcs[1 as libc::c_int as usize]);
    remove_gc_object(&mut (*s).header);
    js_free_rt(rt, s as *mut libc::c_void);
}
unsafe extern "C" fn js_async_function_free(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncFunctionData,
) {
    let ref mut fresh375 = (*s).header.ref_count;
    *fresh375 -= 1;
    if *fresh375 == 0 as libc::c_int {
        js_async_function_free0(rt, s);
    }
}
unsafe extern "C" fn js_async_function_resolve_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut s: *mut JSAsyncFunctionData = (*p).u.async_function_data;
    if !s.is_null() {
        js_async_function_free(rt, s);
    }
}
unsafe extern "C" fn js_async_function_resolve_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut s: *mut JSAsyncFunctionData = (*p).u.async_function_data;
    if !s.is_null() {
        mark_func.expect("non-null function pointer")(rt, &mut (*s).header);
    }
}
unsafe extern "C" fn js_async_function_resolve_create(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncFunctionData,
    mut resolving_funcs: *mut JSValue,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        *resolving_funcs
            .offset(
                i as isize,
            ) = JS_NewObjectProtoClass(
            ctx,
            (*ctx).function_proto,
            (JS_CLASS_ASYNC_FUNCTION_RESOLVE as libc::c_int + i) as JSClassID,
        );
        if JS_IsException(*resolving_funcs.offset(i as isize)) != 0 {
            if i == 1 as libc::c_int {
                JS_FreeValue(ctx, *resolving_funcs.offset(0 as libc::c_int as isize));
            }
            return -(1 as libc::c_int);
        }
        p = *resolving_funcs.offset(i as isize) as intptr_t as *mut libc::c_void
            as *mut JSObject;
        let ref mut fresh376 = (*s).header.ref_count;
        *fresh376 += 1;
        let ref mut fresh377 = (*p).u.async_function_data;
        *fresh377 = s;
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_async_function_resume(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncFunctionData,
) {
    let mut error: JSValue = 0;
    let mut current_block: u64;
    let mut func_ret: JSValue = 0;
    let mut ret2: JSValue = 0;
    func_ret = async_func_resume(ctx, &mut (*s).func_state);
    if JS_IsException(func_ret) != 0 {
        error = 0;
        current_block = 11721467516925318274;
    } else {
        let mut value: JSValue = 0;
        value = *((*s).func_state.frame.cur_sp).offset(-(1 as libc::c_int) as isize);
        *((*s).func_state.frame.cur_sp)
            .offset(
                -(1 as libc::c_int) as isize,
            ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        if JS_IsUndefined(func_ret) != 0 {
            ret2 = JS_Call(
                ctx,
                (*s).resolving_funcs[0 as libc::c_int as usize],
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut value as *mut JSValue,
            );
            JS_FreeValue(ctx, ret2);
            JS_FreeValue(ctx, value);
            js_async_function_terminate((*ctx).rt, s);
            current_block = 1538046216550696469;
        } else {
            let mut promise: JSValue = 0;
            let mut resolving_funcs: [JSValue; 2] = [0; 2];
            let mut resolving_funcs1: [JSValue; 2] = [0; 2];
            let mut i: libc::c_int = 0;
            let mut res: libc::c_int = 0;
            JS_FreeValue(ctx, func_ret);
            promise = js_promise_resolve(
                ctx,
                (*ctx).promise_ctor,
                1 as libc::c_int,
                &mut value as *mut JSValue,
                0 as libc::c_int,
            );
            JS_FreeValue(ctx, value);
            if JS_IsException(promise) != 0 {
                current_block = 11721467516925318274;
            } else if js_async_function_resolve_create(
                ctx,
                s,
                resolving_funcs.as_mut_ptr(),
            ) != 0
            {
                JS_FreeValue(ctx, promise);
                current_block = 11721467516925318274;
            } else {
                i = 0 as libc::c_int;
                while i < 2 as libc::c_int {
                    resolving_funcs1[i
                        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    i += 1;
                }
                res = perform_promise_then(
                    ctx,
                    promise,
                    resolving_funcs.as_mut_ptr(),
                    resolving_funcs1.as_mut_ptr(),
                );
                JS_FreeValue(ctx, promise);
                i = 0 as libc::c_int;
                while i < 2 as libc::c_int {
                    JS_FreeValue(ctx, resolving_funcs[i as usize]);
                    i += 1;
                }
                if res != 0 {
                    current_block = 11721467516925318274;
                } else {
                    current_block = 1538046216550696469;
                }
            }
        }
    }
    match current_block {
        11721467516925318274 => {
            error = JS_GetException(ctx);
            ret2 = JS_Call(
                ctx,
                (*s).resolving_funcs[1 as libc::c_int as usize],
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut error as *mut JSValue,
            );
            JS_FreeValue(ctx, error);
            js_async_function_terminate((*ctx).rt, s);
            JS_FreeValue(ctx, ret2);
        }
        _ => {}
    };
}
unsafe extern "C" fn js_async_function_resolve_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut p: *mut JSObject = func_obj as intptr_t as *mut libc::c_void
        as *mut JSObject;
    let mut s: *mut JSAsyncFunctionData = (*p).u.async_function_data;
    let mut is_reject: BOOL = (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        - JS_CLASS_ASYNC_FUNCTION_RESOLVE as libc::c_int;
    let mut arg: JSValue = 0;
    if argc > 0 as libc::c_int {
        arg = *argv.offset(0 as libc::c_int as isize);
    } else {
        arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).func_state.throw_flag = is_reject;
    if is_reject != 0 {
        JS_Throw(ctx, JS_DupValue(ctx, arg));
    } else {
        *((*s).func_state.frame.cur_sp)
            .offset(-(1 as libc::c_int) as isize) = JS_DupValue(ctx, arg);
    }
    js_async_function_resume(ctx, s);
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_async_function_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut promise: JSValue = 0;
    let mut s: *mut JSAsyncFunctionData = 0 as *mut JSAsyncFunctionData;
    s = js_mallocz(ctx, ::core::mem::size_of::<JSAsyncFunctionData>() as libc::c_ulong)
        as *mut JSAsyncFunctionData;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).header.ref_count = 1 as libc::c_int;
    add_gc_object((*ctx).rt, &mut (*s).header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
    (*s).is_active = FALSE as libc::c_int;
    (*s)
        .resolving_funcs[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*s)
        .resolving_funcs[1 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    promise = JS_NewPromiseCapability(ctx, ((*s).resolving_funcs).as_mut_ptr());
    if !(JS_IsException(promise) != 0) {
        if !(async_func_init(ctx, &mut (*s).func_state, func_obj, this_obj, argc, argv)
            != 0)
        {
            (*s).is_active = TRUE as libc::c_int;
            js_async_function_resume(ctx, s);
            js_async_function_free((*ctx).rt, s);
            return promise;
        }
    }
    JS_FreeValue(ctx, promise);
    js_async_function_free((*ctx).rt, s);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_async_generator_free(
    mut rt: *mut JSRuntime,
    mut s: *mut JSAsyncGeneratorData,
) {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut req: *mut JSAsyncGeneratorRequest = 0 as *mut JSAsyncGeneratorRequest;
    el = (*s).queue.next;
    el1 = (*el).next;
    while el != &mut (*s).queue as *mut list_head {
        req = (el as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
            as *mut JSAsyncGeneratorRequest;
        JS_FreeValueRT(rt, (*req).result);
        JS_FreeValueRT(rt, (*req).promise);
        JS_FreeValueRT(rt, (*req).resolving_funcs[0 as libc::c_int as usize]);
        JS_FreeValueRT(rt, (*req).resolving_funcs[1 as libc::c_int as usize]);
        js_free_rt(rt, req as *mut libc::c_void);
        el = el1;
        el1 = (*el).next;
    }
    if (*s).state as libc::c_uint
        != JS_ASYNC_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint
        && (*s).state as libc::c_uint
            != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN as libc::c_int as libc::c_uint
    {
        async_func_free(rt, &mut (*s).func_state);
    }
    js_free_rt(rt, s as *mut libc::c_void);
}
unsafe extern "C" fn js_async_generator_finalizer(
    mut rt: *mut JSRuntime,
    mut obj: JSValue,
) {
    let mut s: *mut JSAsyncGeneratorData = JS_GetOpaque(
        obj,
        JS_CLASS_ASYNC_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncGeneratorData;
    if !s.is_null() {
        js_async_generator_free(rt, s);
    }
}
unsafe extern "C" fn js_async_generator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSAsyncGeneratorData = JS_GetOpaque(
        val,
        JS_CLASS_ASYNC_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncGeneratorData;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut req: *mut JSAsyncGeneratorRequest = 0 as *mut JSAsyncGeneratorRequest;
    if !s.is_null() {
        el = (*s).queue.next;
        while el != &mut (*s).queue as *mut list_head {
            req = (el as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
                as *mut JSAsyncGeneratorRequest;
            JS_MarkValue(rt, (*req).result, mark_func);
            JS_MarkValue(rt, (*req).promise, mark_func);
            JS_MarkValue(
                rt,
                (*req).resolving_funcs[0 as libc::c_int as usize],
                mark_func,
            );
            JS_MarkValue(
                rt,
                (*req).resolving_funcs[1 as libc::c_int as usize],
                mark_func,
            );
            el = (*el).next;
        }
        if (*s).state as libc::c_uint
            != JS_ASYNC_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint
            && (*s).state as libc::c_uint
                != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN as libc::c_int
                    as libc::c_uint
        {
            async_func_mark(rt, &mut (*s).func_state, mark_func);
        }
    }
}
unsafe extern "C" fn js_async_generator_resolve_function_create(
    mut ctx: *mut JSContext,
    mut generator: JSValue,
    mut resolving_funcs: *mut JSValue,
    mut is_resume_next: BOOL,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut func: JSValue = 0;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        func = JS_NewCFunctionData(
            ctx,
            Some(
                js_async_generator_resolve_function
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            1 as libc::c_int,
            i + is_resume_next * 2 as libc::c_int,
            1 as libc::c_int,
            &mut generator,
        );
        if JS_IsException(func) != 0 {
            if i == 1 as libc::c_int {
                JS_FreeValue(ctx, *resolving_funcs.offset(0 as libc::c_int as isize));
            }
            return -(1 as libc::c_int);
        }
        *resolving_funcs.offset(i as isize) = func;
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_async_generator_await(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
    mut value: JSValue,
) -> libc::c_int {
    let mut promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut resolving_funcs1: [JSValue; 2] = [0; 2];
    let mut i: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    promise = js_promise_resolve(
        ctx,
        (*ctx).promise_ctor,
        1 as libc::c_int,
        &mut value,
        0 as libc::c_int,
    );
    if !(JS_IsException(promise) != 0) {
        if js_async_generator_resolve_function_create(
            ctx,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*s).generator as uintptr_t as libc::c_ulonglong,
            resolving_funcs.as_mut_ptr(),
            FALSE as libc::c_int,
        ) != 0
        {
            JS_FreeValue(ctx, promise);
        } else {
            i = 0 as libc::c_int;
            while i < 2 as libc::c_int {
                resolving_funcs1[i
                    as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                i += 1;
            }
            res = perform_promise_then(
                ctx,
                promise,
                resolving_funcs.as_mut_ptr(),
                resolving_funcs1.as_mut_ptr(),
            );
            JS_FreeValue(ctx, promise);
            i = 0 as libc::c_int;
            while i < 2 as libc::c_int {
                JS_FreeValue(ctx, resolving_funcs[i as usize]);
                i += 1;
            }
            if !(res != 0) {
                return 0 as libc::c_int;
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_async_generator_resolve_or_reject(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
    mut result: JSValue,
    mut is_reject: libc::c_int,
) {
    let mut next: *mut JSAsyncGeneratorRequest = 0 as *mut JSAsyncGeneratorRequest;
    let mut ret: JSValue = 0;
    next = ((*s).queue.next as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
        as *mut JSAsyncGeneratorRequest;
    list_del(&mut (*next).link);
    ret = JS_Call(
        ctx,
        (*next).resolving_funcs[is_reject as usize],
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        1 as libc::c_int,
        &mut result,
    );
    JS_FreeValue(ctx, ret);
    JS_FreeValue(ctx, (*next).result);
    JS_FreeValue(ctx, (*next).promise);
    JS_FreeValue(ctx, (*next).resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, (*next).resolving_funcs[1 as libc::c_int as usize]);
    js_free(ctx, next as *mut libc::c_void);
}
unsafe extern "C" fn js_async_generator_resolve(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
    mut value: JSValue,
    mut done: BOOL,
) {
    let mut result: JSValue = 0;
    result = js_create_iterator_result(ctx, JS_DupValue(ctx, value), done);
    js_async_generator_resolve_or_reject(ctx, s, result, 0 as libc::c_int);
    JS_FreeValue(ctx, result);
}
unsafe extern "C" fn js_async_generator_reject(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
    mut exception: JSValue,
) {
    js_async_generator_resolve_or_reject(ctx, s, exception, 1 as libc::c_int);
}
unsafe extern "C" fn js_async_generator_complete(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
) {
    if (*s).state as libc::c_uint
        != JS_ASYNC_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint
    {
        (*s).state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
        async_func_free((*ctx).rt, &mut (*s).func_state);
    }
}
unsafe extern "C" fn js_async_generator_completed_return(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
    mut value: JSValue,
) -> libc::c_int {
    let mut promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut resolving_funcs1: [JSValue; 2] = [0; 2];
    let mut res: libc::c_int = 0;
    promise = js_promise_resolve(
        ctx,
        (*ctx).promise_ctor,
        1 as libc::c_int,
        &mut value as *mut JSValue,
        0 as libc::c_int,
    );
    if JS_IsException(promise) != 0 {
        return -(1 as libc::c_int);
    }
    if js_async_generator_resolve_function_create(
        ctx,
        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*s).generator as uintptr_t as libc::c_ulonglong,
        resolving_funcs1.as_mut_ptr(),
        TRUE as libc::c_int,
    ) != 0
    {
        JS_FreeValue(ctx, promise);
        return -(1 as libc::c_int);
    }
    resolving_funcs[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    resolving_funcs[1 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    res = perform_promise_then(
        ctx,
        promise,
        resolving_funcs1.as_mut_ptr(),
        resolving_funcs.as_mut_ptr(),
    );
    JS_FreeValue(ctx, resolving_funcs1[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs1[1 as libc::c_int as usize]);
    JS_FreeValue(ctx, promise);
    return res;
}
unsafe extern "C" fn js_async_generator_resume_next(
    mut ctx: *mut JSContext,
    mut s: *mut JSAsyncGeneratorData,
) {
    let mut current_block: u64;
    let mut next: *mut JSAsyncGeneratorRequest = 0 as *mut JSAsyncGeneratorRequest;
    let mut func_ret: JSValue = 0;
    let mut value: JSValue = 0;
    while !(list_empty(&mut (*s).queue) != 0) {
        next = ((*s).queue.next as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
            as *mut JSAsyncGeneratorRequest;
        match (*s).state as libc::c_uint {
            3 => {
                current_block = 6996911070039263677;
            }
            4 => {
                break;
            }
            0 => {
                if (*next).completion_type == 0 as libc::c_int {
                    current_block = 3819247573194708941;
                } else {
                    js_async_generator_complete(ctx, s);
                    continue;
                }
            }
            5 => {
                if (*next).completion_type == 0 as libc::c_int {
                    js_async_generator_resolve(
                        ctx,
                        s,
                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        TRUE as libc::c_int,
                    );
                    break;
                } else if (*next).completion_type == 1 as libc::c_int {
                    (*s).state = JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;
                    js_async_generator_completed_return(ctx, s, (*next).result);
                    break;
                } else {
                    js_async_generator_reject(ctx, s, (*next).result);
                    break;
                }
            }
            1 | 2 => {
                value = JS_DupValue(ctx, (*next).result);
                if (*next).completion_type == 2 as libc::c_int
                    && (*s).state as libc::c_uint
                        == JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD as libc::c_int
                            as libc::c_uint
                {
                    JS_Throw(ctx, value);
                    (*s).func_state.throw_flag = TRUE as libc::c_int;
                    current_block = 14359455889292382949;
                } else {
                    *((*s).func_state.frame.cur_sp)
                        .offset(-(1 as libc::c_int) as isize) = value;
                    *((*s).func_state.frame.cur_sp)
                        .offset(
                            0 as libc::c_int as isize,
                        ) = JS_NewInt32(ctx, (*next).completion_type);
                    let ref mut fresh378 = (*s).func_state.frame.cur_sp;
                    *fresh378 = (*fresh378).offset(1);
                    current_block = 3819247573194708941;
                }
            }
            _ => {
                abort();
            }
        }
        match current_block {
            3819247573194708941 => {
                (*s).func_state.throw_flag = FALSE as libc::c_int;
                current_block = 14359455889292382949;
            }
            _ => {}
        }
        match current_block {
            14359455889292382949 => {
                (*s).state = JS_ASYNC_GENERATOR_STATE_EXECUTING;
            }
            _ => {}
        }
        func_ret = async_func_resume(ctx, &mut (*s).func_state);
        if JS_IsException(func_ret) != 0 {
            value = JS_GetException(ctx);
            js_async_generator_complete(ctx, s);
            js_async_generator_reject(ctx, s, value);
            JS_FreeValue(ctx, value);
        } else if (func_ret >> 32 as libc::c_int) as libc::c_int
            == JS_TAG_INT as libc::c_int
        {
            let mut func_ret_code: libc::c_int = 0;
            value = *((*s).func_state.frame.cur_sp).offset(-(1 as libc::c_int) as isize);
            *((*s).func_state.frame.cur_sp)
                .offset(
                    -(1 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            func_ret_code = func_ret as libc::c_int;
            match func_ret_code {
                1 | 2 => {
                    if func_ret_code == 2 as libc::c_int {
                        (*s).state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
                    } else {
                        (*s).state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD;
                    }
                    js_async_generator_resolve(ctx, s, value, FALSE as libc::c_int);
                    JS_FreeValue(ctx, value);
                }
                0 => {
                    js_async_generator_await(ctx, s, value);
                    JS_FreeValue(ctx, value);
                    break;
                }
                _ => {
                    abort();
                }
            }
        } else {
            assert(JS_IsUndefined(func_ret));
            value = *((*s).func_state.frame.cur_sp).offset(-(1 as libc::c_int) as isize);
            *((*s).func_state.frame.cur_sp)
                .offset(
                    -(1 as libc::c_int) as isize,
                ) = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            js_async_generator_complete(ctx, s);
            js_async_generator_resolve(ctx, s, value, TRUE as libc::c_int);
            JS_FreeValue(ctx, value);
        }
    }
}
unsafe extern "C" fn js_async_generator_resolve_function(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    let mut is_reject: BOOL = magic & 1 as libc::c_int;
    let mut s: *mut JSAsyncGeneratorData = JS_GetOpaque(
        *func_data.offset(0 as libc::c_int as isize),
        JS_CLASS_ASYNC_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncGeneratorData;
    let mut arg: JSValue = *argv.offset(0 as libc::c_int as isize);
    if magic >= 2 as libc::c_int {
        assert(
            ((*s).state as libc::c_uint
                == JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN as libc::c_int
                    as libc::c_uint
                || (*s).state as libc::c_uint
                    == JS_ASYNC_GENERATOR_STATE_COMPLETED as libc::c_int as libc::c_uint)
                as libc::c_int,
        );
        (*s).state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
        if is_reject != 0 {
            js_async_generator_reject(ctx, s, arg);
        } else {
            js_async_generator_resolve(ctx, s, arg, TRUE as libc::c_int);
        }
    } else {
        assert(
            ((*s).state as libc::c_uint
                == JS_ASYNC_GENERATOR_STATE_EXECUTING as libc::c_int as libc::c_uint)
                as libc::c_int,
        );
        (*s).func_state.throw_flag = is_reject;
        if is_reject != 0 {
            JS_Throw(ctx, JS_DupValue(ctx, arg));
        } else {
            *((*s).func_state.frame.cur_sp)
                .offset(-(1 as libc::c_int) as isize) = JS_DupValue(ctx, arg);
        }
        js_async_generator_resume_next(ctx, s);
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_async_generator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSAsyncGeneratorData = JS_GetOpaque(
        this_val,
        JS_CLASS_ASYNC_GENERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncGeneratorData;
    let mut promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut req: *mut JSAsyncGeneratorRequest = 0 as *mut JSAsyncGeneratorRequest;
    promise = JS_NewPromiseCapability(ctx, resolving_funcs.as_mut_ptr());
    if JS_IsException(promise) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if s.is_null() {
        let mut err: JSValue = 0;
        let mut res2: JSValue = 0;
        JS_ThrowTypeError(
            ctx,
            b"not an AsyncGenerator object\0" as *const u8 as *const libc::c_char,
        );
        err = JS_GetException(ctx);
        res2 = JS_Call(
            ctx,
            resolving_funcs[1 as libc::c_int as usize],
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut err as *mut JSValue,
        );
        JS_FreeValue(ctx, err);
        JS_FreeValue(ctx, res2);
        JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
        JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
        return promise;
    }
    req = js_mallocz(
        ctx,
        ::core::mem::size_of::<JSAsyncGeneratorRequest>() as libc::c_ulong,
    ) as *mut JSAsyncGeneratorRequest;
    if req.is_null() {
        JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
        JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
        JS_FreeValue(ctx, promise);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        (*req).completion_type = magic;
        (*req).result = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
        (*req).promise = JS_DupValue(ctx, promise);
        (*req)
            .resolving_funcs[0 as libc::c_int
            as usize] = resolving_funcs[0 as libc::c_int as usize];
        (*req)
            .resolving_funcs[1 as libc::c_int
            as usize] = resolving_funcs[1 as libc::c_int as usize];
        list_add_tail(&mut (*req).link, &mut (*s).queue);
        if (*s).state as libc::c_uint
            != JS_ASYNC_GENERATOR_STATE_EXECUTING as libc::c_int as libc::c_uint
        {
            js_async_generator_resume_next(ctx, s);
        }
        return promise;
    };
}
unsafe extern "C" fn js_async_generator_function_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut func_ret: JSValue = 0;
    let mut s: *mut JSAsyncGeneratorData = 0 as *mut JSAsyncGeneratorData;
    s = js_mallocz(ctx, ::core::mem::size_of::<JSAsyncGeneratorData>() as libc::c_ulong)
        as *mut JSAsyncGeneratorData;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_START;
    init_list_head(&mut (*s).queue);
    if async_func_init(ctx, &mut (*s).func_state, func_obj, this_obj, argc, argv) != 0 {
        (*s).state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
    } else {
        func_ret = async_func_resume(ctx, &mut (*s).func_state);
        if !(JS_IsException(func_ret) != 0) {
            JS_FreeValue(ctx, func_ret);
            obj = js_create_from_ctor(
                ctx,
                func_obj,
                JS_CLASS_ASYNC_GENERATOR as libc::c_int,
            );
            if !(JS_IsException(obj) != 0) {
                let ref mut fresh379 = (*s).generator;
                *fresh379 = obj as intptr_t as *mut libc::c_void as *mut JSObject;
                JS_SetOpaque(obj, s as *mut libc::c_void);
                return obj;
            }
        }
    }
    js_async_generator_free((*ctx).rt, s);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
static mut opcode_info: [JSOpCode; 259] = [
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_i32 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_const as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_const as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 6 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 5 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 5 as libc::c_int as uint8_t,
            n_push: 5 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 5 as libc::c_int as uint8_t,
            n_push: 5 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npop_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 6 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 10 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 3 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 5 as libc::c_int as uint8_t,
            fmt: OP_FMT_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 3 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 4 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 4 as libc::c_int as uint8_t,
            n_push: 5 as libc::c_int as uint8_t,
            fmt: OP_FMT_u8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 2 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 11 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_label_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 2 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 7 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_atom_u16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_u32 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 5 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_u32 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_int as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_i8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_i16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_const8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_const8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_loc8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_loc as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_arg as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none_var_ref as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 2 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 3 as libc::c_int as uint8_t,
            n_pop: 0 as libc::c_int as uint8_t,
            n_push: 0 as libc::c_int as uint8_t,
            fmt: OP_FMT_label16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npopx as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npopx as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npopx as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_npopx as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = JSOpCode {
            size: 1 as libc::c_int as uint8_t,
            n_pop: 1 as libc::c_int as uint8_t,
            n_push: 1 as libc::c_int as uint8_t,
            fmt: OP_FMT_none as libc::c_int as uint8_t,
        };
        init
    },
];
unsafe extern "C" fn free_token(mut s: *mut JSParseState, mut token: *mut JSToken) {
    match (*token).val {
        -127 | -126 => {
            JS_FreeValue((*s).ctx, (*token).u.str_0.str_0);
        }
        -124 => {
            JS_FreeValue((*s).ctx, (*token).u.regexp.body);
            JS_FreeValue((*s).ctx, (*token).u.regexp.flags);
        }
        -125 | -87 => {
            JS_FreeAtom((*s).ctx, (*token).u.ident.atom);
        }
        _ => {
            if (*token).val >= TOK_NULL as libc::c_int
                && (*token).val <= TOK_AWAIT as libc::c_int
            {
                JS_FreeAtom((*s).ctx, (*token).u.ident.atom);
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn js_parse_error(
    mut s: *mut JSParseState,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut ap: va_list = 0 as *mut libc::c_void;
    let mut backtrace_flags: libc::c_int = 0;
    ap = args.clone();
    JS_ThrowError2(ctx, JS_SYNTAX_ERROR, fmt, ap, FALSE as libc::c_int);
    backtrace_flags = 0 as libc::c_int;
    if !((*s).cur_func).is_null() && (*(*s).cur_func).backtrace_barrier != 0 {
        backtrace_flags = (1 as libc::c_int) << 1 as libc::c_int;
    }
    build_backtrace(
        ctx,
        (*(*ctx).rt).current_exception,
        (*s).filename,
        (*s).line_num,
        backtrace_flags,
    );
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_parse_expect(
    mut s: *mut JSParseState,
    mut tok: libc::c_int,
) -> libc::c_int {
    if (*s).token.val != tok {
        return js_parse_error(
            s,
            b"expecting '%c'\0" as *const u8 as *const libc::c_char,
            tok,
        );
    }
    return next_token(s);
}
unsafe extern "C" fn js_parse_expect_semi(mut s: *mut JSParseState) -> libc::c_int {
    if (*s).token.val != ';' as i32 {
        if (*s).token.val == TOK_EOF as libc::c_int || (*s).token.val == '}' as i32
            || (*s).got_lf != 0
        {
            return 0 as libc::c_int;
        }
        return js_parse_error(
            s,
            b"expecting '%c'\0" as *const u8 as *const libc::c_char,
            ';' as i32,
        );
    }
    return next_token(s);
}
unsafe extern "C" fn js_parse_error_reserved_identifier(
    mut s: *mut JSParseState,
) -> libc::c_int {
    let mut buf1: [libc::c_char; 64] = [0; 64];
    return js_parse_error(
        s,
        b"'%s' is a reserved identifier\0" as *const u8 as *const libc::c_char,
        JS_AtomGetStr(
            (*s).ctx,
            buf1.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            (*s).token.u.ident.atom,
        ),
    );
}
unsafe extern "C" fn js_parse_template_part(
    mut s: *mut JSParseState,
    mut p: *const uint8_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut c: uint32_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if string_buffer_init((*s).ctx, b, 32 as libc::c_int) != 0 {
        current_block = 11773812624682151228;
    } else {
        current_block = 10680521327981672866;
    }
    loop {
        match current_block {
            11773812624682151228 => {
                string_buffer_free(b);
                return -(1 as libc::c_int);
            }
            _ => {
                if !(p >= (*s).buf_end) {
                    let fresh380 = p;
                    p = p.offset(1);
                    c = *fresh380 as uint32_t;
                    if c == '`' as i32 as libc::c_uint {
                        break;
                    }
                    if c == '$' as i32 as libc::c_uint && *p as libc::c_int == '{' as i32
                    {
                        p = p.offset(1);
                        break;
                    } else {
                        if c == '\\' as i32 as libc::c_uint {
                            if string_buffer_putc8(b, c) != 0 {
                                current_block = 11773812624682151228;
                                continue;
                            }
                            if p >= (*s).buf_end {
                                current_block = 12838136704373818116;
                            } else {
                                let fresh381 = p;
                                p = p.offset(1);
                                c = *fresh381 as uint32_t;
                                current_block = 8236137900636309791;
                            }
                        } else {
                            current_block = 8236137900636309791;
                        }
                        match current_block {
                            12838136704373818116 => {}
                            _ => {
                                if c == '\r' as i32 as libc::c_uint {
                                    if *p as libc::c_int == '\n' as i32 {
                                        p = p.offset(1);
                                    }
                                    c = '\n' as i32 as uint32_t;
                                }
                                if c == '\n' as i32 as libc::c_uint {
                                    let ref mut fresh382 = (*s).line_num;
                                    *fresh382 += 1;
                                } else if c >= 0x80 as libc::c_int as libc::c_uint {
                                    let mut p_next: *const uint8_t = 0 as *const uint8_t;
                                    c = unicode_from_utf8(
                                        p.offset(-(1 as libc::c_int as isize)),
                                        6 as libc::c_int,
                                        &mut p_next,
                                    ) as uint32_t;
                                    if c > 0x10ffff as libc::c_int as libc::c_uint {
                                        js_parse_error(
                                            s,
                                            b"invalid UTF-8 sequence\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        current_block = 11773812624682151228;
                                        continue;
                                    } else {
                                        p = p_next;
                                    }
                                }
                                if string_buffer_putc(b, c) != 0 {
                                    current_block = 11773812624682151228;
                                    continue;
                                } else {
                                    current_block = 10680521327981672866;
                                    continue;
                                }
                            }
                        }
                    }
                }
                js_parse_error(
                    s,
                    b"unexpected end of string\0" as *const u8 as *const libc::c_char,
                );
                current_block = 11773812624682151228;
            }
        }
    }
    (*s).token.val = TOK_TEMPLATE as libc::c_int;
    (*s).token.u.str_0.sep = c as libc::c_int;
    (*s).token.u.str_0.str_0 = string_buffer_end(b);
    let ref mut fresh383 = (*s).buf_ptr;
    *fresh383 = p;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_string(
    mut s: *mut JSParseState,
    mut sep: libc::c_int,
    mut do_throw: BOOL,
    mut p: *const uint8_t,
    mut token: *mut JSToken,
    mut pp: *mut *const uint8_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0;
    let mut c: uint32_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if string_buffer_init((*s).ctx, b, 32 as libc::c_int) != 0 {
        current_block = 3571303615391462327;
    } else {
        current_block = 17179679302217393232;
    }
    loop {
        match current_block {
            3571303615391462327 => {
                string_buffer_free(b);
                return -(1 as libc::c_int);
            }
            _ => {
                if !(p >= (*s).buf_end) {
                    c = *p as uint32_t;
                    if c < 0x20 as libc::c_int as libc::c_uint {
                        if ((*s).cur_func).is_null() {
                            if do_throw != 0 {
                                js_parse_error(
                                    s,
                                    b"invalid character in a JSON string\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 3571303615391462327;
                            continue;
                        } else if sep == '`' as i32 {
                            if c == '\r' as i32 as libc::c_uint {
                                if *p.offset(1 as libc::c_int as isize) as libc::c_int
                                    == '\n' as i32
                                {
                                    p = p.offset(1);
                                }
                                c = '\n' as i32 as uint32_t;
                            }
                            current_block = 2370887241019905314;
                        } else if c == '\n' as i32 as libc::c_uint
                            || c == '\r' as i32 as libc::c_uint
                        {
                            current_block = 2103954745774401211;
                        } else {
                            current_block = 2370887241019905314;
                        }
                    } else {
                        current_block = 2370887241019905314;
                    }
                    match current_block {
                        2103954745774401211 => {}
                        _ => {
                            p = p.offset(1);
                            if c == sep as libc::c_uint {
                                break;
                            }
                            if c == '$' as i32 as libc::c_uint
                                && *p as libc::c_int == '{' as i32 && sep == '`' as i32
                            {
                                p = p.offset(1);
                                break;
                            } else {
                                if c == '\\' as i32 as libc::c_uint {
                                    c = *p as uint32_t;
                                    match c {
                                        0 => {
                                            if p >= (*s).buf_end {
                                                current_block = 2103954745774401211;
                                            } else {
                                                p = p.offset(1);
                                                current_block = 3736434875406665187;
                                            }
                                        }
                                        39 | 34 | 92 => {
                                            p = p.offset(1);
                                            current_block = 3736434875406665187;
                                        }
                                        13 => {
                                            if *p.offset(1 as libc::c_int as isize) as libc::c_int
                                                == '\n' as i32
                                            {
                                                p = p.offset(1);
                                            }
                                            current_block = 6387846268742986235;
                                        }
                                        10 => {
                                            current_block = 6387846268742986235;
                                        }
                                        _ => {
                                            if c >= '0' as i32 as libc::c_uint
                                                && c <= '9' as i32 as libc::c_uint
                                            {
                                                if ((*s).cur_func).is_null() {
                                                    current_block = 10594185614403926923;
                                                } else if (*(*s).cur_func).js_mode as libc::c_int
                                                    & (1 as libc::c_int) << 0 as libc::c_int == 0
                                                    && sep != '`' as i32
                                                {
                                                    current_block = 11415392010137850081;
                                                } else if c == '0' as i32 as libc::c_uint
                                                    && !(*p.offset(1 as libc::c_int as isize) as libc::c_int
                                                        >= '0' as i32
                                                        && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                                            <= '9' as i32)
                                                {
                                                    p = p.offset(1);
                                                    c = '\0' as i32 as uint32_t;
                                                    current_block = 3736434875406665187;
                                                } else if c >= '8' as i32 as libc::c_uint
                                                    || sep == '`' as i32
                                                {
                                                    current_block = 10594185614403926923;
                                                } else {
                                                    if do_throw != 0 {
                                                        js_parse_error(
                                                            s,
                                                            b"octal escape sequences are not allowed in strict mode\0"
                                                                as *const u8 as *const libc::c_char,
                                                        );
                                                    }
                                                    current_block = 3571303615391462327;
                                                    continue;
                                                }
                                            } else if c >= 0x80 as libc::c_int as libc::c_uint {
                                                let mut p_next: *const uint8_t = 0 as *const uint8_t;
                                                c = unicode_from_utf8(p, 6 as libc::c_int, &mut p_next)
                                                    as uint32_t;
                                                if c > 0x10ffff as libc::c_int as libc::c_uint {
                                                    current_block = 295412740510542588;
                                                } else {
                                                    p = p_next;
                                                    if c == 0x2028 as libc::c_int as libc::c_uint
                                                        || c == 0x2029 as libc::c_int as libc::c_uint
                                                    {
                                                        current_block = 17179679302217393232;
                                                        continue;
                                                    }
                                                    current_block = 3736434875406665187;
                                                }
                                            } else {
                                                current_block = 11415392010137850081;
                                            }
                                            match current_block {
                                                295412740510542588 => {}
                                                3736434875406665187 => {}
                                                _ => {
                                                    match current_block {
                                                        11415392010137850081 => {
                                                            ret = lre_parse_escape(&mut p, TRUE as libc::c_int);
                                                            if ret == -(1 as libc::c_int) {
                                                                current_block = 10594185614403926923;
                                                            } else {
                                                                if ret < 0 as libc::c_int {
                                                                    p = p.offset(1);
                                                                } else {
                                                                    c = ret as uint32_t;
                                                                }
                                                                current_block = 3736434875406665187;
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                    match current_block {
                                                        3736434875406665187 => {}
                                                        _ => {
                                                            if do_throw != 0 {
                                                                js_parse_error(
                                                                    s,
                                                                    b"malformed escape sequence in string literal\0"
                                                                        as *const u8 as *const libc::c_char,
                                                                );
                                                            }
                                                            current_block = 3571303615391462327;
                                                            continue;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    match current_block {
                                        3736434875406665187 => {}
                                        295412740510542588 => {}
                                        2103954745774401211 => {}
                                        _ => {
                                            p = p.offset(1);
                                            if sep != '`' as i32 {
                                                let ref mut fresh384 = (*s).line_num;
                                                *fresh384 += 1;
                                            }
                                            current_block = 17179679302217393232;
                                            continue;
                                        }
                                    }
                                } else if c >= 0x80 as libc::c_int as libc::c_uint {
                                    let mut p_next_0: *const uint8_t = 0 as *const uint8_t;
                                    c = unicode_from_utf8(
                                        p.offset(-(1 as libc::c_int as isize)),
                                        6 as libc::c_int,
                                        &mut p_next_0,
                                    ) as uint32_t;
                                    if c > 0x10ffff as libc::c_int as libc::c_uint {
                                        current_block = 295412740510542588;
                                    } else {
                                        p = p_next_0;
                                        current_block = 3736434875406665187;
                                    }
                                } else {
                                    current_block = 3736434875406665187;
                                }
                                match current_block {
                                    2103954745774401211 => {}
                                    _ => {
                                        match current_block {
                                            295412740510542588 => {
                                                if do_throw != 0 {
                                                    js_parse_error(
                                                        s,
                                                        b"invalid UTF-8 sequence\0" as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                }
                                                current_block = 3571303615391462327;
                                                continue;
                                            }
                                            _ => {
                                                if string_buffer_putc(b, c) != 0 {
                                                    current_block = 3571303615391462327;
                                                    continue;
                                                } else {
                                                    current_block = 17179679302217393232;
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if do_throw != 0 {
                    js_parse_error(
                        s,
                        b"unexpected end of string\0" as *const u8 as *const libc::c_char,
                    );
                }
                current_block = 3571303615391462327;
            }
        }
    }
    (*token).val = TOK_STRING as libc::c_int;
    (*token).u.str_0.sep = c as libc::c_int;
    (*token).u.str_0.str_0 = string_buffer_end(b);
    *pp = p;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn token_is_pseudo_keyword(
    mut s: *mut JSParseState,
    mut atom: JSAtom,
) -> BOOL {
    return ((*s).token.val == TOK_IDENT as libc::c_int && (*s).token.u.ident.atom == atom
        && (*s).token.u.ident.has_escape == 0) as libc::c_int;
}
unsafe extern "C" fn js_parse_regexp(mut s: *mut JSParseState) -> libc::c_int {
    let mut p_next_0: *const uint8_t = 0 as *const uint8_t;
    let mut current_block: u64;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut in_class: BOOL = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut b2_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b2: *mut StringBuffer = &mut b2_s;
    let mut c: uint32_t = 0;
    p = (*s).buf_ptr;
    p = p.offset(1);
    in_class = FALSE as libc::c_int;
    if string_buffer_init((*s).ctx, b, 32 as libc::c_int) != 0 {
        return -(1 as libc::c_int);
    }
    if string_buffer_init((*s).ctx, b2, 1 as libc::c_int) != 0 {
        current_block = 16724315354013500280;
    } else {
        current_block = 13183875560443969876;
    }
    'c_175751: loop {
        match current_block {
            16724315354013500280 => {
                string_buffer_free(b);
                string_buffer_free(b2);
                return -(1 as libc::c_int);
            }
            _ => {
                if !(p >= (*s).buf_end) {
                    let fresh385 = p;
                    p = p.offset(1);
                    c = *fresh385 as uint32_t;
                    if c == '\n' as i32 as libc::c_uint
                        || c == '\r' as i32 as libc::c_uint
                    {
                        current_block = 762442007753944235;
                    } else {
                        if c == '/' as i32 as libc::c_uint {
                            if in_class == 0 {
                                loop {
                                    let mut p_next_1: *const uint8_t = p;
                                    let fresh387 = p_next_1;
                                    p_next_1 = p_next_1.offset(1);
                                    c = *fresh387 as uint32_t;
                                    if c >= 0x80 as libc::c_int as libc::c_uint {
                                        c = unicode_from_utf8(p, 6 as libc::c_int, &mut p_next_1)
                                            as uint32_t;
                                        if c > 0x10ffff as libc::c_int as libc::c_uint {
                                            current_block = 12503245608380505427;
                                            break;
                                        }
                                    }
                                    if lre_js_is_ident_next(c as libc::c_int) == 0 {
                                        current_block = 9859671972921157070;
                                        break;
                                    }
                                    if string_buffer_putc(b2, c) != 0 {
                                        current_block = 16724315354013500280;
                                        continue 'c_175751;
                                    }
                                    p = p_next_1;
                                }
                                match current_block {
                                    12503245608380505427 => {}
                                    _ => {
                                        (*s).token.val = TOK_REGEXP as libc::c_int;
                                        (*s).token.u.regexp.body = string_buffer_end(b);
                                        (*s).token.u.regexp.flags = string_buffer_end(b2);
                                        let ref mut fresh388 = (*s).buf_ptr;
                                        *fresh388 = p;
                                        return 0 as libc::c_int;
                                    }
                                }
                            } else {
                                current_block = 6717214610478484138;
                            }
                        } else if c == '[' as i32 as libc::c_uint {
                            in_class = TRUE as libc::c_int;
                            current_block = 6717214610478484138;
                        } else if c == ']' as i32 as libc::c_uint {
                            in_class = FALSE as libc::c_int;
                            current_block = 6717214610478484138;
                        } else if c == '\\' as i32 as libc::c_uint {
                            if string_buffer_putc8(b, c) != 0 {
                                current_block = 16724315354013500280;
                                continue;
                            }
                            let fresh386 = p;
                            p = p.offset(1);
                            c = *fresh386 as uint32_t;
                            if c == '\n' as i32 as libc::c_uint
                                || c == '\r' as i32 as libc::c_uint
                            {
                                current_block = 762442007753944235;
                            } else if c == '\0' as i32 as libc::c_uint
                                && p >= (*s).buf_end
                            {
                                current_block = 15056304527706504145;
                            } else if c >= 0x80 as libc::c_int as libc::c_uint {
                                let mut p_next: *const uint8_t = 0 as *const uint8_t;
                                c = unicode_from_utf8(
                                    p.offset(-(1 as libc::c_int as isize)),
                                    6 as libc::c_int,
                                    &mut p_next,
                                ) as uint32_t;
                                if c > 0x10ffff as libc::c_int as libc::c_uint {
                                    current_block = 12503245608380505427;
                                } else {
                                    p = p_next;
                                    if c == 0x2028 as libc::c_int as libc::c_uint
                                        || c == 0x2029 as libc::c_int as libc::c_uint
                                    {
                                        current_block = 762442007753944235;
                                    } else {
                                        current_block = 6717214610478484138;
                                    }
                                }
                            } else {
                                current_block = 6717214610478484138;
                            }
                        } else if c >= 0x80 as libc::c_int as libc::c_uint {
                            p_next_0 = 0 as *const uint8_t;
                            c = unicode_from_utf8(
                                p.offset(-(1 as libc::c_int as isize)),
                                6 as libc::c_int,
                                &mut p_next_0,
                            ) as uint32_t;
                            if c > 0x10ffff as libc::c_int as libc::c_uint {
                                current_block = 12503245608380505427;
                            } else {
                                p = p_next_0;
                                if c == 0x2028 as libc::c_int as libc::c_uint
                                    || c == 0x2029 as libc::c_int as libc::c_uint
                                {
                                    current_block = 762442007753944235;
                                } else {
                                    current_block = 6717214610478484138;
                                }
                            }
                        } else {
                            current_block = 6717214610478484138;
                        }
                        match current_block {
                            762442007753944235 => {}
                            15056304527706504145 => {}
                            _ => {
                                match current_block {
                                    12503245608380505427 => {
                                        js_parse_error(
                                            s,
                                            b"invalid UTF-8 sequence\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        current_block = 16724315354013500280;
                                        continue;
                                    }
                                    _ => {
                                        if string_buffer_putc(b, c) != 0 {
                                            current_block = 16724315354013500280;
                                            continue;
                                        } else {
                                            current_block = 13183875560443969876;
                                            continue;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    match current_block {
                        15056304527706504145 => {}
                        _ => {
                            js_parse_error(
                                s,
                                b"unexpected line terminator in regexp\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 16724315354013500280;
                            continue;
                        }
                    }
                }
                js_parse_error(
                    s,
                    b"unexpected end of regexp\0" as *const u8 as *const libc::c_char,
                );
                current_block = 16724315354013500280;
            }
        }
    };
}
unsafe extern "C" fn ident_realloc(
    mut ctx: *mut JSContext,
    mut pbuf: *mut *mut libc::c_char,
    mut psize: *mut size_t,
    mut static_buf: *mut libc::c_char,
) -> libc::c_int {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut new_buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut size: size_t = 0;
    let mut new_size: size_t = 0;
    buf = *pbuf;
    size = *psize;
    if size
        >= (0xffffffff as libc::c_uint)
            .wrapping_div(3 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_ulong
    {
        new_size = 0xffffffff as libc::c_uint as size_t;
    } else {
        new_size = size.wrapping_add(size >> 1 as libc::c_int);
    }
    if buf == static_buf {
        new_buf = js_malloc(ctx, new_size) as *mut libc::c_char;
        if new_buf.is_null() {
            return -(1 as libc::c_int);
        }
        memcpy(new_buf as *mut libc::c_void, buf as *const libc::c_void, size);
    } else {
        new_buf = js_realloc(ctx, buf as *mut libc::c_void, new_size)
            as *mut libc::c_char;
        if new_buf.is_null() {
            return -(1 as libc::c_int);
        }
    }
    *pbuf = new_buf;
    *psize = new_size;
    return 0 as libc::c_int;
}
unsafe extern "C" fn parse_ident(
    mut s: *mut JSParseState,
    mut pp: *mut *const uint8_t,
    mut pident_has_escape: *mut BOOL,
    mut c: libc::c_int,
    mut is_private: BOOL,
) -> JSAtom {
    let mut current_block: u64;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut p1: *const uint8_t = 0 as *const uint8_t;
    let mut ident_buf: [libc::c_char; 128] = [0; 128];
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ident_size: size_t = 0;
    let mut ident_pos: size_t = 0;
    let mut atom: JSAtom = 0;
    p = *pp;
    buf = ident_buf.as_mut_ptr();
    ident_size = ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong;
    ident_pos = 0 as libc::c_int as size_t;
    if is_private != 0 {
        let fresh389 = ident_pos;
        ident_pos = ident_pos.wrapping_add(1);
        *buf.offset(fresh389 as isize) = '#' as i32 as libc::c_char;
    }
    loop {
        p1 = p;
        if c < 128 as libc::c_int {
            let fresh390 = ident_pos;
            ident_pos = ident_pos.wrapping_add(1);
            *buf.offset(fresh390 as isize) = c as libc::c_char;
        } else {
            ident_pos = (ident_pos as libc::c_ulong)
                .wrapping_add(
                    unicode_to_utf8(
                        (buf as *mut uint8_t).offset(ident_pos as isize),
                        c as libc::c_uint,
                    ) as libc::c_ulong,
                ) as size_t as size_t;
        }
        let fresh391 = p1;
        p1 = p1.offset(1);
        c = *fresh391 as libc::c_int;
        if c == '\\' as i32 && *p1 as libc::c_int == 'u' as i32 {
            c = lre_parse_escape(&mut p1, TRUE as libc::c_int);
            *pident_has_escape = TRUE as libc::c_int;
        } else if c >= 128 as libc::c_int {
            c = unicode_from_utf8(p, 6 as libc::c_int, &mut p1);
        }
        if lre_js_is_ident_next(c) == 0 {
            current_block = 14648156034262866959;
            break;
        }
        p = p1;
        if !((ident_pos >= ident_size.wrapping_sub(6 as libc::c_int as libc::c_ulong))
            as libc::c_int as libc::c_long != 0)
        {
            continue;
        }
        if !(ident_realloc((*s).ctx, &mut buf, &mut ident_size, ident_buf.as_mut_ptr())
            != 0)
        {
            continue;
        }
        atom = 0 as libc::c_int as JSAtom;
        current_block = 16103534968090058592;
        break;
    }
    match current_block {
        14648156034262866959 => {
            atom = JS_NewAtomLen((*s).ctx, buf, ident_pos);
        }
        _ => {}
    }
    if (buf != ident_buf.as_mut_ptr()) as libc::c_int as libc::c_long != 0 {
        js_free((*s).ctx, buf as *mut libc::c_void);
    }
    *pp = p;
    return atom;
}
unsafe extern "C" fn next_token(mut s: *mut JSParseState) -> libc::c_int {
    let mut p1_0: *const uint8_t = 0 as *const uint8_t;
    let mut current_block: u64;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut c: libc::c_int = 0;
    let mut ident_has_escape: BOOL = 0;
    let mut atom: JSAtom = 0;
    if js_check_stack_overflow((*(*s).ctx).rt, 0 as libc::c_int as size_t) != 0 {
        return js_parse_error(
            s,
            b"stack overflow\0" as *const u8 as *const libc::c_char,
        );
    }
    free_token(s, &mut (*s).token);
    let ref mut fresh392 = (*s).last_ptr;
    *fresh392 = (*s).buf_ptr;
    p = *fresh392;
    (*s).got_lf = FALSE as libc::c_int;
    (*s).last_line_num = (*s).token.line_num;
    'c_159909: loop {
        (*s).token.line_num = (*s).line_num;
        let ref mut fresh393 = (*s).token.ptr;
        *fresh393 = p;
        c = *p as libc::c_int;
        match c {
            0 => {
                if p >= (*s).buf_end {
                    current_block = 7651349459974463963;
                    break;
                } else {
                    current_block = 17450980188836454259;
                    break;
                }
            }
            96 => {
                if js_parse_template_part(s, p.offset(1 as libc::c_int as isize)) != 0 {
                    current_block = 16877590373229154819;
                    break;
                } else {
                    current_block = 15652330335145281839;
                    break;
                }
            }
            39 | 34 => {
                if js_parse_string(
                    s,
                    c,
                    TRUE as libc::c_int,
                    p.offset(1 as libc::c_int as isize),
                    &mut (*s).token,
                    &mut p,
                ) != 0
                {
                    current_block = 16877590373229154819;
                    break;
                } else {
                    current_block = 3753929071732272283;
                    break;
                }
            }
            13 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '\n' as i32 {
                    p = p.offset(1);
                }
                current_block = 15355034138431462858;
            }
            10 => {
                current_block = 15355034138431462858;
            }
            12 | 11 | 32 | 9 => {
                p = p.offset(1);
                continue;
            }
            47 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '*' as i32 {
                    p = p.offset(2 as libc::c_int as isize);
                    loop {
                        if *p as libc::c_int == '\0' as i32 && p >= (*s).buf_end {
                            js_parse_error(
                                s,
                                b"unexpected end of comment\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 16877590373229154819;
                            break 'c_159909;
                        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int
                            == '*' as i32
                            && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                == '/' as i32
                        {
                            p = p.offset(2 as libc::c_int as isize);
                            continue 'c_159909;
                        } else if *p as libc::c_int == '\n' as i32 {
                            let ref mut fresh395 = (*s).line_num;
                            *fresh395 += 1;
                            (*s).got_lf = TRUE as libc::c_int;
                            p = p.offset(1);
                        } else if *p as libc::c_int == '\r' as i32 {
                            (*s).got_lf = TRUE as libc::c_int;
                            p = p.offset(1);
                        } else if *p as libc::c_int >= 0x80 as libc::c_int {
                            c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                            if c == 0x2028 as libc::c_int || c == 0x2029 as libc::c_int {
                                (*s).got_lf = TRUE as libc::c_int;
                            } else if c == -(1 as libc::c_int) {
                                p = p.offset(1);
                            }
                        } else {
                            p = p.offset(1);
                        }
                    }
                } else if *p.offset(1 as libc::c_int as isize) as libc::c_int
                    == '/' as i32
                {
                    p = p.offset(2 as libc::c_int as isize);
                } else {
                    if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32
                    {
                        p = p.offset(2 as libc::c_int as isize);
                        (*s).token.val = TOK_DIV_ASSIGN as libc::c_int;
                    } else {
                        p = p.offset(1);
                        (*s).token.val = c;
                    }
                    current_block = 3753929071732272283;
                    break;
                }
                current_block = 9620089732919554428;
            }
            92 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == 'u' as i32 {
                    current_block = 14648606000749551097;
                    break;
                } else {
                    current_block = 17450980188836454259;
                    break;
                }
            }
            97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109
            | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122
            | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79
            | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 95 | 36 => {
                p = p.offset(1);
                ident_has_escape = FALSE as libc::c_int;
                current_block = 503680836705688874;
                break;
            }
            35 => {
                p1_0 = 0 as *const uint8_t;
                p = p.offset(1);
                p1_0 = p;
                let fresh396 = p1_0;
                p1_0 = p1_0.offset(1);
                c = *fresh396 as libc::c_int;
                if c == '\\' as i32 && *p1_0 as libc::c_int == 'u' as i32 {
                    c = lre_parse_escape(&mut p1_0, TRUE as libc::c_int);
                } else if c >= 128 as libc::c_int {
                    c = unicode_from_utf8(p, 6 as libc::c_int, &mut p1_0);
                }
                if lre_js_is_ident_first(c) == 0 {
                    current_block = 18221534353613080499;
                    break;
                } else {
                    current_block = 9838996637140935403;
                    break;
                }
            }
            46 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
                    && *p.offset(2 as libc::c_int as isize) as libc::c_int == '.' as i32
                {
                    current_block = 14954430942378083783;
                    break;
                } else {
                    current_block = 5832582820025303349;
                    break;
                }
            }
            48 => {
                if is_digit(*p.offset(1 as libc::c_int as isize) as libc::c_int) != 0
                    && (*(*s).cur_func).js_mode as libc::c_int
                        & (1 as libc::c_int) << 0 as libc::c_int != 0
                {
                    current_block = 10265166559088591044;
                    break;
                } else {
                    current_block = 15514437232607373049;
                    break;
                }
            }
            49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                current_block = 15514437232607373049;
                break;
            }
            42 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 2885804587290726961;
                    break;
                } else {
                    current_block = 2408932541243239002;
                    break;
                }
            }
            37 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 2920409193602730479;
                    break;
                } else {
                    current_block = 17450980188836454259;
                    break;
                }
            }
            43 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 3620302738604709257;
                    break;
                } else {
                    current_block = 12717620301112128284;
                    break;
                }
            }
            45 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_MINUS_ASSIGN as libc::c_int;
                    current_block = 3753929071732272283;
                    break;
                } else {
                    if !(*p.offset(1 as libc::c_int as isize) as libc::c_int
                        == '-' as i32)
                    {
                        current_block = 17450980188836454259;
                        break;
                    }
                    if !((*s).allow_html_comments != 0
                        && *p.offset(2 as libc::c_int as isize) as libc::c_int
                            == '>' as i32 && (*s).last_line_num != (*s).line_num)
                    {
                        p = p.offset(2 as libc::c_int as isize);
                        (*s).token.val = TOK_DEC as libc::c_int;
                        current_block = 3753929071732272283;
                        break;
                    }
                }
                current_block = 9620089732919554428;
            }
            60 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_LTE as libc::c_int;
                    current_block = 3753929071732272283;
                    break;
                } else if *p.offset(1 as libc::c_int as isize) as libc::c_int
                    == '<' as i32
                {
                    if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32
                    {
                        p = p.offset(3 as libc::c_int as isize);
                        (*s).token.val = TOK_SHL_ASSIGN as libc::c_int;
                    } else {
                        p = p.offset(2 as libc::c_int as isize);
                        (*s).token.val = TOK_SHL as libc::c_int;
                    }
                    current_block = 3753929071732272283;
                    break;
                } else if !((*s).allow_html_comments != 0
                    && *p.offset(1 as libc::c_int as isize) as libc::c_int == '!' as i32
                    && *p.offset(2 as libc::c_int as isize) as libc::c_int == '-' as i32
                    && *p.offset(3 as libc::c_int as isize) as libc::c_int == '-' as i32)
                {
                    current_block = 17450980188836454259;
                    break;
                }
                current_block = 9620089732919554428;
            }
            62 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 2311897482351547615;
                    break;
                } else {
                    current_block = 10644040035716118461;
                    break;
                }
            }
            61 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 6744494640291411773;
                    break;
                } else {
                    current_block = 13714309095952152938;
                    break;
                }
            }
            33 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 10632679619850208969;
                    break;
                } else {
                    current_block = 17450980188836454259;
                    break;
                }
            }
            38 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 10408552987007769625;
                    break;
                } else {
                    current_block = 4957587885808349958;
                    break;
                }
            }
            94 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 9040000514319787032;
                    break;
                } else {
                    current_block = 17450980188836454259;
                    break;
                }
            }
            124 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    current_block = 11122898340782283131;
                    break;
                } else {
                    current_block = 13499557289948866384;
                    break;
                }
            }
            63 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '?' as i32 {
                    current_block = 15932507887445511105;
                    break;
                } else {
                    current_block = 17854146808697783763;
                    break;
                }
            }
            _ => {
                if !(c >= 128 as libc::c_int) {
                    current_block = 17450980188836454259;
                    break;
                }
                c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                match c {
                    8233 | 8232 => {
                        current_block = 13862205738381496436;
                    }
                    _ => {
                        if lre_is_space(c) != 0 {
                            continue;
                        }
                        if lre_js_is_ident_first(c) != 0 {
                            current_block = 7499465236084769340;
                            break;
                        } else {
                            current_block = 9657238515557273331;
                            break;
                        }
                    }
                }
            }
        }
        match current_block {
            15355034138431462858 => {
                p = p.offset(1);
            }
            9620089732919554428 => {
                while !(*p as libc::c_int == '\0' as i32 && p >= (*s).buf_end) {
                    if *p as libc::c_int == '\r' as i32
                        || *p as libc::c_int == '\n' as i32
                    {
                        break;
                    }
                    if *p as libc::c_int >= 0x80 as libc::c_int {
                        c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                        if c == 0x2028 as libc::c_int || c == 0x2029 as libc::c_int {
                            break;
                        }
                        if c == -(1 as libc::c_int) {
                            p = p.offset(1);
                        }
                    } else {
                        p = p.offset(1);
                    }
                }
                continue;
            }
            _ => {}
        }
        (*s).got_lf = TRUE as libc::c_int;
        let ref mut fresh394 = (*s).line_num;
        *fresh394 += 1;
    }
    match current_block {
        2408932541243239002 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '*' as i32 {
                if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    p = p.offset(3 as libc::c_int as isize);
                    (*s).token.val = TOK_POW_ASSIGN as libc::c_int;
                } else {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_POW as libc::c_int;
                }
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        14954430942378083783 => {
            p = p.offset(3 as libc::c_int as isize);
            (*s).token.val = TOK_ELLIPSIS as libc::c_int;
            current_block = 3753929071732272283;
        }
        9838996637140935403 => {
            p = p1_0;
            ident_has_escape = FALSE as libc::c_int;
            atom = parse_ident(s, &mut p, &mut ident_has_escape, c, TRUE as libc::c_int);
            if atom == 0 as libc::c_int as libc::c_uint {
                current_block = 16877590373229154819;
            } else {
                (*s).token.u.ident.atom = atom;
                (*s).token.val = TOK_PRIVATE_NAME as libc::c_int;
                current_block = 3753929071732272283;
            }
        }
        4957587885808349958 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '&' as i32 {
                if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    p = p.offset(3 as libc::c_int as isize);
                    (*s).token.val = TOK_LAND_ASSIGN as libc::c_int;
                } else {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_LAND as libc::c_int;
                }
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        10644040035716118461 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '>' as i32 {
                if *p.offset(2 as libc::c_int as isize) as libc::c_int == '>' as i32 {
                    if *p.offset(3 as libc::c_int as isize) as libc::c_int == '=' as i32
                    {
                        p = p.offset(4 as libc::c_int as isize);
                        (*s).token.val = TOK_SHR_ASSIGN as libc::c_int;
                    } else {
                        p = p.offset(3 as libc::c_int as isize);
                        (*s).token.val = TOK_SHR as libc::c_int;
                    }
                } else if *p.offset(2 as libc::c_int as isize) as libc::c_int
                    == '=' as i32
                {
                    p = p.offset(3 as libc::c_int as isize);
                    (*s).token.val = TOK_SAR_ASSIGN as libc::c_int;
                } else {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_SAR as libc::c_int;
                }
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        13499557289948866384 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '|' as i32 {
                if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                    p = p.offset(3 as libc::c_int as isize);
                    (*s).token.val = TOK_LOR_ASSIGN as libc::c_int;
                } else {
                    p = p.offset(2 as libc::c_int as isize);
                    (*s).token.val = TOK_LOR as libc::c_int;
                }
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        14648606000749551097 => {
            let mut p1: *const uint8_t = p.offset(1 as libc::c_int as isize);
            let mut c1: libc::c_int = lre_parse_escape(&mut p1, TRUE as libc::c_int);
            if c1 >= 0 as libc::c_int && lre_js_is_ident_first(c1) != 0 {
                c = c1;
                p = p1;
                ident_has_escape = TRUE as libc::c_int;
                current_block = 503680836705688874;
            } else {
                current_block = 17450980188836454259;
            }
        }
        13714309095952152938 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '>' as i32 {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_ARROW as libc::c_int;
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        12717620301112128284 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '+' as i32 {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_INC as libc::c_int;
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        17854146808697783763 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
                && !(*p.offset(2 as libc::c_int as isize) as libc::c_int >= '0' as i32
                    && *p.offset(2 as libc::c_int as isize) as libc::c_int <= '9' as i32)
            {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_QUESTION_MARK_DOT as libc::c_int;
                current_block = 3753929071732272283;
            } else {
                current_block = 17450980188836454259;
            }
        }
        3620302738604709257 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_PLUS_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        7651349459974463963 => {
            (*s).token.val = TOK_EOF as libc::c_int;
            current_block = 3753929071732272283;
        }
        15652330335145281839 => {
            p = (*s).buf_ptr;
            current_block = 3753929071732272283;
        }
        5832582820025303349 => {
            if *p.offset(1 as libc::c_int as isize) as libc::c_int >= '0' as i32
                && *p.offset(1 as libc::c_int as isize) as libc::c_int <= '9' as i32
            {
                current_block = 15514437232607373049;
            } else {
                current_block = 17450980188836454259;
            }
        }
        10265166559088591044 => {
            js_parse_error(
                s,
                b"octal literals are deprecated in strict mode\0" as *const u8
                    as *const libc::c_char,
            );
            current_block = 16877590373229154819;
        }
        2920409193602730479 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_MOD_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        10632679619850208969 => {
            if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                p = p.offset(3 as libc::c_int as isize);
                (*s).token.val = TOK_STRICT_NEQ as libc::c_int;
            } else {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_NEQ as libc::c_int;
            }
            current_block = 3753929071732272283;
        }
        9040000514319787032 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_XOR_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        15932507887445511105 => {
            if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                p = p.offset(3 as libc::c_int as isize);
                (*s).token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN as libc::c_int;
            } else {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_DOUBLE_QUESTION_MARK as libc::c_int;
            }
            current_block = 3753929071732272283;
        }
        11122898340782283131 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_OR_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        10408552987007769625 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_AND_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        6744494640291411773 => {
            if *p.offset(2 as libc::c_int as isize) as libc::c_int == '=' as i32 {
                p = p.offset(3 as libc::c_int as isize);
                (*s).token.val = TOK_STRICT_EQ as libc::c_int;
            } else {
                p = p.offset(2 as libc::c_int as isize);
                (*s).token.val = TOK_EQ as libc::c_int;
            }
            current_block = 3753929071732272283;
        }
        2311897482351547615 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_GTE as libc::c_int;
            current_block = 3753929071732272283;
        }
        18221534353613080499 => {
            js_parse_error(
                s,
                b"invalid first character of private name\0" as *const u8
                    as *const libc::c_char,
            );
            current_block = 16877590373229154819;
        }
        2885804587290726961 => {
            p = p.offset(2 as libc::c_int as isize);
            (*s).token.val = TOK_MUL_ASSIGN as libc::c_int;
            current_block = 3753929071732272283;
        }
        7499465236084769340 => {
            ident_has_escape = FALSE as libc::c_int;
            current_block = 503680836705688874;
        }
        9657238515557273331 => {
            js_parse_error(
                s,
                b"unexpected character\0" as *const u8 as *const libc::c_char,
            );
            current_block = 16877590373229154819;
        }
        _ => {}
    }
    match current_block {
        15514437232607373049 => {
            let mut ret: JSValue = 0;
            let mut p1_1: *const uint8_t = 0 as *const uint8_t;
            let mut flags: libc::c_int = 0;
            let mut radix: libc::c_int = 0;
            flags = (1 as libc::c_int) << 2 as libc::c_int
                | (1 as libc::c_int) << 4 as libc::c_int
                | (1 as libc::c_int) << 5 as libc::c_int;
            radix = 0 as libc::c_int;
            ret = js_atof(
                (*s).ctx,
                p as *const libc::c_char,
                &mut p as *mut *const uint8_t as *mut *const libc::c_char,
                radix,
                flags,
            );
            if JS_IsException(ret) != 0 {
                current_block = 16877590373229154819;
            } else if JS_VALUE_IS_NAN(ret) != 0
                || lre_js_is_ident_next(
                    unicode_from_utf8(p, 6 as libc::c_int, &mut p1_1),
                ) != 0
            {
                JS_FreeValue((*s).ctx, ret);
                js_parse_error(
                    s,
                    b"invalid number literal\0" as *const u8 as *const libc::c_char,
                );
                current_block = 16877590373229154819;
            } else {
                (*s).token.val = TOK_NUMBER as libc::c_int;
                (*s).token.u.num.val = ret;
                current_block = 3753929071732272283;
            }
        }
        503680836705688874 => {
            atom = parse_ident(
                s,
                &mut p,
                &mut ident_has_escape,
                c,
                FALSE as libc::c_int,
            );
            if atom == 0 as libc::c_int as libc::c_uint {
                current_block = 16877590373229154819;
            } else {
                (*s).token.u.ident.atom = atom;
                (*s).token.u.ident.has_escape = ident_has_escape;
                (*s).token.u.ident.is_reserved = FALSE as libc::c_int;
                if (*s).token.u.ident.atom
                    <= JS_ATOM_super as libc::c_int as libc::c_uint
                    || (*s).token.u.ident.atom
                        <= JS_ATOM_yield as libc::c_int as libc::c_uint
                        && (*(*s).cur_func).js_mode as libc::c_int
                            & (1 as libc::c_int) << 0 as libc::c_int != 0
                    || (*s).token.u.ident.atom
                        == JS_ATOM_yield as libc::c_int as libc::c_uint
                        && ((*(*s).cur_func).func_kind() as libc::c_int
                            & JS_FUNC_GENERATOR as libc::c_int != 0
                            || (*(*s).cur_func).func_type() as libc::c_int
                                == JS_PARSE_FUNC_ARROW as libc::c_int
                                && (*(*s).cur_func).in_function_body == 0
                                && !((*(*s).cur_func).parent).is_null()
                                && (*(*(*s).cur_func).parent).func_kind() as libc::c_int
                                    & JS_FUNC_GENERATOR as libc::c_int != 0)
                    || (*s).token.u.ident.atom
                        == JS_ATOM_await as libc::c_int as libc::c_uint
                        && ((*s).is_module != 0
                            || ((*(*s).cur_func).func_kind() as libc::c_int
                                & JS_FUNC_ASYNC as libc::c_int != 0
                                || (*(*s).cur_func).func_type() as libc::c_int
                                    == JS_PARSE_FUNC_ARROW as libc::c_int
                                    && (*(*s).cur_func).in_function_body == 0
                                    && !((*(*s).cur_func).parent).is_null()
                                    && (*(*(*s).cur_func).parent).func_kind() as libc::c_int
                                        & JS_FUNC_ASYNC as libc::c_int != 0))
                {
                    if ident_has_escape != 0 {
                        (*s).token.u.ident.is_reserved = TRUE as libc::c_int;
                        (*s).token.val = TOK_IDENT as libc::c_int;
                    } else {
                        (*s)
                            .token
                            .val = ((*s).token.u.ident.atom)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            .wrapping_add(TOK_NULL as libc::c_int as libc::c_uint)
                            as libc::c_int;
                    }
                } else {
                    (*s).token.val = TOK_IDENT as libc::c_int;
                }
                current_block = 3753929071732272283;
            }
        }
        17450980188836454259 => {
            (*s).token.val = c;
            p = p.offset(1);
            current_block = 3753929071732272283;
        }
        _ => {}
    }
    match current_block {
        16877590373229154819 => {
            (*s).token.val = TOK_ERROR as libc::c_int;
            return -(1 as libc::c_int);
        }
        _ => {
            let ref mut fresh397 = (*s).buf_ptr;
            *fresh397 = p;
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn json_parse_ident(
    mut s: *mut JSParseState,
    mut pp: *mut *const uint8_t,
    mut c: libc::c_int,
) -> JSAtom {
    let mut current_block: u64;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut ident_buf: [libc::c_char; 128] = [0; 128];
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ident_size: size_t = 0;
    let mut ident_pos: size_t = 0;
    let mut atom: JSAtom = 0;
    p = *pp;
    buf = ident_buf.as_mut_ptr();
    ident_size = ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong;
    ident_pos = 0 as libc::c_int as size_t;
    loop {
        let fresh398 = ident_pos;
        ident_pos = ident_pos.wrapping_add(1);
        *buf.offset(fresh398 as isize) = c as libc::c_char;
        c = *p as libc::c_int;
        if c >= 128 as libc::c_int
            || lre_id_continue_table_ascii[(c >> 5 as libc::c_int) as usize]
                >> (c & 31 as libc::c_int) & 1 as libc::c_int as libc::c_uint == 0
        {
            current_block = 9606288038608642794;
            break;
        }
        p = p.offset(1);
        if !((ident_pos >= ident_size.wrapping_sub(6 as libc::c_int as libc::c_ulong))
            as libc::c_int as libc::c_long != 0)
        {
            continue;
        }
        if !(ident_realloc((*s).ctx, &mut buf, &mut ident_size, ident_buf.as_mut_ptr())
            != 0)
        {
            continue;
        }
        atom = 0 as libc::c_int as JSAtom;
        current_block = 15458509886173859790;
        break;
    }
    match current_block {
        9606288038608642794 => {
            atom = JS_NewAtomLen((*s).ctx, buf, ident_pos);
        }
        _ => {}
    }
    if (buf != ident_buf.as_mut_ptr()) as libc::c_int as libc::c_long != 0 {
        js_free((*s).ctx, buf as *mut libc::c_void);
    }
    *pp = p;
    return atom;
}
unsafe extern "C" fn json_next_token(mut s: *mut JSParseState) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut c: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    if js_check_stack_overflow((*(*s).ctx).rt, 0 as libc::c_int as size_t) != 0 {
        return js_parse_error(
            s,
            b"stack overflow\0" as *const u8 as *const libc::c_char,
        );
    }
    free_token(s, &mut (*s).token);
    let ref mut fresh399 = (*s).last_ptr;
    *fresh399 = (*s).buf_ptr;
    p = *fresh399;
    (*s).last_line_num = (*s).token.line_num;
    'c_128055: loop {
        (*s).token.line_num = (*s).line_num;
        let ref mut fresh400 = (*s).token.ptr;
        *fresh400 = p;
        c = *p as libc::c_int;
        match c {
            0 => {
                if p >= (*s).buf_end {
                    current_block = 2868539653012386629;
                    break;
                } else {
                    current_block = 5730379069162008387;
                    break;
                }
            }
            39 => {
                if (*s).ext_json == 0 {
                    current_block = 7976072742316086414;
                    break;
                } else {
                    current_block = 10393212170080605018;
                    break;
                }
            }
            34 => {
                current_block = 10393212170080605018;
                break;
            }
            13 => {
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '\n' as i32 {
                    p = p.offset(1);
                }
                current_block = 1475166657217250550;
            }
            10 => {
                current_block = 1475166657217250550;
            }
            12 | 11 => {
                if (*s).ext_json == 0 {
                    current_block = 5730379069162008387;
                    break;
                } else {
                    current_block = 5688493161488778490;
                }
            }
            32 | 9 => {
                current_block = 5688493161488778490;
            }
            47 => {
                if (*s).ext_json == 0 {
                    current_block = 5730379069162008387;
                    break;
                }
                if *p.offset(1 as libc::c_int as isize) as libc::c_int == '*' as i32 {
                    p = p.offset(2 as libc::c_int as isize);
                    loop {
                        if *p as libc::c_int == '\0' as i32 && p >= (*s).buf_end {
                            js_parse_error(
                                s,
                                b"unexpected end of comment\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 18049606740653047821;
                            break 'c_128055;
                        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int
                            == '*' as i32
                            && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                == '/' as i32
                        {
                            p = p.offset(2 as libc::c_int as isize);
                            continue 'c_128055;
                        } else if *p as libc::c_int == '\n' as i32 {
                            let ref mut fresh402 = (*s).line_num;
                            *fresh402 += 1;
                            p = p.offset(1);
                        } else if *p as libc::c_int == '\r' as i32 {
                            p = p.offset(1);
                        } else if *p as libc::c_int >= 0x80 as libc::c_int {
                            c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                            if c == -(1 as libc::c_int) {
                                p = p.offset(1);
                            }
                        } else {
                            p = p.offset(1);
                        }
                    }
                } else {
                    if !(*p.offset(1 as libc::c_int as isize) as libc::c_int
                        == '/' as i32)
                    {
                        current_block = 5730379069162008387;
                        break;
                    }
                    p = p.offset(2 as libc::c_int as isize);
                    while !(*p as libc::c_int == '\0' as i32 && p >= (*s).buf_end) {
                        if *p as libc::c_int == '\r' as i32
                            || *p as libc::c_int == '\n' as i32
                        {
                            break;
                        }
                        if *p as libc::c_int >= 0x80 as libc::c_int {
                            c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                            if c == 0x2028 as libc::c_int || c == 0x2029 as libc::c_int {
                                break;
                            }
                            if c == -(1 as libc::c_int) {
                                p = p.offset(1);
                            }
                        } else {
                            p = p.offset(1);
                        }
                    }
                    continue;
                }
            }
            97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109
            | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122
            | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79
            | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 95 | 36 => {
                p = p.offset(1);
                atom = json_parse_ident(s, &mut p, c);
                if atom == 0 as libc::c_int as libc::c_uint {
                    current_block = 18049606740653047821;
                    break;
                } else {
                    current_block = 16463303006880176998;
                    break;
                }
            }
            43 => {
                if (*s).ext_json == 0
                    || is_digit(*p.offset(1 as libc::c_int as isize) as libc::c_int) == 0
                {
                    current_block = 5730379069162008387;
                    break;
                } else {
                    current_block = 3024367268842933116;
                    break;
                }
            }
            48 => {
                if is_digit(*p.offset(1 as libc::c_int as isize) as libc::c_int) != 0 {
                    current_block = 5730379069162008387;
                    break;
                } else {
                    current_block = 3024367268842933116;
                    break;
                }
            }
            45 => {
                if is_digit(*p.offset(1 as libc::c_int as isize) as libc::c_int) == 0 {
                    current_block = 5730379069162008387;
                    break;
                } else {
                    current_block = 3024367268842933116;
                    break;
                }
            }
            49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                current_block = 3024367268842933116;
                break;
            }
            _ => {
                if c >= 128 as libc::c_int {
                    current_block = 1930794479672247912;
                    break;
                } else {
                    current_block = 5730379069162008387;
                    break;
                }
            }
        }
        match current_block {
            5688493161488778490 => {
                p = p.offset(1);
            }
            _ => {
                p = p.offset(1);
                let ref mut fresh401 = (*s).line_num;
                *fresh401 += 1;
            }
        }
    }
    match current_block {
        16463303006880176998 => {
            (*s).token.u.ident.atom = atom;
            (*s).token.u.ident.has_escape = FALSE as libc::c_int;
            (*s).token.u.ident.is_reserved = FALSE as libc::c_int;
            (*s).token.val = TOK_IDENT as libc::c_int;
            current_block = 2222055338596505704;
        }
        3024367268842933116 => {
            let mut ret: JSValue = 0;
            let mut flags: libc::c_int = 0;
            let mut radix: libc::c_int = 0;
            if (*s).ext_json == 0 {
                flags = 0 as libc::c_int;
                radix = 10 as libc::c_int;
            } else {
                flags = (1 as libc::c_int) << 2 as libc::c_int;
                radix = 0 as libc::c_int;
            }
            ret = js_atof(
                (*s).ctx,
                p as *const libc::c_char,
                &mut p as *mut *const uint8_t as *mut *const libc::c_char,
                radix,
                flags,
            );
            if JS_IsException(ret) != 0 {
                current_block = 18049606740653047821;
            } else {
                (*s).token.val = TOK_NUMBER as libc::c_int;
                (*s).token.u.num.val = ret;
                current_block = 2222055338596505704;
            }
        }
        1930794479672247912 => {
            js_parse_error(
                s,
                b"unexpected character\0" as *const u8 as *const libc::c_char,
            );
            current_block = 18049606740653047821;
        }
        2868539653012386629 => {
            (*s).token.val = TOK_EOF as libc::c_int;
            current_block = 2222055338596505704;
        }
        10393212170080605018 => {
            if js_parse_string(
                s,
                c,
                TRUE as libc::c_int,
                p.offset(1 as libc::c_int as isize),
                &mut (*s).token,
                &mut p,
            ) != 0
            {
                current_block = 18049606740653047821;
            } else {
                current_block = 2222055338596505704;
            }
        }
        7976072742316086414 => {
            current_block = 5730379069162008387;
        }
        _ => {}
    }
    match current_block {
        5730379069162008387 => {
            (*s).token.val = c;
            p = p.offset(1);
        }
        18049606740653047821 => {
            (*s).token.val = TOK_ERROR as libc::c_int;
            return -(1 as libc::c_int);
        }
        _ => {}
    }
    let ref mut fresh403 = (*s).buf_ptr;
    *fresh403 = p;
    return 0 as libc::c_int;
}
unsafe extern "C" fn simple_next_token(
    mut pp: *mut *const uint8_t,
    mut no_line_terminator: BOOL,
) -> libc::c_int {
    let mut p: *const uint8_t = 0 as *const uint8_t;
    let mut c: uint32_t = 0;
    p = *pp;
    loop {
        let fresh404 = p;
        p = p.offset(1);
        c = *fresh404 as uint32_t;
        match c {
            13 | 10 => {
                if no_line_terminator != 0 {
                    return '\n' as i32;
                }
                continue;
            }
            32 | 9 | 11 | 12 => {
                continue;
            }
            47 => {
                if *p as libc::c_int == '/' as i32 {
                    if no_line_terminator != 0 {
                        return '\n' as i32;
                    }
                    while *p as libc::c_int != 0 && *p as libc::c_int != '\r' as i32
                        && *p as libc::c_int != '\n' as i32
                    {
                        p = p.offset(1);
                    }
                    continue;
                } else if *p as libc::c_int == '*' as i32 {
                    loop {
                        p = p.offset(1);
                        if !(*p != 0) {
                            break;
                        }
                        if (*p as libc::c_int == '\r' as i32
                            || *p as libc::c_int == '\n' as i32)
                            && no_line_terminator != 0
                        {
                            return '\n' as i32;
                        }
                        if !(*p as libc::c_int == '*' as i32
                            && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                == '/' as i32)
                        {
                            continue;
                        }
                        p = p.offset(2 as libc::c_int as isize);
                        break;
                    }
                    continue;
                }
            }
            61 => {
                if *p as libc::c_int == '>' as i32 {
                    return TOK_ARROW as libc::c_int;
                }
            }
            _ => {
                if lre_js_is_ident_first(c as libc::c_int) != 0 {
                    if c == 'i' as i32 as libc::c_uint {
                        if *p.offset(0 as libc::c_int as isize) as libc::c_int
                            == 'n' as i32
                            && lre_js_is_ident_next(
                                *p.offset(1 as libc::c_int as isize) as libc::c_int,
                            ) == 0
                        {
                            return TOK_IN as libc::c_int;
                        }
                        if *p.offset(0 as libc::c_int as isize) as libc::c_int
                            == 'm' as i32
                            && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                == 'p' as i32
                            && *p.offset(2 as libc::c_int as isize) as libc::c_int
                                == 'o' as i32
                            && *p.offset(3 as libc::c_int as isize) as libc::c_int
                                == 'r' as i32
                            && *p.offset(4 as libc::c_int as isize) as libc::c_int
                                == 't' as i32
                            && lre_js_is_ident_next(
                                *p.offset(5 as libc::c_int as isize) as libc::c_int,
                            ) == 0
                        {
                            *pp = p.offset(5 as libc::c_int as isize);
                            return TOK_IMPORT as libc::c_int;
                        }
                    } else if c == 'o' as i32 as libc::c_uint
                        && *p as libc::c_int == 'f' as i32
                        && lre_js_is_ident_next(
                            *p.offset(1 as libc::c_int as isize) as libc::c_int,
                        ) == 0
                    {
                        return TOK_OF as libc::c_int
                    } else {
                        if c == 'e' as i32 as libc::c_uint
                            && *p.offset(0 as libc::c_int as isize) as libc::c_int
                                == 'x' as i32
                            && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                == 'p' as i32
                            && *p.offset(2 as libc::c_int as isize) as libc::c_int
                                == 'o' as i32
                            && *p.offset(3 as libc::c_int as isize) as libc::c_int
                                == 'r' as i32
                            && *p.offset(4 as libc::c_int as isize) as libc::c_int
                                == 't' as i32
                            && lre_js_is_ident_next(
                                *p.offset(5 as libc::c_int as isize) as libc::c_int,
                            ) == 0
                        {
                            *pp = p.offset(5 as libc::c_int as isize);
                            return TOK_EXPORT as libc::c_int;
                        } else {
                            if c == 'f' as i32 as libc::c_uint
                                && *p.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 'u' as i32
                                && *p.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 'n' as i32
                                && *p.offset(2 as libc::c_int as isize) as libc::c_int
                                    == 'c' as i32
                                && *p.offset(3 as libc::c_int as isize) as libc::c_int
                                    == 't' as i32
                                && *p.offset(4 as libc::c_int as isize) as libc::c_int
                                    == 'i' as i32
                                && *p.offset(5 as libc::c_int as isize) as libc::c_int
                                    == 'o' as i32
                                && *p.offset(6 as libc::c_int as isize) as libc::c_int
                                    == 'n' as i32
                                && lre_js_is_ident_next(
                                    *p.offset(7 as libc::c_int as isize) as libc::c_int,
                                ) == 0
                            {
                                return TOK_FUNCTION as libc::c_int;
                            }
                        }
                    }
                    return TOK_IDENT as libc::c_int;
                }
            }
        }
        return c as libc::c_int;
    };
}
unsafe extern "C" fn peek_token(
    mut s: *mut JSParseState,
    mut no_line_terminator: BOOL,
) -> libc::c_int {
    let mut p: *const uint8_t = (*s).buf_ptr;
    return simple_next_token(&mut p, no_line_terminator);
}
#[no_mangle]
pub unsafe extern "C" fn JS_DetectModule(
    mut input: *const libc::c_char,
    mut input_len: size_t,
) -> libc::c_int {
    let mut p: *const uint8_t = input as *const uint8_t;
    let mut tok: libc::c_int = 0;
    match simple_next_token(&mut p, FALSE as libc::c_int) {
        -51 => {
            tok = simple_next_token(&mut p, FALSE as libc::c_int);
            return (tok != '.' as i32 && tok != '(' as i32) as libc::c_int;
        }
        -53 => return TRUE as libc::c_int,
        _ => return FALSE as libc::c_int,
    };
}
#[inline]
unsafe extern "C" fn get_prev_opcode(mut fd: *mut JSFunctionDef) -> libc::c_int {
    if (*fd).last_opcode_pos < 0 as libc::c_int {
        return OP_invalid as libc::c_int
    } else {
        return *((*fd).byte_code.buf).offset((*fd).last_opcode_pos as isize)
            as libc::c_int
    };
}
unsafe extern "C" fn js_is_live_code(mut s: *mut JSParseState) -> BOOL {
    match get_prev_opcode((*s).cur_func) {
        35 | 37 | 40 | 41 | 46 | 47 | 48 | 107 | 234 | 235 | 110 => {
            return FALSE as libc::c_int;
        }
        _ => return TRUE as libc::c_int,
    };
}
unsafe extern "C" fn emit_u8(mut s: *mut JSParseState, mut val: uint8_t) {
    dbuf_putc(&mut (*(*s).cur_func).byte_code, val);
}
unsafe extern "C" fn emit_u16(mut s: *mut JSParseState, mut val: uint16_t) {
    dbuf_put_u16(&mut (*(*s).cur_func).byte_code, val);
}
unsafe extern "C" fn emit_u32(mut s: *mut JSParseState, mut val: uint32_t) {
    dbuf_put_u32(&mut (*(*s).cur_func).byte_code, val);
}
unsafe extern "C" fn emit_op(mut s: *mut JSParseState, mut val: uint8_t) {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut bc: *mut DynBuf = &mut (*fd).byte_code;
    if ((*fd).last_opcode_line_num != (*s).last_line_num) as libc::c_int as libc::c_long
        != 0
    {
        dbuf_putc(bc, OP_line_num as libc::c_int as uint8_t);
        dbuf_put_u32(bc, (*s).last_line_num as uint32_t);
        (*fd).last_opcode_line_num = (*s).last_line_num;
    }
    (*fd).last_opcode_pos = (*bc).size as libc::c_int;
    dbuf_putc(bc, val);
}
unsafe extern "C" fn emit_atom(mut s: *mut JSParseState, mut name: JSAtom) {
    emit_u32(s, JS_DupAtom((*s).ctx, name));
}
unsafe extern "C" fn update_label(
    mut s: *mut JSFunctionDef,
    mut label: libc::c_int,
    mut delta: libc::c_int,
) -> libc::c_int {
    let mut ls: *mut LabelSlot = 0 as *mut LabelSlot;
    assert((label >= 0 as libc::c_int && label < (*s).label_count) as libc::c_int);
    ls = &mut *((*s).label_slots).offset(label as isize) as *mut LabelSlot;
    (*ls).ref_count += delta;
    assert(((*ls).ref_count >= 0 as libc::c_int) as libc::c_int);
    return (*ls).ref_count;
}
unsafe extern "C" fn new_label_fd(
    mut fd: *mut JSFunctionDef,
    mut label: libc::c_int,
) -> libc::c_int {
    let mut ls: *mut LabelSlot = 0 as *mut LabelSlot;
    if label < 0 as libc::c_int {
        if js_resize_array(
            (*fd).ctx,
            &mut (*fd).label_slots as *mut *mut LabelSlot as *mut libc::c_void
                as *mut *mut libc::c_void,
            ::core::mem::size_of::<LabelSlot>() as libc::c_ulong as libc::c_int,
            &mut (*fd).label_size,
            (*fd).label_count + 1 as libc::c_int,
        ) != 0
        {
            return -(1 as libc::c_int);
        }
        let ref mut fresh405 = (*fd).label_count;
        let fresh406 = *fresh405;
        *fresh405 = *fresh405 + 1;
        label = fresh406;
        ls = &mut *((*fd).label_slots).offset(label as isize) as *mut LabelSlot;
        (*ls).ref_count = 0 as libc::c_int;
        (*ls).pos = -(1 as libc::c_int);
        (*ls).pos2 = -(1 as libc::c_int);
        (*ls).addr = -(1 as libc::c_int);
        let ref mut fresh407 = (*ls).first_reloc;
        *fresh407 = 0 as *mut RelocEntry;
    }
    return label;
}
unsafe extern "C" fn new_label(mut s: *mut JSParseState) -> libc::c_int {
    return new_label_fd((*s).cur_func, -(1 as libc::c_int));
}
unsafe extern "C" fn emit_label(
    mut s: *mut JSParseState,
    mut label: libc::c_int,
) -> libc::c_int {
    if label >= 0 as libc::c_int {
        emit_op(s, OP_label as libc::c_int as uint8_t);
        emit_u32(s, label as uint32_t);
        (*((*(*s).cur_func).label_slots).offset(label as isize))
            .pos = (*(*s).cur_func).byte_code.size as libc::c_int;
        return ((*(*s).cur_func).byte_code.size)
            .wrapping_sub(4 as libc::c_int as libc::c_ulong) as libc::c_int;
    } else {
        return -(1 as libc::c_int)
    };
}
unsafe extern "C" fn emit_goto(
    mut s: *mut JSParseState,
    mut opcode: libc::c_int,
    mut label: libc::c_int,
) -> libc::c_int {
    if js_is_live_code(s) != 0 {
        if label < 0 as libc::c_int {
            label = new_label(s);
        }
        emit_op(s, opcode as uint8_t);
        emit_u32(s, label as uint32_t);
        let ref mut fresh408 = (*((*(*s).cur_func).label_slots).offset(label as isize))
            .ref_count;
        *fresh408 += 1;
        return label;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn cpool_add(
    mut s: *mut JSParseState,
    mut val: JSValue,
) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    if js_resize_array(
        (*s).ctx,
        &mut (*fd).cpool as *mut *mut JSValue as *mut libc::c_void
            as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSValue>() as libc::c_ulong as libc::c_int,
        &mut (*fd).cpool_size,
        (*fd).cpool_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh409 = (*fd).cpool_count;
    let fresh410 = *fresh409;
    *fresh409 = *fresh409 + 1;
    *((*fd).cpool).offset(fresh410 as isize) = val;
    return (*fd).cpool_count - 1 as libc::c_int;
}
unsafe extern "C" fn emit_push_const(
    mut s: *mut JSParseState,
    mut val: JSValue,
    mut as_atom: BOOL,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    if (val >> 32 as libc::c_int) as libc::c_int == JS_TAG_STRING as libc::c_int
        && as_atom != 0
    {
        let mut atom: JSAtom = 0;
        JS_DupValue((*s).ctx, val);
        atom = JS_NewAtomStr(
            (*s).ctx,
            val as intptr_t as *mut libc::c_void as *mut JSString,
        );
        if atom != 0 as libc::c_int as libc::c_uint && __JS_AtomIsTaggedInt(atom) == 0 {
            emit_op(s, OP_push_atom_value as libc::c_int as uint8_t);
            emit_u32(s, atom);
            return 0 as libc::c_int;
        }
    }
    idx = cpool_add(s, JS_DupValue((*s).ctx, val));
    if idx < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    emit_op(s, OP_push_const as libc::c_int as uint8_t);
    emit_u32(s, idx as uint32_t);
    return 0 as libc::c_int;
}
unsafe extern "C" fn find_arg(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = (*fd).arg_count;
    loop {
        let fresh411 = i;
        i = i - 1;
        if !(fresh411 > 0 as libc::c_int) {
            break;
        }
        if (*((*fd).args).offset(i as isize)).var_name == name {
            return i | 0x20000000 as libc::c_int;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn find_var(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = (*fd).var_count;
    loop {
        let fresh412 = i;
        i = i - 1;
        if !(fresh412 > 0 as libc::c_int) {
            break;
        }
        if (*((*fd).vars).offset(i as isize)).var_name == name
            && (*((*fd).vars).offset(i as isize)).scope_level == 0 as libc::c_int
        {
            return i;
        }
    }
    return find_arg(ctx, fd, name);
}
unsafe extern "C" fn find_var_in_scope(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut scope_level: libc::c_int,
) -> libc::c_int {
    let mut scope_idx: libc::c_int = 0;
    scope_idx = (*((*fd).scopes).offset(scope_level as isize)).first;
    while scope_idx >= 0 as libc::c_int {
        if (*((*fd).vars).offset(scope_idx as isize)).scope_level != scope_level {
            break;
        }
        if (*((*fd).vars).offset(scope_idx as isize)).var_name == name {
            return scope_idx;
        }
        scope_idx = (*((*fd).vars).offset(scope_idx as isize)).scope_next;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn is_child_scope(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut scope: libc::c_int,
    mut parent_scope: libc::c_int,
) -> BOOL {
    while scope >= 0 as libc::c_int {
        if scope == parent_scope {
            return TRUE as libc::c_int;
        }
        scope = (*((*fd).scopes).offset(scope as isize)).parent;
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn find_var_in_child_scope(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut scope_level: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*fd).var_count {
        let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(i as isize)
            as *mut JSVarDef;
        if (*vd).var_name == name && (*vd).scope_level == 0 as libc::c_int {
            if is_child_scope(ctx, fd, (*vd).scope_next, scope_level) != 0 {
                return i;
            }
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn find_global_var(
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> *mut JSGlobalVar {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*fd).global_var_count {
        let mut hf: *mut JSGlobalVar = &mut *((*fd).global_vars).offset(i as isize)
            as *mut JSGlobalVar;
        if (*hf).var_name == name {
            return hf;
        }
        i += 1;
    }
    return 0 as *mut JSGlobalVar;
}
unsafe extern "C" fn find_lexical_global_var(
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> *mut JSGlobalVar {
    let mut hf: *mut JSGlobalVar = find_global_var(fd, name);
    if !hf.is_null() && (*hf).is_lexical() as libc::c_int != 0 {
        return hf
    } else {
        return 0 as *mut JSGlobalVar
    };
}
unsafe extern "C" fn find_lexical_decl(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut scope_idx: libc::c_int,
    mut check_catch_var: BOOL,
) -> libc::c_int {
    while scope_idx >= 0 as libc::c_int {
        let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(scope_idx as isize)
            as *mut JSVarDef;
        if (*vd).var_name == name
            && ((*vd).is_lexical() as libc::c_int != 0
                || (*vd).var_kind() as libc::c_int == JS_VAR_CATCH as libc::c_int
                    && check_catch_var != 0)
        {
            return scope_idx;
        }
        scope_idx = (*vd).scope_next;
    }
    if (*fd).is_eval != 0 && (*fd).eval_type == (0 as libc::c_int) << 0 as libc::c_int {
        if !(find_lexical_global_var(fd, name)).is_null() {
            return 0x40000000 as libc::c_int;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn push_scope(mut s: *mut JSParseState) -> libc::c_int {
    if !((*s).cur_func).is_null() {
        let mut fd: *mut JSFunctionDef = (*s).cur_func;
        let mut scope: libc::c_int = (*fd).scope_count;
        if (*fd).scope_count + 1 as libc::c_int > (*fd).scope_size {
            let mut new_size: libc::c_int = 0;
            let mut slack: size_t = 0;
            let mut new_buf: *mut JSVarScope = 0 as *mut JSVarScope;
            new_size = max_int(
                (*fd).scope_count + 1 as libc::c_int,
                (*fd).scope_size * 3 as libc::c_int / 2 as libc::c_int,
            );
            if (*fd).scopes == ((*fd).def_scope_array).as_mut_ptr() {
                new_buf = js_realloc2(
                    (*s).ctx,
                    0 as *mut libc::c_void,
                    (new_size as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSVarScope>() as libc::c_ulong,
                        ),
                    &mut slack,
                ) as *mut JSVarScope;
                if new_buf.is_null() {
                    return -(1 as libc::c_int);
                }
                memcpy(
                    new_buf as *mut libc::c_void,
                    (*fd).scopes as *const libc::c_void,
                    ((*fd).scope_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSVarScope>() as libc::c_ulong,
                        ),
                );
            } else {
                new_buf = js_realloc2(
                    (*s).ctx,
                    (*fd).scopes as *mut libc::c_void,
                    (new_size as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<JSVarScope>() as libc::c_ulong,
                        ),
                    &mut slack,
                ) as *mut JSVarScope;
                if new_buf.is_null() {
                    return -(1 as libc::c_int);
                }
            }
            new_size = (new_size as libc::c_ulong)
                .wrapping_add(
                    slack
                        .wrapping_div(
                            ::core::mem::size_of::<JSVarScope>() as libc::c_ulong,
                        ),
                ) as libc::c_int as libc::c_int;
            let ref mut fresh413 = (*fd).scopes;
            *fresh413 = new_buf;
            (*fd).scope_size = new_size;
        }
        let ref mut fresh414 = (*fd).scope_count;
        *fresh414 += 1;
        (*((*fd).scopes).offset(scope as isize)).parent = (*fd).scope_level;
        (*((*fd).scopes).offset(scope as isize)).first = (*fd).scope_first;
        emit_op(s, OP_enter_scope as libc::c_int as uint8_t);
        emit_u16(s, scope as uint16_t);
        let ref mut fresh415 = (*fd).scope_level;
        *fresh415 = scope;
        return *fresh415;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_first_lexical_var(
    mut fd: *mut JSFunctionDef,
    mut scope: libc::c_int,
) -> libc::c_int {
    while scope >= 0 as libc::c_int {
        let mut scope_idx: libc::c_int = (*((*fd).scopes).offset(scope as isize)).first;
        if scope_idx >= 0 as libc::c_int {
            return scope_idx;
        }
        scope = (*((*fd).scopes).offset(scope as isize)).parent;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn pop_scope(mut s: *mut JSParseState) {
    if !((*s).cur_func).is_null() {
        let mut fd: *mut JSFunctionDef = (*s).cur_func;
        let mut scope: libc::c_int = (*fd).scope_level;
        emit_op(s, OP_leave_scope as libc::c_int as uint8_t);
        emit_u16(s, scope as uint16_t);
        (*fd).scope_level = (*((*fd).scopes).offset(scope as isize)).parent;
        (*fd).scope_first = get_first_lexical_var(fd, (*fd).scope_level);
    }
}
unsafe extern "C" fn close_scopes(
    mut s: *mut JSParseState,
    mut scope: libc::c_int,
    mut scope_stop: libc::c_int,
) {
    while scope > scope_stop {
        emit_op(s, OP_leave_scope as libc::c_int as uint8_t);
        emit_u16(s, scope as uint16_t);
        scope = (*((*(*s).cur_func).scopes).offset(scope as isize)).parent;
    }
}
unsafe extern "C" fn add_var(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    if (*fd).var_count >= 65536 as libc::c_int {
        JS_ThrowInternalError(
            ctx,
            b"too many local variables\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if js_resize_array(
        ctx,
        &mut (*fd).vars as *mut *mut JSVarDef as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong as libc::c_int,
        &mut (*fd).var_size,
        (*fd).var_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh416 = (*fd).var_count;
    let fresh417 = *fresh416;
    *fresh416 = *fresh416 + 1;
    vd = &mut *((*fd).vars).offset(fresh417 as isize) as *mut JSVarDef;
    memset(
        vd as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
    );
    (*vd).var_name = JS_DupAtom(ctx, name);
    (*vd).set_func_pool_idx(-(1 as libc::c_int));
    return (*fd).var_count - 1 as libc::c_int;
}
unsafe extern "C" fn add_scope_var(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut var_kind: JSVarKindEnum,
) -> libc::c_int {
    let mut idx: libc::c_int = add_var(ctx, fd, name);
    if idx >= 0 as libc::c_int {
        let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(idx as isize)
            as *mut JSVarDef;
        (*vd).set_var_kind(var_kind as uint8_t);
        (*vd).scope_level = (*fd).scope_level;
        (*vd).scope_next = (*fd).scope_first;
        (*((*fd).scopes).offset((*fd).scope_level as isize)).first = idx;
        (*fd).scope_first = idx;
    }
    return idx;
}
unsafe extern "C" fn add_func_var(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut idx: libc::c_int = (*fd).func_var_idx;
    if idx < 0 as libc::c_int
        && {
            idx = add_var(ctx, fd, name);
            idx >= 0 as libc::c_int
        }
    {
        (*fd).func_var_idx = idx;
        let ref mut fresh418 = *((*fd).vars).offset(idx as isize);
        (*fresh418).set_var_kind(JS_VAR_FUNCTION_NAME as libc::c_int as uint8_t);
        if (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            let ref mut fresh419 = *((*fd).vars).offset(idx as isize);
            (*fresh419).set_is_const(TRUE as libc::c_int as uint8_t);
        }
    }
    return idx;
}
unsafe extern "C" fn add_arguments_var(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) -> libc::c_int {
    let mut idx: libc::c_int = (*fd).arguments_var_idx;
    if idx < 0 as libc::c_int
        && {
            idx = add_var(ctx, fd, JS_ATOM_arguments as libc::c_int as JSAtom);
            idx >= 0 as libc::c_int
        }
    {
        (*fd).arguments_var_idx = idx;
    }
    return idx;
}
unsafe extern "C" fn add_arguments_arg(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    if (*fd).arguments_arg_idx < 0 as libc::c_int {
        idx = find_var_in_scope(
            ctx,
            fd,
            JS_ATOM_arguments as libc::c_int as JSAtom,
            1 as libc::c_int,
        );
        if idx < 0 as libc::c_int {
            idx = add_var(ctx, fd, JS_ATOM_arguments as libc::c_int as JSAtom);
            if idx < 0 as libc::c_int {
                return -(1 as libc::c_int);
            }
            (*((*fd).vars).offset(idx as isize))
                .scope_next = (*((*fd).scopes).offset(1 as libc::c_int as isize)).first;
            (*((*fd).scopes).offset(1 as libc::c_int as isize)).first = idx;
            (*((*fd).vars).offset(idx as isize)).scope_level = 1 as libc::c_int;
            let ref mut fresh420 = *((*fd).vars).offset(idx as isize);
            (*fresh420).set_is_lexical(TRUE as libc::c_int as uint8_t);
            (*fd).arguments_arg_idx = idx;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn add_arg(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    if (*fd).arg_count >= 65536 as libc::c_int {
        JS_ThrowInternalError(
            ctx,
            b"too many arguments\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if js_resize_array(
        ctx,
        &mut (*fd).args as *mut *mut JSVarDef as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong as libc::c_int,
        &mut (*fd).arg_size,
        (*fd).arg_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh421 = (*fd).arg_count;
    let fresh422 = *fresh421;
    *fresh421 = *fresh421 + 1;
    vd = &mut *((*fd).args).offset(fresh422 as isize) as *mut JSVarDef;
    memset(
        vd as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
    );
    (*vd).var_name = JS_DupAtom(ctx, name);
    (*vd).set_func_pool_idx(-(1 as libc::c_int));
    return (*fd).arg_count - 1 as libc::c_int;
}
unsafe extern "C" fn add_global_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut name: JSAtom,
) -> *mut JSGlobalVar {
    let mut hf: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
    if js_resize_array(
        ctx,
        &mut (*s).global_vars as *mut *mut JSGlobalVar as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSGlobalVar>() as libc::c_ulong as libc::c_int,
        &mut (*s).global_var_size,
        (*s).global_var_count + 1 as libc::c_int,
    ) != 0
    {
        return 0 as *mut JSGlobalVar;
    }
    let ref mut fresh423 = (*s).global_var_count;
    let fresh424 = *fresh423;
    *fresh423 = *fresh423 + 1;
    hf = &mut *((*s).global_vars).offset(fresh424 as isize) as *mut JSGlobalVar;
    (*hf).cpool_idx = -(1 as libc::c_int);
    (*hf).set_force_init(FALSE as libc::c_int as uint8_t);
    (*hf).set_is_lexical(FALSE as libc::c_int as uint8_t);
    (*hf).set_is_const(FALSE as libc::c_int as uint8_t);
    (*hf).scope_level = (*s).scope_level;
    (*hf).var_name = JS_DupAtom(ctx, name);
    return hf;
}
unsafe extern "C" fn define_var(
    mut s: *mut JSParseState,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut var_def_type: JSVarDefEnum,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    let mut idx: libc::c_int = 0;
    match var_def_type as libc::c_uint {
        0 => {
            idx = add_scope_var(ctx, fd, name, JS_VAR_NORMAL);
        }
        1 | 2 | 3 | 4 => {
            idx = find_lexical_decl(
                ctx,
                fd,
                name,
                (*fd).scope_first,
                TRUE as libc::c_int,
            );
            if idx >= 0 as libc::c_int {
                if idx < 0x40000000 as libc::c_int {
                    if (*((*fd).vars).offset(idx as isize)).scope_level
                        == (*fd).scope_level
                    {
                        if !((*fd).js_mode as libc::c_int
                            & (1 as libc::c_int) << 0 as libc::c_int == 0
                            && var_def_type as libc::c_uint
                                == JS_VAR_DEF_FUNCTION_DECL as libc::c_int as libc::c_uint
                            && (*((*fd).vars).offset(idx as isize)).var_kind()
                                as libc::c_int == JS_VAR_FUNCTION_DECL as libc::c_int)
                        {
                            current_block = 12602727479402368790;
                        } else {
                            current_block = 8457315219000651999;
                        }
                    } else if (*((*fd).vars).offset(idx as isize)).var_kind()
                        as libc::c_int == JS_VAR_CATCH as libc::c_int
                        && (*((*fd).vars).offset(idx as isize)).scope_level
                            + 2 as libc::c_int == (*fd).scope_level
                    {
                        current_block = 12602727479402368790;
                    } else {
                        current_block = 8457315219000651999;
                    }
                } else if (*fd).scope_level == (*fd).body_scope {
                    current_block = 12602727479402368790;
                } else {
                    current_block = 8457315219000651999;
                }
                match current_block {
                    8457315219000651999 => {}
                    _ => {
                        return js_parse_error(
                            s,
                            b"invalid redefinition of lexical identifier\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            }
            if var_def_type as libc::c_uint
                != JS_VAR_DEF_FUNCTION_DECL as libc::c_int as libc::c_uint
                && var_def_type as libc::c_uint
                    != JS_VAR_DEF_NEW_FUNCTION_DECL as libc::c_int as libc::c_uint
                && (*fd).scope_level == (*fd).body_scope
                && find_arg(ctx, fd, name) >= 0 as libc::c_int
            {
                return js_parse_error(
                    s,
                    b"invalid redefinition of parameter name\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if find_var_in_child_scope(ctx, fd, name, (*fd).scope_level)
                >= 0 as libc::c_int
            {
                return js_parse_error(
                    s,
                    b"invalid redefinition of a variable\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if (*fd).is_global_var != 0 {
                let mut hf: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
                hf = find_global_var(fd, name);
                if !hf.is_null()
                    && is_child_scope(ctx, fd, (*hf).scope_level, (*fd).scope_level) != 0
                {
                    return js_parse_error(
                        s,
                        b"invalid redefinition of global identifier\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            if (*fd).is_eval != 0
                && ((*fd).eval_type == (0 as libc::c_int) << 0 as libc::c_int
                    || (*fd).eval_type == (1 as libc::c_int) << 0 as libc::c_int)
                && (*fd).scope_level == (*fd).body_scope
            {
                let mut hf_0: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
                hf_0 = add_global_var((*s).ctx, fd, name);
                if hf_0.is_null() {
                    return -(1 as libc::c_int);
                }
                (*hf_0).set_is_lexical(TRUE as libc::c_int as uint8_t);
                (*hf_0)
                    .set_is_const(
                        (var_def_type as libc::c_uint
                            == JS_VAR_DEF_CONST as libc::c_int as libc::c_uint)
                            as libc::c_int as uint8_t,
                    );
                idx = 0x40000000 as libc::c_int;
            } else {
                let mut var_kind: JSVarKindEnum = JS_VAR_NORMAL;
                if var_def_type as libc::c_uint
                    == JS_VAR_DEF_FUNCTION_DECL as libc::c_int as libc::c_uint
                {
                    var_kind = JS_VAR_FUNCTION_DECL;
                } else if var_def_type as libc::c_uint
                    == JS_VAR_DEF_NEW_FUNCTION_DECL as libc::c_int as libc::c_uint
                {
                    var_kind = JS_VAR_NEW_FUNCTION_DECL;
                } else {
                    var_kind = JS_VAR_NORMAL;
                }
                idx = add_scope_var(ctx, fd, name, var_kind);
                if idx >= 0 as libc::c_int {
                    vd = &mut *((*fd).vars).offset(idx as isize) as *mut JSVarDef;
                    (*vd).set_is_lexical(1 as libc::c_int as uint8_t);
                    (*vd)
                        .set_is_const(
                            (var_def_type as libc::c_uint
                                == JS_VAR_DEF_CONST as libc::c_int as libc::c_uint)
                                as libc::c_int as uint8_t,
                        );
                }
            }
        }
        5 => {
            idx = add_scope_var(ctx, fd, name, JS_VAR_CATCH);
        }
        6 => {
            if find_lexical_decl(ctx, fd, name, (*fd).scope_first, FALSE as libc::c_int)
                >= 0 as libc::c_int
            {
                current_block = 11654638613748668116;
            } else if (*fd).is_global_var != 0 {
                let mut hf_1: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
                hf_1 = find_global_var(fd, name);
                if !hf_1.is_null() && (*hf_1).is_lexical() as libc::c_int != 0
                    && (*hf_1).scope_level == (*fd).scope_level
                    && (*fd).eval_type == (1 as libc::c_int) << 0 as libc::c_int
                {
                    current_block = 11654638613748668116;
                } else {
                    hf_1 = add_global_var((*s).ctx, fd, name);
                    if hf_1.is_null() {
                        return -(1 as libc::c_int);
                    }
                    idx = 0x40000000 as libc::c_int;
                    current_block = 2606304779496145856;
                }
            } else {
                idx = find_var(ctx, fd, name);
                if idx >= 0 as libc::c_int {
                    current_block = 2606304779496145856;
                } else {
                    idx = add_var(ctx, fd, name);
                    if idx >= 0 as libc::c_int {
                        if name == JS_ATOM_arguments as libc::c_int as libc::c_uint
                            && (*fd).has_arguments_binding != 0
                        {
                            (*fd).arguments_var_idx = idx;
                        }
                        (*((*fd).vars).offset(idx as isize))
                            .scope_next = (*fd).scope_level;
                    }
                    current_block = 2606304779496145856;
                }
            }
            match current_block {
                2606304779496145856 => {}
                _ => {
                    return js_parse_error(
                        s,
                        b"invalid redefinition of lexical identifier\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
        }
        _ => {
            abort();
        }
    }
    return idx;
}
unsafe extern "C" fn add_private_class_field(
    mut s: *mut JSParseState,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut var_kind: JSVarKindEnum,
) -> libc::c_int {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    let mut idx: libc::c_int = 0;
    idx = add_scope_var(ctx, fd, name, var_kind);
    if idx < 0 as libc::c_int {
        return idx;
    }
    vd = &mut *((*fd).vars).offset(idx as isize) as *mut JSVarDef;
    (*vd).set_is_lexical(1 as libc::c_int as uint8_t);
    (*vd).set_is_const(1 as libc::c_int as uint8_t);
    return idx;
}
unsafe extern "C" fn seal_template_obj(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut prs: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    prs = find_own_property1(p, JS_ATOM_length as libc::c_int as JSAtom);
    if !prs.is_null() {
        if js_update_property_flags(
            ctx,
            p,
            &mut prs,
            (*prs).flags() as libc::c_int
                & !((1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int),
        ) != 0
        {
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh425 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh425).set_extensible(FALSE as libc::c_int as uint8_t);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_template(
    mut s: *mut JSParseState,
    mut call: libc::c_int,
    mut argc: *mut libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut raw_array: JSValue = 0;
    let mut template_object: JSValue = 0;
    let mut cooked: JSToken = JSToken {
        val: 0,
        line_num: 0,
        ptr: 0 as *const uint8_t,
        u: C2RustUnnamed_31 {
            str_0: C2RustUnnamed_35 {
                str_0: 0,
                sep: 0,
            },
        },
    };
    let mut depth: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    raw_array = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    template_object = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if call != 0 {
        template_object = JS_NewArray(ctx);
        if JS_IsException(template_object) != 0 {
            return -(1 as libc::c_int);
        }
        ret = emit_push_const(s, template_object, 0 as libc::c_int);
        JS_FreeValue(ctx, template_object);
        if ret != 0 {
            return -(1 as libc::c_int);
        }
        raw_array = JS_NewArray(ctx);
        if JS_IsException(raw_array) != 0 {
            return -(1 as libc::c_int);
        }
        if JS_DefinePropertyValue(
            ctx,
            template_object,
            JS_ATOM_raw as libc::c_int as JSAtom,
            raw_array,
            (1 as libc::c_int) << 14 as libc::c_int,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
    }
    depth = 0 as libc::c_int;
    loop {
        if !((*s).token.val == TOK_TEMPLATE as libc::c_int) {
            current_block = 6560072651652764009;
            break;
        }
        let mut p: *const uint8_t = ((*s).token.ptr).offset(1 as libc::c_int as isize);
        cooked = (*s).token;
        if call != 0 {
            if JS_DefinePropertyValueUint32(
                ctx,
                raw_array,
                depth as uint32_t,
                JS_DupValue(ctx, (*s).token.u.str_0.str_0),
                (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 14 as libc::c_int,
            ) < 0 as libc::c_int
            {
                return -(1 as libc::c_int);
            }
            if js_parse_string(
                s,
                '`' as i32,
                FALSE as libc::c_int,
                p,
                &mut cooked,
                &mut p,
            ) != 0
            {
                cooked
                    .u
                    .str_0
                    .str_0 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if JS_DefinePropertyValueUint32(
                ctx,
                template_object,
                depth as uint32_t,
                cooked.u.str_0.str_0,
                (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 14 as libc::c_int,
            ) < 0 as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        } else {
            let mut str: *mut JSString = 0 as *mut JSString;
            JS_FreeValue(ctx, (*s).token.u.str_0.str_0);
            (*s)
                .token
                .u
                .str_0
                .str_0 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if js_parse_string(
                s,
                '`' as i32,
                TRUE as libc::c_int,
                p,
                &mut cooked,
                &mut p,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            str = cooked.u.str_0.str_0 as intptr_t as *mut libc::c_void as *mut JSString;
            if (*str).len() as libc::c_int != 0 as libc::c_int
                || depth == 0 as libc::c_int
            {
                ret = emit_push_const(s, cooked.u.str_0.str_0, 1 as libc::c_int);
                JS_FreeValue((*s).ctx, cooked.u.str_0.str_0);
                if ret != 0 {
                    return -(1 as libc::c_int);
                }
                if depth == 0 as libc::c_int {
                    if (*s).token.u.str_0.sep == '`' as i32 {
                        current_block = 6120175051119379639;
                        break;
                    }
                    emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
                    emit_atom(s, JS_ATOM_concat as libc::c_int as JSAtom);
                }
                depth += 1;
            } else {
                JS_FreeValue((*s).ctx, cooked.u.str_0.str_0);
            }
        }
        if (*s).token.u.str_0.sep == '`' as i32 {
            current_block = 5973060197948019737;
            break;
        }
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if js_parse_expr(s) != 0 {
            return -(1 as libc::c_int);
        }
        depth += 1;
        if (*s).token.val != '}' as i32 {
            return js_parse_error(
                s,
                b"expected '}' after template expression\0" as *const u8
                    as *const libc::c_char,
            );
        }
        free_token(s, &mut (*s).token);
        (*s).got_lf = FALSE as libc::c_int;
        (*s).last_line_num = (*s).token.line_num;
        if js_parse_template_part(s, (*s).buf_ptr) != 0 {
            return -(1 as libc::c_int);
        }
    }
    match current_block {
        6560072651652764009 => return js_parse_expect(s, TOK_TEMPLATE as libc::c_int),
        5973060197948019737 => {
            if call != 0 {
                seal_template_obj(ctx, raw_array);
                seal_template_obj(ctx, template_object);
                *argc = depth + 1 as libc::c_int;
            } else {
                emit_op(s, OP_call_method as libc::c_int as uint8_t);
                emit_u16(s, (depth - 1 as libc::c_int) as uint16_t);
            }
        }
        _ => {}
    }
    return next_token(s);
}
unsafe extern "C" fn token_is_ident(mut tok: libc::c_int) -> BOOL {
    return (tok == TOK_IDENT as libc::c_int
        || tok >= TOK_NULL as libc::c_int && tok <= TOK_AWAIT as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn js_parse_property_name(
    mut s: *mut JSParseState,
    mut pname: *mut JSAtom,
    mut allow_method: BOOL,
    mut allow_var: BOOL,
    mut allow_private: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut is_private: libc::c_int = 0 as libc::c_int;
    let mut is_non_reserved_ident: BOOL = 0;
    let mut name: JSAtom = 0;
    let mut prop_type: libc::c_int = 0;
    prop_type = 0 as libc::c_int;
    if allow_method != 0 {
        if token_is_pseudo_keyword(s, JS_ATOM_get as libc::c_int as JSAtom) != 0
            || token_is_pseudo_keyword(s, JS_ATOM_set as libc::c_int as JSAtom) != 0
        {
            name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
            if next_token(s) != 0 {
                current_block = 11461564751339473993;
            } else if (*s).token.val == ':' as i32 || (*s).token.val == ',' as i32
                || (*s).token.val == '}' as i32 || (*s).token.val == '(' as i32
            {
                is_non_reserved_ident = TRUE as libc::c_int;
                current_block = 4836414473529878935;
            } else {
                prop_type = 2 as libc::c_int
                    + (name == JS_ATOM_set as libc::c_int as libc::c_uint)
                        as libc::c_int;
                JS_FreeAtom((*s).ctx, name);
                current_block = 3437258052017859086;
            }
        } else if (*s).token.val == '*' as i32 {
            if next_token(s) != 0 {
                current_block = 10068458442971712163;
            } else {
                prop_type = 4 as libc::c_int;
                current_block = 3437258052017859086;
            }
        } else if token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom) != 0
            && peek_token(s, TRUE as libc::c_int) != '\n' as i32
        {
            name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
            if next_token(s) != 0 {
                current_block = 11461564751339473993;
            } else if (*s).token.val == ':' as i32 || (*s).token.val == ',' as i32
                || (*s).token.val == '}' as i32 || (*s).token.val == '(' as i32
            {
                is_non_reserved_ident = TRUE as libc::c_int;
                current_block = 4836414473529878935;
            } else {
                JS_FreeAtom((*s).ctx, name);
                if (*s).token.val == '*' as i32 {
                    if next_token(s) != 0 {
                        current_block = 10068458442971712163;
                    } else {
                        prop_type = 6 as libc::c_int;
                        current_block = 3437258052017859086;
                    }
                } else {
                    prop_type = 5 as libc::c_int;
                    current_block = 3437258052017859086;
                }
            }
        } else {
            current_block = 3437258052017859086;
        }
    } else {
        current_block = 3437258052017859086;
    }
    match current_block {
        3437258052017859086 => {
            if token_is_ident((*s).token.val) != 0 {
                is_non_reserved_ident = ((*s).token.val == TOK_IDENT as libc::c_int
                    && (*s).token.u.ident.is_reserved == 0) as libc::c_int;
                name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
                if next_token(s) != 0 {
                    current_block = 11461564751339473993;
                } else {
                    current_block = 4836414473529878935;
                }
            } else if (*s).token.val == TOK_STRING as libc::c_int {
                name = JS_ValueToAtom((*s).ctx, (*s).token.u.str_0.str_0);
                if name == 0 as libc::c_int as libc::c_uint {
                    current_block = 10068458442971712163;
                } else if next_token(s) != 0 {
                    current_block = 11461564751339473993;
                } else {
                    current_block = 16203797167131938757;
                }
            } else if (*s).token.val == TOK_NUMBER as libc::c_int {
                let mut val: JSValue = 0;
                val = (*s).token.u.num.val;
                name = JS_ValueToAtom((*s).ctx, val);
                if name == 0 as libc::c_int as libc::c_uint {
                    current_block = 10068458442971712163;
                } else if next_token(s) != 0 {
                    current_block = 11461564751339473993;
                } else {
                    current_block = 16203797167131938757;
                }
            } else if (*s).token.val == '[' as i32 {
                if next_token(s) != 0 {
                    current_block = 10068458442971712163;
                } else if js_parse_expr(s) != 0 {
                    current_block = 10068458442971712163;
                } else if js_parse_expect(s, ']' as i32) != 0 {
                    current_block = 10068458442971712163;
                } else {
                    name = 0 as libc::c_int as JSAtom;
                    current_block = 16203797167131938757;
                }
            } else if (*s).token.val == TOK_PRIVATE_NAME as libc::c_int
                && allow_private != 0
            {
                name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
                if next_token(s) != 0 {
                    current_block = 11461564751339473993;
                } else {
                    is_private = (1 as libc::c_int) << 4 as libc::c_int;
                    current_block = 16203797167131938757;
                }
            } else {
                current_block = 9457218260825332468;
            }
        }
        _ => {}
    }
    match current_block {
        11461564751339473993 => {
            JS_FreeAtom((*s).ctx, name);
            current_block = 10068458442971712163;
        }
        4836414473529878935 => {
            if is_non_reserved_ident != 0 && prop_type == 0 as libc::c_int
                && allow_var != 0
            {
                if !((*s).token.val == ':' as i32
                    || (*s).token.val == '(' as i32 && allow_method != 0)
                {
                    prop_type = 1 as libc::c_int;
                }
            }
            current_block = 16203797167131938757;
        }
        _ => {}
    }
    match current_block {
        16203797167131938757 => {
            if prop_type != 0 as libc::c_int && prop_type != 1 as libc::c_int
                && (*s).token.val != '(' as i32
            {
                JS_FreeAtom((*s).ctx, name);
            } else {
                *pname = name;
                return prop_type | is_private;
            }
            current_block = 9457218260825332468;
        }
        _ => {}
    }
    match current_block {
        9457218260825332468 => {
            js_parse_error(
                s,
                b"invalid property name\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {}
    }
    *pname = 0 as libc::c_int as JSAtom;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_parse_get_pos(
    mut s: *mut JSParseState,
    mut sp: *mut JSParsePos,
) -> libc::c_int {
    (*sp).last_line_num = (*s).last_line_num;
    (*sp).line_num = (*s).token.line_num;
    let ref mut fresh426 = (*sp).ptr;
    *fresh426 = (*s).token.ptr;
    (*sp).got_lf = (*s).got_lf;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_seek_token(
    mut s: *mut JSParseState,
    mut sp: *const JSParsePos,
) -> libc::c_int {
    (*s).token.line_num = (*sp).last_line_num;
    (*s).line_num = (*sp).line_num;
    let ref mut fresh427 = (*s).buf_ptr;
    *fresh427 = (*sp).ptr;
    (*s).got_lf = (*sp).got_lf;
    return next_token(s);
}
unsafe extern "C" fn is_regexp_allowed(mut tok: libc::c_int) -> BOOL {
    match tok {
        -128 | -127 | -124 | -108 | -107 | -85 | -84 | -83 | -78 | 41 | 93 | 125
        | -125 => return FALSE as libc::c_int,
        _ => return TRUE as libc::c_int,
    };
}
unsafe extern "C" fn js_parse_skip_parens_token(
    mut s: *mut JSParseState,
    mut pbits: *mut libc::c_int,
    mut no_line_terminator: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut state: [libc::c_char; 256] = [0; 256];
    let mut level: size_t = 0 as libc::c_int as size_t;
    let mut pos: JSParsePos = JSParsePos {
        last_line_num: 0,
        line_num: 0,
        got_lf: 0,
        ptr: 0 as *const uint8_t,
    };
    let mut last_tok: libc::c_int = 0;
    let mut tok: libc::c_int = TOK_EOF as libc::c_int;
    let mut c: libc::c_int = 0;
    let mut tok_len: libc::c_int = 0;
    let mut bits: libc::c_int = 0 as libc::c_int;
    let fresh428 = level;
    level = level.wrapping_add(1);
    state[fresh428 as usize] = 0 as libc::c_int as libc::c_char;
    js_parse_get_pos(s, &mut pos);
    last_tok = 0 as libc::c_int;
    loop {
        match (*s).token.val {
            40 | 91 | 123 => {
                if level
                    >= ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong
                {
                    break;
                }
                let fresh429 = level;
                level = level.wrapping_add(1);
                state[fresh429 as usize] = (*s).token.val as libc::c_char;
                current_block = 1434579379687443766;
            }
            41 => {
                level = level.wrapping_sub(1);
                if state[level as usize] as libc::c_int != '(' as i32 {
                    break;
                }
                current_block = 1434579379687443766;
            }
            93 => {
                level = level.wrapping_sub(1);
                if state[level as usize] as libc::c_int != '[' as i32 {
                    break;
                }
                current_block = 1434579379687443766;
            }
            125 => {
                level = level.wrapping_sub(1);
                c = state[level as usize] as libc::c_int;
                if c == '`' as i32 {
                    free_token(s, &mut (*s).token);
                    (*s).got_lf = FALSE as libc::c_int;
                    (*s).last_line_num = (*s).token.line_num;
                    if js_parse_template_part(s, (*s).buf_ptr) != 0 {
                        break;
                    }
                    current_block = 17658782906660311292;
                } else {
                    if c != '{' as i32 {
                        break;
                    }
                    current_block = 1434579379687443766;
                }
            }
            -126 => {
                current_block = 17658782906660311292;
            }
            -86 => {
                break;
            }
            59 => {
                if level == 2 as libc::c_int as libc::c_ulong {
                    bits |= (1 as libc::c_int) << 0 as libc::c_int;
                }
                current_block = 1434579379687443766;
            }
            -91 => {
                if level == 2 as libc::c_int as libc::c_ulong {
                    bits |= (1 as libc::c_int) << 1 as libc::c_int;
                }
                current_block = 1434579379687443766;
            }
            61 => {
                bits |= (1 as libc::c_int) << 2 as libc::c_int;
                current_block = 1434579379687443766;
            }
            -122 => {
                tok_len = 2 as libc::c_int;
                current_block = 639767626529203340;
            }
            47 => {
                tok_len = 1 as libc::c_int;
                current_block = 639767626529203340;
            }
            _ => {
                current_block = 1434579379687443766;
            }
        }
        match current_block {
            639767626529203340 => {
                if is_regexp_allowed(last_tok) != 0 {
                    let ref mut fresh431 = (*s).buf_ptr;
                    *fresh431 = (*fresh431).offset(-(tok_len as isize));
                    if js_parse_regexp(s) != 0 {
                        break;
                    }
                }
            }
            17658782906660311292 => {
                if (*s).token.u.str_0.sep != '`' as i32 {
                    if level
                        >= ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong
                    {
                        break;
                    }
                    let fresh430 = level;
                    level = level.wrapping_add(1);
                    state[fresh430 as usize] = '`' as i32 as libc::c_char;
                }
            }
            _ => {}
        }
        if (*s).token.val == TOK_IDENT as libc::c_int
            && (token_is_pseudo_keyword(s, JS_ATOM_of as libc::c_int as JSAtom) != 0
                || token_is_pseudo_keyword(s, JS_ATOM_yield as libc::c_int as JSAtom)
                    != 0)
        {
            last_tok = TOK_OF as libc::c_int;
        } else {
            last_tok = (*s).token.val;
        }
        if next_token(s) != 0 {
            break;
        }
        if !(level <= 1 as libc::c_int as libc::c_ulong) {
            continue;
        }
        tok = (*s).token.val;
        if token_is_pseudo_keyword(s, JS_ATOM_of as libc::c_int as JSAtom) != 0 {
            tok = TOK_OF as libc::c_int;
        }
        if no_line_terminator != 0 && (*s).last_line_num != (*s).token.line_num {
            tok = '\n' as i32;
        }
        break;
    }
    if !pbits.is_null() {
        *pbits = bits;
    }
    if js_parse_seek_token(s, &mut pos) != 0 {
        return -(1 as libc::c_int);
    }
    return tok;
}
unsafe extern "C" fn set_object_name(mut s: *mut JSParseState, mut name: JSAtom) {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut opcode: libc::c_int = 0;
    opcode = get_prev_opcode(fd);
    if opcode == OP_set_name as libc::c_int {
        (*fd).byte_code.size = (*fd).last_opcode_pos as size_t;
        (*fd).last_opcode_pos = -(1 as libc::c_int);
        emit_op(s, OP_set_name as libc::c_int as uint8_t);
        emit_atom(s, name);
    } else if opcode == OP_set_class_name as libc::c_int {
        let mut define_class_pos: libc::c_int = 0;
        let mut atom: JSAtom = 0;
        define_class_pos = (((*fd).last_opcode_pos + 1 as libc::c_int) as libc::c_uint)
            .wrapping_sub(
                get_u32(
                    ((*fd).byte_code.buf)
                        .offset((*fd).last_opcode_pos as isize)
                        .offset(1 as libc::c_int as isize),
                ),
            ) as libc::c_int;
        assert(
            (*((*fd).byte_code.buf).offset(define_class_pos as isize) as libc::c_int
                == OP_define_class as libc::c_int) as libc::c_int,
        );
        atom = get_u32(
            ((*fd).byte_code.buf)
                .offset(define_class_pos as isize)
                .offset(1 as libc::c_int as isize),
        );
        JS_FreeAtom((*s).ctx, atom);
        put_u32(
            ((*fd).byte_code.buf)
                .offset(define_class_pos as isize)
                .offset(1 as libc::c_int as isize),
            JS_DupAtom((*s).ctx, name),
        );
        (*fd).last_opcode_pos = -(1 as libc::c_int);
    }
}
unsafe extern "C" fn set_object_name_computed(mut s: *mut JSParseState) {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut opcode: libc::c_int = 0;
    opcode = get_prev_opcode(fd);
    if opcode == OP_set_name as libc::c_int {
        (*fd).byte_code.size = (*fd).last_opcode_pos as size_t;
        (*fd).last_opcode_pos = -(1 as libc::c_int);
        emit_op(s, OP_set_name_computed as libc::c_int as uint8_t);
    } else if opcode == OP_set_class_name as libc::c_int {
        let mut define_class_pos: libc::c_int = 0;
        define_class_pos = (((*fd).last_opcode_pos + 1 as libc::c_int) as libc::c_uint)
            .wrapping_sub(
                get_u32(
                    ((*fd).byte_code.buf)
                        .offset((*fd).last_opcode_pos as isize)
                        .offset(1 as libc::c_int as isize),
                ),
            ) as libc::c_int;
        assert(
            (*((*fd).byte_code.buf).offset(define_class_pos as isize) as libc::c_int
                == OP_define_class as libc::c_int) as libc::c_int,
        );
        *((*fd).byte_code.buf)
            .offset(
                define_class_pos as isize,
            ) = OP_define_class_computed as libc::c_int as uint8_t;
        (*fd).last_opcode_pos = -(1 as libc::c_int);
    }
}
unsafe extern "C" fn js_parse_object_literal(mut s: *mut JSParseState) -> libc::c_int {
    let mut current_block: u64;
    let mut name: JSAtom = 0 as libc::c_int as JSAtom;
    let mut start_ptr: *const uint8_t = 0 as *const uint8_t;
    let mut start_line: libc::c_int = 0;
    let mut prop_type: libc::c_int = 0;
    let mut has_proto: BOOL = 0;
    if !(next_token(s) != 0) {
        emit_op(s, OP_object as libc::c_int as uint8_t);
        has_proto = FALSE as libc::c_int;
        loop {
            if !((*s).token.val != '}' as i32) {
                current_block = 7158658067966855297;
                break;
            }
            start_ptr = (*s).token.ptr;
            start_line = (*s).token.line_num;
            if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if js_parse_assign_expr(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_op(s, OP_null as libc::c_int as uint8_t);
                emit_op(s, OP_copy_data_properties as libc::c_int as uint8_t);
                emit_u8(
                    s,
                    (2 as libc::c_int | (1 as libc::c_int) << 2 as libc::c_int
                        | (0 as libc::c_int) << 5 as libc::c_int) as uint8_t,
                );
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
            } else {
                prop_type = js_parse_property_name(
                    s,
                    &mut name,
                    TRUE as libc::c_int,
                    TRUE as libc::c_int,
                    FALSE as libc::c_int,
                );
                if prop_type < 0 as libc::c_int {
                    current_block = 8958352563353654650;
                    break;
                }
                if prop_type == 1 as libc::c_int {
                    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                    emit_atom(s, name);
                    emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                    emit_op(s, OP_define_field as libc::c_int as uint8_t);
                    emit_atom(s, name);
                } else if (*s).token.val == '(' as i32 {
                    let mut is_getset: BOOL = (prop_type == 2 as libc::c_int
                        || prop_type == 3 as libc::c_int) as libc::c_int;
                    let mut func_type: JSParseFunctionEnum = JS_PARSE_FUNC_STATEMENT;
                    let mut func_kind: JSFunctionKindEnum = JS_FUNC_NORMAL;
                    let mut op_flags: libc::c_int = 0;
                    func_kind = JS_FUNC_NORMAL;
                    if is_getset != 0 {
                        func_type = (JS_PARSE_FUNC_GETTER as libc::c_int + prop_type
                            - 2 as libc::c_int) as JSParseFunctionEnum;
                    } else {
                        func_type = JS_PARSE_FUNC_METHOD;
                        if prop_type == 4 as libc::c_int {
                            func_kind = JS_FUNC_GENERATOR;
                        } else if prop_type == 5 as libc::c_int {
                            func_kind = JS_FUNC_ASYNC;
                        } else if prop_type == 6 as libc::c_int {
                            func_kind = JS_FUNC_ASYNC_GENERATOR;
                        }
                    }
                    if js_parse_function_decl(
                        s,
                        func_type,
                        func_kind,
                        0 as libc::c_int as JSAtom,
                        start_ptr,
                        start_line,
                    ) != 0
                    {
                        current_block = 8958352563353654650;
                        break;
                    }
                    if name == 0 as libc::c_int as libc::c_uint {
                        emit_op(s, OP_define_method_computed as libc::c_int as uint8_t);
                    } else {
                        emit_op(s, OP_define_method as libc::c_int as uint8_t);
                        emit_atom(s, name);
                    }
                    if is_getset != 0 {
                        op_flags = 1 as libc::c_int + prop_type - 2 as libc::c_int;
                    } else {
                        op_flags = 0 as libc::c_int;
                    }
                    emit_u8(s, (op_flags | 4 as libc::c_int) as uint8_t);
                } else {
                    if js_parse_expect(s, ':' as i32) != 0 {
                        current_block = 8958352563353654650;
                        break;
                    }
                    if js_parse_assign_expr(s) != 0 {
                        current_block = 8958352563353654650;
                        break;
                    }
                    if name == 0 as libc::c_int as libc::c_uint {
                        set_object_name_computed(s);
                        emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                        emit_op(s, OP_drop as libc::c_int as uint8_t);
                    } else if name == JS_ATOM___proto__ as libc::c_int as libc::c_uint {
                        if has_proto != 0 {
                            js_parse_error(
                                s,
                                b"duplicate __proto__ property name\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 8958352563353654650;
                            break;
                        } else {
                            emit_op(s, OP_set_proto as libc::c_int as uint8_t);
                            has_proto = TRUE as libc::c_int;
                        }
                    } else {
                        set_object_name(s, name);
                        emit_op(s, OP_define_field as libc::c_int as uint8_t);
                        emit_atom(s, name);
                    }
                }
                JS_FreeAtom((*s).ctx, name);
            }
            name = 0 as libc::c_int as JSAtom;
            if (*s).token.val != ',' as i32 {
                current_block = 7158658067966855297;
                break;
            }
            if next_token(s) != 0 {
                current_block = 8958352563353654650;
                break;
            }
        }
        match current_block {
            8958352563353654650 => {}
            _ => {
                if !(js_parse_expect(s, '}' as i32) != 0) {
                    return 0 as libc::c_int;
                }
            }
        }
    }
    JS_FreeAtom((*s).ctx, name);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_parse_left_hand_side_expr(
    mut s: *mut JSParseState,
) -> libc::c_int {
    return js_parse_postfix_expr(s, (1 as libc::c_int) << 1 as libc::c_int);
}
unsafe extern "C" fn js_parse_class_default_ctor(
    mut s: *mut JSParseState,
    mut has_super: BOOL,
    mut pfd: *mut *mut JSFunctionDef,
) -> libc::c_int {
    let mut pos: JSParsePos = JSParsePos {
        last_line_num: 0,
        line_num: 0,
        got_lf: 0,
        ptr: 0 as *const uint8_t,
    };
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut ret: libc::c_int = 0;
    let mut line_num: libc::c_int = 0;
    let mut func_type: JSParseFunctionEnum = JS_PARSE_FUNC_STATEMENT;
    let mut saved_buf_end: *const uint8_t = 0 as *const uint8_t;
    js_parse_get_pos(s, &mut pos);
    if has_super != 0 {
        str = b"(){super(...arguments);}\0" as *const u8 as *const libc::c_char;
        func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
    } else {
        str = b"(){}\0" as *const u8 as *const libc::c_char;
        func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
    }
    line_num = (*s).token.line_num;
    saved_buf_end = (*s).buf_end;
    let ref mut fresh432 = (*s).buf_ptr;
    *fresh432 = str as *mut uint8_t;
    let ref mut fresh433 = (*s).buf_end;
    *fresh433 = str.offset(strlen(str) as isize) as *mut uint8_t;
    ret = next_token(s);
    if ret == 0 {
        ret = js_parse_function_decl2(
            s,
            func_type,
            JS_FUNC_NORMAL,
            0 as libc::c_int as JSAtom,
            str as *mut uint8_t,
            line_num,
            JS_PARSE_EXPORT_NONE,
            pfd,
        );
    }
    let ref mut fresh434 = (*s).buf_end;
    *fresh434 = saved_buf_end;
    ret |= js_parse_seek_token(s, &mut pos);
    return ret;
}
unsafe extern "C" fn find_private_class_field(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut scope_level: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    idx = (*((*fd).scopes).offset(scope_level as isize)).first;
    while idx != -(1 as libc::c_int) {
        if (*((*fd).vars).offset(idx as isize)).scope_level != scope_level {
            break;
        }
        if (*((*fd).vars).offset(idx as isize)).var_name == name {
            return idx;
        }
        idx = (*((*fd).vars).offset(idx as isize)).scope_next;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn emit_class_field_init(mut s: *mut JSParseState) {
    let mut label_next: libc::c_int = 0;
    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
    emit_atom(s, JS_ATOM_class_fields_init as libc::c_int as JSAtom);
    emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
    emit_op(s, OP_dup as libc::c_int as uint8_t);
    label_next = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
    emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
    emit_u16(s, 0 as libc::c_int as uint16_t);
    emit_op(s, OP_swap as libc::c_int as uint8_t);
    emit_op(s, OP_call_method as libc::c_int as uint8_t);
    emit_u16(s, 0 as libc::c_int as uint16_t);
    emit_label(s, label_next);
    emit_op(s, OP_drop as libc::c_int as uint8_t);
}
unsafe extern "C" fn get_private_setter_name(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> JSAtom {
    return js_atom_concat_str(ctx, name, b"<set>\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn emit_class_init_start(
    mut s: *mut JSParseState,
    mut cf: *mut ClassFieldsDef,
) -> libc::c_int {
    let mut label_add_brand: libc::c_int = 0;
    let ref mut fresh435 = (*cf).fields_init_fd;
    *fresh435 = js_parse_function_class_fields_init(s);
    if ((*cf).fields_init_fd).is_null() {
        return -(1 as libc::c_int);
    }
    let ref mut fresh436 = (*s).cur_func;
    *fresh436 = (*cf).fields_init_fd;
    emit_op(s, OP_push_false as libc::c_int as uint8_t);
    (*cf).brand_push_pos = (*(*cf).fields_init_fd).last_opcode_pos;
    label_add_brand = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
    emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
    emit_u16(s, 0 as libc::c_int as uint16_t);
    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
    emit_atom(s, JS_ATOM_home_object as libc::c_int as JSAtom);
    emit_u16(s, 0 as libc::c_int as uint16_t);
    emit_op(s, OP_add_brand as libc::c_int as uint8_t);
    emit_label(s, label_add_brand);
    let ref mut fresh437 = (*s).cur_func;
    *fresh437 = (*(*s).cur_func).parent;
    return 0 as libc::c_int;
}
unsafe extern "C" fn add_brand(
    mut s: *mut JSParseState,
    mut cf: *mut ClassFieldsDef,
) -> libc::c_int {
    if (*cf).has_brand == 0 {
        if ((*cf).fields_init_fd).is_null() {
            if emit_class_init_start(s, cf) != 0 {
                return -(1 as libc::c_int);
            }
        }
        *((*(*cf).fields_init_fd).byte_code.buf)
            .offset(
                (*cf).brand_push_pos as isize,
            ) = OP_push_true as libc::c_int as uint8_t;
        (*cf).has_brand = TRUE as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn emit_class_init_end(
    mut s: *mut JSParseState,
    mut cf: *mut ClassFieldsDef,
) {
    let mut cpool_idx: libc::c_int = 0;
    let ref mut fresh438 = (*s).cur_func;
    *fresh438 = (*cf).fields_init_fd;
    emit_op(s, OP_return_undef as libc::c_int as uint8_t);
    let ref mut fresh439 = (*s).cur_func;
    *fresh439 = (*(*s).cur_func).parent;
    cpool_idx = cpool_add(
        s,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    (*(*cf).fields_init_fd).parent_cpool_idx = cpool_idx;
    emit_op(s, OP_fclosure as libc::c_int as uint8_t);
    emit_u32(s, cpool_idx as uint32_t);
    emit_op(s, OP_set_home_object as libc::c_int as uint8_t);
}
unsafe extern "C" fn js_parse_class(
    mut s: *mut JSParseState,
    mut is_class_expr: BOOL,
    mut export_flag: JSParseExportEnum,
) -> libc::c_int {
    let mut func_type: JSParseFunctionEnum = JS_PARSE_FUNC_STATEMENT;
    let mut func_kind: JSFunctionKindEnum = JS_FUNC_NORMAL;
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut name: JSAtom = 0 as libc::c_int as JSAtom;
    let mut class_name: JSAtom = 0 as libc::c_int as JSAtom;
    let mut class_name1: JSAtom = 0;
    let mut class_var_name: JSAtom = 0 as libc::c_int as JSAtom;
    let mut method_fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut ctor_fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut saved_js_mode: libc::c_int = 0;
    let mut class_name_var_idx: libc::c_int = 0;
    let mut prop_type: libc::c_int = 0;
    let mut ctor_cpool_offset: libc::c_int = 0;
    let mut class_flags: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut define_class_offset: libc::c_int = 0;
    let mut is_static: BOOL = 0;
    let mut is_private: BOOL = 0;
    let mut class_start_ptr: *const uint8_t = (*s).token.ptr;
    let mut start_ptr: *const uint8_t = 0 as *const uint8_t;
    let mut class_fields: [ClassFieldsDef; 2] = [ClassFieldsDef {
        fields_init_fd: 0 as *mut JSFunctionDef,
        computed_fields_count: 0,
        has_brand: 0,
        brand_push_pos: 0,
    }; 2];
    saved_js_mode = (*fd).js_mode as libc::c_int;
    let ref mut fresh440 = (*fd).js_mode;
    *fresh440 = (*fresh440 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int)
        as uint8_t;
    if !(next_token(s) != 0) {
        if (*s).token.val == TOK_IDENT as libc::c_int {
            if (*s).token.u.ident.is_reserved != 0 {
                js_parse_error_reserved_identifier(s);
                current_block = 14441787895418106266;
            } else {
                class_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                if next_token(s) != 0 {
                    current_block = 14441787895418106266;
                } else {
                    current_block = 6009453772311597924;
                }
            }
        } else if is_class_expr == 0
            && export_flag as libc::c_uint
                != JS_PARSE_EXPORT_DEFAULT as libc::c_int as libc::c_uint
        {
            js_parse_error(
                s,
                b"class statement requires a name\0" as *const u8 as *const libc::c_char,
            );
            current_block = 14441787895418106266;
        } else {
            current_block = 6009453772311597924;
        }
        match current_block {
            14441787895418106266 => {}
            _ => {
                if is_class_expr == 0 {
                    if class_name == 0 as libc::c_int as libc::c_uint {
                        class_var_name = JS_ATOM__default_ as libc::c_int as JSAtom;
                    } else {
                        class_var_name = class_name;
                    }
                    class_var_name = JS_DupAtom(ctx, class_var_name);
                }
                push_scope(s);
                if (*s).token.val == TOK_EXTENDS as libc::c_int {
                    class_flags = (1 as libc::c_int) << 0 as libc::c_int;
                    if next_token(s) != 0 {
                        current_block = 14441787895418106266;
                    } else if js_parse_left_hand_side_expr(s) != 0 {
                        current_block = 14441787895418106266;
                    } else {
                        current_block = 11459959175219260272;
                    }
                } else {
                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                    current_block = 11459959175219260272;
                }
                match current_block {
                    14441787895418106266 => {}
                    _ => {
                        if class_name != 0 as libc::c_int as libc::c_uint {
                            class_name_var_idx = define_var(
                                s,
                                fd,
                                class_name,
                                JS_VAR_DEF_CONST,
                            );
                            if class_name_var_idx < 0 as libc::c_int {
                                current_block = 14441787895418106266;
                            } else {
                                current_block = 9853141518545631134;
                            }
                        } else {
                            current_block = 9853141518545631134;
                        }
                        match current_block {
                            14441787895418106266 => {}
                            _ => {
                                if !(js_parse_expect(s, '{' as i32) != 0) {
                                    push_scope(s);
                                    emit_op(s, OP_push_const as libc::c_int as uint8_t);
                                    ctor_cpool_offset = (*fd).byte_code.size as libc::c_int;
                                    emit_u32(s, 0 as libc::c_int as uint32_t);
                                    if class_name == 0 as libc::c_int as libc::c_uint {
                                        if class_var_name != 0 as libc::c_int as libc::c_uint {
                                            class_name1 = JS_ATOM_default as libc::c_int as JSAtom;
                                        } else {
                                            class_name1 = JS_ATOM_empty_string as libc::c_int as JSAtom;
                                        }
                                    } else {
                                        class_name1 = class_name;
                                    }
                                    emit_op(s, OP_define_class as libc::c_int as uint8_t);
                                    emit_atom(s, class_name1);
                                    emit_u8(s, class_flags as uint8_t);
                                    define_class_offset = (*fd).last_opcode_pos;
                                    i = 0 as libc::c_int;
                                    while i < 2 as libc::c_int {
                                        let mut cf: *mut ClassFieldsDef = &mut *class_fields
                                            .as_mut_ptr()
                                            .offset(i as isize) as *mut ClassFieldsDef;
                                        let ref mut fresh441 = (*cf).fields_init_fd;
                                        *fresh441 = 0 as *mut JSFunctionDef;
                                        (*cf).computed_fields_count = 0 as libc::c_int;
                                        (*cf).has_brand = FALSE as libc::c_int;
                                        i += 1;
                                    }
                                    ctor_fd = 0 as *mut JSFunctionDef;
                                    loop {
                                        if !((*s).token.val != '}' as i32) {
                                            current_block = 8038949400865391589;
                                            break;
                                        }
                                        if (*s).token.val == ';' as i32 {
                                            if next_token(s) != 0 {
                                                current_block = 14441787895418106266;
                                                break;
                                            }
                                        } else {
                                            is_static = ((*s).token.val == TOK_STATIC as libc::c_int)
                                                as libc::c_int;
                                            prop_type = -(1 as libc::c_int);
                                            if is_static != 0 {
                                                if next_token(s) != 0 {
                                                    current_block = 14441787895418106266;
                                                    break;
                                                }
                                                if (*s).token.val == ';' as i32
                                                    || (*s).token.val == '=' as i32
                                                {
                                                    is_static = FALSE as libc::c_int;
                                                    name = JS_DupAtom(
                                                        ctx,
                                                        JS_ATOM_static as libc::c_int as JSAtom,
                                                    );
                                                    prop_type = 0 as libc::c_int;
                                                }
                                            }
                                            if is_static != 0 {
                                                emit_op(s, OP_swap as libc::c_int as uint8_t);
                                            }
                                            start_ptr = (*s).token.ptr;
                                            if prop_type < 0 as libc::c_int {
                                                prop_type = js_parse_property_name(
                                                    s,
                                                    &mut name,
                                                    TRUE as libc::c_int,
                                                    FALSE as libc::c_int,
                                                    TRUE as libc::c_int,
                                                );
                                                if prop_type < 0 as libc::c_int {
                                                    current_block = 14441787895418106266;
                                                    break;
                                                }
                                            }
                                            is_private = prop_type
                                                & (1 as libc::c_int) << 4 as libc::c_int;
                                            prop_type &= !((1 as libc::c_int) << 4 as libc::c_int);
                                            if name
                                                == JS_ATOM_constructor as libc::c_int as libc::c_uint
                                                && is_static == 0 && prop_type != 0 as libc::c_int
                                                || name == JS_ATOM_prototype as libc::c_int as libc::c_uint
                                                    && is_static != 0
                                                || name
                                                    == JS_ATOM_hash_constructor as libc::c_int as libc::c_uint
                                            {
                                                js_parse_error(
                                                    s,
                                                    b"invalid method name\0" as *const u8 as *const libc::c_char,
                                                );
                                                current_block = 14441787895418106266;
                                                break;
                                            } else {
                                                if prop_type == 2 as libc::c_int
                                                    || prop_type == 3 as libc::c_int
                                                {
                                                    let mut is_set: BOOL = prop_type - 2 as libc::c_int;
                                                    let mut method_fd_0: *mut JSFunctionDef = 0
                                                        as *mut JSFunctionDef;
                                                    if is_private != 0 {
                                                        let mut idx: libc::c_int = 0;
                                                        let mut var_kind: libc::c_int = 0;
                                                        idx = find_private_class_field(
                                                            ctx,
                                                            fd,
                                                            name,
                                                            (*fd).scope_level,
                                                        );
                                                        if idx >= 0 as libc::c_int {
                                                            var_kind = (*((*fd).vars).offset(idx as isize)).var_kind()
                                                                as libc::c_int;
                                                            if var_kind == JS_VAR_PRIVATE_FIELD as libc::c_int
                                                                || var_kind == JS_VAR_PRIVATE_METHOD as libc::c_int
                                                                || var_kind == JS_VAR_PRIVATE_GETTER_SETTER as libc::c_int
                                                                || var_kind == JS_VAR_PRIVATE_GETTER as libc::c_int + is_set
                                                            {
                                                                current_block = 1060016283053951692;
                                                            } else {
                                                                let ref mut fresh442 = *((*fd).vars).offset(idx as isize);
                                                                (*fresh442)
                                                                    .set_var_kind(
                                                                        JS_VAR_PRIVATE_GETTER_SETTER as libc::c_int as uint8_t,
                                                                    );
                                                                current_block = 12070711452894729854;
                                                            }
                                                        } else {
                                                            if add_private_class_field(
                                                                s,
                                                                fd,
                                                                name,
                                                                (JS_VAR_PRIVATE_GETTER as libc::c_int + is_set)
                                                                    as JSVarKindEnum,
                                                            ) < 0 as libc::c_int
                                                            {
                                                                current_block = 14441787895418106266;
                                                                break;
                                                            }
                                                            current_block = 12070711452894729854;
                                                        }
                                                        match current_block {
                                                            1060016283053951692 => {}
                                                            _ => {
                                                                if add_brand(
                                                                    s,
                                                                    &mut *class_fields.as_mut_ptr().offset(is_static as isize),
                                                                ) < 0 as libc::c_int
                                                                {
                                                                    current_block = 14441787895418106266;
                                                                    break;
                                                                }
                                                                current_block = 10369920510435091891;
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 10369920510435091891;
                                                    }
                                                    match current_block {
                                                        1060016283053951692 => {}
                                                        _ => {
                                                            if js_parse_function_decl2(
                                                                s,
                                                                (JS_PARSE_FUNC_GETTER as libc::c_int + is_set)
                                                                    as JSParseFunctionEnum,
                                                                JS_FUNC_NORMAL,
                                                                0 as libc::c_int as JSAtom,
                                                                start_ptr,
                                                                (*s).token.line_num,
                                                                JS_PARSE_EXPORT_NONE,
                                                                &mut method_fd_0,
                                                            ) != 0
                                                            {
                                                                current_block = 14441787895418106266;
                                                                break;
                                                            }
                                                            if is_private != 0 {
                                                                (*method_fd_0).need_home_object = TRUE as libc::c_int;
                                                                emit_op(s, OP_set_home_object as libc::c_int as uint8_t);
                                                                emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                if is_set != 0 {
                                                                    let mut setter_name: JSAtom = 0;
                                                                    let mut ret: libc::c_int = 0;
                                                                    setter_name = get_private_setter_name(ctx, name);
                                                                    if setter_name == 0 as libc::c_int as libc::c_uint {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                    emit_atom(s, setter_name);
                                                                    ret = add_private_class_field(
                                                                        s,
                                                                        fd,
                                                                        setter_name,
                                                                        JS_VAR_PRIVATE_SETTER,
                                                                    );
                                                                    JS_FreeAtom(ctx, setter_name);
                                                                    if ret < 0 as libc::c_int {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                } else {
                                                                    emit_atom(s, name);
                                                                }
                                                                emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                            } else {
                                                                if name == 0 as libc::c_int as libc::c_uint {
                                                                    emit_op(
                                                                        s,
                                                                        OP_define_method_computed as libc::c_int as uint8_t,
                                                                    );
                                                                } else {
                                                                    emit_op(s, OP_define_method as libc::c_int as uint8_t);
                                                                    emit_atom(s, name);
                                                                }
                                                                emit_u8(s, (1 as libc::c_int + is_set) as uint8_t);
                                                            }
                                                            current_block = 16394086363301712866;
                                                        }
                                                    }
                                                } else if prop_type == 0 as libc::c_int
                                                    && (*s).token.val != '(' as i32
                                                {
                                                    let mut cf_0: *mut ClassFieldsDef = &mut *class_fields
                                                        .as_mut_ptr()
                                                        .offset(is_static as isize) as *mut ClassFieldsDef;
                                                    let mut field_var_name: JSAtom = 0 as libc::c_int as JSAtom;
                                                    if name
                                                        == JS_ATOM_constructor as libc::c_int as libc::c_uint
                                                        || name == JS_ATOM_prototype as libc::c_int as libc::c_uint
                                                    {
                                                        js_parse_error(
                                                            s,
                                                            b"invalid field name\0" as *const u8 as *const libc::c_char,
                                                        );
                                                        current_block = 14441787895418106266;
                                                        break;
                                                    } else {
                                                        if is_private != 0 {
                                                            if find_private_class_field(
                                                                ctx,
                                                                fd,
                                                                name,
                                                                (*fd).scope_level,
                                                            ) >= 0 as libc::c_int
                                                            {
                                                                current_block = 1060016283053951692;
                                                            } else {
                                                                if add_private_class_field(
                                                                    s,
                                                                    fd,
                                                                    name,
                                                                    JS_VAR_PRIVATE_FIELD,
                                                                ) < 0 as libc::c_int
                                                                {
                                                                    current_block = 14441787895418106266;
                                                                    break;
                                                                }
                                                                emit_op(s, OP_private_symbol as libc::c_int as uint8_t);
                                                                emit_atom(s, name);
                                                                emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                emit_atom(s, name);
                                                                emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                                current_block = 13256895345714485905;
                                                            }
                                                        } else {
                                                            current_block = 13256895345714485905;
                                                        }
                                                        match current_block {
                                                            1060016283053951692 => {}
                                                            _ => {
                                                                if ((*cf_0).fields_init_fd).is_null() {
                                                                    if emit_class_init_start(s, cf_0) != 0 {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                }
                                                                if name == 0 as libc::c_int as libc::c_uint {
                                                                    field_var_name = js_atom_concat_num(
                                                                        ctx,
                                                                        (JS_ATOM_computed_field as libc::c_int + is_static)
                                                                            as JSAtom,
                                                                        (*cf_0).computed_fields_count as uint32_t,
                                                                    );
                                                                    if field_var_name == 0 as libc::c_int as libc::c_uint {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                    if define_var(s, fd, field_var_name, JS_VAR_DEF_CONST)
                                                                        < 0 as libc::c_int
                                                                    {
                                                                        JS_FreeAtom(ctx, field_var_name);
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    } else {
                                                                        emit_op(s, OP_to_propkey as libc::c_int as uint8_t);
                                                                        emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                        emit_atom(s, field_var_name);
                                                                        emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                                    }
                                                                }
                                                                let ref mut fresh443 = (*s).cur_func;
                                                                *fresh443 = (*cf_0).fields_init_fd;
                                                                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                                                                emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
                                                                emit_u16(s, 0 as libc::c_int as uint16_t);
                                                                if name == 0 as libc::c_int as libc::c_uint {
                                                                    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                                                                    emit_atom(s, field_var_name);
                                                                    emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                                    let ref mut fresh444 = (*cf_0).computed_fields_count;
                                                                    *fresh444 += 1;
                                                                    JS_FreeAtom(ctx, field_var_name);
                                                                } else if is_private != 0 {
                                                                    emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                                                                    emit_atom(s, name);
                                                                    emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                                }
                                                                if (*s).token.val == '=' as i32 {
                                                                    if next_token(s) != 0 {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                    if js_parse_assign_expr(s) != 0 {
                                                                        current_block = 14441787895418106266;
                                                                        break;
                                                                    }
                                                                } else {
                                                                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                                                                }
                                                                if is_private != 0 {
                                                                    set_object_name_computed(s);
                                                                    emit_op(
                                                                        s,
                                                                        OP_define_private_field as libc::c_int as uint8_t,
                                                                    );
                                                                } else if name == 0 as libc::c_int as libc::c_uint {
                                                                    set_object_name_computed(s);
                                                                    emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                                } else {
                                                                    set_object_name(s, name);
                                                                    emit_op(s, OP_define_field as libc::c_int as uint8_t);
                                                                    emit_atom(s, name);
                                                                }
                                                                let ref mut fresh445 = (*s).cur_func;
                                                                *fresh445 = (*(*s).cur_func).parent;
                                                                if js_parse_expect_semi(s) != 0 {
                                                                    current_block = 14441787895418106266;
                                                                    break;
                                                                }
                                                                current_block = 16394086363301712866;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    func_type = JS_PARSE_FUNC_STATEMENT;
                                                    func_kind = JS_FUNC_NORMAL;
                                                    func_type = JS_PARSE_FUNC_METHOD;
                                                    func_kind = JS_FUNC_NORMAL;
                                                    if prop_type == 4 as libc::c_int {
                                                        func_kind = JS_FUNC_GENERATOR;
                                                    } else if prop_type == 5 as libc::c_int {
                                                        func_kind = JS_FUNC_ASYNC;
                                                    } else if prop_type == 6 as libc::c_int {
                                                        func_kind = JS_FUNC_ASYNC_GENERATOR;
                                                    } else if name
                                                        == JS_ATOM_constructor as libc::c_int as libc::c_uint
                                                        && is_static == 0
                                                    {
                                                        if !ctor_fd.is_null() {
                                                            js_parse_error(
                                                                s,
                                                                b"property constructor appears more than once\0"
                                                                    as *const u8 as *const libc::c_char,
                                                            );
                                                            current_block = 14441787895418106266;
                                                            break;
                                                        } else if class_flags
                                                            & (1 as libc::c_int) << 0 as libc::c_int != 0
                                                        {
                                                            func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
                                                        } else {
                                                            func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
                                                        }
                                                    }
                                                    if is_private != 0 {
                                                        if add_brand(
                                                            s,
                                                            &mut *class_fields.as_mut_ptr().offset(is_static as isize),
                                                        ) < 0 as libc::c_int
                                                        {
                                                            current_block = 14441787895418106266;
                                                            break;
                                                        }
                                                    }
                                                    if js_parse_function_decl2(
                                                        s,
                                                        func_type,
                                                        func_kind,
                                                        0 as libc::c_int as JSAtom,
                                                        start_ptr,
                                                        (*s).token.line_num,
                                                        JS_PARSE_EXPORT_NONE,
                                                        &mut method_fd,
                                                    ) != 0
                                                    {
                                                        current_block = 14441787895418106266;
                                                        break;
                                                    }
                                                    if func_type as libc::c_uint
                                                        == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR as libc::c_int
                                                            as libc::c_uint
                                                        || func_type as libc::c_uint
                                                            == JS_PARSE_FUNC_CLASS_CONSTRUCTOR as libc::c_int
                                                                as libc::c_uint
                                                    {
                                                        ctor_fd = method_fd;
                                                        current_block = 16394086363301712866;
                                                    } else if is_private != 0 {
                                                        (*method_fd).need_home_object = TRUE as libc::c_int;
                                                        if find_private_class_field(
                                                            ctx,
                                                            fd,
                                                            name,
                                                            (*fd).scope_level,
                                                        ) >= 0 as libc::c_int
                                                        {
                                                            current_block = 1060016283053951692;
                                                        } else {
                                                            if add_private_class_field(
                                                                s,
                                                                fd,
                                                                name,
                                                                JS_VAR_PRIVATE_METHOD,
                                                            ) < 0 as libc::c_int
                                                            {
                                                                current_block = 14441787895418106266;
                                                                break;
                                                            }
                                                            emit_op(s, OP_set_home_object as libc::c_int as uint8_t);
                                                            emit_op(s, OP_set_name as libc::c_int as uint8_t);
                                                            emit_atom(s, name);
                                                            emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                            emit_atom(s, name);
                                                            emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                            current_block = 16394086363301712866;
                                                        }
                                                    } else {
                                                        if name == 0 as libc::c_int as libc::c_uint {
                                                            emit_op(
                                                                s,
                                                                OP_define_method_computed as libc::c_int as uint8_t,
                                                            );
                                                        } else {
                                                            emit_op(s, OP_define_method as libc::c_int as uint8_t);
                                                            emit_atom(s, name);
                                                        }
                                                        emit_u8(s, 0 as libc::c_int as uint8_t);
                                                        current_block = 16394086363301712866;
                                                    }
                                                }
                                                match current_block {
                                                    1060016283053951692 => {
                                                        js_parse_error(
                                                            s,
                                                            b"private class field is already defined\0" as *const u8
                                                                as *const libc::c_char,
                                                        );
                                                        current_block = 14441787895418106266;
                                                        break;
                                                    }
                                                    _ => {
                                                        if is_static != 0 {
                                                            emit_op(s, OP_swap as libc::c_int as uint8_t);
                                                        }
                                                        JS_FreeAtom(ctx, name);
                                                        name = 0 as libc::c_int as JSAtom;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    match current_block {
                                        14441787895418106266 => {}
                                        _ => {
                                            if (*s).token.val != '}' as i32 {
                                                js_parse_error(
                                                    s,
                                                    b"expecting '%c'\0" as *const u8 as *const libc::c_char,
                                                    '}' as i32,
                                                );
                                            } else {
                                                if ctor_fd.is_null() {
                                                    if js_parse_class_default_ctor(
                                                        s,
                                                        class_flags & (1 as libc::c_int) << 0 as libc::c_int,
                                                        &mut ctor_fd,
                                                    ) != 0
                                                    {
                                                        current_block = 14441787895418106266;
                                                    } else {
                                                        current_block = 2455751414656213165;
                                                    }
                                                } else {
                                                    current_block = 2455751414656213165;
                                                }
                                                match current_block {
                                                    14441787895418106266 => {}
                                                    _ => {
                                                        put_u32(
                                                            ((*fd).byte_code.buf).offset(ctor_cpool_offset as isize),
                                                            (*ctor_fd).parent_cpool_idx as uint32_t,
                                                        );
                                                        if (*fd).js_mode as libc::c_int
                                                            & (1 as libc::c_int) << 1 as libc::c_int == 0
                                                        {
                                                            js_free(ctx, (*ctor_fd).source as *mut libc::c_void);
                                                            (*ctor_fd)
                                                                .source_len = ((*s).buf_ptr).offset_from(class_start_ptr)
                                                                as libc::c_long as libc::c_int;
                                                            let ref mut fresh446 = (*ctor_fd).source;
                                                            *fresh446 = js_strndup(
                                                                ctx,
                                                                class_start_ptr as *const libc::c_char,
                                                                (*ctor_fd).source_len as size_t,
                                                            );
                                                            if ((*ctor_fd).source).is_null() {
                                                                current_block = 14441787895418106266;
                                                            } else {
                                                                current_block = 11889020335300612420;
                                                            }
                                                        } else {
                                                            current_block = 11889020335300612420;
                                                        }
                                                        match current_block {
                                                            14441787895418106266 => {}
                                                            _ => {
                                                                if !(next_token(s) != 0) {
                                                                    let mut cf_1: *mut ClassFieldsDef = &mut *class_fields
                                                                        .as_mut_ptr()
                                                                        .offset(0 as libc::c_int as isize) as *mut ClassFieldsDef;
                                                                    let mut var_idx: libc::c_int = 0;
                                                                    var_idx = define_var(
                                                                        s,
                                                                        fd,
                                                                        JS_ATOM_class_fields_init as libc::c_int as JSAtom,
                                                                        JS_VAR_DEF_CONST,
                                                                    );
                                                                    if !(var_idx < 0 as libc::c_int) {
                                                                        if !((*cf_1).fields_init_fd).is_null() {
                                                                            emit_class_init_end(s, cf_1);
                                                                        } else {
                                                                            emit_op(s, OP_undefined as libc::c_int as uint8_t);
                                                                        }
                                                                        emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                        emit_atom(
                                                                            s,
                                                                            JS_ATOM_class_fields_init as libc::c_int as JSAtom,
                                                                        );
                                                                        emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                                        emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                                        if !(class_fields[1 as libc::c_int as usize].fields_init_fd)
                                                                            .is_null()
                                                                        {
                                                                            let mut cf_2: *mut ClassFieldsDef = &mut *class_fields
                                                                                .as_mut_ptr()
                                                                                .offset(1 as libc::c_int as isize) as *mut ClassFieldsDef;
                                                                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                                                                            emit_class_init_end(s, cf_2);
                                                                            emit_op(s, OP_call_method as libc::c_int as uint8_t);
                                                                            emit_u16(s, 0 as libc::c_int as uint16_t);
                                                                            emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                                        }
                                                                        if class_name != 0 as libc::c_int as libc::c_uint {
                                                                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                                                                            emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                            emit_atom(s, class_name);
                                                                            emit_u16(s, (*fd).scope_level as uint16_t);
                                                                        }
                                                                        pop_scope(s);
                                                                        pop_scope(s);
                                                                        if class_var_name != 0 as libc::c_int as libc::c_uint {
                                                                            if define_var(s, fd, class_var_name, JS_VAR_DEF_LET)
                                                                                < 0 as libc::c_int
                                                                            {
                                                                                current_block = 14441787895418106266;
                                                                            } else {
                                                                                emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                                                emit_atom(s, class_var_name);
                                                                                emit_u16(s, (*fd).scope_level as uint16_t);
                                                                                current_block = 4957587885808349958;
                                                                            }
                                                                        } else {
                                                                            if class_name == 0 as libc::c_int as libc::c_uint {
                                                                                emit_op(s, OP_set_class_name as libc::c_int as uint8_t);
                                                                                emit_u32(
                                                                                    s,
                                                                                    ((*fd).last_opcode_pos + 1 as libc::c_int
                                                                                        - define_class_offset) as uint32_t,
                                                                                );
                                                                            }
                                                                            current_block = 4957587885808349958;
                                                                        }
                                                                        match current_block {
                                                                            14441787895418106266 => {}
                                                                            _ => {
                                                                                if export_flag as libc::c_uint
                                                                                    != JS_PARSE_EXPORT_NONE as libc::c_int as libc::c_uint
                                                                                {
                                                                                    if (add_export_entry(
                                                                                        s,
                                                                                        (*fd).module,
                                                                                        class_var_name,
                                                                                        if export_flag as libc::c_uint
                                                                                            == JS_PARSE_EXPORT_NAMED as libc::c_int as libc::c_uint
                                                                                        {
                                                                                            class_var_name
                                                                                        } else {
                                                                                            JS_ATOM_default as libc::c_int as libc::c_uint
                                                                                        },
                                                                                        JS_EXPORT_TYPE_LOCAL,
                                                                                    ))
                                                                                        .is_null()
                                                                                    {
                                                                                        current_block = 14441787895418106266;
                                                                                    } else {
                                                                                        current_block = 15712984148872257586;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 15712984148872257586;
                                                                                }
                                                                                match current_block {
                                                                                    14441787895418106266 => {}
                                                                                    _ => {
                                                                                        JS_FreeAtom(ctx, class_name);
                                                                                        JS_FreeAtom(ctx, class_var_name);
                                                                                        (*fd).js_mode = saved_js_mode as uint8_t;
                                                                                        return 0 as libc::c_int;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeAtom(ctx, name);
    JS_FreeAtom(ctx, class_name);
    JS_FreeAtom(ctx, class_var_name);
    (*fd).js_mode = saved_js_mode as uint8_t;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_parse_array_literal(mut s: *mut JSParseState) -> libc::c_int {
    let mut current_block: u64;
    let mut idx: uint32_t = 0;
    let mut need_length: BOOL = 0;
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    idx = 0 as libc::c_int as uint32_t;
    loop {
        if !((*s).token.val != ']' as i32 && idx < 32 as libc::c_int as libc::c_uint) {
            current_block = 12800627514080957624;
            break;
        }
        if (*s).token.val == ',' as i32 || (*s).token.val == TOK_ELLIPSIS as libc::c_int
        {
            current_block = 12800627514080957624;
            break;
        }
        if js_parse_assign_expr(s) != 0 {
            return -(1 as libc::c_int);
        }
        idx = idx.wrapping_add(1);
        if (*s).token.val == ',' as i32 {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
        } else if (*s).token.val != ']' as i32 {
            current_block = 6025072393223836178;
            break;
        }
    }
    match current_block {
        12800627514080957624 => {
            emit_op(s, OP_array_from as libc::c_int as uint8_t);
            emit_u16(s, idx as uint16_t);
            need_length = FALSE as libc::c_int;
            while (*s).token.val != ']' as i32
                && idx < 0x7fffffff as libc::c_int as libc::c_uint
            {
                if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                    break;
                }
                need_length = TRUE as libc::c_int;
                if (*s).token.val != ',' as i32 {
                    if js_parse_assign_expr(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    emit_op(s, OP_define_field as libc::c_int as uint8_t);
                    emit_u32(s, __JS_AtomFromUInt32(idx));
                    need_length = FALSE as libc::c_int;
                }
                idx = idx.wrapping_add(1);
                if (*s).token.val == ',' as i32 {
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                }
            }
            if (*s).token.val == ']' as i32 {
                if need_length != 0 {
                    emit_op(s, OP_dup as libc::c_int as uint8_t);
                    emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
                    emit_u32(s, idx);
                    emit_op(s, OP_put_field as libc::c_int as uint8_t);
                    emit_atom(s, JS_ATOM_length as libc::c_int as JSAtom);
                }
            } else {
                emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
                emit_u32(s, idx);
                while (*s).token.val != ']' as i32 {
                    if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                        if next_token(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if js_parse_assign_expr(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        emit_op(s, OP_append as libc::c_int as uint8_t);
                    } else {
                        need_length = TRUE as libc::c_int;
                        if (*s).token.val != ',' as i32 {
                            if js_parse_assign_expr(s) != 0 {
                                return -(1 as libc::c_int);
                            }
                            emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                            need_length = FALSE as libc::c_int;
                        }
                        emit_op(s, OP_inc as libc::c_int as uint8_t);
                    }
                    if (*s).token.val != ',' as i32 {
                        break;
                    }
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                }
                if need_length != 0 {
                    emit_op(s, OP_dup1 as libc::c_int as uint8_t);
                    emit_op(s, OP_put_field as libc::c_int as uint8_t);
                    emit_atom(s, JS_ATOM_length as libc::c_int as JSAtom);
                } else {
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                }
            }
        }
        _ => {}
    }
    return js_parse_expect(s, ']' as i32);
}
unsafe extern "C" fn has_with_scope(
    mut s: *mut JSFunctionDef,
    mut scope_level: libc::c_int,
) -> BOOL {
    while !s.is_null() {
        let mut scope_idx: libc::c_int = (*((*s).scopes).offset(scope_level as isize))
            .first;
        while scope_idx >= 0 as libc::c_int {
            let mut vd: *mut JSVarDef = &mut *((*s).vars).offset(scope_idx as isize)
                as *mut JSVarDef;
            if (*vd).var_name == JS_ATOM__with_ as libc::c_int as libc::c_uint {
                return TRUE as libc::c_int;
            }
            scope_idx = (*vd).scope_next;
        }
        scope_level = (*s).parent_scope_level;
        s = (*s).parent;
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn get_lvalue(
    mut s: *mut JSParseState,
    mut popcode: *mut libc::c_int,
    mut pscope: *mut libc::c_int,
    mut pname: *mut JSAtom,
    mut plabel: *mut libc::c_int,
    mut pdepth: *mut libc::c_int,
    mut keep: BOOL,
    mut tok: libc::c_int,
) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut opcode: libc::c_int = 0;
    let mut scope: libc::c_int = 0;
    let mut label: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut name: JSAtom = 0;
    fd = (*s).cur_func;
    scope = 0 as libc::c_int;
    name = 0 as libc::c_int as JSAtom;
    label = -(1 as libc::c_int);
    depth = 0 as libc::c_int;
    let mut current_block_28: u64;
    opcode = get_prev_opcode(fd);
    match opcode {
        182 => {
            name = get_u32(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(1 as libc::c_int as isize),
            );
            scope = get_u16(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(5 as libc::c_int as isize),
            ) as libc::c_int;
            if (name == JS_ATOM_arguments as libc::c_int as libc::c_uint
                || name == JS_ATOM_eval as libc::c_int as libc::c_uint)
                && (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                    != 0
            {
                return js_parse_error(
                    s,
                    b"invalid lvalue in strict mode\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if name == JS_ATOM_this as libc::c_int as libc::c_uint
                || name == JS_ATOM_new_target as libc::c_int as libc::c_uint
            {
                current_block_28 = 3114421561623944453;
            } else {
                depth = 2 as libc::c_int;
                current_block_28 = 11459959175219260272;
            }
        }
        65 => {
            name = get_u32(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(1 as libc::c_int as isize),
            );
            depth = 1 as libc::c_int;
            current_block_28 = 11459959175219260272;
        }
        188 => {
            name = get_u32(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(1 as libc::c_int as isize),
            );
            scope = get_u16(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(5 as libc::c_int as isize),
            ) as libc::c_int;
            depth = 1 as libc::c_int;
            current_block_28 = 11459959175219260272;
        }
        71 => {
            depth = 2 as libc::c_int;
            current_block_28 = 11459959175219260272;
        }
        74 => {
            depth = 3 as libc::c_int;
            current_block_28 = 11459959175219260272;
        }
        _ => {
            current_block_28 = 3114421561623944453;
        }
    }
    match current_block_28 {
        11459959175219260272 => {}
        _ => {
            if tok == TOK_FOR as libc::c_int {
                return js_parse_error(
                    s,
                    b"invalid for in/of left hand-side\0" as *const u8
                        as *const libc::c_char,
                )
            } else if tok == TOK_INC as libc::c_int || tok == TOK_DEC as libc::c_int {
                return js_parse_error(
                    s,
                    b"invalid increment/decrement operand\0" as *const u8
                        as *const libc::c_char,
                )
            } else if tok == '[' as i32 || tok == '{' as i32 {
                return js_parse_error(
                    s,
                    b"invalid destructuring target\0" as *const u8 as *const libc::c_char,
                )
            } else {
                return js_parse_error(
                    s,
                    b"invalid assignment left-hand side\0" as *const u8
                        as *const libc::c_char,
                )
            }
        }
    }
    (*fd).byte_code.size = (*fd).last_opcode_pos as size_t;
    (*fd).last_opcode_pos = -(1 as libc::c_int);
    if keep != 0 {
        match opcode {
            182 => {
                label = new_label(s);
                emit_op(s, OP_scope_make_ref as libc::c_int as uint8_t);
                emit_atom(s, name);
                emit_u32(s, label as uint32_t);
                emit_u16(s, scope as uint16_t);
                update_label(fd, label, 1 as libc::c_int);
                emit_op(s, OP_get_ref_value as libc::c_int as uint8_t);
                opcode = OP_get_ref_value as libc::c_int;
            }
            65 => {
                emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
                emit_atom(s, name);
            }
            188 => {
                emit_op(s, OP_scope_get_private_field2 as libc::c_int as uint8_t);
                emit_atom(s, name);
                emit_u16(s, scope as uint16_t);
            }
            71 => {
                emit_op(s, OP_to_propkey2 as libc::c_int as uint8_t);
                emit_op(s, OP_dup2 as libc::c_int as uint8_t);
                emit_op(s, OP_get_array_el as libc::c_int as uint8_t);
            }
            74 => {
                emit_op(s, OP_to_propkey as libc::c_int as uint8_t);
                emit_op(s, OP_dup3 as libc::c_int as uint8_t);
                emit_op(s, OP_get_super_value as libc::c_int as uint8_t);
            }
            _ => {
                abort();
            }
        }
    } else {
        match opcode {
            182 => {
                label = new_label(s);
                emit_op(s, OP_scope_make_ref as libc::c_int as uint8_t);
                emit_atom(s, name);
                emit_u32(s, label as uint32_t);
                emit_u16(s, scope as uint16_t);
                update_label(fd, label, 1 as libc::c_int);
                opcode = OP_get_ref_value as libc::c_int;
            }
            71 => {
                emit_op(s, OP_to_propkey2 as libc::c_int as uint8_t);
            }
            74 => {
                emit_op(s, OP_to_propkey as libc::c_int as uint8_t);
            }
            _ => {}
        }
    }
    *popcode = opcode;
    *pscope = scope;
    *pname = name;
    *plabel = label;
    if !pdepth.is_null() {
        *pdepth = depth;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn put_lvalue(
    mut s: *mut JSParseState,
    mut opcode: libc::c_int,
    mut scope: libc::c_int,
    mut name: JSAtom,
    mut label: libc::c_int,
    mut special: PutLValueEnum,
    mut is_let_0: BOOL,
) {
    match opcode {
        65 | 188 => {
            match special as libc::c_uint {
                0 | 1 => {}
                2 => {
                    emit_op(s, OP_insert2 as libc::c_int as uint8_t);
                }
                3 => {
                    emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                }
                4 => {
                    emit_op(s, OP_swap as libc::c_int as uint8_t);
                }
                _ => {
                    abort();
                }
            }
        }
        71 | 60 => {
            if opcode == OP_get_ref_value as libc::c_int {
                JS_FreeAtom((*s).ctx, name);
                emit_label(s, label);
            }
            match special as libc::c_uint {
                0 => {
                    emit_op(s, OP_nop as libc::c_int as uint8_t);
                }
                1 => {}
                2 => {
                    emit_op(s, OP_insert3 as libc::c_int as uint8_t);
                }
                3 => {
                    emit_op(s, OP_perm4 as libc::c_int as uint8_t);
                }
                4 => {
                    emit_op(s, OP_rot3l as libc::c_int as uint8_t);
                }
                _ => {
                    abort();
                }
            }
        }
        74 => {
            match special as libc::c_uint {
                0 | 1 => {}
                2 => {
                    emit_op(s, OP_insert4 as libc::c_int as uint8_t);
                }
                3 => {
                    emit_op(s, OP_perm5 as libc::c_int as uint8_t);
                }
                4 => {
                    emit_op(s, OP_rot4l as libc::c_int as uint8_t);
                }
                _ => {
                    abort();
                }
            }
        }
        _ => {}
    }
    match opcode {
        182 => {
            assert(
                (special as libc::c_uint
                    == PUT_LVALUE_NOKEEP as libc::c_int as libc::c_uint
                    || special as libc::c_uint
                        == PUT_LVALUE_NOKEEP_DEPTH as libc::c_int as libc::c_uint)
                    as libc::c_int,
            );
            emit_op(
                s,
                (if is_let_0 != 0 {
                    OP_scope_put_var_init as libc::c_int
                } else {
                    OP_scope_put_var as libc::c_int
                }) as uint8_t,
            );
            emit_u32(s, name);
            emit_u16(s, scope as uint16_t);
        }
        65 => {
            emit_op(s, OP_put_field as libc::c_int as uint8_t);
            emit_u32(s, name);
        }
        188 => {
            emit_op(s, OP_scope_put_private_field as libc::c_int as uint8_t);
            emit_u32(s, name);
            emit_u16(s, scope as uint16_t);
        }
        71 => {
            emit_op(s, OP_put_array_el as libc::c_int as uint8_t);
        }
        60 => {
            emit_op(s, OP_put_ref_value as libc::c_int as uint8_t);
        }
        74 => {
            emit_op(s, OP_put_super_value as libc::c_int as uint8_t);
        }
        _ => {
            abort();
        }
    };
}
unsafe extern "C" fn js_parse_expr_paren(mut s: *mut JSParseState) -> libc::c_int {
    if js_parse_expect(s, '(' as i32) != 0 {
        return -(1 as libc::c_int);
    }
    if js_parse_expr(s) != 0 {
        return -(1 as libc::c_int);
    }
    if js_parse_expect(s, ')' as i32) != 0 {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_unsupported_keyword(
    mut s: *mut JSParseState,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut buf: [libc::c_char; 64] = [0; 64];
    return js_parse_error(
        s,
        b"unsupported keyword: %s\0" as *const u8 as *const libc::c_char,
        JS_AtomGetStr(
            (*s).ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            atom,
        ),
    );
}
unsafe extern "C" fn js_define_var(
    mut s: *mut JSParseState,
    mut name: JSAtom,
    mut tok: libc::c_int,
) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut var_def_type: JSVarDefEnum = JS_VAR_DEF_WITH;
    if name == JS_ATOM_yield as libc::c_int as libc::c_uint
        && (*fd).func_kind() as libc::c_int == JS_FUNC_GENERATOR as libc::c_int
    {
        return js_parse_error(
            s,
            b"yield is a reserved identifier\0" as *const u8 as *const libc::c_char,
        );
    }
    if (name == JS_ATOM_arguments as libc::c_int as libc::c_uint
        || name == JS_ATOM_eval as libc::c_int as libc::c_uint)
        && (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
    {
        return js_parse_error(
            s,
            b"invalid variable name in strict mode\0" as *const u8 as *const libc::c_char,
        );
    }
    if (name == JS_ATOM_let as libc::c_int as libc::c_uint
        || name == JS_ATOM_undefined as libc::c_int as libc::c_uint)
        && (tok == TOK_LET as libc::c_int || tok == TOK_CONST as libc::c_int)
    {
        return js_parse_error(
            s,
            b"invalid lexical variable name\0" as *const u8 as *const libc::c_char,
        );
    }
    match tok {
        -47 => {
            var_def_type = JS_VAR_DEF_LET;
        }
        -55 => {
            var_def_type = JS_VAR_DEF_CONST;
        }
        -79 => {
            var_def_type = JS_VAR_DEF_VAR;
        }
        -61 => {
            var_def_type = JS_VAR_DEF_CATCH;
        }
        _ => {
            abort();
        }
    }
    if define_var(s, fd, name, var_def_type) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_emit_spread_code(
    mut s: *mut JSParseState,
    mut depth: libc::c_int,
) {
    let mut label_rest_next: libc::c_int = 0;
    let mut label_rest_done: libc::c_int = 0;
    emit_op(s, OP_array_from as libc::c_int as uint8_t);
    emit_u16(s, 0 as libc::c_int as uint16_t);
    emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
    emit_u32(s, 0 as libc::c_int as uint32_t);
    label_rest_next = new_label(s);
    emit_label(s, label_rest_next);
    emit_op(s, OP_for_of_next as libc::c_int as uint8_t);
    emit_u8(s, (2 as libc::c_int + depth) as uint8_t);
    label_rest_done = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
    emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
    emit_op(s, OP_inc as libc::c_int as uint8_t);
    emit_goto(s, OP_goto as libc::c_int, label_rest_next);
    emit_label(s, label_rest_done);
    emit_op(s, OP_drop as libc::c_int as uint8_t);
    emit_op(s, OP_drop as libc::c_int as uint8_t);
}
unsafe extern "C" fn js_parse_check_duplicate_parameter(
    mut s: *mut JSParseState,
    mut name: JSAtom,
) -> libc::c_int {
    let mut current_block: u64;
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    loop {
        if !(i < (*fd).arg_count) {
            current_block = 15240798224410183470;
            break;
        }
        if (*((*fd).args).offset(i as isize)).var_name == name {
            current_block = 9111195560215369431;
            break;
        }
        i += 1;
    }
    match current_block {
        15240798224410183470 => {
            i = 0 as libc::c_int;
            loop {
                if !(i < (*fd).var_count) {
                    current_block = 5720623009719927633;
                    break;
                }
                if (*((*fd).vars).offset(i as isize)).var_name == name {
                    current_block = 9111195560215369431;
                    break;
                }
                i += 1;
            }
            match current_block {
                9111195560215369431 => {}
                _ => return 0 as libc::c_int,
            }
        }
        _ => {}
    }
    return js_parse_error(
        s,
        b"duplicate parameter names not allowed in this context\0" as *const u8
            as *const libc::c_char,
    );
}
unsafe extern "C" fn js_parse_destructuring_var(
    mut s: *mut JSParseState,
    mut tok: libc::c_int,
    mut is_arg: libc::c_int,
) -> JSAtom {
    let mut name: JSAtom = 0;
    if !((*s).token.val == TOK_IDENT as libc::c_int
        && (*s).token.u.ident.is_reserved == 0)
        || (*(*s).cur_func).js_mode as libc::c_int
            & (1 as libc::c_int) << 0 as libc::c_int != 0
            && ((*s).token.u.ident.atom == JS_ATOM_eval as libc::c_int as libc::c_uint
                || (*s).token.u.ident.atom
                    == JS_ATOM_arguments as libc::c_int as libc::c_uint)
    {
        js_parse_error(
            s,
            b"invalid destructuring target\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int as JSAtom;
    }
    name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
    if !(is_arg != 0 && js_parse_check_duplicate_parameter(s, name) != 0) {
        if !(next_token(s) != 0) {
            return name;
        }
    }
    JS_FreeAtom((*s).ctx, name);
    return 0 as libc::c_int as JSAtom;
}
unsafe extern "C" fn js_parse_destructuring_element(
    mut s: *mut JSParseState,
    mut tok: libc::c_int,
    mut is_arg: libc::c_int,
    mut hasval: libc::c_int,
    mut has_ellipsis: libc::c_int,
    mut allow_initializer: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut label_parse: libc::c_int = 0;
    let mut label_assign: libc::c_int = 0;
    let mut label_done: libc::c_int = 0;
    let mut label_lvalue: libc::c_int = 0;
    let mut depth_lvalue: libc::c_int = 0;
    let mut start_addr: libc::c_int = 0;
    let mut assign_addr: libc::c_int = 0;
    let mut prop_name: JSAtom = 0;
    let mut var_name: JSAtom = 0;
    let mut opcode: libc::c_int = 0;
    let mut scope: libc::c_int = 0;
    let mut tok1: libc::c_int = 0;
    let mut skip_bits: libc::c_int = 0;
    let mut has_initializer: BOOL = 0;
    if has_ellipsis < 0 as libc::c_int {
        js_parse_skip_parens_token(s, &mut skip_bits, FALSE as libc::c_int);
        has_ellipsis = skip_bits & (1 as libc::c_int) << 1 as libc::c_int;
    }
    label_parse = new_label(s);
    label_assign = new_label(s);
    start_addr = (*(*s).cur_func).byte_code.size as libc::c_int;
    if hasval != 0 {
        emit_op(s, OP_dup as libc::c_int as uint8_t);
        emit_op(s, OP_undefined as libc::c_int as uint8_t);
        emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
        emit_goto(s, OP_if_true as libc::c_int, label_parse);
        emit_label(s, label_assign);
    } else {
        emit_goto(s, OP_goto as libc::c_int, label_parse);
        emit_label(s, label_assign);
        emit_op(s, OP_dup as libc::c_int as uint8_t);
    }
    assign_addr = (*(*s).cur_func).byte_code.size as libc::c_int;
    if (*s).token.val == '{' as i32 {
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        emit_op(s, OP_to_object as libc::c_int as uint8_t);
        if has_ellipsis != 0 {
            emit_op(s, OP_object as libc::c_int as uint8_t);
            emit_op(s, OP_swap as libc::c_int as uint8_t);
        }
        loop {
            if !((*s).token.val != '}' as i32) {
                current_block = 2942604368452602584;
                break;
            }
            let mut prop_type: libc::c_int = 0;
            if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                if has_ellipsis == 0 {
                    JS_ThrowInternalError(
                        (*s).ctx,
                        b"unexpected ellipsis token\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if tok != 0 {
                    var_name = js_parse_destructuring_var(s, tok, is_arg);
                    if var_name == 0 as libc::c_int as libc::c_uint {
                        return -(1 as libc::c_int);
                    }
                    opcode = OP_scope_get_var as libc::c_int;
                    scope = (*(*s).cur_func).scope_level;
                    label_lvalue = -(1 as libc::c_int);
                    depth_lvalue = 0 as libc::c_int;
                } else {
                    if js_parse_left_hand_side_expr(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if get_lvalue(
                        s,
                        &mut opcode,
                        &mut scope,
                        &mut var_name,
                        &mut label_lvalue,
                        &mut depth_lvalue,
                        FALSE as libc::c_int,
                        '{' as i32,
                    ) != 0
                    {
                        return -(1 as libc::c_int);
                    }
                }
                if (*s).token.val != '}' as i32 {
                    js_parse_error(
                        s,
                        b"assignment rest property must be last\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 18059893083651528794;
                    break;
                } else {
                    emit_op(s, OP_object as libc::c_int as uint8_t);
                    emit_op(s, OP_copy_data_properties as libc::c_int as uint8_t);
                    emit_u8(
                        s,
                        (0 as libc::c_int
                            | (depth_lvalue + 1 as libc::c_int) << 2 as libc::c_int
                            | (depth_lvalue + 2 as libc::c_int) << 5 as libc::c_int)
                            as uint8_t,
                    );
                }
            } else {
                prop_type = js_parse_property_name(
                    s,
                    &mut prop_name,
                    FALSE as libc::c_int,
                    TRUE as libc::c_int,
                    FALSE as libc::c_int,
                );
                if prop_type < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                var_name = 0 as libc::c_int as JSAtom;
                opcode = OP_scope_get_var as libc::c_int;
                scope = (*(*s).cur_func).scope_level;
                label_lvalue = -(1 as libc::c_int);
                depth_lvalue = 0 as libc::c_int;
                if prop_type == 0 as libc::c_int {
                    if next_token(s) != 0 {
                        current_block = 934368767011392570;
                        break;
                    }
                    if ((*s).token.val == '[' as i32 || (*s).token.val == '{' as i32)
                        && {
                            tok1 = js_parse_skip_parens_token(
                                s,
                                &mut skip_bits,
                                FALSE as libc::c_int,
                            );
                            tok1 == ',' as i32 || tok1 == '=' as i32
                                || tok1 == '}' as i32
                        }
                    {
                        if prop_name == 0 as libc::c_int as libc::c_uint {
                            if has_ellipsis != 0 {
                                emit_op(s, OP_to_propkey as libc::c_int as uint8_t);
                                emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                                emit_op(s, OP_null as libc::c_int as uint8_t);
                                emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                                emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                            }
                            emit_op(s, OP_get_array_el2 as libc::c_int as uint8_t);
                        } else {
                            if has_ellipsis != 0 {
                                emit_op(s, OP_swap as libc::c_int as uint8_t);
                                emit_op(s, OP_null as libc::c_int as uint8_t);
                                emit_op(s, OP_define_field as libc::c_int as uint8_t);
                                emit_atom(s, prop_name);
                                emit_op(s, OP_swap as libc::c_int as uint8_t);
                            }
                            emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
                            emit_u32(s, prop_name);
                        }
                        if js_parse_destructuring_element(
                            s,
                            tok,
                            is_arg,
                            TRUE as libc::c_int,
                            -(1 as libc::c_int),
                            TRUE as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            return -(1 as libc::c_int);
                        }
                        if (*s).token.val == '}' as i32 {
                            current_block = 2942604368452602584;
                            break;
                        }
                        if js_parse_expect(s, ',' as i32) != 0 {
                            return -(1 as libc::c_int);
                        }
                        continue;
                    } else {
                        if prop_name == 0 as libc::c_int as libc::c_uint {
                            emit_op(s, OP_to_propkey2 as libc::c_int as uint8_t);
                            if has_ellipsis != 0 {
                                emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                                emit_op(s, OP_null as libc::c_int as uint8_t);
                                emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                                emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                            }
                            emit_op(s, OP_dup1 as libc::c_int as uint8_t);
                        } else {
                            if has_ellipsis != 0 {
                                emit_op(s, OP_swap as libc::c_int as uint8_t);
                                emit_op(s, OP_null as libc::c_int as uint8_t);
                                emit_op(s, OP_define_field as libc::c_int as uint8_t);
                                emit_atom(s, prop_name);
                                emit_op(s, OP_swap as libc::c_int as uint8_t);
                            }
                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                        }
                        if tok != 0 {
                            var_name = js_parse_destructuring_var(s, tok, is_arg);
                            if var_name == 0 as libc::c_int as libc::c_uint {
                                current_block = 934368767011392570;
                                break;
                            }
                            current_block = 12696043255897098083;
                        } else {
                            if js_parse_left_hand_side_expr(s) != 0 {
                                current_block = 934368767011392570;
                                break;
                            }
                            current_block = 9184155549272868982;
                        }
                    }
                } else {
                    if is_arg != 0
                        && js_parse_check_duplicate_parameter(s, prop_name) != 0
                    {
                        current_block = 934368767011392570;
                        break;
                    }
                    if (*(*s).cur_func).js_mode as libc::c_int
                        & (1 as libc::c_int) << 0 as libc::c_int != 0
                        && (prop_name == JS_ATOM_eval as libc::c_int as libc::c_uint
                            || prop_name
                                == JS_ATOM_arguments as libc::c_int as libc::c_uint)
                    {
                        js_parse_error(
                            s,
                            b"invalid destructuring target\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 934368767011392570;
                        break;
                    } else {
                        if has_ellipsis != 0 {
                            emit_op(s, OP_swap as libc::c_int as uint8_t);
                            emit_op(s, OP_null as libc::c_int as uint8_t);
                            emit_op(s, OP_define_field as libc::c_int as uint8_t);
                            emit_atom(s, prop_name);
                            emit_op(s, OP_swap as libc::c_int as uint8_t);
                        }
                        if tok == 0 || tok == TOK_VAR as libc::c_int {
                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                            emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                            emit_atom(s, prop_name);
                            emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                            current_block = 9184155549272868982;
                        } else {
                            var_name = JS_DupAtom((*s).ctx, prop_name);
                            emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
                            emit_u32(s, prop_name);
                            current_block = 6278837169292305196;
                        }
                    }
                }
                match current_block {
                    6278837169292305196 => {}
                    _ => {
                        match current_block {
                            9184155549272868982 => {
                                if get_lvalue(
                                    s,
                                    &mut opcode,
                                    &mut scope,
                                    &mut var_name,
                                    &mut label_lvalue,
                                    &mut depth_lvalue,
                                    FALSE as libc::c_int,
                                    '{' as i32,
                                ) != 0
                                {
                                    current_block = 934368767011392570;
                                    break;
                                }
                                if prop_name == 0 as libc::c_int as libc::c_uint {
                                    match depth_lvalue {
                                        1 => {
                                            emit_op(s, OP_rot3r as libc::c_int as uint8_t);
                                        }
                                        2 => {
                                            emit_op(s, OP_swap2 as libc::c_int as uint8_t);
                                        }
                                        3 => {
                                            emit_op(s, OP_rot5l as libc::c_int as uint8_t);
                                            emit_op(s, OP_rot5l as libc::c_int as uint8_t);
                                        }
                                        _ => {}
                                    }
                                } else {
                                    match depth_lvalue {
                                        1 => {
                                            emit_op(s, OP_swap as libc::c_int as uint8_t);
                                        }
                                        2 => {
                                            emit_op(s, OP_rot3l as libc::c_int as uint8_t);
                                        }
                                        3 => {
                                            emit_op(s, OP_rot4l as libc::c_int as uint8_t);
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            _ => {}
                        }
                        if prop_name == 0 as libc::c_int as libc::c_uint {
                            emit_op(s, OP_get_array_el as libc::c_int as uint8_t);
                        } else {
                            emit_op(s, OP_get_field as libc::c_int as uint8_t);
                            emit_u32(s, prop_name);
                        }
                    }
                }
            }
            if tok != 0 {
                if js_define_var(s, var_name, tok) != 0 {
                    current_block = 18059893083651528794;
                    break;
                }
                scope = (*(*s).cur_func).scope_level;
            }
            if (*s).token.val == '=' as i32 {
                let mut label_hasval: libc::c_int = 0;
                emit_op(s, OP_dup as libc::c_int as uint8_t);
                emit_op(s, OP_undefined as libc::c_int as uint8_t);
                emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
                label_hasval = emit_goto(
                    s,
                    OP_if_false as libc::c_int,
                    -(1 as libc::c_int),
                );
                if next_token(s) != 0 {
                    current_block = 18059893083651528794;
                    break;
                }
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                if js_parse_assign_expr(s) != 0 {
                    current_block = 18059893083651528794;
                    break;
                }
                if opcode == OP_scope_get_var as libc::c_int
                    || opcode == OP_get_ref_value as libc::c_int
                {
                    set_object_name(s, var_name);
                }
                emit_label(s, label_hasval);
            }
            put_lvalue(
                s,
                opcode,
                scope,
                var_name,
                label_lvalue,
                PUT_LVALUE_NOKEEP_DEPTH,
                (tok == TOK_CONST as libc::c_int || tok == TOK_LET as libc::c_int)
                    as libc::c_int,
            );
            if (*s).token.val == '}' as i32 {
                current_block = 2942604368452602584;
                break;
            }
            if js_parse_expect(s, ',' as i32) != 0 {
                return -(1 as libc::c_int);
            }
        }
        match current_block {
            18059893083651528794 => {}
            _ => {
                match current_block {
                    934368767011392570 => {
                        JS_FreeAtom((*s).ctx, prop_name);
                        current_block = 18059893083651528794;
                    }
                    _ => {
                        emit_op(s, OP_drop as libc::c_int as uint8_t);
                        if has_ellipsis != 0 {
                            emit_op(s, OP_drop as libc::c_int as uint8_t);
                        }
                        if next_token(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        current_block = 18368972393688527475;
                    }
                }
            }
        }
    } else if (*s).token.val == '[' as i32 {
        let mut has_spread: BOOL = 0;
        let mut enum_depth: libc::c_int = 0;
        let mut block_env: BlockEnv = BlockEnv {
            prev: 0 as *mut BlockEnv,
            label_name: 0,
            label_break: 0,
            label_cont: 0,
            drop_count: 0,
            label_finally: 0,
            scope_level: 0,
            has_iterator: 0,
        };
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        push_break_entry(
            (*s).cur_func,
            &mut block_env,
            0 as libc::c_int as JSAtom,
            -(1 as libc::c_int),
            -(1 as libc::c_int),
            2 as libc::c_int,
        );
        block_env.has_iterator = TRUE as libc::c_int;
        emit_op(s, OP_for_of_start as libc::c_int as uint8_t);
        has_spread = FALSE as libc::c_int;
        loop {
            if !((*s).token.val != ']' as i32) {
                current_block = 613454377845503748;
                break;
            }
            if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if (*s).token.val == ',' as i32 || (*s).token.val == ']' as i32 {
                    return js_parse_error(
                        s,
                        b"missing binding pattern...\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                has_spread = TRUE as libc::c_int;
            }
            if (*s).token.val == ',' as i32 {
                emit_op(s, OP_for_of_next as libc::c_int as uint8_t);
                emit_u8(s, 0 as libc::c_int as uint8_t);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
            } else if ((*s).token.val == '[' as i32 || (*s).token.val == '{' as i32)
                && {
                    tok1 = js_parse_skip_parens_token(
                        s,
                        &mut skip_bits,
                        FALSE as libc::c_int,
                    );
                    tok1 == ',' as i32 || tok1 == '=' as i32 || tok1 == ']' as i32
                }
            {
                if has_spread != 0 {
                    if tok1 == '=' as i32 {
                        return js_parse_error(
                            s,
                            b"rest element cannot have a default value\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    js_emit_spread_code(s, 0 as libc::c_int);
                } else {
                    emit_op(s, OP_for_of_next as libc::c_int as uint8_t);
                    emit_u8(s, 0 as libc::c_int as uint8_t);
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                }
                if js_parse_destructuring_element(
                    s,
                    tok,
                    is_arg,
                    TRUE as libc::c_int,
                    skip_bits & (1 as libc::c_int) << 1 as libc::c_int,
                    TRUE as libc::c_int,
                ) < 0 as libc::c_int
                {
                    return -(1 as libc::c_int);
                }
            } else {
                var_name = 0 as libc::c_int as JSAtom;
                enum_depth = 0 as libc::c_int;
                if tok != 0 {
                    var_name = js_parse_destructuring_var(s, tok, is_arg);
                    if var_name == 0 as libc::c_int as libc::c_uint {
                        current_block = 18059893083651528794;
                        break;
                    }
                    if js_define_var(s, var_name, tok) != 0 {
                        current_block = 18059893083651528794;
                        break;
                    }
                    opcode = OP_scope_get_var as libc::c_int;
                    scope = (*(*s).cur_func).scope_level;
                } else {
                    if js_parse_left_hand_side_expr(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if get_lvalue(
                        s,
                        &mut opcode,
                        &mut scope,
                        &mut var_name,
                        &mut label_lvalue,
                        &mut enum_depth,
                        FALSE as libc::c_int,
                        '[' as i32,
                    ) != 0
                    {
                        return -(1 as libc::c_int);
                    }
                }
                if has_spread != 0 {
                    js_emit_spread_code(s, enum_depth);
                } else {
                    emit_op(s, OP_for_of_next as libc::c_int as uint8_t);
                    emit_u8(s, enum_depth as uint8_t);
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                }
                if (*s).token.val == '=' as i32 && has_spread == 0 {
                    let mut label_hasval_0: libc::c_int = 0;
                    emit_op(s, OP_dup as libc::c_int as uint8_t);
                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                    emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
                    label_hasval_0 = emit_goto(
                        s,
                        OP_if_false as libc::c_int,
                        -(1 as libc::c_int),
                    );
                    if next_token(s) != 0 {
                        current_block = 18059893083651528794;
                        break;
                    }
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                    if js_parse_assign_expr(s) != 0 {
                        current_block = 18059893083651528794;
                        break;
                    }
                    if opcode == OP_scope_get_var as libc::c_int
                        || opcode == OP_get_ref_value as libc::c_int
                    {
                        set_object_name(s, var_name);
                    }
                    emit_label(s, label_hasval_0);
                }
                put_lvalue(
                    s,
                    opcode,
                    scope,
                    var_name,
                    label_lvalue,
                    PUT_LVALUE_NOKEEP_DEPTH,
                    (tok == TOK_CONST as libc::c_int || tok == TOK_LET as libc::c_int)
                        as libc::c_int,
                );
            }
            if (*s).token.val == ']' as i32 {
                current_block = 613454377845503748;
                break;
            }
            if has_spread != 0 {
                return js_parse_error(
                    s,
                    b"rest element must be the last one\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if js_parse_expect(s, ',' as i32) != 0 {
                return -(1 as libc::c_int);
            }
        }
        match current_block {
            18059893083651528794 => {}
            _ => {
                emit_op(s, OP_iterator_close as libc::c_int as uint8_t);
                pop_break_entry((*s).cur_func);
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                current_block = 18368972393688527475;
            }
        }
    } else {
        return js_parse_error(
            s,
            b"invalid assignment syntax\0" as *const u8 as *const libc::c_char,
        )
    }
    match current_block {
        18059893083651528794 => {
            JS_FreeAtom((*s).ctx, var_name);
            return -(1 as libc::c_int);
        }
        _ => {
            if (*s).token.val == '=' as i32 && allow_initializer != 0 {
                label_done = emit_goto(s, OP_goto as libc::c_int, -(1 as libc::c_int));
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_label(s, label_parse);
                if hasval != 0 {
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                }
                if js_parse_assign_expr(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_goto(s, OP_goto as libc::c_int, label_assign);
                emit_label(s, label_done);
                has_initializer = TRUE as libc::c_int;
            } else {
                if hasval == 0 {
                    js_parse_error(
                        s,
                        b"too complicated destructuring expression\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                memset(
                    ((*(*s).cur_func).byte_code.buf).offset(start_addr as isize)
                        as *mut libc::c_void,
                    OP_nop as libc::c_int,
                    (assign_addr - start_addr) as libc::c_ulong,
                );
                let ref mut fresh447 = (*((*(*s).cur_func).label_slots)
                    .offset(label_parse as isize))
                    .ref_count;
                *fresh447 -= 1;
                has_initializer = FALSE as libc::c_int;
            }
            return has_initializer;
        }
    };
}
unsafe extern "C" fn optional_chain_test(
    mut s: *mut JSParseState,
    mut poptional_chaining_label: *mut libc::c_int,
    mut drop_count: libc::c_int,
) {
    let mut label_next: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    if *poptional_chaining_label < 0 as libc::c_int {
        *poptional_chaining_label = new_label(s);
    }
    emit_op(s, OP_dup as libc::c_int as uint8_t);
    emit_op(s, OP_is_undefined_or_null as libc::c_int as uint8_t);
    label_next = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
    i = 0 as libc::c_int;
    while i < drop_count {
        emit_op(s, OP_drop as libc::c_int as uint8_t);
        i += 1;
    }
    emit_op(s, OP_undefined as libc::c_int as uint8_t);
    emit_goto(s, OP_goto as libc::c_int, *poptional_chaining_label);
    emit_label(s, label_next);
}
unsafe extern "C" fn js_parse_postfix_expr(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut call_type: FuncCallType = FUNC_CALL_NORMAL;
    let mut optional_chaining_label: libc::c_int = 0;
    let mut accept_lparen: BOOL = (parse_flags & (1 as libc::c_int) << 1 as libc::c_int
        != 0 as libc::c_int) as libc::c_int;
    call_type = FUNC_CALL_NORMAL;
    let mut current_block_179: u64;
    match (*s).token.val {
        -128 => {
            let mut val: JSValue = 0;
            val = (*s).token.u.num.val;
            if (val >> 32 as libc::c_int) as libc::c_int == JS_TAG_INT as libc::c_int {
                emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
                emit_u32(s, val as libc::c_int as uint32_t);
            } else if emit_push_const(s, val, 0 as libc::c_int) < 0 as libc::c_int {
                return -(1 as libc::c_int)
            }
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_179 = 10996290961880923853;
        }
        -126 => {
            if js_parse_template(s, 0 as libc::c_int, 0 as *mut libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_179 = 10996290961880923853;
        }
        -127 => {
            if emit_push_const(s, (*s).token.u.str_0.str_0, 1 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_179 = 10996290961880923853;
        }
        -122 => {
            let ref mut fresh448 = (*s).buf_ptr;
            *fresh448 = (*fresh448).offset(-(2 as libc::c_int as isize));
            current_block_179 = 11704779964153908183;
        }
        47 => {
            let ref mut fresh449 = (*s).buf_ptr;
            *fresh449 = (*fresh449).offset(-1);
            current_block_179 = 11704779964153908183;
        }
        40 => {
            if parse_flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                && js_parse_skip_parens_token(
                    s,
                    0 as *mut libc::c_int,
                    TRUE as libc::c_int,
                ) == TOK_ARROW as libc::c_int
            {
                if js_parse_function_decl(
                    s,
                    JS_PARSE_FUNC_ARROW,
                    JS_FUNC_NORMAL,
                    0 as libc::c_int as JSAtom,
                    (*s).token.ptr,
                    (*s).token.line_num,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
            } else if js_parse_expr_paren(s) != 0 {
                return -(1 as libc::c_int)
            }
            current_block_179 = 10996290961880923853;
        }
        -59 => {
            if js_parse_function_decl(
                s,
                JS_PARSE_FUNC_EXPR,
                JS_FUNC_NORMAL,
                0 as libc::c_int as JSAtom,
                (*s).token.ptr,
                (*s).token.line_num,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            current_block_179 = 10996290961880923853;
        }
        -56 => {
            if js_parse_class(s, TRUE as libc::c_int, JS_PARSE_EXPORT_NONE) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_179 = 10996290961880923853;
        }
        -85 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_null as libc::c_int as uint8_t);
            current_block_179 = 10996290961880923853;
        }
        -78 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
            emit_u16(s, 0 as libc::c_int as uint16_t);
            current_block_179 = 10996290961880923853;
        }
        -84 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_push_false as libc::c_int as uint8_t);
            current_block_179 = 10996290961880923853;
        }
        -83 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_push_true as libc::c_int as uint8_t);
            current_block_179 = 10996290961880923853;
        }
        -125 => {
            let mut name: JSAtom = 0;
            if (*s).token.u.ident.is_reserved != 0 {
                return js_parse_error_reserved_identifier(s);
            }
            if parse_flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                && peek_token(s, TRUE as libc::c_int) == TOK_ARROW as libc::c_int
            {
                if js_parse_function_decl(
                    s,
                    JS_PARSE_FUNC_ARROW,
                    JS_FUNC_NORMAL,
                    0 as libc::c_int as JSAtom,
                    (*s).token.ptr,
                    (*s).token.line_num,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
            } else {
                let mut current_block_92: u64;
                if token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom)
                    != 0 && peek_token(s, TRUE as libc::c_int) != '\n' as i32
                {
                    let mut source_ptr: *const uint8_t = 0 as *const uint8_t;
                    let mut source_line_num: libc::c_int = 0;
                    source_ptr = (*s).token.ptr;
                    source_line_num = (*s).token.line_num;
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if (*s).token.val == TOK_FUNCTION as libc::c_int {
                        if js_parse_function_decl(
                            s,
                            JS_PARSE_FUNC_EXPR,
                            JS_FUNC_ASYNC,
                            0 as libc::c_int as JSAtom,
                            source_ptr,
                            source_line_num,
                        ) != 0
                        {
                            return -(1 as libc::c_int);
                        }
                        current_block_92 = 4488496028633655612;
                    } else if parse_flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                        && ((*s).token.val == '(' as i32
                            && js_parse_skip_parens_token(
                                s,
                                0 as *mut libc::c_int,
                                TRUE as libc::c_int,
                            ) == TOK_ARROW as libc::c_int
                            || (*s).token.val == TOK_IDENT as libc::c_int
                                && (*s).token.u.ident.is_reserved == 0
                                && peek_token(s, TRUE as libc::c_int)
                                    == TOK_ARROW as libc::c_int)
                    {
                        if js_parse_function_decl(
                            s,
                            JS_PARSE_FUNC_ARROW,
                            JS_FUNC_ASYNC,
                            0 as libc::c_int as JSAtom,
                            source_ptr,
                            source_line_num,
                        ) != 0
                        {
                            return -(1 as libc::c_int);
                        }
                        current_block_92 = 4488496028633655612;
                    } else {
                        name = JS_DupAtom(
                            (*s).ctx,
                            JS_ATOM_async as libc::c_int as JSAtom,
                        );
                        current_block_92 = 5384736943498869577;
                    }
                } else {
                    if (*s).token.u.ident.atom
                        == JS_ATOM_arguments as libc::c_int as libc::c_uint
                        && (*(*s).cur_func).arguments_allowed == 0
                    {
                        js_parse_error(
                            s,
                            b"'arguments' identifier is not allowed in class field initializer\0"
                                as *const u8 as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    name = JS_DupAtom((*s).ctx, (*s).token.u.ident.atom);
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    current_block_92 = 5384736943498869577;
                }
                match current_block_92 {
                    5384736943498869577 => {
                        emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                        emit_u32(s, name);
                        emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                    }
                    _ => {}
                }
            }
            current_block_179 = 10996290961880923853;
        }
        123 | 91 => {
            let mut skip_bits: libc::c_int = 0;
            if js_parse_skip_parens_token(s, &mut skip_bits, FALSE as libc::c_int)
                == '=' as i32
            {
                if js_parse_destructuring_element(
                    s,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    FALSE as libc::c_int,
                    skip_bits & (1 as libc::c_int) << 1 as libc::c_int,
                    TRUE as libc::c_int,
                ) < 0 as libc::c_int
                {
                    return -(1 as libc::c_int);
                }
            } else if (*s).token.val == '{' as i32 {
                if js_parse_object_literal(s) != 0 {
                    return -(1 as libc::c_int);
                }
            } else if js_parse_array_literal(s) != 0 {
                return -(1 as libc::c_int)
            }
            current_block_179 = 10996290961880923853;
        }
        -74 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if (*s).token.val == '.' as i32 {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if token_is_pseudo_keyword(s, JS_ATOM_target as libc::c_int as JSAtom)
                    == 0
                {
                    return js_parse_error(
                        s,
                        b"expecting target\0" as *const u8 as *const libc::c_char,
                    );
                }
                if (*(*s).cur_func).new_target_allowed == 0 {
                    return js_parse_error(
                        s,
                        b"new.target only allowed within functions\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_new_target as libc::c_int as JSAtom);
                emit_u16(s, 0 as libc::c_int as uint16_t);
            } else {
                if js_parse_postfix_expr(s, 0 as libc::c_int) != 0 {
                    return -(1 as libc::c_int);
                }
                accept_lparen = TRUE as libc::c_int;
                if (*s).token.val != '(' as i32 {
                    emit_op(s, OP_dup as libc::c_int as uint8_t);
                    emit_op(s, OP_call_constructor as libc::c_int as uint8_t);
                    emit_u16(s, 0 as libc::c_int as uint16_t);
                } else {
                    call_type = FUNC_CALL_NEW;
                }
            }
            current_block_179 = 10996290961880923853;
        }
        -50 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if (*s).token.val == '(' as i32 {
                if (*(*s).cur_func).super_call_allowed == 0 {
                    return js_parse_error(
                        s,
                        b"super() is only valid in a derived class constructor\0"
                            as *const u8 as *const libc::c_char,
                    );
                }
                call_type = FUNC_CALL_SUPER_CTOR;
            } else if (*s).token.val == '.' as i32 || (*s).token.val == '[' as i32 {
                if (*(*s).cur_func).super_allowed == 0 {
                    return js_parse_error(
                        s,
                        b"'super' is only valid in a method\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
                emit_u16(s, 0 as libc::c_int as uint16_t);
                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_home_object as libc::c_int as JSAtom);
                emit_u16(s, 0 as libc::c_int as uint16_t);
                emit_op(s, OP_get_super as libc::c_int as uint8_t);
            } else {
                return js_parse_error(
                    s,
                    b"invalid use of 'super'\0" as *const u8 as *const libc::c_char,
                )
            }
            current_block_179 = 10996290961880923853;
        }
        -51 => {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if (*s).token.val == '.' as i32 {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if token_is_pseudo_keyword(s, JS_ATOM_meta as libc::c_int as JSAtom) == 0
                {
                    return js_parse_error(
                        s,
                        b"meta expected\0" as *const u8 as *const libc::c_char,
                    );
                }
                if (*s).is_module == 0 {
                    return js_parse_error(
                        s,
                        b"import.meta only valid in module code\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_op(s, OP_special_object as libc::c_int as uint8_t);
                emit_u8(s, OP_SPECIAL_OBJECT_IMPORT_META as libc::c_int as uint8_t);
            } else {
                if js_parse_expect(s, '(' as i32) != 0 {
                    return -(1 as libc::c_int);
                }
                if accept_lparen == 0 {
                    return js_parse_error(
                        s,
                        b"invalid use of 'import()'\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if js_parse_assign_expr(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if js_parse_expect(s, ')' as i32) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_op(s, OP_import as libc::c_int as uint8_t);
            }
            current_block_179 = 10996290961880923853;
        }
        _ => {
            return js_parse_error(
                s,
                b"unexpected token in expression: '%.*s'\0" as *const u8
                    as *const libc::c_char,
                ((*s).buf_ptr).offset_from((*s).token.ptr) as libc::c_long
                    as libc::c_int,
                (*s).token.ptr,
            );
        }
    }
    match current_block_179 {
        11704779964153908183 => {
            let mut str: JSValue = 0;
            let mut ret: libc::c_int = 0;
            let mut backtrace_flags: libc::c_int = 0;
            if ((*(*s).ctx).compile_regexp).is_none() {
                return js_parse_error(
                    s,
                    b"RegExp are not supported\0" as *const u8 as *const libc::c_char,
                );
            }
            if js_parse_regexp(s) != 0 {
                return -(1 as libc::c_int);
            }
            ret = emit_push_const(s, (*s).token.u.regexp.body, 0 as libc::c_int);
            str = ((*(*s).ctx).compile_regexp)
                .expect(
                    "non-null function pointer",
                )((*s).ctx, (*s).token.u.regexp.body, (*s).token.u.regexp.flags);
            if JS_IsException(str) != 0 {
                backtrace_flags = 0 as libc::c_int;
                if !((*s).cur_func).is_null() && (*(*s).cur_func).backtrace_barrier != 0
                {
                    backtrace_flags = (1 as libc::c_int) << 1 as libc::c_int;
                }
                build_backtrace(
                    (*s).ctx,
                    (*(*(*s).ctx).rt).current_exception,
                    (*s).filename,
                    (*s).token.line_num,
                    backtrace_flags,
                );
                return -(1 as libc::c_int);
            }
            ret = emit_push_const(s, str, 0 as libc::c_int);
            JS_FreeValue((*s).ctx, str);
            if ret != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_regexp as libc::c_int as uint8_t);
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
        }
        _ => {}
    }
    optional_chaining_label = -(1 as libc::c_int);
    let mut prev_op: libc::c_int = 0;
    let mut opcode: libc::c_int = 0;
    let mut arg_count: libc::c_int = 0;
    let mut drop_count: libc::c_int = 0;
    let mut current_block_366: u64;
    loop {
        let mut fd: *mut JSFunctionDef = (*s).cur_func;
        let mut has_optional_chain: BOOL = FALSE as libc::c_int;
        if (*s).token.val == TOK_QUESTION_MARK_DOT as libc::c_int {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            has_optional_chain = TRUE as libc::c_int;
            if (*s).token.val == '(' as i32 && accept_lparen != 0 {
                current_block_366 = 9409403273494360800;
            } else if (*s).token.val == '[' as i32 {
                current_block_366 = 2076256706409669625;
            } else {
                current_block_366 = 17098449439643340602;
            }
        } else if (*s).token.val == TOK_TEMPLATE as libc::c_int
            && call_type as libc::c_uint
                == FUNC_CALL_NORMAL as libc::c_int as libc::c_uint
        {
            if optional_chaining_label >= 0 as libc::c_int {
                return js_parse_error(
                    s,
                    b"template literal cannot appear in an optional chain\0" as *const u8
                        as *const libc::c_char,
                );
            }
            call_type = FUNC_CALL_TEMPLATE;
            current_block_366 = 17332264657795998381;
        } else if (*s).token.val == '(' as i32 && accept_lparen != 0 {
            opcode = 0;
            arg_count = 0;
            drop_count = 0;
            current_block_366 = 9409403273494360800;
        } else if (*s).token.val == '.' as i32 {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_366 = 17098449439643340602;
        } else {
            if !((*s).token.val == '[' as i32) {
                break;
            }
            prev_op = 0;
            current_block_366 = 2076256706409669625;
        }
        match current_block_366 {
            2076256706409669625 => {
                prev_op = get_prev_opcode(fd);
                if has_optional_chain != 0 {
                    optional_chain_test(
                        s,
                        &mut optional_chaining_label,
                        1 as libc::c_int,
                    );
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if js_parse_expr(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if js_parse_expect(s, ']' as i32) != 0 {
                    return -(1 as libc::c_int);
                }
                if prev_op == OP_get_super as libc::c_int {
                    emit_op(s, OP_get_super_value as libc::c_int as uint8_t);
                } else {
                    emit_op(s, OP_get_array_el as libc::c_int as uint8_t);
                }
                continue;
            }
            17098449439643340602 => {
                if (*s).token.val == TOK_PRIVATE_NAME as libc::c_int {
                    if get_prev_opcode(fd) == OP_get_super as libc::c_int {
                        return js_parse_error(
                            s,
                            b"private class field forbidden after super\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if has_optional_chain != 0 {
                        optional_chain_test(
                            s,
                            &mut optional_chaining_label,
                            1 as libc::c_int,
                        );
                    }
                    emit_op(s, OP_scope_get_private_field as libc::c_int as uint8_t);
                    emit_atom(s, (*s).token.u.ident.atom);
                    emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                } else {
                    if token_is_ident((*s).token.val) == 0 {
                        return js_parse_error(
                            s,
                            b"expecting field name\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    if get_prev_opcode(fd) == OP_get_super as libc::c_int {
                        let mut val_0: JSValue = 0;
                        let mut ret_0: libc::c_int = 0;
                        val_0 = JS_AtomToValue((*s).ctx, (*s).token.u.ident.atom);
                        ret_0 = emit_push_const(s, val_0, 1 as libc::c_int);
                        JS_FreeValue((*s).ctx, val_0);
                        if ret_0 != 0 {
                            return -(1 as libc::c_int);
                        }
                        emit_op(s, OP_get_super_value as libc::c_int as uint8_t);
                    } else {
                        if has_optional_chain != 0 {
                            optional_chain_test(
                                s,
                                &mut optional_chaining_label,
                                1 as libc::c_int,
                            );
                        }
                        emit_op(s, OP_get_field as libc::c_int as uint8_t);
                        emit_atom(s, (*s).token.u.ident.atom);
                    }
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                continue;
            }
            9409403273494360800 => {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if call_type as libc::c_uint
                    == FUNC_CALL_NORMAL as libc::c_int as libc::c_uint
                {
                    current_block_366 = 17332264657795998381;
                } else {
                    opcode = OP_invalid as libc::c_int;
                    current_block_366 = 16286683003977321678;
                }
            }
            _ => {}
        }
        match current_block_366 {
            17332264657795998381 => {
                opcode = get_prev_opcode(fd);
                match opcode {
                    65 => {
                        *((*fd).byte_code.buf)
                            .offset(
                                (*fd).last_opcode_pos as isize,
                            ) = OP_get_field2 as libc::c_int as uint8_t;
                        drop_count = 2 as libc::c_int;
                    }
                    188 => {
                        *((*fd).byte_code.buf)
                            .offset(
                                (*fd).last_opcode_pos as isize,
                            ) = OP_scope_get_private_field2 as libc::c_int as uint8_t;
                        drop_count = 2 as libc::c_int;
                    }
                    71 => {
                        *((*fd).byte_code.buf)
                            .offset(
                                (*fd).last_opcode_pos as isize,
                            ) = OP_get_array_el2 as libc::c_int as uint8_t;
                        drop_count = 2 as libc::c_int;
                    }
                    182 => {
                        let mut name_0: JSAtom = 0;
                        let mut scope: libc::c_int = 0;
                        name_0 = get_u32(
                            ((*fd).byte_code.buf)
                                .offset((*fd).last_opcode_pos as isize)
                                .offset(1 as libc::c_int as isize),
                        );
                        scope = get_u16(
                            ((*fd).byte_code.buf)
                                .offset((*fd).last_opcode_pos as isize)
                                .offset(5 as libc::c_int as isize),
                        ) as libc::c_int;
                        if name_0 == JS_ATOM_eval as libc::c_int as libc::c_uint
                            && call_type as libc::c_uint
                                == FUNC_CALL_NORMAL as libc::c_int as libc::c_uint
                            && has_optional_chain == 0
                        {
                            opcode = OP_eval as libc::c_int;
                        } else if has_with_scope(fd, scope) != 0 {
                            opcode = OP_scope_get_ref as libc::c_int;
                            *((*fd).byte_code.buf)
                                .offset((*fd).last_opcode_pos as isize) = opcode as uint8_t;
                        }
                        drop_count = 1 as libc::c_int;
                    }
                    74 => {
                        *((*fd).byte_code.buf)
                            .offset(
                                (*fd).last_opcode_pos as isize,
                            ) = OP_get_array_el as libc::c_int as uint8_t;
                        opcode = OP_get_array_el as libc::c_int;
                        drop_count = 2 as libc::c_int;
                    }
                    _ => {
                        opcode = OP_invalid as libc::c_int;
                        drop_count = 1 as libc::c_int;
                    }
                }
                if has_optional_chain != 0 {
                    optional_chain_test(s, &mut optional_chaining_label, drop_count);
                }
            }
            _ => {}
        }
        if call_type as libc::c_uint == FUNC_CALL_TEMPLATE as libc::c_int as libc::c_uint
        {
            if js_parse_template(s, 1 as libc::c_int, &mut arg_count) != 0 {
                return -(1 as libc::c_int);
            }
            current_block_366 = 17303515161642976378;
        } else {
            if call_type as libc::c_uint
                == FUNC_CALL_SUPER_CTOR as libc::c_int as libc::c_uint
            {
                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_this_active_func as libc::c_int as JSAtom);
                emit_u16(s, 0 as libc::c_int as uint16_t);
                emit_op(s, OP_get_super as libc::c_int as uint8_t);
                emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_new_target as libc::c_int as JSAtom);
                emit_u16(s, 0 as libc::c_int as uint16_t);
            } else if call_type as libc::c_uint
                == FUNC_CALL_NEW as libc::c_int as libc::c_uint
            {
                emit_op(s, OP_dup as libc::c_int as uint8_t);
            }
            arg_count = 0 as libc::c_int;
            while (*s).token.val != ')' as i32 {
                if arg_count >= 65535 as libc::c_int {
                    return js_parse_error(
                        s,
                        b"Too many call arguments\0" as *const u8 as *const libc::c_char,
                    );
                }
                if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                    break;
                }
                if js_parse_assign_expr(s) != 0 {
                    return -(1 as libc::c_int);
                }
                arg_count += 1;
                if (*s).token.val == ')' as i32 {
                    break;
                }
                if js_parse_expect(s, ',' as i32) != 0 {
                    return -(1 as libc::c_int);
                }
            }
            if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                emit_op(s, OP_array_from as libc::c_int as uint8_t);
                emit_u16(s, arg_count as uint16_t);
                emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
                emit_u32(s, arg_count as uint32_t);
                while (*s).token.val != ')' as i32 {
                    if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                        if next_token(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        if js_parse_assign_expr(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        emit_op(s, OP_append as libc::c_int as uint8_t);
                    } else {
                        if js_parse_assign_expr(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                        emit_op(s, OP_define_array_el as libc::c_int as uint8_t);
                        emit_op(s, OP_inc as libc::c_int as uint8_t);
                    }
                    if (*s).token.val == ')' as i32 {
                        break;
                    }
                    if js_parse_expect(s, ',' as i32) != 0 {
                        return -(1 as libc::c_int);
                    }
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                match opcode {
                    65 | 188 | 71 | 186 => {
                        emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                        emit_op(s, OP_apply as libc::c_int as uint8_t);
                        emit_u16(
                            s,
                            (call_type as libc::c_uint
                                == FUNC_CALL_NEW as libc::c_int as libc::c_uint)
                                as libc::c_int as uint16_t,
                        );
                    }
                    49 => {
                        emit_op(s, OP_apply_eval as libc::c_int as uint8_t);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                        (*fd).has_eval_call = TRUE as libc::c_int;
                    }
                    _ => {
                        if call_type as libc::c_uint
                            == FUNC_CALL_SUPER_CTOR as libc::c_int as libc::c_uint
                        {
                            emit_op(s, OP_apply as libc::c_int as uint8_t);
                            emit_u16(s, 1 as libc::c_int as uint16_t);
                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                            emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                            emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
                            emit_u16(s, 0 as libc::c_int as uint16_t);
                            emit_class_field_init(s);
                        } else if call_type as libc::c_uint
                            == FUNC_CALL_NEW as libc::c_int as libc::c_uint
                        {
                            emit_op(s, OP_perm3 as libc::c_int as uint8_t);
                            emit_op(s, OP_apply as libc::c_int as uint8_t);
                            emit_u16(s, 1 as libc::c_int as uint16_t);
                        } else {
                            emit_op(s, OP_undefined as libc::c_int as uint8_t);
                            emit_op(s, OP_swap as libc::c_int as uint8_t);
                            emit_op(s, OP_apply as libc::c_int as uint8_t);
                            emit_u16(s, 0 as libc::c_int as uint16_t);
                        }
                    }
                }
                current_block_366 = 17438544502371948387;
            } else {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                current_block_366 = 17303515161642976378;
            }
        }
        match current_block_366 {
            17303515161642976378 => {
                match opcode {
                    65 | 188 | 71 | 186 => {
                        emit_op(s, OP_call_method as libc::c_int as uint8_t);
                        emit_u16(s, arg_count as uint16_t);
                    }
                    49 => {
                        emit_op(s, OP_eval as libc::c_int as uint8_t);
                        emit_u16(s, arg_count as uint16_t);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                        (*fd).has_eval_call = TRUE as libc::c_int;
                    }
                    _ => {
                        if call_type as libc::c_uint
                            == FUNC_CALL_SUPER_CTOR as libc::c_int as libc::c_uint
                        {
                            emit_op(s, OP_call_constructor as libc::c_int as uint8_t);
                            emit_u16(s, arg_count as uint16_t);
                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                            emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                            emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
                            emit_u16(s, 0 as libc::c_int as uint16_t);
                            emit_class_field_init(s);
                        } else if call_type as libc::c_uint
                            == FUNC_CALL_NEW as libc::c_int as libc::c_uint
                        {
                            emit_op(s, OP_call_constructor as libc::c_int as uint8_t);
                            emit_u16(s, arg_count as uint16_t);
                        } else {
                            emit_op(s, OP_call as libc::c_int as uint8_t);
                            emit_u16(s, arg_count as uint16_t);
                        }
                    }
                }
            }
            _ => {}
        }
        call_type = FUNC_CALL_NORMAL;
    }
    if optional_chaining_label >= 0 as libc::c_int {
        emit_label(s, optional_chaining_label);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_delete(mut s: *mut JSParseState) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut name: JSAtom = 0;
    let mut opcode: libc::c_int = 0;
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    if js_parse_unary(s, (1 as libc::c_int) << 4 as libc::c_int) != 0 {
        return -(1 as libc::c_int);
    }
    let mut current_block_28: u64;
    opcode = get_prev_opcode(fd);
    match opcode {
        65 => {
            let mut val: JSValue = 0;
            let mut ret: libc::c_int = 0;
            name = get_u32(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(1 as libc::c_int as isize),
            );
            (*fd).byte_code.size = (*fd).last_opcode_pos as size_t;
            (*fd).last_opcode_pos = -(1 as libc::c_int);
            val = JS_AtomToValue((*s).ctx, name);
            ret = emit_push_const(s, val, 1 as libc::c_int);
            JS_FreeValue((*s).ctx, val);
            JS_FreeAtom((*s).ctx, name);
            if ret != 0 {
                return ret;
            }
            current_block_28 = 3481528401080234495;
        }
        71 => {
            (*fd).byte_code.size = (*fd).last_opcode_pos as size_t;
            (*fd).last_opcode_pos = -(1 as libc::c_int);
            current_block_28 = 3481528401080234495;
        }
        182 => {
            name = get_u32(
                ((*fd).byte_code.buf)
                    .offset((*fd).last_opcode_pos as isize)
                    .offset(1 as libc::c_int as isize),
            );
            if name == JS_ATOM_this as libc::c_int as libc::c_uint
                || name == JS_ATOM_new_target as libc::c_int as libc::c_uint
            {
                current_block_28 = 278533847047427854;
            } else {
                if (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                    != 0
                {
                    return js_parse_error(
                        s,
                        b"cannot delete a direct reference in strict mode\0" as *const u8
                            as *const libc::c_char,
                    )
                } else {
                    *((*fd).byte_code.buf)
                        .offset(
                            (*fd).last_opcode_pos as isize,
                        ) = OP_scope_delete_var as libc::c_int as uint8_t;
                }
                current_block_28 = 14136749492126903395;
            }
        }
        188 => {
            return js_parse_error(
                s,
                b"cannot delete a private class field\0" as *const u8
                    as *const libc::c_char,
            );
        }
        74 => {
            emit_op(s, OP_throw_error as libc::c_int as uint8_t);
            emit_atom(s, 0 as libc::c_int as JSAtom);
            emit_u8(s, 3 as libc::c_int as uint8_t);
            current_block_28 = 14136749492126903395;
        }
        _ => {
            current_block_28 = 278533847047427854;
        }
    }
    match current_block_28 {
        278533847047427854 => {
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            emit_op(s, OP_push_true as libc::c_int as uint8_t);
        }
        3481528401080234495 => {
            emit_op(s, OP_delete as libc::c_int as uint8_t);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_unary(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut op: libc::c_int = 0;
    match (*s).token.val {
        43 | 45 | 33 | 126 | -76 => {
            op = (*s).token.val;
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if js_parse_unary(s, (1 as libc::c_int) << 4 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            match op {
                45 => {
                    emit_op(s, OP_neg as libc::c_int as uint8_t);
                }
                43 => {
                    emit_op(s, OP_plus as libc::c_int as uint8_t);
                }
                33 => {
                    emit_op(s, OP_lnot as libc::c_int as uint8_t);
                }
                126 => {
                    emit_op(s, OP_not as libc::c_int as uint8_t);
                }
                -76 => {
                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                }
                _ => {
                    abort();
                }
            }
            parse_flags = 0 as libc::c_int;
        }
        -108 | -107 => {
            let mut opcode: libc::c_int = 0;
            let mut op_0: libc::c_int = 0;
            let mut scope: libc::c_int = 0;
            let mut label: libc::c_int = 0;
            let mut name: JSAtom = 0;
            op_0 = (*s).token.val;
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if js_parse_unary(s, 0 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            if get_lvalue(
                s,
                &mut opcode,
                &mut scope,
                &mut name,
                &mut label,
                0 as *mut libc::c_int,
                TRUE as libc::c_int,
                op_0,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            emit_op(
                s,
                (OP_dec as libc::c_int + op_0 - TOK_DEC as libc::c_int) as uint8_t,
            );
            put_lvalue(
                s,
                opcode,
                scope,
                name,
                label,
                PUT_LVALUE_KEEP_TOP,
                FALSE as libc::c_int,
            );
        }
        -75 => {
            let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if js_parse_unary(s, (1 as libc::c_int) << 4 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            fd = (*s).cur_func;
            if get_prev_opcode(fd) == OP_scope_get_var as libc::c_int {
                *((*fd).byte_code.buf)
                    .offset(
                        (*fd).last_opcode_pos as isize,
                    ) = OP_scope_get_var_undef as libc::c_int as uint8_t;
            }
            emit_op(s, OP_typeof as libc::c_int as uint8_t);
            parse_flags = 0 as libc::c_int;
        }
        -77 => {
            if js_parse_delete(s) != 0 {
                return -(1 as libc::c_int);
            }
            parse_flags = 0 as libc::c_int;
        }
        -40 => {
            if (*(*s).cur_func).func_kind() as libc::c_int & JS_FUNC_ASYNC as libc::c_int
                == 0
            {
                return js_parse_error(
                    s,
                    b"unexpected 'await' keyword\0" as *const u8 as *const libc::c_char,
                );
            }
            if (*(*s).cur_func).in_function_body == 0 {
                return js_parse_error(
                    s,
                    b"await in default expression\0" as *const u8 as *const libc::c_char,
                );
            }
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if js_parse_unary(s, (1 as libc::c_int) << 4 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_await as libc::c_int as uint8_t);
            parse_flags = 0 as libc::c_int;
        }
        _ => {
            if js_parse_postfix_expr(
                s,
                parse_flags & (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            if (*s).got_lf == 0
                && ((*s).token.val == TOK_DEC as libc::c_int
                    || (*s).token.val == TOK_INC as libc::c_int)
            {
                let mut opcode_0: libc::c_int = 0;
                let mut op_1: libc::c_int = 0;
                let mut scope_0: libc::c_int = 0;
                let mut label_0: libc::c_int = 0;
                let mut name_0: JSAtom = 0;
                op_1 = (*s).token.val;
                if get_lvalue(
                    s,
                    &mut opcode_0,
                    &mut scope_0,
                    &mut name_0,
                    &mut label_0,
                    0 as *mut libc::c_int,
                    TRUE as libc::c_int,
                    op_1,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
                emit_op(
                    s,
                    (OP_post_dec as libc::c_int + op_1 - TOK_DEC as libc::c_int)
                        as uint8_t,
                );
                put_lvalue(
                    s,
                    opcode_0,
                    scope_0,
                    name_0,
                    label_0,
                    PUT_LVALUE_KEEP_SECOND,
                    FALSE as libc::c_int,
                );
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
            }
        }
    }
    if parse_flags
        & ((1 as libc::c_int) << 3 as libc::c_int
            | (1 as libc::c_int) << 4 as libc::c_int) != 0
    {
        if (*s).token.val == TOK_POW as libc::c_int {
            if parse_flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                JS_ThrowSyntaxError(
                    (*s).ctx,
                    b"unparenthesized unary expression can't appear on the left-hand side of '**'\0"
                        as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            if js_parse_unary(s, (1 as libc::c_int) << 3 as libc::c_int) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_pow as libc::c_int as uint8_t);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_expr_binary(
    mut s: *mut JSParseState,
    mut level: libc::c_int,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut op: libc::c_int = 0;
    let mut opcode: libc::c_int = 0;
    if level == 0 as libc::c_int {
        return js_parse_unary(
            s,
            parse_flags & (1 as libc::c_int) << 2 as libc::c_int
                | (1 as libc::c_int) << 3 as libc::c_int,
        );
    }
    if js_parse_expr_binary(s, level - 1 as libc::c_int, parse_flags) != 0 {
        return -(1 as libc::c_int);
    }
    loop {
        op = (*s).token.val;
        match level {
            1 => {
                match op {
                    42 => {
                        opcode = OP_mul as libc::c_int;
                    }
                    47 => {
                        opcode = OP_div as libc::c_int;
                    }
                    37 => {
                        opcode = OP_mod as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            2 => {
                match op {
                    43 => {
                        opcode = OP_add as libc::c_int;
                    }
                    45 => {
                        opcode = OP_sub as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            3 => {
                match op {
                    -106 => {
                        opcode = OP_shl as libc::c_int;
                    }
                    -105 => {
                        opcode = OP_sar as libc::c_int;
                    }
                    -104 => {
                        opcode = OP_shr as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            4 => {
                match op {
                    60 => {
                        opcode = OP_lt as libc::c_int;
                    }
                    62 => {
                        opcode = OP_gt as libc::c_int;
                    }
                    -102 => {
                        opcode = OP_lte as libc::c_int;
                    }
                    -100 => {
                        opcode = OP_gte as libc::c_int;
                    }
                    -72 => {
                        opcode = OP_instanceof as libc::c_int;
                    }
                    -73 => {
                        if parse_flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                            opcode = OP_in as libc::c_int;
                        } else {
                            return 0 as libc::c_int
                        }
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            5 => {
                match op {
                    -99 => {
                        opcode = OP_eq as libc::c_int;
                    }
                    -97 => {
                        opcode = OP_neq as libc::c_int;
                    }
                    -98 => {
                        opcode = OP_strict_eq as libc::c_int;
                    }
                    -96 => {
                        opcode = OP_strict_neq as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            6 => {
                match op {
                    38 => {
                        opcode = OP_and as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            7 => {
                match op {
                    94 => {
                        opcode = OP_xor as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            8 => {
                match op {
                    124 => {
                        opcode = OP_or as libc::c_int;
                    }
                    _ => return 0 as libc::c_int,
                }
            }
            _ => {
                abort();
            }
        }
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if js_parse_expr_binary(
            s,
            level - 1 as libc::c_int,
            parse_flags & !((1 as libc::c_int) << 2 as libc::c_int),
        ) != 0
        {
            return -(1 as libc::c_int);
        }
        emit_op(s, opcode as uint8_t);
    };
}
unsafe extern "C" fn js_parse_logical_and_or(
    mut s: *mut JSParseState,
    mut op: libc::c_int,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut label1: libc::c_int = 0;
    if op == TOK_LAND as libc::c_int {
        if js_parse_expr_binary(s, 8 as libc::c_int, parse_flags) != 0 {
            return -(1 as libc::c_int);
        }
    } else if js_parse_logical_and_or(s, TOK_LAND as libc::c_int, parse_flags) != 0 {
        return -(1 as libc::c_int)
    }
    if (*s).token.val == op {
        label1 = new_label(s);
        loop {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_dup as libc::c_int as uint8_t);
            emit_goto(
                s,
                if op == TOK_LAND as libc::c_int {
                    OP_if_false as libc::c_int
                } else {
                    OP_if_true as libc::c_int
                },
                label1,
            );
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            if op == TOK_LAND as libc::c_int {
                if js_parse_expr_binary(
                    s,
                    8 as libc::c_int,
                    parse_flags & !((1 as libc::c_int) << 2 as libc::c_int),
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
            } else if js_parse_logical_and_or(
                s,
                TOK_LAND as libc::c_int,
                parse_flags & !((1 as libc::c_int) << 2 as libc::c_int),
            ) != 0
            {
                return -(1 as libc::c_int)
            }
            if !((*s).token.val != op) {
                continue;
            }
            if (*s).token.val == TOK_DOUBLE_QUESTION_MARK as libc::c_int {
                return js_parse_error(
                    s,
                    b"cannot mix ?? with && or ||\0" as *const u8 as *const libc::c_char,
                );
            }
            break;
        }
        emit_label(s, label1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_coalesce_expr(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut label1: libc::c_int = 0;
    if js_parse_logical_and_or(s, TOK_LOR as libc::c_int, parse_flags) != 0 {
        return -(1 as libc::c_int);
    }
    if (*s).token.val == TOK_DOUBLE_QUESTION_MARK as libc::c_int {
        label1 = new_label(s);
        loop {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_dup as libc::c_int as uint8_t);
            emit_op(s, OP_is_undefined_or_null as libc::c_int as uint8_t);
            emit_goto(s, OP_if_false as libc::c_int, label1);
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            if js_parse_expr_binary(
                s,
                8 as libc::c_int,
                parse_flags & !((1 as libc::c_int) << 2 as libc::c_int),
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            if (*s).token.val != TOK_DOUBLE_QUESTION_MARK as libc::c_int {
                break;
            }
        }
        emit_label(s, label1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_cond_expr(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut label1: libc::c_int = 0;
    let mut label2: libc::c_int = 0;
    if js_parse_coalesce_expr(s, parse_flags) != 0 {
        return -(1 as libc::c_int);
    }
    if (*s).token.val == '?' as i32 {
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        label1 = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
        if js_parse_assign_expr(s) != 0 {
            return -(1 as libc::c_int);
        }
        if js_parse_expect(s, ':' as i32) != 0 {
            return -(1 as libc::c_int);
        }
        label2 = emit_goto(s, OP_goto as libc::c_int, -(1 as libc::c_int));
        emit_label(s, label1);
        if js_parse_assign_expr2(s, parse_flags & (1 as libc::c_int) << 0 as libc::c_int)
            != 0
        {
            return -(1 as libc::c_int);
        }
        emit_label(s, label2);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_assign_expr2(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut opcode: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut scope: libc::c_int = 0;
    let mut name0: JSAtom = 0 as libc::c_int as JSAtom;
    let mut name: JSAtom = 0;
    if (*s).token.val == TOK_YIELD as libc::c_int {
        let mut is_star: BOOL = FALSE as libc::c_int;
        let mut is_async: BOOL = 0;
        if (*(*s).cur_func).func_kind() as libc::c_int & JS_FUNC_GENERATOR as libc::c_int
            == 0
        {
            return js_parse_error(
                s,
                b"unexpected 'yield' keyword\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*(*s).cur_func).in_function_body == 0 {
            return js_parse_error(
                s,
                b"yield in default expression\0" as *const u8 as *const libc::c_char,
            );
        }
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if (*s).token.val != ';' as i32 && (*s).token.val != ')' as i32
            && (*s).token.val != ']' as i32 && (*s).token.val != '}' as i32
            && (*s).token.val != ',' as i32 && (*s).token.val != ':' as i32
            && (*s).got_lf == 0
        {
            if (*s).token.val == '*' as i32 {
                is_star = TRUE as libc::c_int;
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
            }
            if js_parse_assign_expr2(s, parse_flags) != 0 {
                return -(1 as libc::c_int);
            }
        } else {
            emit_op(s, OP_undefined as libc::c_int as uint8_t);
        }
        is_async = ((*(*s).cur_func).func_kind() as libc::c_int
            == JS_FUNC_ASYNC_GENERATOR as libc::c_int) as libc::c_int;
        if is_star != 0 {
            let mut label_loop: libc::c_int = 0;
            let mut label_return: libc::c_int = 0;
            let mut label_next: libc::c_int = 0;
            let mut label_return1: libc::c_int = 0;
            let mut label_yield: libc::c_int = 0;
            let mut label_throw: libc::c_int = 0;
            let mut label_throw1: libc::c_int = 0;
            let mut label_throw2: libc::c_int = 0;
            label_loop = new_label(s);
            label_yield = new_label(s);
            emit_op(
                s,
                (if is_async != 0 {
                    OP_for_await_of_start as libc::c_int
                } else {
                    OP_for_of_start as libc::c_int
                }) as uint8_t,
            );
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            emit_op(s, OP_undefined as libc::c_int as uint8_t);
            emit_op(s, OP_undefined as libc::c_int as uint8_t);
            emit_label(s, label_loop);
            emit_op(s, OP_iterator_next as libc::c_int as uint8_t);
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_op(s, OP_iterator_check_object as libc::c_int as uint8_t);
            emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_done as libc::c_int as JSAtom);
            label_next = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            emit_label(s, label_yield);
            if is_async != 0 {
                emit_op(s, OP_get_field as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_value as libc::c_int as JSAtom);
                emit_op(s, OP_await as libc::c_int as uint8_t);
                emit_op(s, OP_async_yield_star as libc::c_int as uint8_t);
            } else {
                emit_op(s, OP_yield_star as libc::c_int as uint8_t);
            }
            emit_op(s, OP_dup as libc::c_int as uint8_t);
            label_return = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            emit_goto(s, OP_goto as libc::c_int, label_loop);
            emit_label(s, label_return);
            emit_op(s, OP_push_i32 as libc::c_int as uint8_t);
            emit_u32(s, 2 as libc::c_int as uint32_t);
            emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
            label_throw = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_op(s, OP_iterator_call as libc::c_int as uint8_t);
            emit_u8(s, 0 as libc::c_int as uint8_t);
            label_return1 = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_op(s, OP_iterator_check_object as libc::c_int as uint8_t);
            emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_done as libc::c_int as JSAtom);
            emit_goto(s, OP_if_false as libc::c_int, label_yield);
            emit_op(s, OP_get_field as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_value as libc::c_int as JSAtom);
            emit_label(s, label_return1);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            emit_return(s, TRUE as libc::c_int);
            emit_label(s, label_throw);
            emit_op(s, OP_iterator_call as libc::c_int as uint8_t);
            emit_u8(s, 1 as libc::c_int as uint8_t);
            label_throw1 = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_op(s, OP_iterator_check_object as libc::c_int as uint8_t);
            emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_done as libc::c_int as JSAtom);
            emit_goto(s, OP_if_false as libc::c_int, label_yield);
            emit_goto(s, OP_goto as libc::c_int, label_next);
            emit_label(s, label_throw1);
            emit_op(s, OP_iterator_call as libc::c_int as uint8_t);
            emit_u8(s, 2 as libc::c_int as uint8_t);
            label_throw2 = emit_goto(s, OP_if_true as libc::c_int, -(1 as libc::c_int));
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_label(s, label_throw2);
            emit_op(s, OP_throw_error as libc::c_int as uint8_t);
            emit_atom(s, 0 as libc::c_int as JSAtom);
            emit_u8(s, 4 as libc::c_int as uint8_t);
            emit_label(s, label_next);
            emit_op(s, OP_get_field as libc::c_int as uint8_t);
            emit_atom(s, JS_ATOM_value as libc::c_int as JSAtom);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            emit_op(s, OP_nip as libc::c_int as uint8_t);
        } else {
            let mut label_next_0: libc::c_int = 0;
            if is_async != 0 {
                emit_op(s, OP_await as libc::c_int as uint8_t);
            }
            emit_op(s, OP_yield as libc::c_int as uint8_t);
            label_next_0 = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
            emit_return(s, TRUE as libc::c_int);
            emit_label(s, label_next_0);
        }
        return 0 as libc::c_int;
    }
    if (*s).token.val == TOK_IDENT as libc::c_int {
        name0 = (*s).token.u.ident.atom;
    }
    if js_parse_cond_expr(s, parse_flags | (1 as libc::c_int) << 2 as libc::c_int) != 0 {
        return -(1 as libc::c_int);
    }
    op = (*s).token.val;
    if op == '=' as i32
        || op >= TOK_MUL_ASSIGN as libc::c_int && op <= TOK_POW_ASSIGN as libc::c_int
    {
        let mut label: libc::c_int = 0;
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if get_lvalue(
            s,
            &mut opcode,
            &mut scope,
            &mut name,
            &mut label,
            0 as *mut libc::c_int,
            (op != '=' as i32) as libc::c_int,
            op,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
        if js_parse_assign_expr2(s, parse_flags) != 0 {
            JS_FreeAtom((*s).ctx, name);
            return -(1 as libc::c_int);
        }
        if op == '=' as i32 {
            if opcode == OP_get_ref_value as libc::c_int && name == name0 {
                set_object_name(s, name);
            }
        } else {
            static mut assign_opcodes: [uint8_t; 12] = [
                OP_mul as libc::c_int as uint8_t,
                OP_div as libc::c_int as uint8_t,
                OP_mod as libc::c_int as uint8_t,
                OP_add as libc::c_int as uint8_t,
                OP_sub as libc::c_int as uint8_t,
                OP_shl as libc::c_int as uint8_t,
                OP_sar as libc::c_int as uint8_t,
                OP_shr as libc::c_int as uint8_t,
                OP_and as libc::c_int as uint8_t,
                OP_xor as libc::c_int as uint8_t,
                OP_or as libc::c_int as uint8_t,
                OP_pow as libc::c_int as uint8_t,
            ];
            op = assign_opcodes[(op - TOK_MUL_ASSIGN as libc::c_int) as usize]
                as libc::c_int;
            emit_op(s, op as uint8_t);
        }
        put_lvalue(
            s,
            opcode,
            scope,
            name,
            label,
            PUT_LVALUE_KEEP_TOP,
            FALSE as libc::c_int,
        );
    } else if op >= TOK_LAND_ASSIGN as libc::c_int
        && op <= TOK_DOUBLE_QUESTION_MARK_ASSIGN as libc::c_int
    {
        let mut label_0: libc::c_int = 0;
        let mut label1: libc::c_int = 0;
        let mut depth_lvalue: libc::c_int = 0;
        let mut label2: libc::c_int = 0;
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if get_lvalue(
            s,
            &mut opcode,
            &mut scope,
            &mut name,
            &mut label_0,
            &mut depth_lvalue,
            TRUE as libc::c_int,
            op,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
        emit_op(s, OP_dup as libc::c_int as uint8_t);
        if op == TOK_DOUBLE_QUESTION_MARK_ASSIGN as libc::c_int {
            emit_op(s, OP_is_undefined_or_null as libc::c_int as uint8_t);
        }
        label1 = emit_goto(
            s,
            if op == TOK_LOR_ASSIGN as libc::c_int {
                OP_if_true as libc::c_int
            } else {
                OP_if_false as libc::c_int
            },
            -(1 as libc::c_int),
        );
        emit_op(s, OP_drop as libc::c_int as uint8_t);
        if js_parse_assign_expr2(s, parse_flags) != 0 {
            JS_FreeAtom((*s).ctx, name);
            return -(1 as libc::c_int);
        }
        if opcode == OP_get_ref_value as libc::c_int && name == name0 {
            set_object_name(s, name);
        }
        match depth_lvalue {
            1 => {
                emit_op(s, OP_insert2 as libc::c_int as uint8_t);
            }
            2 => {
                emit_op(s, OP_insert3 as libc::c_int as uint8_t);
            }
            3 => {
                emit_op(s, OP_insert4 as libc::c_int as uint8_t);
            }
            _ => {
                abort();
            }
        }
        put_lvalue(
            s,
            opcode,
            scope,
            name,
            label_0,
            PUT_LVALUE_NOKEEP_DEPTH,
            FALSE as libc::c_int,
        );
        label2 = emit_goto(s, OP_goto as libc::c_int, -(1 as libc::c_int));
        emit_label(s, label1);
        while depth_lvalue != 0 as libc::c_int {
            emit_op(s, OP_nip as libc::c_int as uint8_t);
            depth_lvalue -= 1;
        }
        emit_label(s, label2);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_assign_expr(mut s: *mut JSParseState) -> libc::c_int {
    return js_parse_assign_expr2(s, (1 as libc::c_int) << 0 as libc::c_int);
}
unsafe extern "C" fn js_parse_expr2(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
) -> libc::c_int {
    let mut comma: BOOL = FALSE as libc::c_int;
    loop {
        if js_parse_assign_expr2(s, parse_flags) != 0 {
            return -(1 as libc::c_int);
        }
        if comma != 0 {
            (*(*s).cur_func).last_opcode_pos = -(1 as libc::c_int);
        }
        if (*s).token.val != ',' as i32 {
            break;
        }
        comma = TRUE as libc::c_int;
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        emit_op(s, OP_drop as libc::c_int as uint8_t);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_expr(mut s: *mut JSParseState) -> libc::c_int {
    return js_parse_expr2(s, (1 as libc::c_int) << 0 as libc::c_int);
}
unsafe extern "C" fn push_break_entry(
    mut fd: *mut JSFunctionDef,
    mut be: *mut BlockEnv,
    mut label_name: JSAtom,
    mut label_break: libc::c_int,
    mut label_cont: libc::c_int,
    mut drop_count: libc::c_int,
) {
    let ref mut fresh450 = (*be).prev;
    *fresh450 = (*fd).top_break;
    let ref mut fresh451 = (*fd).top_break;
    *fresh451 = be;
    (*be).label_name = label_name;
    (*be).label_break = label_break;
    (*be).label_cont = label_cont;
    (*be).drop_count = drop_count;
    (*be).label_finally = -(1 as libc::c_int);
    (*be).scope_level = (*fd).scope_level;
    (*be).has_iterator = FALSE as libc::c_int;
}
unsafe extern "C" fn pop_break_entry(mut fd: *mut JSFunctionDef) {
    let mut be: *mut BlockEnv = 0 as *mut BlockEnv;
    be = (*fd).top_break;
    let ref mut fresh452 = (*fd).top_break;
    *fresh452 = (*be).prev;
}
unsafe extern "C" fn emit_break(
    mut s: *mut JSParseState,
    mut name: JSAtom,
    mut is_cont: libc::c_int,
) -> libc::c_int {
    let mut top: *mut BlockEnv = 0 as *mut BlockEnv;
    let mut i: libc::c_int = 0;
    let mut scope_level: libc::c_int = 0;
    scope_level = (*(*s).cur_func).scope_level;
    top = (*(*s).cur_func).top_break;
    while !top.is_null() {
        close_scopes(s, scope_level, (*top).scope_level);
        scope_level = (*top).scope_level;
        if is_cont != 0 && (*top).label_cont != -(1 as libc::c_int)
            && (name == 0 as libc::c_int as libc::c_uint || (*top).label_name == name)
        {
            emit_goto(s, OP_goto as libc::c_int, (*top).label_cont);
            return 0 as libc::c_int;
        }
        if is_cont == 0 && (*top).label_break != -(1 as libc::c_int)
            && (name == 0 as libc::c_int as libc::c_uint || (*top).label_name == name)
        {
            emit_goto(s, OP_goto as libc::c_int, (*top).label_break);
            return 0 as libc::c_int;
        }
        i = 0 as libc::c_int;
        if (*top).has_iterator != 0 {
            emit_op(s, OP_iterator_close as libc::c_int as uint8_t);
            i += 3 as libc::c_int;
        }
        while i < (*top).drop_count {
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            i += 1;
        }
        if (*top).label_finally != -(1 as libc::c_int) {
            emit_op(s, OP_undefined as libc::c_int as uint8_t);
            emit_goto(s, OP_gosub as libc::c_int, (*top).label_finally);
            emit_op(s, OP_drop as libc::c_int as uint8_t);
        }
        top = (*top).prev;
    }
    if name == 0 as libc::c_int as libc::c_uint {
        if is_cont != 0 {
            return js_parse_error(
                s,
                b"continue must be inside loop\0" as *const u8 as *const libc::c_char,
            )
        } else {
            return js_parse_error(
                s,
                b"break must be inside loop or switch\0" as *const u8
                    as *const libc::c_char,
            )
        }
    } else {
        return js_parse_error(
            s,
            b"break/continue label not found\0" as *const u8 as *const libc::c_char,
        )
    };
}
unsafe extern "C" fn emit_return(mut s: *mut JSParseState, mut hasval: BOOL) {
    let mut top: *mut BlockEnv = 0 as *mut BlockEnv;
    let mut drop_count: libc::c_int = 0;
    drop_count = 0 as libc::c_int;
    top = (*(*s).cur_func).top_break;
    while !top.is_null() {
        if (*top).has_iterator != 0 {
            if hasval == 0 {
                emit_op(s, OP_undefined as libc::c_int as uint8_t);
                hasval = TRUE as libc::c_int;
            }
            emit_op(s, OP_iterator_close_return as libc::c_int as uint8_t);
            if (*(*s).cur_func).func_kind() as libc::c_int
                == JS_FUNC_ASYNC_GENERATOR as libc::c_int
            {
                let mut label_next: libc::c_int = 0;
                let mut label_next2: libc::c_int = 0;
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                emit_op(s, OP_get_field2 as libc::c_int as uint8_t);
                emit_atom(s, JS_ATOM_return as libc::c_int as JSAtom);
                emit_op(s, OP_dup as libc::c_int as uint8_t);
                emit_op(s, OP_is_undefined_or_null as libc::c_int as uint8_t);
                label_next = emit_goto(
                    s,
                    OP_if_true as libc::c_int,
                    -(1 as libc::c_int),
                );
                emit_op(s, OP_call_method as libc::c_int as uint8_t);
                emit_u16(s, 0 as libc::c_int as uint16_t);
                emit_op(s, OP_iterator_check_object as libc::c_int as uint8_t);
                emit_op(s, OP_await as libc::c_int as uint8_t);
                label_next2 = emit_goto(s, OP_goto as libc::c_int, -(1 as libc::c_int));
                emit_label(s, label_next);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
                emit_label(s, label_next2);
                emit_op(s, OP_drop as libc::c_int as uint8_t);
            } else {
                emit_op(s, OP_iterator_close as libc::c_int as uint8_t);
            }
            drop_count = -(3 as libc::c_int);
        }
        drop_count += (*top).drop_count;
        if (*top).label_finally != -(1 as libc::c_int) {
            while drop_count != 0 {
                emit_op(
                    s,
                    (if hasval != 0 {
                        OP_nip as libc::c_int
                    } else {
                        OP_drop as libc::c_int
                    }) as uint8_t,
                );
                drop_count -= 1;
            }
            if hasval == 0 {
                emit_op(s, OP_undefined as libc::c_int as uint8_t);
                hasval = TRUE as libc::c_int;
            }
            emit_goto(s, OP_gosub as libc::c_int, (*top).label_finally);
        }
        top = (*top).prev;
    }
    if (*(*s).cur_func).is_derived_class_constructor != 0 {
        let mut label_return: libc::c_int = 0;
        if hasval != 0 {
            emit_op(s, OP_check_ctor_return as libc::c_int as uint8_t);
            label_return = emit_goto(s, OP_if_false as libc::c_int, -(1 as libc::c_int));
            emit_op(s, OP_drop as libc::c_int as uint8_t);
        } else {
            label_return = -(1 as libc::c_int);
        }
        emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
        emit_atom(s, JS_ATOM_this as libc::c_int as JSAtom);
        emit_u16(s, 0 as libc::c_int as uint16_t);
        emit_label(s, label_return);
        emit_op(s, OP_return as libc::c_int as uint8_t);
    } else if (*(*s).cur_func).func_kind() as libc::c_int
        != JS_FUNC_NORMAL as libc::c_int
    {
        if hasval == 0 {
            emit_op(s, OP_undefined as libc::c_int as uint8_t);
        } else if (*(*s).cur_func).func_kind() as libc::c_int
            == JS_FUNC_ASYNC_GENERATOR as libc::c_int
        {
            emit_op(s, OP_await as libc::c_int as uint8_t);
        }
        emit_op(s, OP_return_async as libc::c_int as uint8_t);
    } else {
        emit_op(
            s,
            (if hasval != 0 {
                OP_return as libc::c_int
            } else {
                OP_return_undef as libc::c_int
            }) as uint8_t,
        );
    };
}
unsafe extern "C" fn js_parse_statement(mut s: *mut JSParseState) -> libc::c_int {
    return js_parse_statement_or_decl(s, 0 as libc::c_int);
}
unsafe extern "C" fn js_parse_block(mut s: *mut JSParseState) -> libc::c_int {
    if js_parse_expect(s, '{' as i32) != 0 {
        return -(1 as libc::c_int);
    }
    if (*s).token.val != '}' as i32 {
        push_scope(s);
        loop {
            if js_parse_statement_or_decl(
                s,
                (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            if (*s).token.val == '}' as i32 {
                break;
            }
        }
        pop_scope(s);
    }
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_var(
    mut s: *mut JSParseState,
    mut parse_flags: libc::c_int,
    mut tok: libc::c_int,
    mut export_flag: BOOL,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut name: JSAtom = 0 as libc::c_int as JSAtom;
    loop {
        if (*s).token.val == TOK_IDENT as libc::c_int {
            if (*s).token.u.ident.is_reserved != 0 {
                return js_parse_error_reserved_identifier(s);
            }
            name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
            if name == JS_ATOM_let as libc::c_int as libc::c_uint
                && (tok == TOK_LET as libc::c_int || tok == TOK_CONST as libc::c_int)
            {
                js_parse_error(
                    s,
                    b"'let' is not a valid lexical identifier\0" as *const u8
                        as *const libc::c_char,
                );
                current_block = 13741721601950477407;
                break;
            } else {
                if next_token(s) != 0 {
                    current_block = 13741721601950477407;
                    break;
                }
                if js_define_var(s, name, tok) != 0 {
                    current_block = 13741721601950477407;
                    break;
                }
                if export_flag != 0 {
                    if (add_export_entry(
                        s,
                        (*(*s).cur_func).module,
                        name,
                        name,
                        JS_EXPORT_TYPE_LOCAL,
                    ))
                        .is_null()
                    {
                        current_block = 13741721601950477407;
                        break;
                    }
                }
                if (*s).token.val == '=' as i32 {
                    if next_token(s) != 0 {
                        current_block = 13741721601950477407;
                        break;
                    }
                    if tok == TOK_VAR as libc::c_int {
                        let mut opcode: libc::c_int = 0;
                        let mut scope: libc::c_int = 0;
                        let mut label: libc::c_int = 0;
                        let mut name1: JSAtom = 0;
                        emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                        emit_atom(s, name);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                        if get_lvalue(
                            s,
                            &mut opcode,
                            &mut scope,
                            &mut name1,
                            &mut label,
                            0 as *mut libc::c_int,
                            FALSE as libc::c_int,
                            '=' as i32,
                        ) < 0 as libc::c_int
                        {
                            current_block = 13741721601950477407;
                            break;
                        }
                        if js_parse_assign_expr2(s, parse_flags) != 0 {
                            JS_FreeAtom(ctx, name1);
                            current_block = 13741721601950477407;
                            break;
                        } else {
                            set_object_name(s, name);
                            put_lvalue(
                                s,
                                opcode,
                                scope,
                                name1,
                                label,
                                PUT_LVALUE_NOKEEP,
                                FALSE as libc::c_int,
                            );
                        }
                    } else {
                        if js_parse_assign_expr2(s, parse_flags) != 0 {
                            current_block = 13741721601950477407;
                            break;
                        }
                        set_object_name(s, name);
                        emit_op(
                            s,
                            (if tok == TOK_CONST as libc::c_int
                                || tok == TOK_LET as libc::c_int
                            {
                                OP_scope_put_var_init as libc::c_int
                            } else {
                                OP_scope_put_var as libc::c_int
                            }) as uint8_t,
                        );
                        emit_atom(s, name);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                    }
                } else if tok == TOK_CONST as libc::c_int {
                    js_parse_error(
                        s,
                        b"missing initializer for const variable\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 13741721601950477407;
                    break;
                } else if tok == TOK_LET as libc::c_int {
                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                    emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                    emit_atom(s, name);
                    emit_u16(s, (*fd).scope_level as uint16_t);
                }
                JS_FreeAtom(ctx, name);
            }
        } else {
            let mut skip_bits: libc::c_int = 0;
            if ((*s).token.val == '[' as i32 || (*s).token.val == '{' as i32)
                && js_parse_skip_parens_token(s, &mut skip_bits, FALSE as libc::c_int)
                    == '=' as i32
            {
                emit_op(s, OP_undefined as libc::c_int as uint8_t);
                if js_parse_destructuring_element(
                    s,
                    tok,
                    0 as libc::c_int,
                    TRUE as libc::c_int,
                    skip_bits & (1 as libc::c_int) << 1 as libc::c_int,
                    TRUE as libc::c_int,
                ) < 0 as libc::c_int
                {
                    return -(1 as libc::c_int);
                }
            } else {
                return js_parse_error(
                    s,
                    b"variable name expected\0" as *const u8 as *const libc::c_char,
                )
            }
        }
        if (*s).token.val != ',' as i32 {
            current_block = 1854459640724737493;
            break;
        }
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
    }
    match current_block {
        1854459640724737493 => return 0 as libc::c_int,
        _ => {
            JS_FreeAtom(ctx, name);
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn is_label(mut s: *mut JSParseState) -> BOOL {
    return ((*s).token.val == TOK_IDENT as libc::c_int
        && (*s).token.u.ident.is_reserved == 0
        && peek_token(s, FALSE as libc::c_int) == ':' as i32) as libc::c_int;
}
unsafe extern "C" fn is_let(
    mut s: *mut JSParseState,
    mut decl_mask: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = FALSE as libc::c_int;
    if token_is_pseudo_keyword(s, JS_ATOM_let as libc::c_int as JSAtom) != 0 {
        let mut pos: JSParsePos = JSParsePos {
            last_line_num: 0,
            line_num: 0,
            got_lf: 0,
            ptr: 0 as *const uint8_t,
        };
        js_parse_get_pos(s, &mut pos);
        if next_token(s) != 0 {
            res = -(1 as libc::c_int);
        } else if (*s).token.val == '[' as i32 {
            res = TRUE as libc::c_int;
        } else if (*s).token.val == '{' as i32
            || (*s).token.val == TOK_IDENT as libc::c_int
                && (*s).token.u.ident.is_reserved == 0
            || (*s).token.val == TOK_LET as libc::c_int
            || (*s).token.val == TOK_YIELD as libc::c_int
            || (*s).token.val == TOK_AWAIT as libc::c_int
        {
            if (*s).last_line_num == (*s).token.line_num
                || decl_mask & (1 as libc::c_int) << 2 as libc::c_int != 0
            {
                res = TRUE as libc::c_int;
            }
        }
        if js_parse_seek_token(s, &mut pos) != 0 {
            res = -(1 as libc::c_int);
        }
    }
    return res;
}
unsafe extern "C" fn js_parse_for_in_of(
    mut s: *mut JSParseState,
    mut label_name: libc::c_int,
    mut is_async: BOOL,
) -> libc::c_int {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut var_name: JSAtom = 0;
    let mut has_initializer: BOOL = 0;
    let mut is_for_of: BOOL = 0;
    let mut has_destructuring: BOOL = 0;
    let mut tok: libc::c_int = 0;
    let mut tok1: libc::c_int = 0;
    let mut opcode: libc::c_int = 0;
    let mut scope: libc::c_int = 0;
    let mut block_scope_level: libc::c_int = 0;
    let mut label_next: libc::c_int = 0;
    let mut label_expr: libc::c_int = 0;
    let mut label_cont: libc::c_int = 0;
    let mut label_body: libc::c_int = 0;
    let mut label_break: libc::c_int = 0;
    let mut pos_next: libc::c_int = 0;
    let mut pos_expr: libc::c_int = 0;
    let mut break_entry: BlockEnv = BlockEnv {
        prev: 0 as *mut BlockEnv,
        label_name: 0,
        label_break: 0,
        label_cont: 0,
        drop_count: 0,
        label_finally: 0,
        scope_level: 0,
        has_iterator: 0,
    };
    has_initializer = FALSE as libc::c_int;
    has_destructuring = FALSE as libc::c_int;
    is_for_of = FALSE as libc::c_int;
    block_scope_level = (*fd).scope_level;
    label_cont = new_label(s);
    label_body = new_label(s);
    label_break = new_label(s);
    label_next = new_label(s);
    push_scope(s);
    push_break_entry(
        (*s).cur_func,
        &mut break_entry,
        label_name as JSAtom,
        label_break,
        label_cont,
        1 as libc::c_int,
    );
    break_entry.scope_level = block_scope_level;
    label_expr = emit_goto(s, OP_goto as libc::c_int, -(1 as libc::c_int));
    pos_next = (*(*s).cur_func).byte_code.size as libc::c_int;
    emit_label(s, label_next);
    tok = (*s).token.val;
    match is_let(s, (1 as libc::c_int) << 2 as libc::c_int) {
        1 => {
            tok = TOK_LET as libc::c_int;
        }
        0 => {}
        _ => return -(1 as libc::c_int),
    }
    if tok == TOK_VAR as libc::c_int || tok == TOK_LET as libc::c_int
        || tok == TOK_CONST as libc::c_int
    {
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if !((*s).token.val == TOK_IDENT as libc::c_int
            && (*s).token.u.ident.is_reserved == 0)
        {
            if (*s).token.val == '[' as i32 || (*s).token.val == '{' as i32 {
                if js_parse_destructuring_element(
                    s,
                    tok,
                    0 as libc::c_int,
                    TRUE as libc::c_int,
                    -(1 as libc::c_int),
                    FALSE as libc::c_int,
                ) < 0 as libc::c_int
                {
                    return -(1 as libc::c_int);
                }
                has_destructuring = TRUE as libc::c_int;
            } else {
                return js_parse_error(
                    s,
                    b"variable name expected\0" as *const u8 as *const libc::c_char,
                )
            }
            var_name = 0 as libc::c_int as JSAtom;
        } else {
            var_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
            if next_token(s) != 0 {
                JS_FreeAtom((*s).ctx, var_name);
                return -(1 as libc::c_int);
            }
            if js_define_var(s, var_name, tok) != 0 {
                JS_FreeAtom((*s).ctx, var_name);
                return -(1 as libc::c_int);
            }
            emit_op(
                s,
                (if tok == TOK_CONST as libc::c_int || tok == TOK_LET as libc::c_int {
                    OP_scope_put_var_init as libc::c_int
                } else {
                    OP_scope_put_var as libc::c_int
                }) as uint8_t,
            );
            emit_atom(s, var_name);
            emit_u16(s, (*fd).scope_level as uint16_t);
        }
    } else {
        let mut skip_bits: libc::c_int = 0;
        if ((*s).token.val == '[' as i32 || (*s).token.val == '{' as i32)
            && {
                tok1 = js_parse_skip_parens_token(
                    s,
                    &mut skip_bits,
                    FALSE as libc::c_int,
                );
                tok1 == TOK_IN as libc::c_int || tok1 == TOK_OF as libc::c_int
            }
        {
            if js_parse_destructuring_element(
                s,
                0 as libc::c_int,
                0 as libc::c_int,
                TRUE as libc::c_int,
                skip_bits & (1 as libc::c_int) << 1 as libc::c_int,
                TRUE as libc::c_int,
            ) < 0 as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        } else {
            let mut lvalue_label: libc::c_int = 0;
            if js_parse_left_hand_side_expr(s) != 0 {
                return -(1 as libc::c_int);
            }
            if get_lvalue(
                s,
                &mut opcode,
                &mut scope,
                &mut var_name,
                &mut lvalue_label,
                0 as *mut libc::c_int,
                FALSE as libc::c_int,
                TOK_FOR as libc::c_int,
            ) != 0
            {
                return -(1 as libc::c_int);
            }
            put_lvalue(
                s,
                opcode,
                scope,
                var_name,
                lvalue_label,
                PUT_LVALUE_NOKEEP_BOTTOM,
                FALSE as libc::c_int,
            );
        }
        var_name = 0 as libc::c_int as JSAtom;
    }
    emit_goto(s, OP_goto as libc::c_int, label_body);
    pos_expr = (*(*s).cur_func).byte_code.size as libc::c_int;
    emit_label(s, label_expr);
    if (*s).token.val == '=' as i32 {
        has_initializer = TRUE as libc::c_int;
        if next_token(s) != 0 || js_parse_assign_expr2(s, 0 as libc::c_int) != 0 {
            JS_FreeAtom(ctx, var_name);
            return -(1 as libc::c_int);
        }
        if var_name != 0 as libc::c_int as libc::c_uint {
            emit_op(s, OP_scope_put_var as libc::c_int as uint8_t);
            emit_atom(s, var_name);
            emit_u16(s, (*fd).scope_level as uint16_t);
        }
    }
    JS_FreeAtom(ctx, var_name);
    let mut current_block_79: u64;
    if token_is_pseudo_keyword(s, JS_ATOM_of as libc::c_int as JSAtom) != 0 {
        is_for_of = TRUE as libc::c_int;
        break_entry.has_iterator = is_for_of;
        break_entry.drop_count += 2 as libc::c_int;
        if has_initializer != 0 {
            current_block_79 = 5087028378753490291;
        } else {
            current_block_79 = 17485376261910781866;
        }
    } else if (*s).token.val == TOK_IN as libc::c_int {
        if is_async != 0 {
            return js_parse_error(
                s,
                b"'for await' loop should be used with 'of'\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if has_initializer != 0
            && (tok != TOK_VAR as libc::c_int
                || (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                    != 0 || has_destructuring != 0)
        {
            current_block_79 = 5087028378753490291;
        } else {
            current_block_79 = 17485376261910781866;
        }
    } else {
        return js_parse_error(
            s,
            b"expected 'of' or 'in' in for control expression\0" as *const u8
                as *const libc::c_char,
        )
    }
    match current_block_79 {
        17485376261910781866 => {}
        _ => {
            return js_parse_error(
                s,
                b"a declaration in the head of a for-%s loop can't have an initializer\0"
                    as *const u8 as *const libc::c_char,
                if is_for_of != 0 {
                    b"of\0" as *const u8 as *const libc::c_char
                } else {
                    b"in\0" as *const u8 as *const libc::c_char
                },
            );
        }
    }
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    if is_for_of != 0 {
        if js_parse_assign_expr(s) != 0 {
            return -(1 as libc::c_int);
        }
    } else if js_parse_expr(s) != 0 {
        return -(1 as libc::c_int)
    }
    close_scopes(s, (*(*s).cur_func).scope_level, block_scope_level);
    if is_for_of != 0 {
        if is_async != 0 {
            emit_op(s, OP_for_await_of_start as libc::c_int as uint8_t);
        } else {
            emit_op(s, OP_for_of_start as libc::c_int as uint8_t);
        }
    } else {
        emit_op(s, OP_for_in_start as libc::c_int as uint8_t);
    }
    emit_goto(s, OP_goto as libc::c_int, label_cont);
    if js_parse_expect(s, ')' as i32) != 0 {
        return -(1 as libc::c_int);
    }
    let mut bc: *mut DynBuf = &mut (*(*s).cur_func).byte_code;
    let mut chunk_size: libc::c_int = pos_expr - pos_next;
    let mut offset: libc::c_int = ((*bc).size).wrapping_sub(pos_next as libc::c_ulong)
        as libc::c_int;
    let mut i: libc::c_int = 0;
    dbuf_realloc(bc, ((*bc).size).wrapping_add(chunk_size as libc::c_ulong));
    dbuf_put(bc, ((*bc).buf).offset(pos_next as isize), chunk_size as size_t);
    memset(
        ((*bc).buf).offset(pos_next as isize) as *mut libc::c_void,
        OP_nop as libc::c_int,
        chunk_size as libc::c_ulong,
    );
    (*(*s).cur_func)
        .last_opcode_pos = ((*bc).size).wrapping_sub(5 as libc::c_int as libc::c_ulong)
        as libc::c_int;
    i = label_cont;
    while i < (*(*s).cur_func).label_count {
        let mut ls: *mut LabelSlot = &mut *((*(*s).cur_func).label_slots)
            .offset(i as isize) as *mut LabelSlot;
        if (*ls).pos >= pos_next && (*ls).pos < pos_expr {
            (*ls).pos += offset;
        }
        i += 1;
    }
    emit_label(s, label_body);
    if js_parse_statement(s) != 0 {
        return -(1 as libc::c_int);
    }
    close_scopes(s, (*(*s).cur_func).scope_level, block_scope_level);
    emit_label(s, label_cont);
    if is_for_of != 0 {
        if is_async != 0 {
            emit_op(s, OP_dup3 as libc::c_int as uint8_t);
            emit_op(s, OP_drop as libc::c_int as uint8_t);
            emit_op(s, OP_call_method as libc::c_int as uint8_t);
            emit_u16(s, 0 as libc::c_int as uint16_t);
            emit_op(s, OP_await as libc::c_int as uint8_t);
            emit_op(s, OP_iterator_get_value_done as libc::c_int as uint8_t);
        } else {
            emit_op(s, OP_for_of_next as libc::c_int as uint8_t);
            emit_u8(s, 0 as libc::c_int as uint8_t);
        }
    } else {
        emit_op(s, OP_for_in_next as libc::c_int as uint8_t);
    }
    emit_goto(s, OP_if_false as libc::c_int, label_next);
    emit_op(s, OP_drop as libc::c_int as uint8_t);
    emit_label(s, label_break);
    if is_for_of != 0 {
        emit_op(s, OP_iterator_close as libc::c_int as uint8_t);
    } else {
        emit_op(s, OP_drop as libc::c_int as uint8_t);
    }
    pop_break_entry((*s).cur_func);
    pop_scope(s);
    return 0 as libc::c_int;
}
unsafe extern "C" fn set_eval_ret_undefined(mut s: *mut JSParseState) {
    if (*(*s).cur_func).eval_ret_idx >= 0 as libc::c_int {
        emit_op(s, OP_undefined as libc::c_int as uint8_t);
        emit_op(s, OP_put_loc as libc::c_int as uint8_t);
        emit_u16(s, (*(*s).cur_func).eval_ret_idx as uint16_t);
    }
}
unsafe extern "C" fn js_parse_statement_or_decl(
    mut s: *mut JSParseState,
    mut decl_mask: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut label_name: JSAtom = 0;
    let mut tok: libc::c_int = 0;
    label_name = 0 as libc::c_int as JSAtom;
    if is_label(s) != 0 {
        let mut be: *mut BlockEnv = 0 as *mut BlockEnv;
        label_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
        be = (*(*s).cur_func).top_break;
        loop {
            if be.is_null() {
                current_block = 11812396948646013369;
                break;
            }
            if (*be).label_name == label_name {
                js_parse_error(
                    s,
                    b"duplicate label name\0" as *const u8 as *const libc::c_char,
                );
                current_block = 12396192944262515411;
                break;
            } else {
                be = (*be).prev;
            }
        }
        match current_block {
            12396192944262515411 => {}
            _ => {
                if next_token(s) != 0 {
                    current_block = 12396192944262515411;
                } else if js_parse_expect(s, ':' as i32) != 0 {
                    current_block = 12396192944262515411;
                } else if (*s).token.val != TOK_FOR as libc::c_int
                    && (*s).token.val != TOK_DO as libc::c_int
                    && (*s).token.val != TOK_WHILE as libc::c_int
                {
                    let mut label_break: libc::c_int = 0;
                    let mut mask: libc::c_int = 0;
                    let mut break_entry: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    label_break = new_label(s);
                    push_break_entry(
                        (*s).cur_func,
                        &mut break_entry,
                        label_name,
                        label_break,
                        -(1 as libc::c_int),
                        0 as libc::c_int,
                    );
                    if (*(*s).cur_func).js_mode as libc::c_int
                        & (1 as libc::c_int) << 0 as libc::c_int == 0
                        && decl_mask & (1 as libc::c_int) << 1 as libc::c_int != 0
                    {
                        mask = (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int;
                    } else {
                        mask = 0 as libc::c_int;
                    }
                    if js_parse_statement_or_decl(s, mask) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        emit_label(s, label_break);
                        pop_break_entry((*s).cur_func);
                        current_block = 9209223076084871265;
                    }
                } else {
                    current_block = 9828876828309294594;
                }
            }
        }
    } else {
        current_block = 9828876828309294594;
    }
    match current_block {
        9828876828309294594 => {
            tok = (*s).token.val;
            match tok {
                123 => {
                    if js_parse_block(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        current_block = 9209223076084871265;
                    }
                }
                -80 => {
                    if (*(*s).cur_func).is_eval != 0 {
                        js_parse_error(
                            s,
                            b"return not in a function\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 12396192944262515411;
                    } else if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        if (*s).token.val != ';' as i32 && (*s).token.val != '}' as i32
                            && (*s).got_lf == 0
                        {
                            if js_parse_expr(s) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                emit_return(s, TRUE as libc::c_int);
                                current_block = 15597372965620363352;
                            }
                        } else {
                            emit_return(s, FALSE as libc::c_int);
                            current_block = 15597372965620363352;
                        }
                        match current_block {
                            12396192944262515411 => {}
                            _ => {
                                if js_parse_expect_semi(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    current_block = 9209223076084871265;
                                }
                            }
                        }
                    }
                }
                -63 => {
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else if (*s).got_lf != 0 {
                        js_parse_error(
                            s,
                            b"line terminator not allowed after throw\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 12396192944262515411;
                    } else if js_parse_expr(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        emit_op(s, OP_throw as libc::c_int as uint8_t);
                        if js_parse_expect_semi(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            current_block = 9209223076084871265;
                        }
                    }
                }
                -47 | -55 => {
                    current_block = 16774769609864108664;
                }
                -79 => {
                    current_block = 6644231700228160965;
                }
                -82 => {
                    let mut label1: libc::c_int = 0;
                    let mut label2: libc::c_int = 0;
                    let mut mask_0: libc::c_int = 0;
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        push_scope(s);
                        set_eval_ret_undefined(s);
                        if js_parse_expr_paren(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            label1 = emit_goto(
                                s,
                                OP_if_false as libc::c_int,
                                -(1 as libc::c_int),
                            );
                            if (*(*s).cur_func).js_mode as libc::c_int
                                & (1 as libc::c_int) << 0 as libc::c_int != 0
                            {
                                mask_0 = 0 as libc::c_int;
                            } else {
                                mask_0 = (1 as libc::c_int) << 0 as libc::c_int;
                            }
                            if js_parse_statement_or_decl(s, mask_0) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                if (*s).token.val == TOK_ELSE as libc::c_int {
                                    label2 = emit_goto(
                                        s,
                                        OP_goto as libc::c_int,
                                        -(1 as libc::c_int),
                                    );
                                    if next_token(s) != 0 {
                                        current_block = 12396192944262515411;
                                    } else {
                                        emit_label(s, label1);
                                        if js_parse_statement_or_decl(s, mask_0) != 0 {
                                            current_block = 12396192944262515411;
                                        } else {
                                            label1 = label2;
                                            current_block = 15462640364611497761;
                                        }
                                    }
                                } else {
                                    current_block = 15462640364611497761;
                                }
                                match current_block {
                                    12396192944262515411 => {}
                                    _ => {
                                        emit_label(s, label1);
                                        pop_scope(s);
                                        current_block = 9209223076084871265;
                                    }
                                }
                            }
                        }
                    }
                }
                -70 => {
                    let mut label_cont: libc::c_int = 0;
                    let mut label_break_0: libc::c_int = 0;
                    let mut break_entry_0: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    label_cont = new_label(s);
                    label_break_0 = new_label(s);
                    push_break_entry(
                        (*s).cur_func,
                        &mut break_entry_0,
                        label_name,
                        label_break_0,
                        label_cont,
                        0 as libc::c_int,
                    );
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        set_eval_ret_undefined(s);
                        emit_label(s, label_cont);
                        if js_parse_expr_paren(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            emit_goto(s, OP_if_false as libc::c_int, label_break_0);
                            if js_parse_statement(s) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                emit_goto(s, OP_goto as libc::c_int, label_cont);
                                emit_label(s, label_break_0);
                                pop_break_entry((*s).cur_func);
                                current_block = 9209223076084871265;
                            }
                        }
                    }
                }
                -71 => {
                    let mut label_cont_0: libc::c_int = 0;
                    let mut label_break_1: libc::c_int = 0;
                    let mut label1_0: libc::c_int = 0;
                    let mut break_entry_1: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    label_cont_0 = new_label(s);
                    label_break_1 = new_label(s);
                    label1_0 = new_label(s);
                    push_break_entry(
                        (*s).cur_func,
                        &mut break_entry_1,
                        label_name,
                        label_break_1,
                        label_cont_0,
                        0 as libc::c_int,
                    );
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        emit_label(s, label1_0);
                        set_eval_ret_undefined(s);
                        if js_parse_statement(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            emit_label(s, label_cont_0);
                            if js_parse_expect(s, TOK_WHILE as libc::c_int) != 0 {
                                current_block = 12396192944262515411;
                            } else if js_parse_expr_paren(s) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                if (*s).token.val == ';' as i32 {
                                    if next_token(s) != 0 {
                                        current_block = 12396192944262515411;
                                    } else {
                                        current_block = 5706507068631705000;
                                    }
                                } else {
                                    current_block = 5706507068631705000;
                                }
                                match current_block {
                                    12396192944262515411 => {}
                                    _ => {
                                        emit_goto(s, OP_if_true as libc::c_int, label1_0);
                                        emit_label(s, label_break_1);
                                        pop_break_entry((*s).cur_func);
                                        current_block = 9209223076084871265;
                                    }
                                }
                            }
                        }
                    }
                }
                -69 => {
                    let mut label_cont_1: libc::c_int = 0;
                    let mut label_break_2: libc::c_int = 0;
                    let mut label_body: libc::c_int = 0;
                    let mut label_test: libc::c_int = 0;
                    let mut pos_cont: libc::c_int = 0;
                    let mut pos_body: libc::c_int = 0;
                    let mut block_scope_level: libc::c_int = 0;
                    let mut break_entry_2: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    let mut tok_0: libc::c_int = 0;
                    let mut bits: libc::c_int = 0;
                    let mut is_async: BOOL = 0;
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        set_eval_ret_undefined(s);
                        bits = 0 as libc::c_int;
                        is_async = FALSE as libc::c_int;
                        if (*s).token.val == '(' as i32 {
                            js_parse_skip_parens_token(
                                s,
                                &mut bits,
                                FALSE as libc::c_int,
                            );
                            current_block = 17917672080766325409;
                        } else if (*s).token.val == TOK_AWAIT as libc::c_int {
                            if (*(*s).cur_func).func_kind() as libc::c_int
                                & JS_FUNC_ASYNC as libc::c_int == 0
                            {
                                js_parse_error(
                                    s,
                                    b"for await is only valid in asynchronous functions\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 12396192944262515411;
                            } else {
                                is_async = TRUE as libc::c_int;
                                if next_token(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    current_block = 17917672080766325409;
                                }
                            }
                        } else {
                            current_block = 17917672080766325409;
                        }
                        match current_block {
                            12396192944262515411 => {}
                            _ => {
                                if js_parse_expect(s, '(' as i32) != 0 {
                                    current_block = 12396192944262515411;
                                } else if bits & (1 as libc::c_int) << 0 as libc::c_int == 0
                                {
                                    if js_parse_for_in_of(
                                        s,
                                        label_name as libc::c_int,
                                        is_async,
                                    ) != 0
                                    {
                                        current_block = 12396192944262515411;
                                    } else {
                                        current_block = 9209223076084871265;
                                    }
                                } else {
                                    block_scope_level = (*(*s).cur_func).scope_level;
                                    push_scope(s);
                                    tok_0 = (*s).token.val;
                                    if tok_0 != ';' as i32 {
                                        match is_let(s, (1 as libc::c_int) << 2 as libc::c_int) {
                                            1 => {
                                                current_block = 5502231252250354566;
                                                match current_block {
                                                    5502231252250354566 => {
                                                        tok_0 = TOK_LET as libc::c_int;
                                                    }
                                                    _ => {}
                                                }
                                                if tok_0 == TOK_VAR as libc::c_int
                                                    || tok_0 == TOK_LET as libc::c_int
                                                    || tok_0 == TOK_CONST as libc::c_int
                                                {
                                                    if next_token(s) != 0 {
                                                        current_block = 12396192944262515411;
                                                    } else if js_parse_var(
                                                        s,
                                                        FALSE as libc::c_int,
                                                        tok_0,
                                                        FALSE as libc::c_int,
                                                    ) != 0
                                                    {
                                                        current_block = 12396192944262515411;
                                                    } else {
                                                        current_block = 850175865728824115;
                                                    }
                                                } else if js_parse_expr2(s, FALSE as libc::c_int) != 0 {
                                                    current_block = 12396192944262515411;
                                                } else {
                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                    current_block = 850175865728824115;
                                                }
                                                match current_block {
                                                    12396192944262515411 => {}
                                                    _ => {
                                                        close_scopes(
                                                            s,
                                                            (*(*s).cur_func).scope_level,
                                                            block_scope_level,
                                                        );
                                                        current_block = 7315983924538012637;
                                                    }
                                                }
                                            }
                                            0 => {
                                                current_block = 8507773468922410051;
                                                match current_block {
                                                    5502231252250354566 => {
                                                        tok_0 = TOK_LET as libc::c_int;
                                                    }
                                                    _ => {}
                                                }
                                                if tok_0 == TOK_VAR as libc::c_int
                                                    || tok_0 == TOK_LET as libc::c_int
                                                    || tok_0 == TOK_CONST as libc::c_int
                                                {
                                                    if next_token(s) != 0 {
                                                        current_block = 12396192944262515411;
                                                    } else if js_parse_var(
                                                        s,
                                                        FALSE as libc::c_int,
                                                        tok_0,
                                                        FALSE as libc::c_int,
                                                    ) != 0
                                                    {
                                                        current_block = 12396192944262515411;
                                                    } else {
                                                        current_block = 850175865728824115;
                                                    }
                                                } else if js_parse_expr2(s, FALSE as libc::c_int) != 0 {
                                                    current_block = 12396192944262515411;
                                                } else {
                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                    current_block = 850175865728824115;
                                                }
                                                match current_block {
                                                    12396192944262515411 => {}
                                                    _ => {
                                                        close_scopes(
                                                            s,
                                                            (*(*s).cur_func).scope_level,
                                                            block_scope_level,
                                                        );
                                                        current_block = 7315983924538012637;
                                                    }
                                                }
                                            }
                                            _ => {
                                                current_block = 12396192944262515411;
                                            }
                                        }
                                    } else {
                                        current_block = 7315983924538012637;
                                    }
                                    match current_block {
                                        12396192944262515411 => {}
                                        _ => {
                                            if js_parse_expect(s, ';' as i32) != 0 {
                                                current_block = 12396192944262515411;
                                            } else {
                                                label_test = new_label(s);
                                                label_cont_1 = new_label(s);
                                                label_body = new_label(s);
                                                label_break_2 = new_label(s);
                                                push_break_entry(
                                                    (*s).cur_func,
                                                    &mut break_entry_2,
                                                    label_name,
                                                    label_break_2,
                                                    label_cont_1,
                                                    0 as libc::c_int,
                                                );
                                                if (*s).token.val == ';' as i32 {
                                                    label_test = label_body;
                                                    current_block = 2544535129495155983;
                                                } else {
                                                    emit_label(s, label_test);
                                                    if js_parse_expr(s) != 0 {
                                                        current_block = 12396192944262515411;
                                                    } else {
                                                        emit_goto(s, OP_if_false as libc::c_int, label_break_2);
                                                        current_block = 2544535129495155983;
                                                    }
                                                }
                                                match current_block {
                                                    12396192944262515411 => {}
                                                    _ => {
                                                        if js_parse_expect(s, ';' as i32) != 0 {
                                                            current_block = 12396192944262515411;
                                                        } else {
                                                            if (*s).token.val == ')' as i32 {
                                                                label_cont_1 = label_test;
                                                                break_entry_2.label_cont = label_cont_1;
                                                                pos_cont = 0 as libc::c_int;
                                                                current_block = 7371321987304394147;
                                                            } else {
                                                                emit_goto(s, OP_goto as libc::c_int, label_body);
                                                                pos_cont = (*(*s).cur_func).byte_code.size as libc::c_int;
                                                                emit_label(s, label_cont_1);
                                                                if js_parse_expr(s) != 0 {
                                                                    current_block = 12396192944262515411;
                                                                } else {
                                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                                    if label_test != label_body {
                                                                        emit_goto(s, OP_goto as libc::c_int, label_test);
                                                                    }
                                                                    current_block = 7371321987304394147;
                                                                }
                                                            }
                                                            match current_block {
                                                                12396192944262515411 => {}
                                                                _ => {
                                                                    if js_parse_expect(s, ')' as i32) != 0 {
                                                                        current_block = 12396192944262515411;
                                                                    } else {
                                                                        pos_body = (*(*s).cur_func).byte_code.size as libc::c_int;
                                                                        emit_label(s, label_body);
                                                                        if js_parse_statement(s) != 0 {
                                                                            current_block = 12396192944262515411;
                                                                        } else {
                                                                            close_scopes(
                                                                                s,
                                                                                (*(*s).cur_func).scope_level,
                                                                                block_scope_level,
                                                                            );
                                                                            if 1 as libc::c_int != 0 && label_test != label_body
                                                                                && label_cont_1 != label_test
                                                                            {
                                                                                let mut bc: *mut DynBuf = &mut (*(*s).cur_func).byte_code;
                                                                                let mut chunk_size: libc::c_int = pos_body - pos_cont;
                                                                                let mut offset: libc::c_int = ((*bc).size)
                                                                                    .wrapping_sub(pos_cont as libc::c_ulong) as libc::c_int;
                                                                                let mut i: libc::c_int = 0;
                                                                                dbuf_realloc(
                                                                                    bc,
                                                                                    ((*bc).size).wrapping_add(chunk_size as libc::c_ulong),
                                                                                );
                                                                                dbuf_put(
                                                                                    bc,
                                                                                    ((*bc).buf).offset(pos_cont as isize),
                                                                                    chunk_size as size_t,
                                                                                );
                                                                                memset(
                                                                                    ((*bc).buf).offset(pos_cont as isize) as *mut libc::c_void,
                                                                                    OP_nop as libc::c_int,
                                                                                    chunk_size as libc::c_ulong,
                                                                                );
                                                                                (*(*s).cur_func)
                                                                                    .last_opcode_pos = ((*bc).size)
                                                                                    .wrapping_sub(5 as libc::c_int as libc::c_ulong)
                                                                                    as libc::c_int;
                                                                                i = label_cont_1;
                                                                                while i < (*(*s).cur_func).label_count {
                                                                                    let mut ls: *mut LabelSlot = &mut *((*(*s).cur_func)
                                                                                        .label_slots)
                                                                                        .offset(i as isize) as *mut LabelSlot;
                                                                                    if (*ls).pos >= pos_cont && (*ls).pos < pos_body {
                                                                                        (*ls).pos += offset;
                                                                                    }
                                                                                    i += 1;
                                                                                }
                                                                            } else {
                                                                                emit_goto(s, OP_goto as libc::c_int, label_cont_1);
                                                                            }
                                                                            emit_label(s, label_break_2);
                                                                            pop_break_entry((*s).cur_func);
                                                                            pop_scope(s);
                                                                            current_block = 9209223076084871265;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                -68 | -67 => {
                    let mut is_cont: libc::c_int = (*s).token.val
                        - TOK_BREAK as libc::c_int;
                    let mut label: libc::c_int = 0;
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        if (*s).got_lf == 0 && (*s).token.val == TOK_IDENT as libc::c_int
                            && (*s).token.u.ident.is_reserved == 0
                        {
                            label = (*s).token.u.ident.atom as libc::c_int;
                        } else {
                            label = 0 as libc::c_int;
                        }
                        if emit_break(s, label as JSAtom, is_cont) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            if label != 0 as libc::c_int {
                                if next_token(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    current_block = 2860109724005416757;
                                }
                            } else {
                                current_block = 2860109724005416757;
                            }
                            match current_block {
                                12396192944262515411 => {}
                                _ => {
                                    if js_parse_expect_semi(s) != 0 {
                                        current_block = 12396192944262515411;
                                    } else {
                                        current_block = 9209223076084871265;
                                    }
                                }
                            }
                        }
                    }
                }
                -66 => {
                    let mut label_case: libc::c_int = 0;
                    let mut label_break_3: libc::c_int = 0;
                    let mut label1_1: libc::c_int = 0;
                    let mut default_label_pos: libc::c_int = 0;
                    let mut break_entry_3: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        set_eval_ret_undefined(s);
                        if js_parse_expr_paren(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            push_scope(s);
                            label_break_3 = new_label(s);
                            push_break_entry(
                                (*s).cur_func,
                                &mut break_entry_3,
                                label_name,
                                label_break_3,
                                -(1 as libc::c_int),
                                1 as libc::c_int,
                            );
                            if js_parse_expect(s, '{' as i32) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                default_label_pos = -(1 as libc::c_int);
                                label_case = -(1 as libc::c_int);
                                's_1058: loop {
                                    if !((*s).token.val != '}' as i32) {
                                        current_block = 13273562938126804119;
                                        break;
                                    }
                                    if (*s).token.val == TOK_CASE as libc::c_int {
                                        label1_1 = -(1 as libc::c_int);
                                        if label_case >= 0 as libc::c_int {
                                            label1_1 = emit_goto(
                                                s,
                                                OP_goto as libc::c_int,
                                                -(1 as libc::c_int),
                                            );
                                        }
                                        emit_label(s, label_case);
                                        label_case = -(1 as libc::c_int);
                                        loop {
                                            if next_token(s) != 0 {
                                                current_block = 12396192944262515411;
                                                break 's_1058;
                                            }
                                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                                            if js_parse_expr(s) != 0 {
                                                current_block = 12396192944262515411;
                                                break 's_1058;
                                            }
                                            if js_parse_expect(s, ':' as i32) != 0 {
                                                current_block = 12396192944262515411;
                                                break 's_1058;
                                            }
                                            emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
                                            if (*s).token.val == TOK_CASE as libc::c_int {
                                                label1_1 = emit_goto(
                                                    s,
                                                    OP_if_true as libc::c_int,
                                                    label1_1,
                                                );
                                            } else {
                                                label_case = emit_goto(
                                                    s,
                                                    OP_if_false as libc::c_int,
                                                    -(1 as libc::c_int),
                                                );
                                                emit_label(s, label1_1);
                                                break;
                                            }
                                        }
                                    } else if (*s).token.val == TOK_DEFAULT as libc::c_int {
                                        if next_token(s) != 0 {
                                            current_block = 12396192944262515411;
                                            break;
                                        }
                                        if js_parse_expect(s, ':' as i32) != 0 {
                                            current_block = 12396192944262515411;
                                            break;
                                        }
                                        if default_label_pos >= 0 as libc::c_int {
                                            js_parse_error(
                                                s,
                                                b"duplicate default\0" as *const u8 as *const libc::c_char,
                                            );
                                            current_block = 12396192944262515411;
                                            break;
                                        } else {
                                            if label_case < 0 as libc::c_int {
                                                label_case = emit_goto(
                                                    s,
                                                    OP_goto as libc::c_int,
                                                    -(1 as libc::c_int),
                                                );
                                            }
                                            emit_op(s, OP_label as libc::c_int as uint8_t);
                                            emit_u32(s, 0 as libc::c_int as uint32_t);
                                            default_label_pos = ((*(*s).cur_func).byte_code.size)
                                                .wrapping_sub(4 as libc::c_int as libc::c_ulong)
                                                as libc::c_int;
                                        }
                                    } else if label_case < 0 as libc::c_int {
                                        js_parse_error(
                                            s,
                                            b"invalid switch statement\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        current_block = 12396192944262515411;
                                        break;
                                    } else if js_parse_statement_or_decl(
                                        s,
                                        (1 as libc::c_int) << 0 as libc::c_int
                                            | (1 as libc::c_int) << 1 as libc::c_int
                                            | (1 as libc::c_int) << 2 as libc::c_int,
                                    ) != 0
                                    {
                                        current_block = 12396192944262515411;
                                        break;
                                    }
                                }
                                match current_block {
                                    12396192944262515411 => {}
                                    _ => {
                                        if js_parse_expect(s, '}' as i32) != 0 {
                                            current_block = 12396192944262515411;
                                        } else {
                                            if default_label_pos >= 0 as libc::c_int {
                                                put_u32(
                                                    ((*(*s).cur_func).byte_code.buf)
                                                        .offset(default_label_pos as isize),
                                                    label_case as uint32_t,
                                                );
                                                (*((*(*s).cur_func).label_slots)
                                                    .offset(label_case as isize))
                                                    .pos = default_label_pos + 4 as libc::c_int;
                                            } else {
                                                emit_label(s, label_case);
                                            }
                                            emit_label(s, label_break_3);
                                            emit_op(s, OP_drop as libc::c_int as uint8_t);
                                            pop_break_entry((*s).cur_func);
                                            pop_scope(s);
                                            current_block = 9209223076084871265;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                -62 => {
                    let mut label_catch: libc::c_int = 0;
                    let mut label_catch2: libc::c_int = 0;
                    let mut label_finally: libc::c_int = 0;
                    let mut label_end: libc::c_int = 0;
                    let mut name: JSAtom = 0;
                    let mut block_env: BlockEnv = BlockEnv {
                        prev: 0 as *mut BlockEnv,
                        label_name: 0,
                        label_break: 0,
                        label_cont: 0,
                        drop_count: 0,
                        label_finally: 0,
                        scope_level: 0,
                        has_iterator: 0,
                    };
                    set_eval_ret_undefined(s);
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        label_catch = new_label(s);
                        label_catch2 = new_label(s);
                        label_finally = new_label(s);
                        label_end = new_label(s);
                        emit_goto(s, OP_catch as libc::c_int, label_catch);
                        push_break_entry(
                            (*s).cur_func,
                            &mut block_env,
                            0 as libc::c_int as JSAtom,
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                            1 as libc::c_int,
                        );
                        block_env.label_finally = label_finally;
                        if js_parse_block(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            pop_break_entry((*s).cur_func);
                            if js_is_live_code(s) != 0 {
                                emit_op(s, OP_drop as libc::c_int as uint8_t);
                                emit_op(s, OP_undefined as libc::c_int as uint8_t);
                                emit_goto(s, OP_gosub as libc::c_int, label_finally);
                                emit_op(s, OP_drop as libc::c_int as uint8_t);
                                emit_goto(s, OP_goto as libc::c_int, label_end);
                            }
                            if (*s).token.val == TOK_CATCH as libc::c_int {
                                if next_token(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    push_scope(s);
                                    emit_label(s, label_catch);
                                    if (*s).token.val == '{' as i32 {
                                        emit_op(s, OP_drop as libc::c_int as uint8_t);
                                        current_block = 7216079654829136900;
                                    } else if js_parse_expect(s, '(' as i32) != 0 {
                                        current_block = 12396192944262515411;
                                    } else {
                                        if !((*s).token.val == TOK_IDENT as libc::c_int
                                            && (*s).token.u.ident.is_reserved == 0)
                                        {
                                            if (*s).token.val == '[' as i32
                                                || (*s).token.val == '{' as i32
                                            {
                                                if js_parse_destructuring_element(
                                                    s,
                                                    TOK_LET as libc::c_int,
                                                    0 as libc::c_int,
                                                    TRUE as libc::c_int,
                                                    -(1 as libc::c_int),
                                                    TRUE as libc::c_int,
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 12396192944262515411;
                                                } else {
                                                    current_block = 17516866169921771843;
                                                }
                                            } else {
                                                js_parse_error(
                                                    s,
                                                    b"identifier expected\0" as *const u8 as *const libc::c_char,
                                                );
                                                current_block = 12396192944262515411;
                                            }
                                        } else {
                                            name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                                            if next_token(s) != 0
                                                || js_define_var(s, name, TOK_CATCH as libc::c_int)
                                                    < 0 as libc::c_int
                                            {
                                                JS_FreeAtom(ctx, name);
                                                current_block = 12396192944262515411;
                                            } else {
                                                emit_op(s, OP_scope_put_var as libc::c_int as uint8_t);
                                                emit_u32(s, name);
                                                emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                current_block = 17516866169921771843;
                                            }
                                        }
                                        match current_block {
                                            12396192944262515411 => {}
                                            _ => {
                                                if js_parse_expect(s, ')' as i32) != 0 {
                                                    current_block = 12396192944262515411;
                                                } else {
                                                    current_block = 7216079654829136900;
                                                }
                                            }
                                        }
                                    }
                                    match current_block {
                                        12396192944262515411 => {}
                                        _ => {
                                            emit_goto(s, OP_catch as libc::c_int, label_catch2);
                                            push_scope(s);
                                            push_break_entry(
                                                (*s).cur_func,
                                                &mut block_env,
                                                0 as libc::c_int as JSAtom,
                                                -(1 as libc::c_int),
                                                -(1 as libc::c_int),
                                                1 as libc::c_int,
                                            );
                                            block_env.label_finally = label_finally;
                                            if js_parse_block(s) != 0 {
                                                current_block = 12396192944262515411;
                                            } else {
                                                pop_break_entry((*s).cur_func);
                                                pop_scope(s);
                                                pop_scope(s);
                                                if js_is_live_code(s) != 0 {
                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                                                    emit_goto(s, OP_gosub as libc::c_int, label_finally);
                                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                    emit_goto(s, OP_goto as libc::c_int, label_end);
                                                }
                                                emit_label(s, label_catch2);
                                                emit_goto(s, OP_gosub as libc::c_int, label_finally);
                                                emit_op(s, OP_throw as libc::c_int as uint8_t);
                                                current_block = 3893156993890508670;
                                            }
                                        }
                                    }
                                }
                            } else if (*s).token.val == TOK_FINALLY as libc::c_int {
                                emit_label(s, label_catch);
                                emit_goto(s, OP_gosub as libc::c_int, label_finally);
                                emit_op(s, OP_throw as libc::c_int as uint8_t);
                                current_block = 3893156993890508670;
                            } else {
                                js_parse_error(
                                    s,
                                    b"expecting catch or finally\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 12396192944262515411;
                            }
                            match current_block {
                                12396192944262515411 => {}
                                _ => {
                                    emit_label(s, label_finally);
                                    if (*s).token.val == TOK_FINALLY as libc::c_int {
                                        let mut saved_eval_ret_idx: libc::c_int = 0 as libc::c_int;
                                        if next_token(s) != 0 {
                                            current_block = 12396192944262515411;
                                        } else {
                                            push_break_entry(
                                                (*s).cur_func,
                                                &mut block_env,
                                                0 as libc::c_int as JSAtom,
                                                -(1 as libc::c_int),
                                                -(1 as libc::c_int),
                                                2 as libc::c_int,
                                            );
                                            if (*(*s).cur_func).eval_ret_idx >= 0 as libc::c_int {
                                                saved_eval_ret_idx = add_var(
                                                    (*s).ctx,
                                                    (*s).cur_func,
                                                    JS_ATOM__ret_ as libc::c_int as JSAtom,
                                                );
                                                if saved_eval_ret_idx < 0 as libc::c_int {
                                                    current_block = 12396192944262515411;
                                                } else {
                                                    emit_op(s, OP_get_loc as libc::c_int as uint8_t);
                                                    emit_u16(s, (*(*s).cur_func).eval_ret_idx as uint16_t);
                                                    emit_op(s, OP_put_loc as libc::c_int as uint8_t);
                                                    emit_u16(s, saved_eval_ret_idx as uint16_t);
                                                    set_eval_ret_undefined(s);
                                                    current_block = 14166554486324432560;
                                                }
                                            } else {
                                                current_block = 14166554486324432560;
                                            }
                                            match current_block {
                                                12396192944262515411 => {}
                                                _ => {
                                                    if js_parse_block(s) != 0 {
                                                        current_block = 12396192944262515411;
                                                    } else {
                                                        if (*(*s).cur_func).eval_ret_idx >= 0 as libc::c_int {
                                                            emit_op(s, OP_get_loc as libc::c_int as uint8_t);
                                                            emit_u16(s, saved_eval_ret_idx as uint16_t);
                                                            emit_op(s, OP_put_loc as libc::c_int as uint8_t);
                                                            emit_u16(s, (*(*s).cur_func).eval_ret_idx as uint16_t);
                                                        }
                                                        pop_break_entry((*s).cur_func);
                                                        current_block = 2126221883176060805;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 2126221883176060805;
                                    }
                                    match current_block {
                                        12396192944262515411 => {}
                                        _ => {
                                            emit_op(s, OP_ret as libc::c_int as uint8_t);
                                            emit_label(s, label_end);
                                            current_block = 9209223076084871265;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                59 => {
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        current_block = 9209223076084871265;
                    }
                }
                -57 => {
                    if (*(*s).cur_func).js_mode as libc::c_int
                        & (1 as libc::c_int) << 0 as libc::c_int != 0
                    {
                        js_parse_error(
                            s,
                            b"invalid keyword: with\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 12396192944262515411;
                    } else {
                        let mut with_idx: libc::c_int = 0;
                        if next_token(s) != 0 {
                            current_block = 12396192944262515411;
                        } else if js_parse_expr_paren(s) != 0 {
                            current_block = 12396192944262515411;
                        } else {
                            push_scope(s);
                            with_idx = define_var(
                                s,
                                (*s).cur_func,
                                JS_ATOM__with_ as libc::c_int as JSAtom,
                                JS_VAR_DEF_WITH,
                            );
                            if with_idx < 0 as libc::c_int {
                                current_block = 12396192944262515411;
                            } else {
                                emit_op(s, OP_to_object as libc::c_int as uint8_t);
                                emit_op(s, OP_put_loc as libc::c_int as uint8_t);
                                emit_u16(s, with_idx as uint16_t);
                                set_eval_ret_undefined(s);
                                if js_parse_statement(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    pop_scope(s);
                                    current_block = 9209223076084871265;
                                }
                            }
                        }
                    }
                }
                -59 => {
                    if decl_mask & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                        current_block = 18408797158655187591;
                    } else if decl_mask & (1 as libc::c_int) << 2 as libc::c_int == 0
                        && peek_token(s, FALSE as libc::c_int) == '*' as i32
                    {
                        current_block = 18408797158655187591;
                    } else {
                        current_block = 17421048415767565572;
                    }
                }
                -125 => {
                    if (*s).token.u.ident.is_reserved != 0 {
                        js_parse_error_reserved_identifier(s);
                        current_block = 12396192944262515411;
                    } else {
                        match is_let(s, decl_mask) {
                            1 => {
                                current_block = 8499605076890806464;
                                match current_block {
                                    15504907882810622421 => {
                                        if token_is_pseudo_keyword(
                                            s,
                                            JS_ATOM_async as libc::c_int as JSAtom,
                                        ) != 0
                                            && peek_token(s, TRUE as libc::c_int)
                                                == TOK_FUNCTION as libc::c_int
                                        {
                                            if decl_mask & (1 as libc::c_int) << 2 as libc::c_int == 0 {
                                                current_block = 18408797158655187591;
                                            } else {
                                                current_block = 17421048415767565572;
                                            }
                                        } else {
                                            current_block = 6851749167472275627;
                                        }
                                    }
                                    _ => {
                                        tok = TOK_LET as libc::c_int;
                                        current_block = 16774769609864108664;
                                    }
                                }
                            }
                            0 => {
                                current_block = 15504907882810622421;
                                match current_block {
                                    15504907882810622421 => {
                                        if token_is_pseudo_keyword(
                                            s,
                                            JS_ATOM_async as libc::c_int as JSAtom,
                                        ) != 0
                                            && peek_token(s, TRUE as libc::c_int)
                                                == TOK_FUNCTION as libc::c_int
                                        {
                                            if decl_mask & (1 as libc::c_int) << 2 as libc::c_int == 0 {
                                                current_block = 18408797158655187591;
                                            } else {
                                                current_block = 17421048415767565572;
                                            }
                                        } else {
                                            current_block = 6851749167472275627;
                                        }
                                    }
                                    _ => {
                                        tok = TOK_LET as libc::c_int;
                                        current_block = 16774769609864108664;
                                    }
                                }
                            }
                            _ => {
                                current_block = 12396192944262515411;
                            }
                        }
                    }
                }
                -56 => {
                    if decl_mask & (1 as libc::c_int) << 2 as libc::c_int == 0 {
                        js_parse_error(
                            s,
                            b"class declarations can't appear in single-statement context\0"
                                as *const u8 as *const libc::c_char,
                        );
                        current_block = 12396192944262515411;
                    } else {
                        if js_parse_class(s, FALSE as libc::c_int, JS_PARSE_EXPORT_NONE)
                            != 0
                        {
                            return -(1 as libc::c_int);
                        }
                        current_block = 9209223076084871265;
                    }
                }
                -58 => {
                    if next_token(s) != 0 {
                        current_block = 12396192944262515411;
                    } else if js_parse_expect_semi(s) != 0 {
                        current_block = 12396192944262515411;
                    } else {
                        current_block = 9209223076084871265;
                    }
                }
                -54 | -53 | -52 => {
                    js_unsupported_keyword(s, (*s).token.u.ident.atom);
                    current_block = 12396192944262515411;
                }
                _ => {
                    current_block = 6851749167472275627;
                }
            }
            match current_block {
                12396192944262515411 => {}
                9209223076084871265 => {}
                _ => {
                    match current_block {
                        6851749167472275627 => {
                            if js_parse_expr(s) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                if (*(*s).cur_func).eval_ret_idx >= 0 as libc::c_int {
                                    emit_op(s, OP_put_loc as libc::c_int as uint8_t);
                                    emit_u16(s, (*(*s).cur_func).eval_ret_idx as uint16_t);
                                } else {
                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                }
                                if js_parse_expect_semi(s) != 0 {
                                    current_block = 12396192944262515411;
                                } else {
                                    current_block = 9209223076084871265;
                                }
                            }
                        }
                        16774769609864108664 => {
                            if decl_mask & (1 as libc::c_int) << 2 as libc::c_int == 0 {
                                js_parse_error(
                                    s,
                                    b"lexical declarations can't appear in single-statement context\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 12396192944262515411;
                            } else {
                                current_block = 6644231700228160965;
                            }
                        }
                        18408797158655187591 => {
                            js_parse_error(
                                s,
                                b"function declarations can't appear in single-statement context\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 12396192944262515411;
                        }
                        17421048415767565572 => {
                            if js_parse_function_decl(
                                s,
                                JS_PARSE_FUNC_VAR,
                                JS_FUNC_NORMAL,
                                0 as libc::c_int as JSAtom,
                                (*s).token.ptr,
                                (*s).token.line_num,
                            ) != 0
                            {
                                current_block = 12396192944262515411;
                            } else {
                                current_block = 9209223076084871265;
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        12396192944262515411 => {}
                        9209223076084871265 => {}
                        _ => {
                            if next_token(s) != 0 {
                                current_block = 12396192944262515411;
                            } else if js_parse_var(
                                s,
                                TRUE as libc::c_int,
                                tok,
                                FALSE as libc::c_int,
                            ) != 0
                            {
                                current_block = 12396192944262515411;
                            } else if js_parse_expect_semi(s) != 0 {
                                current_block = 12396192944262515411;
                            } else {
                                current_block = 9209223076084871265;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        12396192944262515411 => {
            JS_FreeAtom(ctx, label_name);
            return -(1 as libc::c_int);
        }
        _ => {
            JS_FreeAtom(ctx, label_name);
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn js_new_module_def(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> *mut JSModuleDef {
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    m = js_mallocz(ctx, ::core::mem::size_of::<JSModuleDef>() as libc::c_ulong)
        as *mut JSModuleDef;
    if m.is_null() {
        JS_FreeAtom(ctx, name);
        return 0 as *mut JSModuleDef;
    }
    (*m).header.ref_count = 1 as libc::c_int;
    (*m).module_name = name;
    (*m)
        .module_ns = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*m)
        .func_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*m)
        .eval_exception = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*m)
        .meta_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    list_add_tail(&mut (*m).link, &mut (*ctx).loaded_modules);
    return m;
}
unsafe extern "C" fn js_mark_module_def(
    mut rt: *mut JSRuntime,
    mut m: *mut JSModuleDef,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        let mut me: *mut JSExportEntry = &mut *((*m).export_entries).offset(i as isize)
            as *mut JSExportEntry;
        if (*me).export_type as libc::c_uint
            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
            && !((*me).u.local.var_ref).is_null()
        {
            mark_func
                .expect(
                    "non-null function pointer",
                )(rt, &mut (*(*me).u.local.var_ref).c2rust_unnamed.header);
        }
        i += 1;
    }
    JS_MarkValue(rt, (*m).module_ns, mark_func);
    JS_MarkValue(rt, (*m).func_obj, mark_func);
    JS_MarkValue(rt, (*m).eval_exception, mark_func);
    JS_MarkValue(rt, (*m).meta_obj, mark_func);
}
unsafe extern "C" fn js_free_module_def(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) {
    let mut i: libc::c_int = 0;
    JS_FreeAtom(ctx, (*m).module_name);
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        JS_FreeAtom(ctx, (*rme).module_name);
        i += 1;
    }
    js_free(ctx, (*m).req_module_entries as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        let mut me: *mut JSExportEntry = &mut *((*m).export_entries).offset(i as isize)
            as *mut JSExportEntry;
        if (*me).export_type as libc::c_uint
            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
        {
            free_var_ref((*ctx).rt, (*me).u.local.var_ref);
        }
        JS_FreeAtom(ctx, (*me).export_name);
        JS_FreeAtom(ctx, (*me).local_name);
        i += 1;
    }
    js_free(ctx, (*m).export_entries as *mut libc::c_void);
    js_free(ctx, (*m).star_export_entries as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*m).import_entries_count {
        let mut mi: *mut JSImportEntry = &mut *((*m).import_entries).offset(i as isize)
            as *mut JSImportEntry;
        JS_FreeAtom(ctx, (*mi).import_name);
        i += 1;
    }
    js_free(ctx, (*m).import_entries as *mut libc::c_void);
    JS_FreeValue(ctx, (*m).module_ns);
    JS_FreeValue(ctx, (*m).func_obj);
    JS_FreeValue(ctx, (*m).eval_exception);
    JS_FreeValue(ctx, (*m).meta_obj);
    list_del(&mut (*m).link);
    js_free(ctx, m as *mut libc::c_void);
}
unsafe extern "C" fn add_req_module_entry(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut module_name: JSAtom,
) -> libc::c_int {
    let mut rme: *mut JSReqModuleEntry = 0 as *mut JSReqModuleEntry;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        rme = &mut *((*m).req_module_entries).offset(i as isize)
            as *mut JSReqModuleEntry;
        if (*rme).module_name == module_name {
            return i;
        }
        i += 1;
    }
    if js_resize_array(
        ctx,
        &mut (*m).req_module_entries as *mut *mut JSReqModuleEntry
            as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSReqModuleEntry>() as libc::c_ulong as libc::c_int,
        &mut (*m).req_module_entries_size,
        (*m).req_module_entries_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh453 = (*m).req_module_entries_count;
    let fresh454 = *fresh453;
    *fresh453 = *fresh453 + 1;
    rme = &mut *((*m).req_module_entries).offset(fresh454 as isize)
        as *mut JSReqModuleEntry;
    (*rme).module_name = JS_DupAtom(ctx, module_name);
    let ref mut fresh455 = (*rme).module;
    *fresh455 = 0 as *mut JSModuleDef;
    return i;
}
unsafe extern "C" fn find_export_entry(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut export_name: JSAtom,
) -> *mut JSExportEntry {
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        me = &mut *((*m).export_entries).offset(i as isize) as *mut JSExportEntry;
        if (*me).export_name == export_name {
            return me;
        }
        i += 1;
    }
    return 0 as *mut JSExportEntry;
}
unsafe extern "C" fn add_export_entry2(
    mut ctx: *mut JSContext,
    mut s: *mut JSParseState,
    mut m: *mut JSModuleDef,
    mut local_name: JSAtom,
    mut export_name: JSAtom,
    mut export_type: JSExportTypeEnum,
) -> *mut JSExportEntry {
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    if !(find_export_entry(ctx, m, export_name)).is_null() {
        let mut buf1: [libc::c_char; 64] = [0; 64];
        if !s.is_null() {
            js_parse_error(
                s,
                b"duplicate exported name '%s'\0" as *const u8 as *const libc::c_char,
                JS_AtomGetStr(
                    ctx,
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    export_name,
                ),
            );
        } else {
            __JS_ThrowSyntaxErrorAtom(
                ctx,
                export_name,
                b"duplicate exported name '%s'\0" as *const u8 as *const libc::c_char,
                b"\0" as *const u8 as *const libc::c_char,
            );
        }
        return 0 as *mut JSExportEntry;
    }
    if js_resize_array(
        ctx,
        &mut (*m).export_entries as *mut *mut JSExportEntry as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSExportEntry>() as libc::c_ulong as libc::c_int,
        &mut (*m).export_entries_size,
        (*m).export_entries_count + 1 as libc::c_int,
    ) != 0
    {
        return 0 as *mut JSExportEntry;
    }
    let ref mut fresh456 = (*m).export_entries_count;
    let fresh457 = *fresh456;
    *fresh456 = *fresh456 + 1;
    me = &mut *((*m).export_entries).offset(fresh457 as isize) as *mut JSExportEntry;
    memset(
        me as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSExportEntry>() as libc::c_ulong,
    );
    (*me).local_name = JS_DupAtom(ctx, local_name);
    (*me).export_name = JS_DupAtom(ctx, export_name);
    (*me).export_type = export_type;
    return me;
}
unsafe extern "C" fn add_export_entry(
    mut s: *mut JSParseState,
    mut m: *mut JSModuleDef,
    mut local_name: JSAtom,
    mut export_name: JSAtom,
    mut export_type: JSExportTypeEnum,
) -> *mut JSExportEntry {
    return add_export_entry2((*s).ctx, s, m, local_name, export_name, export_type);
}
unsafe extern "C" fn add_star_export_entry(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut req_module_idx: libc::c_int,
) -> libc::c_int {
    let mut se: *mut JSStarExportEntry = 0 as *mut JSStarExportEntry;
    if js_resize_array(
        ctx,
        &mut (*m).star_export_entries as *mut *mut JSStarExportEntry
            as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSStarExportEntry>() as libc::c_ulong as libc::c_int,
        &mut (*m).star_export_entries_size,
        (*m).star_export_entries_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh458 = (*m).star_export_entries_count;
    let fresh459 = *fresh458;
    *fresh458 = *fresh458 + 1;
    se = &mut *((*m).star_export_entries).offset(fresh459 as isize)
        as *mut JSStarExportEntry;
    (*se).req_module_idx = req_module_idx;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewCModule(
    mut ctx: *mut JSContext,
    mut name_str: *const libc::c_char,
    mut func: Option::<JSModuleInitFunc>,
) -> *mut JSModuleDef {
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut name: JSAtom = 0;
    name = JS_NewAtom(ctx, name_str);
    if name == 0 as libc::c_int as libc::c_uint {
        return 0 as *mut JSModuleDef;
    }
    m = js_new_module_def(ctx, name);
    let ref mut fresh460 = (*m).init_func;
    *fresh460 = func;
    return m;
}
#[no_mangle]
pub unsafe extern "C" fn JS_AddModuleExport(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut export_name: *const libc::c_char,
) -> libc::c_int {
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    let mut name: JSAtom = 0;
    name = JS_NewAtom(ctx, export_name);
    if name == 0 as libc::c_int as libc::c_uint {
        return -(1 as libc::c_int);
    }
    me = add_export_entry2(
        ctx,
        0 as *mut JSParseState,
        m,
        0 as libc::c_int as JSAtom,
        name,
        JS_EXPORT_TYPE_LOCAL,
    );
    JS_FreeAtom(ctx, name);
    if me.is_null() { return -(1 as libc::c_int) } else { return 0 as libc::c_int };
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetModuleExport(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut export_name: *const libc::c_char,
    mut val: JSValue,
) -> libc::c_int {
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    let mut name: JSAtom = 0;
    name = JS_NewAtom(ctx, export_name);
    if !(name == 0 as libc::c_int as libc::c_uint) {
        me = find_export_entry(ctx, m, name);
        JS_FreeAtom(ctx, name);
        if !me.is_null() {
            set_value(ctx, (*(*me).u.local.var_ref).pvalue, val);
            return 0 as libc::c_int;
        }
    }
    JS_FreeValue(ctx, val);
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetModuleLoaderFunc(
    mut rt: *mut JSRuntime,
    mut module_normalize: Option::<JSModuleNormalizeFunc>,
    mut module_loader: Option::<JSModuleLoaderFunc>,
    mut opaque: *mut libc::c_void,
) {
    let ref mut fresh461 = (*rt).module_normalize_func;
    *fresh461 = module_normalize;
    let ref mut fresh462 = (*rt).module_loader_func;
    *fresh462 = module_loader;
    let ref mut fresh463 = (*rt).module_loader_opaque;
    *fresh463 = opaque;
}
unsafe extern "C" fn js_default_module_normalize_name(
    mut ctx: *mut JSContext,
    mut base_name: *const libc::c_char,
    mut name: *const libc::c_char,
) -> *mut libc::c_char {
    let mut filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut r: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: libc::c_int = 0;
    if *name.offset(0 as libc::c_int as isize) as libc::c_int != '.' as i32 {
        return js_strdup(ctx, name);
    }
    p = strrchr(base_name, '/' as i32);
    if !p.is_null() {
        len = p.offset_from(base_name) as libc::c_long as libc::c_int;
    } else {
        len = 0 as libc::c_int;
    }
    filename = js_malloc(
        ctx,
        (len as libc::c_ulong)
            .wrapping_add(strlen(name))
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if filename.is_null() {
        return 0 as *mut libc::c_char;
    }
    memcpy(
        filename as *mut libc::c_void,
        base_name as *const libc::c_void,
        len as libc::c_ulong,
    );
    *filename.offset(len as isize) = '\0' as i32 as libc::c_char;
    r = name;
    loop {
        if *r.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
            && *r.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32
        {
            r = r.offset(2 as libc::c_int as isize);
        } else {
            if !(*r.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                && *r.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
                && *r.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32)
            {
                break;
            }
            if *filename.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32
            {
                break;
            }
            p = strrchr(filename, '/' as i32);
            if p.is_null() {
                p = filename;
            } else {
                p = p.offset(1);
            }
            if strcmp(p, b".\0" as *const u8 as *const libc::c_char) == 0
                || strcmp(p, b"..\0" as *const u8 as *const libc::c_char) == 0
            {
                break;
            }
            if p > filename {
                p = p.offset(-1);
            }
            *p = '\0' as i32 as libc::c_char;
            r = r.offset(3 as libc::c_int as isize);
        }
    }
    if *filename.offset(0 as libc::c_int as isize) as libc::c_int != '\0' as i32 {
        strcat(filename, b"/\0" as *const u8 as *const libc::c_char);
    }
    strcat(filename, r);
    return filename;
}
unsafe extern "C" fn js_find_loaded_module(
    mut ctx: *mut JSContext,
    mut name: JSAtom,
) -> *mut JSModuleDef {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    el = (*ctx).loaded_modules.next;
    while el != &mut (*ctx).loaded_modules as *mut list_head {
        m = (el as *mut uint8_t).offset(-(8 as libc::c_ulong as isize))
            as *mut JSModuleDef;
        if (*m).module_name == name {
            return m;
        }
        el = (*el).next;
    }
    return 0 as *mut JSModuleDef;
}
unsafe extern "C" fn js_host_resolve_imported_module(
    mut ctx: *mut JSContext,
    mut base_cname: *const libc::c_char,
    mut cname1: *const libc::c_char,
) -> *mut JSModuleDef {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut cname: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut module_name: JSAtom = 0;
    if ((*rt).module_normalize_func).is_none() {
        cname = js_default_module_normalize_name(ctx, base_cname, cname1);
    } else {
        cname = ((*rt).module_normalize_func)
            .expect(
                "non-null function pointer",
            )(ctx, base_cname, cname1, (*rt).module_loader_opaque);
    }
    if cname.is_null() {
        return 0 as *mut JSModuleDef;
    }
    module_name = JS_NewAtom(ctx, cname);
    if module_name == 0 as libc::c_int as libc::c_uint {
        js_free(ctx, cname as *mut libc::c_void);
        return 0 as *mut JSModuleDef;
    }
    m = js_find_loaded_module(ctx, module_name);
    if !m.is_null() {
        js_free(ctx, cname as *mut libc::c_void);
        JS_FreeAtom(ctx, module_name);
        return m;
    }
    JS_FreeAtom(ctx, module_name);
    if ((*rt).module_loader_func).is_none() {
        JS_ThrowReferenceError(
            ctx,
            b"could not load module '%s'\0" as *const u8 as *const libc::c_char,
            cname,
        );
        js_free(ctx, cname as *mut libc::c_void);
        return 0 as *mut JSModuleDef;
    }
    m = ((*rt).module_loader_func)
        .expect("non-null function pointer")(ctx, cname, (*rt).module_loader_opaque);
    js_free(ctx, cname as *mut libc::c_void);
    return m;
}
unsafe extern "C" fn js_host_resolve_imported_module_atom(
    mut ctx: *mut JSContext,
    mut base_module_name: JSAtom,
    mut module_name1: JSAtom,
) -> *mut JSModuleDef {
    let mut base_cname: *const libc::c_char = 0 as *const libc::c_char;
    let mut cname: *const libc::c_char = 0 as *const libc::c_char;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    base_cname = JS_AtomToCString(ctx, base_module_name);
    if base_cname.is_null() {
        return 0 as *mut JSModuleDef;
    }
    cname = JS_AtomToCString(ctx, module_name1);
    if cname.is_null() {
        JS_FreeCString(ctx, base_cname);
        return 0 as *mut JSModuleDef;
    }
    m = js_host_resolve_imported_module(ctx, base_cname, cname);
    JS_FreeCString(ctx, base_cname);
    JS_FreeCString(ctx, cname);
    return m;
}
unsafe extern "C" fn find_resolve_entry(
    mut s: *mut JSResolveState,
    mut m: *mut JSModuleDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s).count {
        let mut re: *mut JSResolveEntry = &mut *((*s).array).offset(i as isize)
            as *mut JSResolveEntry;
        if (*re).module == m && (*re).name == name {
            return i;
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn add_resolve_entry(
    mut ctx: *mut JSContext,
    mut s: *mut JSResolveState,
    mut m: *mut JSModuleDef,
    mut name: JSAtom,
) -> libc::c_int {
    let mut re: *mut JSResolveEntry = 0 as *mut JSResolveEntry;
    if js_resize_array(
        ctx,
        &mut (*s).array as *mut *mut JSResolveEntry as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSResolveEntry>() as libc::c_ulong as libc::c_int,
        &mut (*s).size,
        (*s).count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh464 = (*s).count;
    let fresh465 = *fresh464;
    *fresh464 = *fresh464 + 1;
    re = &mut *((*s).array).offset(fresh465 as isize) as *mut JSResolveEntry;
    let ref mut fresh466 = (*re).module;
    *fresh466 = m;
    (*re).name = JS_DupAtom(ctx, name);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_resolve_export1(
    mut ctx: *mut JSContext,
    mut pmodule: *mut *mut JSModuleDef,
    mut pme: *mut *mut JSExportEntry,
    mut m: *mut JSModuleDef,
    mut export_name: JSAtom,
    mut s: *mut JSResolveState,
) -> JSResolveResultEnum {
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    *pmodule = 0 as *mut JSModuleDef;
    *pme = 0 as *mut JSExportEntry;
    if find_resolve_entry(s, m, export_name) >= 0 as libc::c_int {
        return JS_RESOLVE_RES_CIRCULAR;
    }
    if add_resolve_entry(ctx, s, m, export_name) < 0 as libc::c_int {
        return JS_RESOLVE_RES_EXCEPTION;
    }
    me = find_export_entry(ctx, m, export_name);
    if !me.is_null() {
        if (*me).export_type as libc::c_uint
            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
        {
            *pmodule = m;
            *pme = me;
            return JS_RESOLVE_RES_FOUND;
        } else {
            let mut m1: *mut JSModuleDef = 0 as *mut JSModuleDef;
            m1 = (*((*m).req_module_entries).offset((*me).u.req_module_idx as isize))
                .module;
            if (*me).local_name == JS_ATOM__star_ as libc::c_int as libc::c_uint {
                *pmodule = m;
                *pme = me;
                return JS_RESOLVE_RES_FOUND;
            } else {
                return js_resolve_export1(ctx, pmodule, pme, m1, (*me).local_name, s)
            }
        }
    } else {
        if export_name != JS_ATOM_default as libc::c_int as libc::c_uint {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < (*m).star_export_entries_count {
                let mut se: *mut JSStarExportEntry = &mut *((*m).star_export_entries)
                    .offset(i as isize) as *mut JSStarExportEntry;
                let mut m1_0: *mut JSModuleDef = 0 as *mut JSModuleDef;
                let mut res_m: *mut JSModuleDef = 0 as *mut JSModuleDef;
                let mut res_me: *mut JSExportEntry = 0 as *mut JSExportEntry;
                let mut ret: JSResolveResultEnum = JS_RESOLVE_RES_FOUND;
                m1_0 = (*((*m).req_module_entries).offset((*se).req_module_idx as isize))
                    .module;
                ret = js_resolve_export1(
                    ctx,
                    &mut res_m,
                    &mut res_me,
                    m1_0,
                    export_name,
                    s,
                );
                if ret as libc::c_int == JS_RESOLVE_RES_AMBIGUOUS as libc::c_int
                    || ret as libc::c_int == JS_RESOLVE_RES_EXCEPTION as libc::c_int
                {
                    return ret
                } else {
                    if ret as libc::c_int == JS_RESOLVE_RES_FOUND as libc::c_int {
                        if !(*pme).is_null() {
                            if *pmodule != res_m
                                || (*res_me).local_name != (**pme).local_name
                            {
                                *pmodule = 0 as *mut JSModuleDef;
                                *pme = 0 as *mut JSExportEntry;
                                return JS_RESOLVE_RES_AMBIGUOUS;
                            }
                        } else {
                            *pmodule = res_m;
                            *pme = res_me;
                        }
                    }
                }
                i += 1;
            }
            if !(*pme).is_null() {
                return JS_RESOLVE_RES_FOUND;
            }
        }
        return JS_RESOLVE_RES_NOT_FOUND;
    };
}
unsafe extern "C" fn js_resolve_export(
    mut ctx: *mut JSContext,
    mut pmodule: *mut *mut JSModuleDef,
    mut pme: *mut *mut JSExportEntry,
    mut m: *mut JSModuleDef,
    mut export_name: JSAtom,
) -> JSResolveResultEnum {
    let mut ss: JSResolveState = JSResolveState {
        array: 0 as *mut JSResolveEntry,
        size: 0,
        count: 0,
    };
    let mut s: *mut JSResolveState = &mut ss;
    let mut i: libc::c_int = 0;
    let mut ret: JSResolveResultEnum = JS_RESOLVE_RES_FOUND;
    let ref mut fresh467 = (*s).array;
    *fresh467 = 0 as *mut JSResolveEntry;
    (*s).size = 0 as libc::c_int;
    (*s).count = 0 as libc::c_int;
    ret = js_resolve_export1(ctx, pmodule, pme, m, export_name, s);
    i = 0 as libc::c_int;
    while i < (*s).count {
        JS_FreeAtom(ctx, (*((*s).array).offset(i as isize)).name);
        i += 1;
    }
    js_free(ctx, (*s).array as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn js_resolve_export_throw_error(
    mut ctx: *mut JSContext,
    mut res: JSResolveResultEnum,
    mut m: *mut JSModuleDef,
    mut export_name: JSAtom,
) {
    let mut buf1: [libc::c_char; 64] = [0; 64];
    let mut buf2: [libc::c_char; 64] = [0; 64];
    match res as libc::c_int {
        -1 => {}
        2 => {
            JS_ThrowSyntaxError(
                ctx,
                b"circular reference when looking for export '%s' in module '%s'\0"
                    as *const u8 as *const libc::c_char,
                JS_AtomGetStr(
                    ctx,
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    export_name,
                ),
                JS_AtomGetStr(
                    ctx,
                    buf2.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    (*m).module_name,
                ),
            );
        }
        3 => {
            JS_ThrowSyntaxError(
                ctx,
                b"export '%s' in module '%s' is ambiguous\0" as *const u8
                    as *const libc::c_char,
                JS_AtomGetStr(
                    ctx,
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    export_name,
                ),
                JS_AtomGetStr(
                    ctx,
                    buf2.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    (*m).module_name,
                ),
            );
        }
        1 | _ => {
            JS_ThrowSyntaxError(
                ctx,
                b"Could not find export '%s' in module '%s'\0" as *const u8
                    as *const libc::c_char,
                JS_AtomGetStr(
                    ctx,
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    export_name,
                ),
                JS_AtomGetStr(
                    ctx,
                    buf2.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
                        as libc::c_int,
                    (*m).module_name,
                ),
            );
        }
    };
}
unsafe extern "C" fn find_exported_name(
    mut s: *mut GetExportNamesState,
    mut name: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s).exported_names_count {
        if (*((*s).exported_names).offset(i as isize)).export_name == name {
            return i;
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn get_exported_names(
    mut ctx: *mut JSContext,
    mut s: *mut GetExportNamesState,
    mut m: *mut JSModuleDef,
    mut from_star: BOOL,
) -> libc::c_int {
    let mut en: *mut ExportedNameEntry = 0 as *mut ExportedNameEntry;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s).modules_count {
        if *((*s).modules).offset(i as isize) == m {
            return 0 as libc::c_int;
        }
        i += 1;
    }
    if js_resize_array(
        ctx,
        &mut (*s).modules as *mut *mut *mut JSModuleDef as *mut *mut libc::c_void,
        ::core::mem::size_of::<*mut JSModuleDef>() as libc::c_ulong as libc::c_int,
        &mut (*s).modules_size,
        (*s).modules_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh468 = (*s).modules_count;
    let fresh469 = *fresh468;
    *fresh468 = *fresh468 + 1;
    let ref mut fresh470 = *((*s).modules).offset(fresh469 as isize);
    *fresh470 = m;
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        let mut me: *mut JSExportEntry = &mut *((*m).export_entries).offset(i as isize)
            as *mut JSExportEntry;
        if !(from_star != 0
            && (*me).export_name == JS_ATOM_default as libc::c_int as libc::c_uint)
        {
            j = find_exported_name(s, (*me).export_name);
            if j < 0 as libc::c_int {
                if js_resize_array(
                    ctx,
                    &mut (*s).exported_names as *mut *mut ExportedNameEntry
                        as *mut *mut libc::c_void,
                    ::core::mem::size_of::<ExportedNameEntry>() as libc::c_ulong
                        as libc::c_int,
                    &mut (*s).exported_names_size,
                    (*s).exported_names_count + 1 as libc::c_int,
                ) != 0
                {
                    return -(1 as libc::c_int);
                }
                let ref mut fresh471 = (*s).exported_names_count;
                let fresh472 = *fresh471;
                *fresh471 = *fresh471 + 1;
                en = &mut *((*s).exported_names).offset(fresh472 as isize)
                    as *mut ExportedNameEntry;
                (*en).export_name = (*me).export_name;
                if from_star != 0
                    || (*me).export_type as libc::c_uint
                        != JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
                {
                    let ref mut fresh473 = (*en).u.me;
                    *fresh473 = 0 as *mut JSExportEntry;
                } else {
                    let ref mut fresh474 = (*en).u.me;
                    *fresh474 = me;
                }
            } else {
                en = &mut *((*s).exported_names).offset(j as isize)
                    as *mut ExportedNameEntry;
                let ref mut fresh475 = (*en).u.me;
                *fresh475 = 0 as *mut JSExportEntry;
            }
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*m).star_export_entries_count {
        let mut se: *mut JSStarExportEntry = &mut *((*m).star_export_entries)
            .offset(i as isize) as *mut JSStarExportEntry;
        let mut m1: *mut JSModuleDef = 0 as *mut JSModuleDef;
        m1 = (*((*m).req_module_entries).offset((*se).req_module_idx as isize)).module;
        if get_exported_names(ctx, s, m1, TRUE as libc::c_int) != 0 {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_module_ns_has(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
) -> libc::c_int {
    return (find_own_property1(
        obj as intptr_t as *mut libc::c_void as *mut JSObject,
        atom,
    ) != 0 as *mut libc::c_void as *mut JSShapeProperty) as libc::c_int;
}
static mut js_module_ns_exotic_methods: JSClassExoticMethods = unsafe {
    {
        let mut init = JSClassExoticMethods {
            get_own_property: None,
            get_own_property_names: None,
            delete_property: None,
            define_own_property: None,
            has_property: Some(
                js_module_ns_has
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            get_property: None,
            set_property: None,
        };
        init
    }
};
unsafe extern "C" fn exported_names_cmp(
    mut p1: *const libc::c_void,
    mut p2: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut ctx: *mut JSContext = opaque as *mut JSContext;
    let mut me1: *const ExportedNameEntry = p1 as *const ExportedNameEntry;
    let mut me2: *const ExportedNameEntry = p2 as *const ExportedNameEntry;
    let mut str1: JSValue = 0;
    let mut str2: JSValue = 0;
    let mut ret: libc::c_int = 0;
    str1 = JS_AtomToString(ctx, (*me1).export_name);
    str2 = JS_AtomToString(ctx, (*me2).export_name);
    if JS_IsException(str1) != 0 || JS_IsException(str2) != 0 {
        ret = 0 as libc::c_int;
    } else {
        ret = js_string_compare(
            ctx,
            str1 as intptr_t as *mut libc::c_void as *mut JSString,
            str2 as intptr_t as *mut libc::c_void as *mut JSString,
        );
    }
    JS_FreeValue(ctx, str1);
    JS_FreeValue(ctx, str2);
    return ret;
}
unsafe extern "C" fn js_module_ns_autoinit(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut atom: JSAtom,
    mut opaque: *mut libc::c_void,
) -> JSValue {
    let mut m: *mut JSModuleDef = opaque as *mut JSModuleDef;
    return js_get_module_ns(ctx, m);
}
unsafe extern "C" fn js_build_module_ns(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut s_s: GetExportNamesState = GetExportNamesState {
        modules: 0 as *mut *mut JSModuleDef,
        modules_size: 0,
        modules_count: 0,
        exported_names: 0 as *mut ExportedNameEntry,
        exported_names_size: 0,
        exported_names_count: 0,
    };
    let mut s: *mut GetExportNamesState = &mut s_s;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut pr: *mut JSProperty = 0 as *mut JSProperty;
    obj = JS_NewObjectClass(ctx, JS_CLASS_MODULE_NS as libc::c_int);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<GetExportNamesState>() as libc::c_ulong,
    );
    ret = get_exported_names(ctx, s, m, FALSE as libc::c_int);
    js_free(ctx, (*s).modules as *mut libc::c_void);
    if !(ret != 0) {
        i = 0 as libc::c_int;
        loop {
            if !(i < (*s).exported_names_count) {
                current_block = 7659304154607701039;
                break;
            }
            let mut en: *mut ExportedNameEntry = &mut *((*s).exported_names)
                .offset(i as isize) as *mut ExportedNameEntry;
            let mut res: JSResolveResultEnum = JS_RESOLVE_RES_FOUND;
            let mut res_me: *mut JSExportEntry = 0 as *mut JSExportEntry;
            let mut res_m: *mut JSModuleDef = 0 as *mut JSModuleDef;
            if !((*en).u.me).is_null() {
                res_me = (*en).u.me;
                res_m = m;
                res = JS_RESOLVE_RES_FOUND;
            } else {
                res = js_resolve_export(
                    ctx,
                    &mut res_m,
                    &mut res_me,
                    m,
                    (*en).export_name,
                );
            }
            if res as libc::c_int != JS_RESOLVE_RES_FOUND as libc::c_int {
                if res as libc::c_int != JS_RESOLVE_RES_AMBIGUOUS as libc::c_int {
                    js_resolve_export_throw_error(ctx, res, m, (*en).export_name);
                    current_block = 8886489510299653190;
                    break;
                } else {
                    (*en).export_type = EXPORTED_NAME_AMBIGUOUS;
                }
            } else if (*res_me).local_name
                == JS_ATOM__star_ as libc::c_int as libc::c_uint
            {
                (*en).export_type = EXPORTED_NAME_NS;
                let ref mut fresh476 = (*en).u.module;
                *fresh476 = (*((*res_m).req_module_entries)
                    .offset((*res_me).u.req_module_idx as isize))
                    .module;
            } else {
                (*en).export_type = EXPORTED_NAME_NORMAL;
                if !((*res_me).u.local.var_ref).is_null() {
                    let ref mut fresh477 = (*en).u.var_ref;
                    *fresh477 = (*res_me).u.local.var_ref;
                } else {
                    let mut p1: *mut JSObject = (*res_m).func_obj as intptr_t
                        as *mut libc::c_void as *mut JSObject;
                    p1 = (*res_m).func_obj as intptr_t as *mut libc::c_void
                        as *mut JSObject;
                    let ref mut fresh478 = (*en).u.var_ref;
                    *fresh478 = *((*p1).u.func.var_refs)
                        .offset((*res_me).u.local.var_idx as isize);
                }
            }
            i += 1;
        }
        match current_block {
            8886489510299653190 => {}
            _ => {
                rqsort(
                    (*s).exported_names as *mut libc::c_void,
                    (*s).exported_names_count as size_t,
                    ::core::mem::size_of::<ExportedNameEntry>() as libc::c_ulong,
                    Some(
                        exported_names_cmp
                            as unsafe extern "C" fn(
                                *const libc::c_void,
                                *const libc::c_void,
                                *mut libc::c_void,
                            ) -> libc::c_int,
                    ),
                    ctx as *mut libc::c_void,
                );
                i = 0 as libc::c_int;
                loop {
                    if !(i < (*s).exported_names_count) {
                        current_block = 2516253395664191498;
                        break;
                    }
                    let mut en_0: *mut ExportedNameEntry = &mut *((*s).exported_names)
                        .offset(i as isize) as *mut ExportedNameEntry;
                    match (*en_0).export_type as libc::c_uint {
                        1 => {
                            let mut var_ref: *mut JSVarRef = (*en_0).u.var_ref;
                            pr = add_property(
                                ctx,
                                p,
                                (*en_0).export_name,
                                (1 as libc::c_int) << 2 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (2 as libc::c_int) << 4 as libc::c_int,
                            );
                            if pr.is_null() {
                                current_block = 8886489510299653190;
                                break;
                            }
                            let ref mut fresh479 = (*var_ref)
                                .c2rust_unnamed
                                .header
                                .ref_count;
                            *fresh479 += 1;
                            let ref mut fresh480 = (*pr).u.var_ref;
                            *fresh480 = var_ref;
                        }
                        2 => {
                            if JS_DefineAutoInitProperty(
                                ctx,
                                obj,
                                (*en_0).export_name,
                                JS_AUTOINIT_ID_MODULE_NS,
                                (*en_0).u.module as *mut libc::c_void,
                                (1 as libc::c_int) << 2 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int,
                            ) < 0 as libc::c_int
                            {
                                current_block = 8886489510299653190;
                                break;
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                }
                match current_block {
                    8886489510299653190 => {}
                    _ => {
                        js_free(ctx, (*s).exported_names as *mut libc::c_void);
                        JS_DefinePropertyValue(
                            ctx,
                            obj,
                            JS_ATOM_Symbol_toStringTag as libc::c_int as JSAtom,
                            JS_AtomToString(
                                ctx,
                                JS_ATOM_Module as libc::c_int as JSAtom,
                            ),
                            0 as libc::c_int,
                        );
                        let ref mut fresh481 = (*p).c2rust_unnamed.c2rust_unnamed;
                        (*fresh481).set_extensible(FALSE as libc::c_int as uint8_t);
                        return obj;
                    }
                }
            }
        }
    }
    js_free(ctx, (*s).exported_names as *mut libc::c_void);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_get_module_ns(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> JSValue {
    if JS_IsUndefined((*m).module_ns) != 0 {
        let mut val: JSValue = 0;
        val = js_build_module_ns(ctx, m);
        if JS_IsException(val) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        (*m).module_ns = val;
    }
    return JS_DupValue(ctx, (*m).module_ns);
}
unsafe extern "C" fn js_resolve_module(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut m1: *mut JSModuleDef = 0 as *mut JSModuleDef;
    if (*m).resolved() != 0 {
        return 0 as libc::c_int;
    }
    (*m).set_resolved(TRUE as libc::c_int);
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        m1 = js_host_resolve_imported_module_atom(
            ctx,
            (*m).module_name,
            (*rme).module_name,
        );
        if m1.is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh482 = (*rme).module;
        *fresh482 = m1;
        if js_resolve_module(ctx, m1) < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_create_module_var(
    mut ctx: *mut JSContext,
    mut is_lexical: BOOL,
) -> *mut JSVarRef {
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    var_ref = js_malloc(ctx, ::core::mem::size_of::<JSVarRef>() as libc::c_ulong)
        as *mut JSVarRef;
    if var_ref.is_null() {
        return 0 as *mut JSVarRef;
    }
    (*var_ref).c2rust_unnamed.header.ref_count = 1 as libc::c_int;
    if is_lexical != 0 {
        (*var_ref)
            .value = (JS_TAG_UNINITIALIZED as libc::c_int as uint64_t)
            << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        (*var_ref)
            .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    let ref mut fresh483 = (*var_ref).pvalue;
    *fresh483 = &mut (*var_ref).value;
    let ref mut fresh484 = (*var_ref).c2rust_unnamed.c2rust_unnamed;
    (*fresh484).set_is_detached(TRUE as libc::c_int as uint8_t);
    add_gc_object(
        (*ctx).rt,
        &mut (*var_ref).c2rust_unnamed.header,
        JS_GC_OBJ_TYPE_VAR_REF,
    );
    return var_ref;
}
unsafe extern "C" fn js_create_module_bytecode_function(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> libc::c_int {
    let mut current_block: u64;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut i: libc::c_int = 0;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut func_obj: JSValue = 0;
    let mut bfunc: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    bfunc = (*m).func_obj;
    func_obj = JS_NewObjectProtoClass(
        ctx,
        (*ctx).function_proto,
        JS_CLASS_BYTECODE_FUNCTION as libc::c_int as JSClassID,
    );
    if JS_IsException(func_obj) != 0 {
        return -(1 as libc::c_int);
    }
    b = bfunc as intptr_t as *mut libc::c_void as *mut JSFunctionBytecode;
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh485 = (*p).u.func.function_bytecode;
    *fresh485 = b;
    let ref mut fresh486 = (*b).header.ref_count;
    *fresh486 += 1;
    let ref mut fresh487 = (*p).u.func.home_object;
    *fresh487 = 0 as *mut JSObject;
    let ref mut fresh488 = (*p).u.func.var_refs;
    *fresh488 = 0 as *mut *mut JSVarRef;
    if (*b).closure_var_count != 0 {
        var_refs = js_mallocz(
            ctx,
            (::core::mem::size_of::<*mut JSVarRef>() as libc::c_ulong)
                .wrapping_mul((*b).closure_var_count as libc::c_ulong),
        ) as *mut *mut JSVarRef;
        if var_refs.is_null() {
            current_block = 15808508757351324985;
        } else {
            let ref mut fresh489 = (*p).u.func.var_refs;
            *fresh489 = var_refs;
            i = 0 as libc::c_int;
            loop {
                if !(i < (*b).closure_var_count) {
                    current_block = 11298138898191919651;
                    break;
                }
                let mut cv: *mut JSClosureVar = &mut *((*b).closure_var)
                    .offset(i as isize) as *mut JSClosureVar;
                let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
                if (*cv).is_local() != 0 {
                    var_ref = js_create_module_var(ctx, (*cv).is_lexical() as BOOL);
                    if var_ref.is_null() {
                        current_block = 15808508757351324985;
                        break;
                    }
                    let ref mut fresh490 = *var_refs.offset(i as isize);
                    *fresh490 = var_ref;
                }
                i += 1;
            }
        }
        match current_block {
            11298138898191919651 => {}
            _ => {
                JS_FreeValue(ctx, func_obj);
                return -(1 as libc::c_int);
            }
        }
    }
    (*m).func_obj = func_obj;
    JS_FreeValue(ctx, bfunc);
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_create_module_function(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> libc::c_int {
    let mut is_c_module: BOOL = 0;
    let mut i: libc::c_int = 0;
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    if (*m).func_created() != 0 {
        return 0 as libc::c_int;
    }
    is_c_module = ((*m).init_func).is_some() as libc::c_int;
    if is_c_module != 0 {
        i = 0 as libc::c_int;
        while i < (*m).export_entries_count {
            let mut me: *mut JSExportEntry = &mut *((*m).export_entries)
                .offset(i as isize) as *mut JSExportEntry;
            if (*me).export_type as libc::c_uint
                == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
            {
                var_ref = js_create_module_var(ctx, FALSE as libc::c_int);
                if var_ref.is_null() {
                    return -(1 as libc::c_int);
                }
                let ref mut fresh491 = (*me).u.local.var_ref;
                *fresh491 = var_ref;
            }
            i += 1;
        }
    } else if js_create_module_bytecode_function(ctx, m) != 0 {
        return -(1 as libc::c_int)
    }
    (*m).set_func_created(TRUE as libc::c_int);
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        if js_create_module_function(ctx, (*rme).module) < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_link_module(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> libc::c_int {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut mi: *mut JSImportEntry = 0 as *mut JSImportEntry;
    let mut m1: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut var_ref: *mut JSVarRef = 0 as *mut JSVarRef;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut is_c_module: BOOL = 0;
    let mut ret_val: JSValue = 0;
    if (*m).instantiated() != 0 {
        return 0 as libc::c_int;
    }
    (*m).set_instantiated(TRUE as libc::c_int);
    i = 0 as libc::c_int;
    loop {
        if !(i < (*m).req_module_entries_count) {
            current_block = 7746791466490516765;
            break;
        }
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        if js_link_module(ctx, (*rme).module) < 0 as libc::c_int {
            current_block = 13474444576092412364;
            break;
        }
        i += 1;
    }
    match current_block {
        7746791466490516765 => {
            i = 0 as libc::c_int;
            loop {
                if !(i < (*m).export_entries_count) {
                    current_block = 2668756484064249700;
                    break;
                }
                let mut me: *mut JSExportEntry = &mut *((*m).export_entries)
                    .offset(i as isize) as *mut JSExportEntry;
                if (*me).export_type as libc::c_uint
                    == JS_EXPORT_TYPE_INDIRECT as libc::c_int as libc::c_uint
                    && (*me).local_name != JS_ATOM__star_ as libc::c_int as libc::c_uint
                {
                    let mut ret: JSResolveResultEnum = JS_RESOLVE_RES_FOUND;
                    let mut res_me: *mut JSExportEntry = 0 as *mut JSExportEntry;
                    let mut res_m: *mut JSModuleDef = 0 as *mut JSModuleDef;
                    let mut m1_0: *mut JSModuleDef = 0 as *mut JSModuleDef;
                    m1_0 = (*((*m).req_module_entries)
                        .offset((*me).u.req_module_idx as isize))
                        .module;
                    ret = js_resolve_export(
                        ctx,
                        &mut res_m,
                        &mut res_me,
                        m1_0,
                        (*me).local_name,
                    );
                    if ret as libc::c_int != JS_RESOLVE_RES_FOUND as libc::c_int {
                        js_resolve_export_throw_error(ctx, ret, m, (*me).export_name);
                        current_block = 13474444576092412364;
                        break;
                    }
                }
                i += 1;
            }
            match current_block {
                13474444576092412364 => {}
                _ => {
                    is_c_module = ((*m).init_func).is_some() as libc::c_int;
                    if is_c_module == 0 {
                        p = (*m).func_obj as intptr_t as *mut libc::c_void
                            as *mut JSObject;
                        var_refs = (*p).u.func.var_refs;
                        i = 0 as libc::c_int;
                        loop {
                            if !(i < (*m).import_entries_count) {
                                current_block = 6721012065216013753;
                                break;
                            }
                            mi = &mut *((*m).import_entries).offset(i as isize)
                                as *mut JSImportEntry;
                            m1 = (*((*m).req_module_entries)
                                .offset((*mi).req_module_idx as isize))
                                .module;
                            if (*mi).import_name
                                == JS_ATOM__star_ as libc::c_int as libc::c_uint
                            {
                                let mut val: JSValue = 0;
                                val = js_get_module_ns(ctx, m1);
                                if JS_IsException(val) != 0 {
                                    current_block = 13474444576092412364;
                                    break;
                                }
                                set_value(
                                    ctx,
                                    &mut (**var_refs.offset((*mi).var_idx as isize)).value,
                                    val,
                                );
                            } else {
                                let mut ret_0: JSResolveResultEnum = JS_RESOLVE_RES_FOUND;
                                let mut res_me_0: *mut JSExportEntry = 0
                                    as *mut JSExportEntry;
                                let mut res_m_0: *mut JSModuleDef = 0 as *mut JSModuleDef;
                                let mut p1: *mut JSObject = 0 as *mut JSObject;
                                ret_0 = js_resolve_export(
                                    ctx,
                                    &mut res_m_0,
                                    &mut res_me_0,
                                    m1,
                                    (*mi).import_name,
                                );
                                if ret_0 as libc::c_int
                                    != JS_RESOLVE_RES_FOUND as libc::c_int
                                {
                                    js_resolve_export_throw_error(
                                        ctx,
                                        ret_0,
                                        m1,
                                        (*mi).import_name,
                                    );
                                    current_block = 13474444576092412364;
                                    break;
                                } else if (*res_me_0).local_name
                                    == JS_ATOM__star_ as libc::c_int as libc::c_uint
                                {
                                    let mut val_0: JSValue = 0;
                                    let mut m2: *mut JSModuleDef = 0 as *mut JSModuleDef;
                                    m2 = (*((*res_m_0).req_module_entries)
                                        .offset((*res_me_0).u.req_module_idx as isize))
                                        .module;
                                    val_0 = js_get_module_ns(ctx, m2);
                                    if JS_IsException(val_0) != 0 {
                                        current_block = 13474444576092412364;
                                        break;
                                    }
                                    var_ref = js_create_module_var(ctx, TRUE as libc::c_int);
                                    if var_ref.is_null() {
                                        JS_FreeValue(ctx, val_0);
                                        current_block = 13474444576092412364;
                                        break;
                                    } else {
                                        set_value(ctx, &mut (*var_ref).value, val_0);
                                        let ref mut fresh492 = *var_refs
                                            .offset((*mi).var_idx as isize);
                                        *fresh492 = var_ref;
                                    }
                                } else {
                                    var_ref = (*res_me_0).u.local.var_ref;
                                    if var_ref.is_null() {
                                        p1 = (*res_m_0).func_obj as intptr_t as *mut libc::c_void
                                            as *mut JSObject;
                                        var_ref = *((*p1).u.func.var_refs)
                                            .offset((*res_me_0).u.local.var_idx as isize);
                                    }
                                    let ref mut fresh493 = (*var_ref)
                                        .c2rust_unnamed
                                        .header
                                        .ref_count;
                                    *fresh493 += 1;
                                    let ref mut fresh494 = *var_refs
                                        .offset((*mi).var_idx as isize);
                                    *fresh494 = var_ref;
                                }
                            }
                            i += 1;
                        }
                        match current_block {
                            13474444576092412364 => {}
                            _ => {
                                i = 0 as libc::c_int;
                                while i < (*m).export_entries_count {
                                    let mut me_0: *mut JSExportEntry = &mut *((*m)
                                        .export_entries)
                                        .offset(i as isize) as *mut JSExportEntry;
                                    if (*me_0).export_type as libc::c_uint
                                        == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
                                    {
                                        var_ref = *var_refs
                                            .offset((*me_0).u.local.var_idx as isize);
                                        let ref mut fresh495 = (*var_ref)
                                            .c2rust_unnamed
                                            .header
                                            .ref_count;
                                        *fresh495 += 1;
                                        let ref mut fresh496 = (*me_0).u.local.var_ref;
                                        *fresh496 = var_ref;
                                    }
                                    i += 1;
                                }
                                ret_val = JS_Call(
                                    ctx,
                                    (*m).func_obj,
                                    (JS_TAG_BOOL as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 1 as libc::c_int as uint32_t as libc::c_ulonglong,
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                );
                                if JS_IsException(ret_val) != 0 {
                                    current_block = 13474444576092412364;
                                } else {
                                    JS_FreeValue(ctx, ret_val);
                                    current_block = 13484060386966298149;
                                }
                            }
                        }
                    } else {
                        current_block = 13484060386966298149;
                    }
                    match current_block {
                        13474444576092412364 => {}
                        _ => return 0 as libc::c_int,
                    }
                }
            }
        }
        _ => {}
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetScriptOrModuleName(
    mut ctx: *mut JSContext,
    mut n_stack_levels: libc::c_int,
) -> JSAtom {
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    sf = (*(*ctx).rt).current_stack_frame;
    if sf.is_null() {
        return 0 as libc::c_int as JSAtom;
    }
    loop {
        let fresh497 = n_stack_levels;
        n_stack_levels = n_stack_levels - 1;
        if !(fresh497 > 0 as libc::c_int) {
            break;
        }
        sf = (*sf).prev_frame;
        if sf.is_null() {
            return 0 as libc::c_int as JSAtom;
        }
    }
    if ((*sf).cur_func >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_OBJECT as libc::c_int
    {
        return 0 as libc::c_int as JSAtom;
    }
    p = (*sf).cur_func as intptr_t as *mut libc::c_void as *mut JSObject;
    if js_class_has_bytecode((*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID)
        == 0
    {
        return 0 as libc::c_int as JSAtom;
    }
    b = (*p).u.func.function_bytecode;
    if (*b).has_debug() == 0 {
        return 0 as libc::c_int as JSAtom;
    }
    return JS_DupAtom(ctx, (*b).debug.filename);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetModuleName(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> JSAtom {
    return JS_DupAtom(ctx, (*m).module_name);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetImportMeta(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> JSValue {
    let mut obj: JSValue = 0;
    obj = (*m).meta_obj;
    if JS_IsUndefined(obj) != 0 {
        obj = JS_NewObjectProto(
            ctx,
            (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        );
        if JS_IsException(obj) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        (*m).meta_obj = obj;
    }
    return JS_DupValue(ctx, obj);
}
unsafe extern "C" fn js_import_meta(mut ctx: *mut JSContext) -> JSValue {
    let mut filename: JSAtom = 0;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    filename = JS_GetScriptOrModuleName(ctx, 0 as libc::c_int);
    if !(filename == 0 as libc::c_int as libc::c_uint) {
        m = js_find_loaded_module(ctx, filename);
        JS_FreeAtom(ctx, filename);
        if !m.is_null() {
            return JS_GetImportMeta(ctx, m);
        }
    }
    JS_ThrowTypeError(
        ctx,
        b"import.meta not supported in this context\0" as *const u8
            as *const libc::c_char,
    );
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_RunModule(
    mut ctx: *mut JSContext,
    mut basename: *const libc::c_char,
    mut filename: *const libc::c_char,
) -> *mut JSModuleDef {
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut ret: JSValue = 0;
    let mut func_obj: JSValue = 0;
    m = js_host_resolve_imported_module(ctx, basename, filename);
    if m.is_null() {
        return 0 as *mut JSModuleDef;
    }
    if js_resolve_module(ctx, m) < 0 as libc::c_int {
        js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
        return 0 as *mut JSModuleDef;
    }
    func_obj = JS_DupValue(
        ctx,
        (JS_TAG_MODULE as libc::c_int as uint64_t) << 32 as libc::c_int
            | m as uintptr_t as libc::c_ulonglong,
    );
    ret = JS_EvalFunction(ctx, func_obj);
    if JS_IsException(ret) != 0 {
        return 0 as *mut JSModuleDef;
    }
    JS_FreeValue(ctx, ret);
    return m;
}
unsafe extern "C" fn js_dynamic_import_job(
    mut ctx: *mut JSContext,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut resolving_funcs: *mut JSValue = argv;
    let mut basename_val: JSValue = *argv.offset(2 as libc::c_int as isize);
    let mut specifier: JSValue = *argv.offset(3 as libc::c_int as isize);
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut basename: *const libc::c_char = 0 as *const libc::c_char;
    let mut filename: *const libc::c_char = 0 as *const libc::c_char;
    let mut ret: JSValue = 0;
    let mut err: JSValue = 0;
    let mut ns: JSValue = 0;
    if JS_IsString(basename_val) == 0 {
        JS_ThrowTypeError(
            ctx,
            b"no function filename for import()\0" as *const u8 as *const libc::c_char,
        );
    } else {
        basename = JS_ToCString(ctx, basename_val);
        if !basename.is_null() {
            filename = JS_ToCString(ctx, specifier);
            if !filename.is_null() {
                m = JS_RunModule(ctx, basename, filename);
                JS_FreeCString(ctx, filename);
                if !m.is_null() {
                    ns = js_get_module_ns(ctx, m);
                    if !(JS_IsException(ns) != 0) {
                        ret = JS_Call(
                            ctx,
                            *resolving_funcs.offset(0 as libc::c_int as isize),
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            1 as libc::c_int,
                            &mut ns as *mut JSValue,
                        );
                        JS_FreeValue(ctx, ret);
                        JS_FreeValue(ctx, ns);
                        JS_FreeCString(ctx, basename);
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                }
            }
        }
    }
    err = JS_GetException(ctx);
    ret = JS_Call(
        ctx,
        *resolving_funcs.offset(1 as libc::c_int as isize),
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        1 as libc::c_int,
        &mut err as *mut JSValue,
    );
    JS_FreeValue(ctx, ret);
    JS_FreeValue(ctx, err);
    JS_FreeCString(ctx, basename);
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_dynamic_import(
    mut ctx: *mut JSContext,
    mut specifier: JSValue,
) -> JSValue {
    let mut basename: JSAtom = 0;
    let mut promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut basename_val: JSValue = 0;
    let mut args: [JSValue; 4] = [0; 4];
    basename = JS_GetScriptOrModuleName(ctx, 0 as libc::c_int);
    if basename == 0 as libc::c_int as libc::c_uint {
        basename_val = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        basename_val = JS_AtomToValue(ctx, basename);
    }
    JS_FreeAtom(ctx, basename);
    if JS_IsException(basename_val) != 0 {
        return basename_val;
    }
    promise = JS_NewPromiseCapability(ctx, resolving_funcs.as_mut_ptr());
    if JS_IsException(promise) != 0 {
        JS_FreeValue(ctx, basename_val);
        return promise;
    }
    args[0 as libc::c_int as usize] = resolving_funcs[0 as libc::c_int as usize];
    args[1 as libc::c_int as usize] = resolving_funcs[1 as libc::c_int as usize];
    args[2 as libc::c_int as usize] = basename_val;
    args[3 as libc::c_int as usize] = specifier;
    JS_EnqueueJob(
        ctx,
        Some(
            js_dynamic_import_job
                as unsafe extern "C" fn(
                    *mut JSContext,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        4 as libc::c_int,
        args.as_mut_ptr(),
    );
    JS_FreeValue(ctx, basename_val);
    JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
    return promise;
}
unsafe extern "C" fn js_evaluate_module(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
) -> JSValue {
    let mut m1: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut i: libc::c_int = 0;
    let mut ret_val: JSValue = 0;
    if (*m).eval_mark() != 0 {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (*m).evaluated() != 0 {
        if (*m).eval_has_exception() != 0 {
            return JS_Throw(ctx, JS_DupValue(ctx, (*m).eval_exception))
        } else {
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong
        }
    }
    (*m).set_eval_mark(TRUE as libc::c_int);
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        m1 = (*rme).module;
        if (*m1).eval_mark() == 0 {
            ret_val = js_evaluate_module(ctx, m1);
            if JS_IsException(ret_val) != 0 {
                (*m).set_eval_mark(FALSE as libc::c_int);
                return ret_val;
            }
            JS_FreeValue(ctx, ret_val);
        }
        i += 1;
    }
    if ((*m).init_func).is_some() {
        if ((*m).init_func).expect("non-null function pointer")(ctx, m)
            < 0 as libc::c_int
        {
            ret_val = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        } else {
            ret_val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    } else {
        ret_val = JS_CallFree(
            ctx,
            (*m).func_obj,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            0 as libc::c_int,
            0 as *mut JSValue,
        );
        (*m)
            .func_obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
            << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsException(ret_val) != 0 {
        (*m).set_eval_has_exception(TRUE as libc::c_int);
        (*m).eval_exception = JS_DupValue(ctx, (*(*ctx).rt).current_exception);
    }
    (*m).set_eval_mark(FALSE as libc::c_int);
    (*m).set_evaluated(TRUE as libc::c_int);
    return ret_val;
}
unsafe extern "C" fn js_parse_from_clause(mut s: *mut JSParseState) -> JSAtom {
    let mut module_name: JSAtom = 0;
    if token_is_pseudo_keyword(s, JS_ATOM_from as libc::c_int as JSAtom) == 0 {
        js_parse_error(s, b"from clause expected\0" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int as JSAtom;
    }
    if next_token(s) != 0 {
        return 0 as libc::c_int as JSAtom;
    }
    if (*s).token.val != TOK_STRING as libc::c_int {
        js_parse_error(s, b"string expected\0" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int as JSAtom;
    }
    module_name = JS_ValueToAtom((*s).ctx, (*s).token.u.str_0.str_0);
    if module_name == 0 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int as JSAtom;
    }
    if next_token(s) != 0 {
        JS_FreeAtom((*s).ctx, module_name);
        return 0 as libc::c_int as JSAtom;
    }
    return module_name;
}
unsafe extern "C" fn js_parse_export(mut s: *mut JSParseState) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut m: *mut JSModuleDef = (*(*s).cur_func).module;
    let mut local_name: JSAtom = 0;
    let mut export_name: JSAtom = 0;
    let mut first_export: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tok: libc::c_int = 0;
    let mut module_name: JSAtom = 0;
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    tok = (*s).token.val;
    if tok == TOK_CLASS as libc::c_int {
        return js_parse_class(s, FALSE as libc::c_int, JS_PARSE_EXPORT_NAMED)
    } else {
        if tok == TOK_FUNCTION as libc::c_int
            || token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom) != 0
                && peek_token(s, TRUE as libc::c_int) == TOK_FUNCTION as libc::c_int
        {
            return js_parse_function_decl2(
                s,
                JS_PARSE_FUNC_STATEMENT,
                JS_FUNC_NORMAL,
                0 as libc::c_int as JSAtom,
                (*s).token.ptr,
                (*s).token.line_num,
                JS_PARSE_EXPORT_NAMED,
                0 as *mut *mut JSFunctionDef,
            );
        }
    }
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    match tok {
        123 => {
            first_export = (*m).export_entries_count;
            loop {
                if !((*s).token.val != '}' as i32) {
                    current_block = 572715077006366937;
                    break;
                }
                if token_is_ident((*s).token.val) == 0 {
                    js_parse_error(
                        s,
                        b"identifier expected\0" as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                local_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                export_name = 0 as libc::c_int as JSAtom;
                if next_token(s) != 0 {
                    current_block = 6578377140305491581;
                    break;
                }
                if token_is_pseudo_keyword(s, JS_ATOM_as as libc::c_int as JSAtom) != 0 {
                    if next_token(s) != 0 {
                        current_block = 6578377140305491581;
                        break;
                    }
                    if token_is_ident((*s).token.val) == 0 {
                        js_parse_error(
                            s,
                            b"identifier expected\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 6578377140305491581;
                        break;
                    } else {
                        export_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                        if next_token(s) != 0 {
                            current_block = 6578377140305491581;
                            break;
                        }
                    }
                } else {
                    export_name = JS_DupAtom(ctx, local_name);
                }
                me = add_export_entry(
                    s,
                    m,
                    local_name,
                    export_name,
                    JS_EXPORT_TYPE_LOCAL,
                );
                JS_FreeAtom(ctx, local_name);
                JS_FreeAtom(ctx, export_name);
                if me.is_null() {
                    return -(1 as libc::c_int);
                }
                if (*s).token.val != ',' as i32 {
                    current_block = 572715077006366937;
                    break;
                }
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
            }
            match current_block {
                572715077006366937 => {
                    if js_parse_expect(s, '}' as i32) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if token_is_pseudo_keyword(s, JS_ATOM_from as libc::c_int as JSAtom)
                        != 0
                    {
                        module_name = js_parse_from_clause(s);
                        if module_name == 0 as libc::c_int as libc::c_uint {
                            return -(1 as libc::c_int);
                        }
                        idx = add_req_module_entry(ctx, m, module_name);
                        JS_FreeAtom(ctx, module_name);
                        if idx < 0 as libc::c_int {
                            return -(1 as libc::c_int);
                        }
                        i = first_export;
                        while i < (*m).export_entries_count {
                            me = &mut *((*m).export_entries).offset(i as isize)
                                as *mut JSExportEntry;
                            (*me).export_type = JS_EXPORT_TYPE_INDIRECT;
                            (*me).u.req_module_idx = idx;
                            i += 1;
                        }
                    }
                    current_block = 796174441944384681;
                }
                _ => {
                    JS_FreeAtom(ctx, local_name);
                    current_block = 12884152458899860845;
                }
            }
        }
        42 => {
            if token_is_pseudo_keyword(s, JS_ATOM_as as libc::c_int as JSAtom) != 0 {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                if token_is_ident((*s).token.val) == 0 {
                    js_parse_error(
                        s,
                        b"identifier expected\0" as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                export_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                if next_token(s) != 0 {
                    current_block = 12884152458899860845;
                } else {
                    module_name = js_parse_from_clause(s);
                    if module_name == 0 as libc::c_int as libc::c_uint {
                        current_block = 12884152458899860845;
                    } else {
                        idx = add_req_module_entry(ctx, m, module_name);
                        JS_FreeAtom(ctx, module_name);
                        if idx < 0 as libc::c_int {
                            current_block = 12884152458899860845;
                        } else {
                            me = add_export_entry(
                                s,
                                m,
                                JS_ATOM__star_ as libc::c_int as JSAtom,
                                export_name,
                                JS_EXPORT_TYPE_INDIRECT,
                            );
                            JS_FreeAtom(ctx, export_name);
                            if me.is_null() {
                                return -(1 as libc::c_int);
                            }
                            (*me).u.req_module_idx = idx;
                            current_block = 796174441944384681;
                        }
                    }
                }
            } else {
                module_name = js_parse_from_clause(s);
                if module_name == 0 as libc::c_int as libc::c_uint {
                    return -(1 as libc::c_int);
                }
                idx = add_req_module_entry(ctx, m, module_name);
                JS_FreeAtom(ctx, module_name);
                if idx < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                if add_star_export_entry(ctx, m, idx) < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                current_block = 796174441944384681;
            }
        }
        -64 => {
            if (*s).token.val == TOK_CLASS as libc::c_int {
                return js_parse_class(s, FALSE as libc::c_int, JS_PARSE_EXPORT_DEFAULT)
            } else {
                if (*s).token.val == TOK_FUNCTION as libc::c_int
                    || token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom)
                        != 0
                        && peek_token(s, TRUE as libc::c_int)
                            == TOK_FUNCTION as libc::c_int
                {
                    return js_parse_function_decl2(
                        s,
                        JS_PARSE_FUNC_STATEMENT,
                        JS_FUNC_NORMAL,
                        0 as libc::c_int as JSAtom,
                        (*s).token.ptr,
                        (*s).token.line_num,
                        JS_PARSE_EXPORT_DEFAULT,
                        0 as *mut *mut JSFunctionDef,
                    )
                } else {
                    if js_parse_assign_expr(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                }
            }
            set_object_name(s, JS_ATOM_default as libc::c_int as JSAtom);
            local_name = JS_ATOM__default_ as libc::c_int as JSAtom;
            if define_var(s, (*s).cur_func, local_name, JS_VAR_DEF_LET)
                < 0 as libc::c_int
            {
                return -(1 as libc::c_int);
            }
            emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
            emit_atom(s, local_name);
            emit_u16(s, 0 as libc::c_int as uint16_t);
            if (add_export_entry(
                s,
                m,
                local_name,
                JS_ATOM_default as libc::c_int as JSAtom,
                JS_EXPORT_TYPE_LOCAL,
            ))
                .is_null()
            {
                return -(1 as libc::c_int);
            }
            current_block = 796174441944384681;
        }
        -79 | -47 | -55 => {
            return js_parse_var(s, TRUE as libc::c_int, tok, TRUE as libc::c_int);
        }
        _ => {
            return js_parse_error(
                s,
                b"invalid export syntax\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    match current_block {
        796174441944384681 => return js_parse_expect_semi(s),
        _ => {
            JS_FreeAtom(ctx, export_name);
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn add_import(
    mut s: *mut JSParseState,
    mut m: *mut JSModuleDef,
    mut local_name: JSAtom,
    mut import_name: JSAtom,
) -> libc::c_int {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut i: libc::c_int = 0;
    let mut var_idx: libc::c_int = 0;
    let mut mi: *mut JSImportEntry = 0 as *mut JSImportEntry;
    let mut is_local: BOOL = 0;
    if local_name == JS_ATOM_arguments as libc::c_int as libc::c_uint
        || local_name == JS_ATOM_eval as libc::c_int as libc::c_uint
    {
        return js_parse_error(
            s,
            b"invalid import binding\0" as *const u8 as *const libc::c_char,
        );
    }
    if local_name != JS_ATOM_default as libc::c_int as libc::c_uint {
        i = 0 as libc::c_int;
        while i < (*(*s).cur_func).closure_var_count {
            if (*((*(*s).cur_func).closure_var).offset(i as isize)).var_name
                == local_name
            {
                return js_parse_error(
                    s,
                    b"duplicate import binding\0" as *const u8 as *const libc::c_char,
                );
            }
            i += 1;
        }
    }
    is_local = (import_name == JS_ATOM__star_ as libc::c_int as libc::c_uint)
        as libc::c_int;
    var_idx = add_closure_var(
        ctx,
        (*s).cur_func,
        is_local,
        FALSE as libc::c_int,
        (*m).import_entries_count,
        local_name,
        TRUE as libc::c_int,
        TRUE as libc::c_int,
        FALSE as libc::c_int as JSVarKindEnum,
    );
    if var_idx < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if js_resize_array(
        ctx,
        &mut (*m).import_entries as *mut *mut JSImportEntry as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSImportEntry>() as libc::c_ulong as libc::c_int,
        &mut (*m).import_entries_size,
        (*m).import_entries_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh498 = (*m).import_entries_count;
    let fresh499 = *fresh498;
    *fresh498 = *fresh498 + 1;
    mi = &mut *((*m).import_entries).offset(fresh499 as isize) as *mut JSImportEntry;
    (*mi).import_name = JS_DupAtom(ctx, import_name);
    (*mi).var_idx = var_idx;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_import(mut s: *mut JSParseState) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut m: *mut JSModuleDef = (*(*s).cur_func).module;
    let mut local_name: JSAtom = 0;
    let mut import_name: JSAtom = 0;
    let mut module_name: JSAtom = 0;
    let mut first_import: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    first_import = (*m).import_entries_count;
    if (*s).token.val == TOK_STRING as libc::c_int {
        module_name = JS_ValueToAtom(ctx, (*s).token.u.str_0.str_0);
        if module_name == 0 as libc::c_int as libc::c_uint {
            return -(1 as libc::c_int);
        }
        if next_token(s) != 0 {
            JS_FreeAtom(ctx, module_name);
            return -(1 as libc::c_int);
        }
    } else {
        if (*s).token.val == TOK_IDENT as libc::c_int {
            if (*s).token.u.ident.is_reserved != 0 {
                return js_parse_error_reserved_identifier(s);
            }
            local_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
            import_name = JS_ATOM_default as libc::c_int as JSAtom;
            if next_token(s) != 0 {
                current_block = 8982935226458888733;
            } else if add_import(s, m, local_name, import_name) != 0 {
                current_block = 8982935226458888733;
            } else {
                JS_FreeAtom(ctx, local_name);
                if (*s).token.val != ',' as i32 {
                    current_block = 1559405320077436205;
                } else {
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    current_block = 11298138898191919651;
                }
            }
        } else {
            current_block = 11298138898191919651;
        }
        match current_block {
            11298138898191919651 => {
                if (*s).token.val == '*' as i32 {
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if token_is_pseudo_keyword(s, JS_ATOM_as as libc::c_int as JSAtom)
                        == 0
                    {
                        return js_parse_error(
                            s,
                            b"expecting 'as'\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    if token_is_ident((*s).token.val) == 0 {
                        js_parse_error(
                            s,
                            b"identifier expected\0" as *const u8 as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    local_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                    import_name = JS_ATOM__star_ as libc::c_int as JSAtom;
                    if next_token(s) != 0 {
                        current_block = 8982935226458888733;
                    } else if add_import(s, m, local_name, import_name) != 0 {
                        current_block = 8982935226458888733;
                    } else {
                        JS_FreeAtom(ctx, local_name);
                        current_block = 1559405320077436205;
                    }
                } else if (*s).token.val == '{' as i32 {
                    if next_token(s) != 0 {
                        return -(1 as libc::c_int);
                    }
                    loop {
                        if !((*s).token.val != '}' as i32) {
                            current_block = 317151059986244064;
                            break;
                        }
                        if token_is_ident((*s).token.val) == 0 {
                            js_parse_error(
                                s,
                                b"identifier expected\0" as *const u8 as *const libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        }
                        import_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                        local_name = 0 as libc::c_int as JSAtom;
                        if next_token(s) != 0 {
                            current_block = 8982935226458888733;
                            break;
                        }
                        if token_is_pseudo_keyword(
                            s,
                            JS_ATOM_as as libc::c_int as JSAtom,
                        ) != 0
                        {
                            if next_token(s) != 0 {
                                current_block = 8982935226458888733;
                                break;
                            }
                            if token_is_ident((*s).token.val) == 0 {
                                js_parse_error(
                                    s,
                                    b"identifier expected\0" as *const u8 as *const libc::c_char,
                                );
                                current_block = 8982935226458888733;
                                break;
                            } else {
                                local_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                                if next_token(s) != 0 {
                                    current_block = 8982935226458888733;
                                    break;
                                }
                            }
                        } else {
                            local_name = JS_DupAtom(ctx, import_name);
                        }
                        if add_import(s, m, local_name, import_name) != 0 {
                            current_block = 8982935226458888733;
                            break;
                        }
                        JS_FreeAtom(ctx, local_name);
                        JS_FreeAtom(ctx, import_name);
                        if (*s).token.val != ',' as i32 {
                            current_block = 317151059986244064;
                            break;
                        }
                        if next_token(s) != 0 {
                            return -(1 as libc::c_int);
                        }
                    }
                    match current_block {
                        8982935226458888733 => {}
                        _ => {
                            if js_parse_expect(s, '}' as i32) != 0 {
                                return -(1 as libc::c_int);
                            }
                            current_block = 1559405320077436205;
                        }
                    }
                } else {
                    current_block = 1559405320077436205;
                }
            }
            _ => {}
        }
        match current_block {
            1559405320077436205 => {
                module_name = js_parse_from_clause(s);
                if module_name == 0 as libc::c_int as libc::c_uint {
                    return -(1 as libc::c_int);
                }
            }
            _ => {
                JS_FreeAtom(ctx, local_name);
                JS_FreeAtom(ctx, import_name);
                return -(1 as libc::c_int);
            }
        }
    }
    idx = add_req_module_entry(ctx, m, module_name);
    JS_FreeAtom(ctx, module_name);
    if idx < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    i = first_import;
    while i < (*m).import_entries_count {
        (*((*m).import_entries).offset(i as isize)).req_module_idx = idx;
        i += 1;
    }
    return js_parse_expect_semi(s);
}
unsafe extern "C" fn js_parse_source_element(mut s: *mut JSParseState) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut tok: libc::c_int = 0;
    if (*s).token.val == TOK_FUNCTION as libc::c_int
        || token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom) != 0
            && peek_token(s, TRUE as libc::c_int) == TOK_FUNCTION as libc::c_int
    {
        if js_parse_function_decl(
            s,
            JS_PARSE_FUNC_STATEMENT,
            JS_FUNC_NORMAL,
            0 as libc::c_int as JSAtom,
            (*s).token.ptr,
            (*s).token.line_num,
        ) != 0
        {
            return -(1 as libc::c_int);
        }
    } else if (*s).token.val == TOK_EXPORT as libc::c_int && !((*fd).module).is_null() {
        if js_parse_export(s) != 0 {
            return -(1 as libc::c_int);
        }
    } else if (*s).token.val == TOK_IMPORT as libc::c_int && !((*fd).module).is_null()
        && {
            tok = peek_token(s, FALSE as libc::c_int);
            tok != '(' as i32 && tok != '.' as i32
        }
    {
        if js_parse_import(s) != 0 {
            return -(1 as libc::c_int);
        }
    } else if js_parse_statement_or_decl(
        s,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int)
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_new_function_def(
    mut ctx: *mut JSContext,
    mut parent: *mut JSFunctionDef,
    mut is_eval: BOOL,
    mut is_func_expr: BOOL,
    mut filename: *const libc::c_char,
    mut line_num: libc::c_int,
) -> *mut JSFunctionDef {
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    fd = js_mallocz(ctx, ::core::mem::size_of::<JSFunctionDef>() as libc::c_ulong)
        as *mut JSFunctionDef;
    if fd.is_null() {
        return 0 as *mut JSFunctionDef;
    }
    let ref mut fresh500 = (*fd).ctx;
    *fresh500 = ctx;
    init_list_head(&mut (*fd).child_list);
    let ref mut fresh501 = (*fd).parent;
    *fresh501 = parent;
    (*fd).parent_cpool_idx = -(1 as libc::c_int);
    if !parent.is_null() {
        list_add_tail(&mut (*fd).link, &mut (*parent).child_list);
        (*fd).js_mode = (*parent).js_mode;
        (*fd).parent_scope_level = (*parent).scope_level;
    }
    (*fd).is_eval = is_eval;
    (*fd).is_func_expr = is_func_expr;
    js_dbuf_init(ctx, &mut (*fd).byte_code);
    (*fd).last_opcode_pos = -(1 as libc::c_int);
    (*fd).func_name = 0 as libc::c_int as JSAtom;
    (*fd).var_object_idx = -(1 as libc::c_int);
    (*fd).arg_var_object_idx = -(1 as libc::c_int);
    (*fd).arguments_var_idx = -(1 as libc::c_int);
    (*fd).arguments_arg_idx = -(1 as libc::c_int);
    (*fd).func_var_idx = -(1 as libc::c_int);
    (*fd).eval_ret_idx = -(1 as libc::c_int);
    (*fd).this_var_idx = -(1 as libc::c_int);
    (*fd).new_target_var_idx = -(1 as libc::c_int);
    (*fd).this_active_func_var_idx = -(1 as libc::c_int);
    (*fd).home_object_var_idx = -(1 as libc::c_int);
    let ref mut fresh502 = (*fd).scopes;
    *fresh502 = ((*fd).def_scope_array).as_mut_ptr();
    (*fd)
        .scope_size = (::core::mem::size_of::<[JSVarScope; 4]>() as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<JSVarScope>() as libc::c_ulong)
        as libc::c_int;
    (*fd).scope_count = 1 as libc::c_int;
    (*((*fd).scopes).offset(0 as libc::c_int as isize)).first = -(1 as libc::c_int);
    (*((*fd).scopes).offset(0 as libc::c_int as isize)).parent = -(1 as libc::c_int);
    (*fd).scope_level = 0 as libc::c_int;
    (*fd).scope_first = -(1 as libc::c_int);
    (*fd).body_scope = -(1 as libc::c_int);
    (*fd).filename = JS_NewAtom(ctx, filename);
    (*fd).line_num = line_num;
    js_dbuf_init(ctx, &mut (*fd).pc2line);
    (*fd).last_opcode_line_num = line_num;
    return fd;
}
unsafe extern "C" fn free_bytecode_atoms(
    mut rt: *mut JSRuntime,
    mut bc_buf: *const uint8_t,
    mut bc_len: libc::c_int,
    mut use_short_opcodes: BOOL,
) {
    let mut pos: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    let mut oi: *const JSOpCode = 0 as *const JSOpCode;
    pos = 0 as libc::c_int;
    while pos < bc_len {
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        if use_short_opcodes != 0 {
            oi = &*opcode_info
                .as_ptr()
                .offset(
                    (if op >= OP_TEMP_START as libc::c_int {
                        op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
                    } else {
                        op
                    }) as isize,
                ) as *const JSOpCode;
        } else {
            oi = &*opcode_info.as_ptr().offset(op as isize) as *const JSOpCode;
        }
        len = (*oi).size as libc::c_int;
        match (*oi).fmt as libc::c_int {
            23 | 24 | 25 | 26 | 27 => {
                atom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                JS_FreeAtomRT(rt, atom);
            }
            _ => {}
        }
        pos += len;
    }
}
unsafe extern "C" fn js_free_function_def(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) {
    let mut i: libc::c_int = 0;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    el = (*fd).child_list.next;
    el1 = (*el).next;
    while el != &mut (*fd).child_list as *mut list_head {
        let mut fd1: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
        fd1 = (el as *mut uint8_t).offset(-(24 as libc::c_ulong as isize))
            as *mut JSFunctionDef;
        js_free_function_def(ctx, fd1);
        el = el1;
        el1 = (*el).next;
    }
    free_bytecode_atoms(
        (*ctx).rt,
        (*fd).byte_code.buf,
        (*fd).byte_code.size as libc::c_int,
        (*fd).use_short_opcodes,
    );
    dbuf_free(&mut (*fd).byte_code);
    js_free(ctx, (*fd).jump_slots as *mut libc::c_void);
    js_free(ctx, (*fd).label_slots as *mut libc::c_void);
    js_free(ctx, (*fd).line_number_slots as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*fd).cpool_count {
        JS_FreeValue(ctx, *((*fd).cpool).offset(i as isize));
        i += 1;
    }
    js_free(ctx, (*fd).cpool as *mut libc::c_void);
    JS_FreeAtom(ctx, (*fd).func_name);
    i = 0 as libc::c_int;
    while i < (*fd).var_count {
        JS_FreeAtom(ctx, (*((*fd).vars).offset(i as isize)).var_name);
        i += 1;
    }
    js_free(ctx, (*fd).vars as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*fd).arg_count {
        JS_FreeAtom(ctx, (*((*fd).args).offset(i as isize)).var_name);
        i += 1;
    }
    js_free(ctx, (*fd).args as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*fd).global_var_count {
        JS_FreeAtom(ctx, (*((*fd).global_vars).offset(i as isize)).var_name);
        i += 1;
    }
    js_free(ctx, (*fd).global_vars as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < (*fd).closure_var_count {
        let mut cv: *mut JSClosureVar = &mut *((*fd).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        JS_FreeAtom(ctx, (*cv).var_name);
        i += 1;
    }
    js_free(ctx, (*fd).closure_var as *mut libc::c_void);
    if (*fd).scopes != ((*fd).def_scope_array).as_mut_ptr() {
        js_free(ctx, (*fd).scopes as *mut libc::c_void);
    }
    JS_FreeAtom(ctx, (*fd).filename);
    dbuf_free(&mut (*fd).pc2line);
    js_free(ctx, (*fd).source as *mut libc::c_void);
    if !((*fd).parent).is_null() {
        list_del(&mut (*fd).link);
    }
    js_free(ctx, fd as *mut libc::c_void);
}
unsafe extern "C" fn add_closure_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut is_local: BOOL,
    mut is_arg: BOOL,
    mut var_idx: libc::c_int,
    mut var_name: JSAtom,
    mut is_const: BOOL,
    mut is_lexical: BOOL,
    mut var_kind: JSVarKindEnum,
) -> libc::c_int {
    let mut cv: *mut JSClosureVar = 0 as *mut JSClosureVar;
    if (*s).closure_var_count >= 65536 as libc::c_int {
        JS_ThrowInternalError(
            ctx,
            b"too many closure variables\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if js_resize_array(
        ctx,
        &mut (*s).closure_var as *mut *mut JSClosureVar as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSClosureVar>() as libc::c_ulong as libc::c_int,
        &mut (*s).closure_var_size,
        (*s).closure_var_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh503 = (*s).closure_var_count;
    let fresh504 = *fresh503;
    *fresh503 = *fresh503 + 1;
    cv = &mut *((*s).closure_var).offset(fresh504 as isize) as *mut JSClosureVar;
    (*cv).set_is_local(is_local as uint8_t);
    (*cv).set_is_arg(is_arg as uint8_t);
    (*cv).set_is_const(is_const as uint8_t);
    (*cv).set_is_lexical(is_lexical as uint8_t);
    (*cv).set_var_kind(var_kind as uint8_t);
    (*cv).var_idx = var_idx as uint16_t;
    (*cv).var_name = JS_DupAtom(ctx, var_name);
    return (*s).closure_var_count - 1 as libc::c_int;
}
unsafe extern "C" fn find_closure_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s).closure_var_count {
        let mut cv: *mut JSClosureVar = &mut *((*s).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        if (*cv).var_name == var_name {
            return i;
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn get_closure_var2(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut fd: *mut JSFunctionDef,
    mut is_local: BOOL,
    mut is_arg: BOOL,
    mut var_idx: libc::c_int,
    mut var_name: JSAtom,
    mut is_const: BOOL,
    mut is_lexical: BOOL,
    mut var_kind: JSVarKindEnum,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if fd != (*s).parent {
        var_idx = get_closure_var2(
            ctx,
            (*s).parent,
            fd,
            is_local,
            is_arg,
            var_idx,
            var_name,
            is_const,
            is_lexical,
            var_kind,
        );
        if var_idx < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        is_local = FALSE as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*s).closure_var_count {
        let mut cv: *mut JSClosureVar = &mut *((*s).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        if (*cv).var_idx as libc::c_int == var_idx
            && (*cv).is_arg() as libc::c_int == is_arg
            && (*cv).is_local() as libc::c_int == is_local
        {
            return i;
        }
        i += 1;
    }
    return add_closure_var(
        ctx,
        s,
        is_local,
        is_arg,
        var_idx,
        var_name,
        is_const,
        is_lexical,
        var_kind,
    );
}
unsafe extern "C" fn get_closure_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut fd: *mut JSFunctionDef,
    mut is_arg: BOOL,
    mut var_idx: libc::c_int,
    mut var_name: JSAtom,
    mut is_const: BOOL,
    mut is_lexical: BOOL,
    mut var_kind: JSVarKindEnum,
) -> libc::c_int {
    return get_closure_var2(
        ctx,
        s,
        fd,
        TRUE as libc::c_int,
        is_arg,
        var_idx,
        var_name,
        is_const,
        is_lexical,
        var_kind,
    );
}
unsafe extern "C" fn get_with_scope_opcode(mut op: libc::c_int) -> libc::c_int {
    if op == OP_scope_get_var_undef as libc::c_int {
        return OP_with_get_var as libc::c_int
    } else {
        return OP_with_get_var as libc::c_int + (op - OP_scope_get_var as libc::c_int)
    };
}
unsafe extern "C" fn can_opt_put_ref_value(
    mut bc_buf: *const uint8_t,
    mut pos: libc::c_int,
) -> BOOL {
    let mut opcode: libc::c_int = *bc_buf.offset(pos as isize) as libc::c_int;
    return (*bc_buf.offset((pos + 1 as libc::c_int) as isize) as libc::c_int
        == OP_put_ref_value as libc::c_int
        && (opcode == OP_insert3 as libc::c_int || opcode == OP_perm4 as libc::c_int
            || opcode == OP_nop as libc::c_int || opcode == OP_rot3l as libc::c_int))
        as libc::c_int;
}
unsafe extern "C" fn can_opt_put_global_ref_value(
    mut bc_buf: *const uint8_t,
    mut pos: libc::c_int,
) -> BOOL {
    let mut opcode: libc::c_int = *bc_buf.offset(pos as isize) as libc::c_int;
    return (*bc_buf.offset((pos + 1 as libc::c_int) as isize) as libc::c_int
        == OP_put_ref_value as libc::c_int
        && (opcode == OP_insert3 as libc::c_int || opcode == OP_perm4 as libc::c_int
            || opcode == OP_nop as libc::c_int || opcode == OP_rot3l as libc::c_int))
        as libc::c_int;
}
unsafe extern "C" fn optimize_scope_make_ref(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut bc: *mut DynBuf,
    mut bc_buf: *mut uint8_t,
    mut ls: *mut LabelSlot,
    mut pos_next: libc::c_int,
    mut get_op: libc::c_int,
    mut var_idx: libc::c_int,
) -> libc::c_int {
    let mut label_pos: libc::c_int = 0;
    let mut end_pos: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    if *bc_buf.offset(pos_next as isize) as libc::c_int
        == OP_get_ref_value as libc::c_int
    {
        dbuf_putc(bc, get_op as uint8_t);
        dbuf_put_u16(bc, var_idx as uint16_t);
        pos_next += 1;
    }
    label_pos = (*ls).pos;
    pos = label_pos - 5 as libc::c_int;
    assert(
        (*bc_buf.offset(pos as isize) as libc::c_int == OP_label as libc::c_int)
            as libc::c_int,
    );
    end_pos = label_pos + 2 as libc::c_int;
    if *bc_buf.offset(label_pos as isize) as libc::c_int == OP_insert3 as libc::c_int {
        let fresh505 = pos;
        pos = pos + 1;
        *bc_buf.offset(fresh505 as isize) = OP_dup as libc::c_int as uint8_t;
    }
    *bc_buf.offset(pos as isize) = (get_op + 1 as libc::c_int) as uint8_t;
    put_u16(
        bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
        var_idx as uint16_t,
    );
    pos += 3 as libc::c_int;
    while pos < end_pos {
        let fresh506 = pos;
        pos = pos + 1;
        *bc_buf.offset(fresh506 as isize) = OP_nop as libc::c_int as uint8_t;
    }
    return pos_next;
}
unsafe extern "C" fn optimize_scope_make_global_ref(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut bc: *mut DynBuf,
    mut bc_buf: *mut uint8_t,
    mut ls: *mut LabelSlot,
    mut pos_next: libc::c_int,
    mut var_name: JSAtom,
) -> libc::c_int {
    let mut label_pos: libc::c_int = 0;
    let mut end_pos: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut is_strict: BOOL = 0;
    is_strict = ((*s).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
        != 0 as libc::c_int) as libc::c_int;
    if is_strict != 0 {
        dbuf_putc(bc, OP_check_var as libc::c_int as uint8_t);
        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
    }
    if *bc_buf.offset(pos_next as isize) as libc::c_int
        == OP_get_ref_value as libc::c_int
    {
        dbuf_putc(bc, OP_get_var as libc::c_int as uint8_t);
        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
        pos_next += 1;
    }
    label_pos = (*ls).pos;
    pos = label_pos - 5 as libc::c_int;
    assert(
        (*bc_buf.offset(pos as isize) as libc::c_int == OP_label as libc::c_int)
            as libc::c_int,
    );
    end_pos = label_pos + 2 as libc::c_int;
    op = *bc_buf.offset(label_pos as isize) as libc::c_int;
    if is_strict != 0 {
        if op != OP_nop as libc::c_int {
            match op {
                22 => {
                    op = OP_insert2 as libc::c_int;
                }
                25 => {
                    op = OP_perm3 as libc::c_int;
                }
                29 => {
                    op = OP_swap as libc::c_int;
                }
                _ => {
                    abort();
                }
            }
            let fresh507 = pos;
            pos = pos + 1;
            *bc_buf.offset(fresh507 as isize) = op as uint8_t;
        }
    } else if op == OP_insert3 as libc::c_int {
        let fresh508 = pos;
        pos = pos + 1;
        *bc_buf.offset(fresh508 as isize) = OP_dup as libc::c_int as uint8_t;
    }
    if is_strict != 0 {
        *bc_buf.offset(pos as isize) = OP_put_var_strict as libc::c_int as uint8_t;
    } else {
        *bc_buf.offset(pos as isize) = OP_put_var as libc::c_int as uint8_t;
    }
    put_u32(
        bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
        JS_DupAtom(ctx, var_name),
    );
    pos += 5 as libc::c_int;
    while pos < end_pos {
        let fresh509 = pos;
        pos = pos + 1;
        *bc_buf.offset(fresh509 as isize) = OP_nop as libc::c_int as uint8_t;
    }
    return pos_next;
}
unsafe extern "C" fn add_var_this(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    idx = add_var(ctx, fd, JS_ATOM_this as libc::c_int as JSAtom);
    if idx >= 0 as libc::c_int && (*fd).is_derived_class_constructor != 0 {
        let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(idx as isize)
            as *mut JSVarDef;
        (*vd).set_is_lexical(1 as libc::c_int as uint8_t);
    }
    return idx;
}
unsafe extern "C" fn resolve_pseudo_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
) -> libc::c_int {
    let mut var_idx: libc::c_int = 0;
    if (*s).has_this_binding == 0 {
        return -(1 as libc::c_int);
    }
    match var_name {
        115 => {
            if (*s).home_object_var_idx < 0 as libc::c_int {
                (*s).home_object_var_idx = add_var(ctx, s, var_name);
            }
            var_idx = (*s).home_object_var_idx;
        }
        114 => {
            if (*s).this_active_func_var_idx < 0 as libc::c_int {
                (*s).this_active_func_var_idx = add_var(ctx, s, var_name);
            }
            var_idx = (*s).this_active_func_var_idx;
        }
        113 => {
            if (*s).new_target_var_idx < 0 as libc::c_int {
                (*s).new_target_var_idx = add_var(ctx, s, var_name);
            }
            var_idx = (*s).new_target_var_idx;
        }
        8 => {
            if (*s).this_var_idx < 0 as libc::c_int {
                (*s).this_var_idx = add_var_this(ctx, s);
            }
            var_idx = (*s).this_var_idx;
        }
        _ => {
            var_idx = -(1 as libc::c_int);
        }
    }
    return var_idx;
}
unsafe extern "C" fn var_object_test(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
    mut op: libc::c_int,
    mut bc: *mut DynBuf,
    mut plabel_done: *mut libc::c_int,
    mut is_with: BOOL,
) {
    dbuf_putc(bc, get_with_scope_opcode(op) as uint8_t);
    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
    *plabel_done = new_label_fd(s, *plabel_done);
    dbuf_put_u32(bc, *plabel_done as uint32_t);
    dbuf_putc(bc, is_with as uint8_t);
    update_label(s, *plabel_done, 1 as libc::c_int);
    let ref mut fresh510 = (*s).jump_size;
    *fresh510 += 1;
}
unsafe extern "C" fn resolve_scope_var(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
    mut scope_level: libc::c_int,
    mut op: libc::c_int,
    mut bc: *mut DynBuf,
    mut bc_buf: *mut uint8_t,
    mut ls: *mut LabelSlot,
    mut pos_next: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut idx: libc::c_int = 0;
    let mut var_idx: libc::c_int = 0;
    let mut is_put: libc::c_int = 0;
    let mut label_done: libc::c_int = 0;
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    let mut is_pseudo_var: BOOL = 0;
    let mut is_arg_scope: BOOL = 0;
    label_done = -(1 as libc::c_int);
    is_pseudo_var = (var_name == JS_ATOM_home_object as libc::c_int as libc::c_uint
        || var_name == JS_ATOM_this_active_func as libc::c_int as libc::c_uint
        || var_name == JS_ATOM_new_target as libc::c_int as libc::c_uint
        || var_name == JS_ATOM_this as libc::c_int as libc::c_uint) as libc::c_int;
    var_idx = -(1 as libc::c_int);
    idx = (*((*s).scopes).offset(scope_level as isize)).first;
    loop {
        if !(idx >= 0 as libc::c_int) {
            current_block = 18317007320854588510;
            break;
        }
        vd = &mut *((*s).vars).offset(idx as isize) as *mut JSVarDef;
        if (*vd).var_name == var_name {
            if op == OP_scope_put_var as libc::c_int
                || op == OP_scope_make_ref as libc::c_int
            {
                if (*vd).is_const() != 0 {
                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                    current_block = 3590608195283441220;
                    break;
                }
            }
            var_idx = idx;
            current_block = 18317007320854588510;
            break;
        } else {
            if (*vd).var_name == JS_ATOM__with_ as libc::c_int as libc::c_uint
                && is_pseudo_var == 0
            {
                dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
                dbuf_put_u16(bc, idx as uint16_t);
                var_object_test(
                    ctx,
                    s,
                    var_name,
                    op,
                    bc,
                    &mut label_done,
                    1 as libc::c_int,
                );
            }
            idx = (*vd).scope_next;
        }
    }
    match current_block {
        18317007320854588510 => {
            is_arg_scope = (idx == -(2 as libc::c_int)) as libc::c_int;
            if var_idx < 0 as libc::c_int {
                if is_arg_scope == 0 {
                    var_idx = find_var(ctx, s, var_name);
                }
                if var_idx < 0 as libc::c_int && is_pseudo_var != 0 {
                    var_idx = resolve_pseudo_var(ctx, s, var_name);
                }
                if var_idx < 0 as libc::c_int
                    && var_name == JS_ATOM_arguments as libc::c_int as libc::c_uint
                    && (*s).has_arguments_binding != 0
                {
                    var_idx = add_arguments_var(ctx, s);
                }
                if var_idx < 0 as libc::c_int && (*s).is_func_expr != 0
                    && var_name == (*s).func_name
                {
                    var_idx = add_func_var(ctx, s, var_name);
                }
            }
            if var_idx >= 0 as libc::c_int {
                if (op == OP_scope_put_var as libc::c_int
                    || op == OP_scope_make_ref as libc::c_int)
                    && var_idx & 0x20000000 as libc::c_int == 0
                    && (*((*s).vars).offset(var_idx as isize)).is_const() as libc::c_int
                        != 0
                {
                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                } else {
                    let mut current_block_89: u64;
                    match op {
                        185 => {
                            if var_idx & 0x20000000 as libc::c_int == 0
                                && (*((*s).vars).offset(var_idx as isize)).var_kind()
                                    as libc::c_int == JS_VAR_FUNCTION_NAME as libc::c_int
                            {
                                dbuf_putc(bc, OP_object as libc::c_int as uint8_t);
                                dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
                                dbuf_put_u16(bc, var_idx as uint16_t);
                                dbuf_putc(bc, OP_define_field as libc::c_int as uint8_t);
                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                dbuf_putc(bc, OP_push_atom_value as libc::c_int as uint8_t);
                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                            } else if label_done == -(1 as libc::c_int)
                                && can_opt_put_ref_value(bc_buf, (*ls).pos) != 0
                            {
                                let mut get_op: libc::c_int = 0;
                                if var_idx & 0x20000000 as libc::c_int != 0 {
                                    get_op = OP_get_arg as libc::c_int;
                                    var_idx -= 0x20000000 as libc::c_int;
                                } else if (*((*s).vars).offset(var_idx as isize))
                                    .is_lexical() != 0
                                {
                                    get_op = OP_get_loc_check as libc::c_int;
                                } else {
                                    get_op = OP_get_loc as libc::c_int;
                                }
                                pos_next = optimize_scope_make_ref(
                                    ctx,
                                    s,
                                    bc,
                                    bc_buf,
                                    ls,
                                    pos_next,
                                    get_op,
                                    var_idx,
                                );
                            } else if var_idx & 0x20000000 as libc::c_int != 0 {
                                dbuf_putc(bc, OP_make_arg_ref as libc::c_int as uint8_t);
                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                dbuf_put_u16(
                                    bc,
                                    (var_idx - 0x20000000 as libc::c_int) as uint16_t,
                                );
                            } else {
                                dbuf_putc(bc, OP_make_loc_ref as libc::c_int as uint8_t);
                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                dbuf_put_u16(bc, var_idx as uint16_t);
                            }
                            current_block_89 = 14865402277128115059;
                        }
                        186 => {
                            dbuf_putc(bc, OP_undefined as libc::c_int as uint8_t);
                            current_block_89 = 4070248935163474208;
                        }
                        181 | 182 | 183 | 187 => {
                            current_block_89 = 4070248935163474208;
                        }
                        184 => {
                            dbuf_putc(bc, OP_push_false as libc::c_int as uint8_t);
                            current_block_89 = 14865402277128115059;
                        }
                        _ => {
                            current_block_89 = 14865402277128115059;
                        }
                    }
                    match current_block_89 {
                        4070248935163474208 => {
                            is_put = (op == OP_scope_put_var as libc::c_int
                                || op == OP_scope_put_var_init as libc::c_int)
                                as libc::c_int;
                            if var_idx & 0x20000000 as libc::c_int != 0 {
                                dbuf_putc(
                                    bc,
                                    (OP_get_arg as libc::c_int + is_put) as uint8_t,
                                );
                                dbuf_put_u16(
                                    bc,
                                    (var_idx - 0x20000000 as libc::c_int) as uint16_t,
                                );
                            } else {
                                if is_put != 0 {
                                    if (*((*s).vars).offset(var_idx as isize)).is_lexical() != 0
                                    {
                                        if op == OP_scope_put_var_init as libc::c_int {
                                            if var_name == JS_ATOM_this as libc::c_int as libc::c_uint {
                                                dbuf_putc(
                                                    bc,
                                                    OP_put_loc_check_init as libc::c_int as uint8_t,
                                                );
                                            } else {
                                                dbuf_putc(bc, OP_put_loc as libc::c_int as uint8_t);
                                            }
                                        } else {
                                            dbuf_putc(bc, OP_put_loc_check as libc::c_int as uint8_t);
                                        }
                                    } else {
                                        dbuf_putc(bc, OP_put_loc as libc::c_int as uint8_t);
                                    }
                                } else if (*((*s).vars).offset(var_idx as isize))
                                    .is_lexical() != 0
                                {
                                    dbuf_putc(bc, OP_get_loc_check as libc::c_int as uint8_t);
                                } else {
                                    dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
                                }
                                dbuf_put_u16(bc, var_idx as uint16_t);
                            }
                        }
                        _ => {}
                    }
                }
            } else {
                if is_arg_scope == 0 && (*s).var_object_idx >= 0 as libc::c_int
                    && is_pseudo_var == 0
                {
                    dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
                    dbuf_put_u16(bc, (*s).var_object_idx as uint16_t);
                    var_object_test(
                        ctx,
                        s,
                        var_name,
                        op,
                        bc,
                        &mut label_done,
                        0 as libc::c_int,
                    );
                }
                if (*s).arg_var_object_idx >= 0 as libc::c_int && is_pseudo_var == 0 {
                    dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
                    dbuf_put_u16(bc, (*s).arg_var_object_idx as uint16_t);
                    var_object_test(
                        ctx,
                        s,
                        var_name,
                        op,
                        bc,
                        &mut label_done,
                        0 as libc::c_int,
                    );
                }
                fd = s;
                's_546: loop {
                    if ((*fd).parent).is_null() {
                        current_block = 3640574680223420878;
                        break;
                    }
                    scope_level = (*fd).parent_scope_level;
                    fd = (*fd).parent;
                    idx = (*((*fd).scopes).offset(scope_level as isize)).first;
                    while idx >= 0 as libc::c_int {
                        vd = &mut *((*fd).vars).offset(idx as isize) as *mut JSVarDef;
                        if (*vd).var_name == var_name {
                            if op == OP_scope_put_var as libc::c_int
                                || op == OP_scope_make_ref as libc::c_int
                            {
                                if (*vd).is_const() != 0 {
                                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                                    current_block = 3590608195283441220;
                                    break 's_546;
                                }
                            }
                            var_idx = idx;
                            break;
                        } else {
                            if (*vd).var_name
                                == JS_ATOM__with_ as libc::c_int as libc::c_uint
                                && is_pseudo_var == 0
                            {
                                (*vd).set_is_captured(1 as libc::c_int as uint8_t);
                                idx = get_closure_var(
                                    ctx,
                                    s,
                                    fd,
                                    FALSE as libc::c_int,
                                    idx,
                                    (*vd).var_name,
                                    FALSE as libc::c_int,
                                    FALSE as libc::c_int,
                                    JS_VAR_NORMAL,
                                );
                                if idx >= 0 as libc::c_int {
                                    dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                                    dbuf_put_u16(bc, idx as uint16_t);
                                    var_object_test(
                                        ctx,
                                        s,
                                        var_name,
                                        op,
                                        bc,
                                        &mut label_done,
                                        1 as libc::c_int,
                                    );
                                }
                            }
                            idx = (*vd).scope_next;
                        }
                    }
                    is_arg_scope = (idx == -(2 as libc::c_int)) as libc::c_int;
                    if var_idx >= 0 as libc::c_int {
                        current_block = 3640574680223420878;
                        break;
                    }
                    if is_arg_scope == 0 {
                        var_idx = find_var(ctx, fd, var_name);
                        if var_idx >= 0 as libc::c_int {
                            current_block = 3640574680223420878;
                            break;
                        }
                    }
                    if is_pseudo_var != 0 {
                        var_idx = resolve_pseudo_var(ctx, fd, var_name);
                        if var_idx >= 0 as libc::c_int {
                            current_block = 3640574680223420878;
                            break;
                        }
                    }
                    if var_name == JS_ATOM_arguments as libc::c_int as libc::c_uint
                        && (*fd).has_arguments_binding != 0
                    {
                        var_idx = add_arguments_var(ctx, fd);
                        current_block = 3640574680223420878;
                        break;
                    } else if (*fd).is_func_expr != 0 && (*fd).func_name == var_name {
                        var_idx = add_func_var(ctx, fd, var_name);
                        current_block = 3640574680223420878;
                        break;
                    } else {
                        if is_arg_scope == 0 && (*fd).var_object_idx >= 0 as libc::c_int
                            && is_pseudo_var == 0
                        {
                            vd = &mut *((*fd).vars).offset((*fd).var_object_idx as isize)
                                as *mut JSVarDef;
                            (*vd).set_is_captured(1 as libc::c_int as uint8_t);
                            idx = get_closure_var(
                                ctx,
                                s,
                                fd,
                                FALSE as libc::c_int,
                                (*fd).var_object_idx,
                                (*vd).var_name,
                                FALSE as libc::c_int,
                                FALSE as libc::c_int,
                                JS_VAR_NORMAL,
                            );
                            dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                            dbuf_put_u16(bc, idx as uint16_t);
                            var_object_test(
                                ctx,
                                s,
                                var_name,
                                op,
                                bc,
                                &mut label_done,
                                0 as libc::c_int,
                            );
                        }
                        if (*fd).arg_var_object_idx >= 0 as libc::c_int
                            && is_pseudo_var == 0
                        {
                            vd = &mut *((*fd).vars)
                                .offset((*fd).arg_var_object_idx as isize) as *mut JSVarDef;
                            (*vd).set_is_captured(1 as libc::c_int as uint8_t);
                            idx = get_closure_var(
                                ctx,
                                s,
                                fd,
                                FALSE as libc::c_int,
                                (*fd).arg_var_object_idx,
                                (*vd).var_name,
                                FALSE as libc::c_int,
                                FALSE as libc::c_int,
                                JS_VAR_NORMAL,
                            );
                            dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                            dbuf_put_u16(bc, idx as uint16_t);
                            var_object_test(
                                ctx,
                                s,
                                var_name,
                                op,
                                bc,
                                &mut label_done,
                                0 as libc::c_int,
                            );
                        }
                        if (*fd).is_eval != 0 {
                            current_block = 3640574680223420878;
                            break;
                        }
                    }
                }
                match current_block {
                    3590608195283441220 => {}
                    _ => {
                        if fd.is_null() {
                            fd = s;
                        }
                        if var_idx < 0 as libc::c_int && (*fd).is_eval != 0 {
                            let mut idx1: libc::c_int = 0;
                            idx1 = 0 as libc::c_int;
                            loop {
                                if !(idx1 < (*fd).closure_var_count) {
                                    current_block = 17418136423408909163;
                                    break;
                                }
                                let mut cv: *mut JSClosureVar = &mut *((*fd).closure_var)
                                    .offset(idx1 as isize) as *mut JSClosureVar;
                                if var_name == (*cv).var_name {
                                    if fd != s {
                                        idx = get_closure_var2(
                                            ctx,
                                            s,
                                            fd,
                                            FALSE as libc::c_int,
                                            (*cv).is_arg() as BOOL,
                                            idx1,
                                            (*cv).var_name,
                                            (*cv).is_const() as BOOL,
                                            (*cv).is_lexical() as BOOL,
                                            (*cv).var_kind() as JSVarKindEnum,
                                        );
                                    } else {
                                        idx = idx1;
                                    }
                                    current_block = 13432215440221038456;
                                    break;
                                } else {
                                    if ((*cv).var_name
                                        == JS_ATOM__var_ as libc::c_int as libc::c_uint
                                        || (*cv).var_name
                                            == JS_ATOM__arg_var_ as libc::c_int as libc::c_uint
                                        || (*cv).var_name
                                            == JS_ATOM__with_ as libc::c_int as libc::c_uint)
                                        && is_pseudo_var == 0
                                    {
                                        let mut is_with: libc::c_int = ((*cv).var_name
                                            == JS_ATOM__with_ as libc::c_int as libc::c_uint)
                                            as libc::c_int;
                                        if fd != s {
                                            idx = get_closure_var2(
                                                ctx,
                                                s,
                                                fd,
                                                FALSE as libc::c_int,
                                                (*cv).is_arg() as BOOL,
                                                idx1,
                                                (*cv).var_name,
                                                FALSE as libc::c_int,
                                                FALSE as libc::c_int,
                                                JS_VAR_NORMAL,
                                            );
                                        } else {
                                            idx = idx1;
                                        }
                                        dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                                        dbuf_put_u16(bc, idx as uint16_t);
                                        var_object_test(
                                            ctx,
                                            s,
                                            var_name,
                                            op,
                                            bc,
                                            &mut label_done,
                                            is_with,
                                        );
                                    }
                                    idx1 += 1;
                                }
                            }
                        } else {
                            current_block = 17418136423408909163;
                        }
                        match current_block {
                            17418136423408909163 => {
                                if var_idx >= 0 as libc::c_int {
                                    if var_idx & 0x20000000 as libc::c_int != 0 {
                                        let ref mut fresh511 = *((*fd).args)
                                            .offset((var_idx - 0x20000000 as libc::c_int) as isize);
                                        (*fresh511).set_is_captured(1 as libc::c_int as uint8_t);
                                        idx = get_closure_var(
                                            ctx,
                                            s,
                                            fd,
                                            TRUE as libc::c_int,
                                            var_idx - 0x20000000 as libc::c_int,
                                            var_name,
                                            FALSE as libc::c_int,
                                            FALSE as libc::c_int,
                                            JS_VAR_NORMAL,
                                        );
                                    } else {
                                        let ref mut fresh512 = *((*fd).vars)
                                            .offset(var_idx as isize);
                                        (*fresh512).set_is_captured(1 as libc::c_int as uint8_t);
                                        idx = get_closure_var(
                                            ctx,
                                            s,
                                            fd,
                                            FALSE as libc::c_int,
                                            var_idx,
                                            var_name,
                                            (*((*fd).vars).offset(var_idx as isize)).is_const() as BOOL,
                                            (*((*fd).vars).offset(var_idx as isize)).is_lexical()
                                                as BOOL,
                                            (*((*fd).vars).offset(var_idx as isize)).var_kind()
                                                as JSVarKindEnum,
                                        );
                                    }
                                    if idx >= 0 as libc::c_int {
                                        current_block = 13432215440221038456;
                                    } else {
                                        current_block = 3334301343165654039;
                                    }
                                } else {
                                    current_block = 3334301343165654039;
                                }
                                match current_block {
                                    13432215440221038456 => {}
                                    _ => {
                                        match op {
                                            185 => {
                                                if label_done == -(1 as libc::c_int)
                                                    && can_opt_put_global_ref_value(bc_buf, (*ls).pos) != 0
                                                {
                                                    pos_next = optimize_scope_make_global_ref(
                                                        ctx,
                                                        s,
                                                        bc,
                                                        bc_buf,
                                                        ls,
                                                        pos_next,
                                                        var_name,
                                                    );
                                                } else {
                                                    dbuf_putc(bc, OP_make_var_ref as libc::c_int as uint8_t);
                                                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                                }
                                            }
                                            186 => {
                                                dbuf_putc(bc, OP_undefined as libc::c_int as uint8_t);
                                                dbuf_putc(bc, OP_get_var as libc::c_int as uint8_t);
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                            }
                                            181 | 182 | 183 => {
                                                dbuf_putc(
                                                    bc,
                                                    (OP_get_var_undef as libc::c_int
                                                        + (op - OP_scope_get_var_undef as libc::c_int)) as uint8_t,
                                                );
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                            }
                                            187 => {
                                                dbuf_putc(bc, OP_put_var_init as libc::c_int as uint8_t);
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                            }
                                            184 => {
                                                dbuf_putc(bc, OP_delete_var as libc::c_int as uint8_t);
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                            }
                                            _ => {}
                                        }
                                        current_block = 3590608195283441220;
                                    }
                                }
                            }
                            _ => {}
                        }
                        match current_block {
                            3590608195283441220 => {}
                            _ => {
                                if (op == OP_scope_put_var as libc::c_int
                                    || op == OP_scope_make_ref as libc::c_int)
                                    && (*((*s).closure_var).offset(idx as isize)).is_const()
                                        as libc::c_int != 0
                                {
                                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                                } else {
                                    let mut current_block_210: u64;
                                    match op {
                                        185 => {
                                            if (*((*s).closure_var).offset(idx as isize)).var_kind()
                                                as libc::c_int == JS_VAR_FUNCTION_NAME as libc::c_int
                                            {
                                                dbuf_putc(bc, OP_object as libc::c_int as uint8_t);
                                                dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                                                dbuf_put_u16(bc, idx as uint16_t);
                                                dbuf_putc(bc, OP_define_field as libc::c_int as uint8_t);
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                                dbuf_putc(bc, OP_push_atom_value as libc::c_int as uint8_t);
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                            } else if label_done == -(1 as libc::c_int)
                                                && can_opt_put_ref_value(bc_buf, (*ls).pos) != 0
                                            {
                                                let mut get_op_0: libc::c_int = 0;
                                                if (*((*s).closure_var).offset(idx as isize)).is_lexical()
                                                    != 0
                                                {
                                                    get_op_0 = OP_get_var_ref_check as libc::c_int;
                                                } else {
                                                    get_op_0 = OP_get_var_ref as libc::c_int;
                                                }
                                                pos_next = optimize_scope_make_ref(
                                                    ctx,
                                                    s,
                                                    bc,
                                                    bc_buf,
                                                    ls,
                                                    pos_next,
                                                    get_op_0,
                                                    idx,
                                                );
                                            } else {
                                                dbuf_putc(
                                                    bc,
                                                    OP_make_var_ref_ref as libc::c_int as uint8_t,
                                                );
                                                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                                                dbuf_put_u16(bc, idx as uint16_t);
                                            }
                                            current_block_210 = 12032176231992402880;
                                        }
                                        186 => {
                                            dbuf_putc(bc, OP_undefined as libc::c_int as uint8_t);
                                            current_block_210 = 17307617439238419116;
                                        }
                                        181 | 182 | 183 | 187 => {
                                            current_block_210 = 17307617439238419116;
                                        }
                                        184 => {
                                            dbuf_putc(bc, OP_push_false as libc::c_int as uint8_t);
                                            current_block_210 = 12032176231992402880;
                                        }
                                        _ => {
                                            current_block_210 = 12032176231992402880;
                                        }
                                    }
                                    match current_block_210 {
                                        17307617439238419116 => {
                                            is_put = (op == OP_scope_put_var as libc::c_int
                                                || op == OP_scope_put_var_init as libc::c_int)
                                                as libc::c_int;
                                            if is_put != 0 {
                                                if (*((*s).closure_var).offset(idx as isize)).is_lexical()
                                                    != 0
                                                {
                                                    if op == OP_scope_put_var_init as libc::c_int {
                                                        if var_name == JS_ATOM_this as libc::c_int as libc::c_uint {
                                                            dbuf_putc(
                                                                bc,
                                                                OP_put_var_ref_check_init as libc::c_int as uint8_t,
                                                            );
                                                        } else {
                                                            dbuf_putc(bc, OP_put_var_ref as libc::c_int as uint8_t);
                                                        }
                                                    } else {
                                                        dbuf_putc(
                                                            bc,
                                                            OP_put_var_ref_check as libc::c_int as uint8_t,
                                                        );
                                                    }
                                                } else {
                                                    dbuf_putc(bc, OP_put_var_ref as libc::c_int as uint8_t);
                                                }
                                            } else if (*((*s).closure_var).offset(idx as isize))
                                                .is_lexical() != 0
                                            {
                                                dbuf_putc(
                                                    bc,
                                                    OP_get_var_ref_check as libc::c_int as uint8_t,
                                                );
                                            } else {
                                                dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                                            }
                                            dbuf_put_u16(bc, idx as uint16_t);
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    if label_done >= 0 as libc::c_int {
        dbuf_putc(bc, OP_label as libc::c_int as uint8_t);
        dbuf_put_u32(bc, label_done as uint32_t);
        (*((*s).label_slots).offset(label_done as isize))
            .pos2 = (*bc).size as libc::c_int;
    }
    return pos_next;
}
unsafe extern "C" fn find_private_class_field_all(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut name: JSAtom,
    mut scope_level: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    idx = (*((*fd).scopes).offset(scope_level as isize)).first;
    while idx >= 0 as libc::c_int {
        if (*((*fd).vars).offset(idx as isize)).var_name == name {
            return idx;
        }
        idx = (*((*fd).vars).offset(idx as isize)).scope_next;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn get_loc_or_ref(
    mut bc: *mut DynBuf,
    mut is_ref: BOOL,
    mut idx: libc::c_int,
) {
    if is_ref != 0 {
        dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
    } else {
        dbuf_putc(bc, OP_get_loc as libc::c_int as uint8_t);
    }
    dbuf_put_u16(bc, idx as uint16_t);
}
unsafe extern "C" fn resolve_scope_private_field1(
    mut ctx: *mut JSContext,
    mut pis_ref: *mut BOOL,
    mut pvar_kind: *mut libc::c_int,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
    mut scope_level: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut var_kind: libc::c_int = 0;
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut is_ref: BOOL = 0;
    fd = s;
    is_ref = FALSE as libc::c_int;
    's_24: loop {
        idx = find_private_class_field_all(ctx, fd, var_name, scope_level);
        if idx >= 0 as libc::c_int {
            var_kind = (*((*fd).vars).offset(idx as isize)).var_kind() as libc::c_int;
            if is_ref != 0 {
                idx = get_closure_var(
                    ctx,
                    s,
                    fd,
                    FALSE as libc::c_int,
                    idx,
                    var_name,
                    TRUE as libc::c_int,
                    TRUE as libc::c_int,
                    JS_VAR_NORMAL,
                );
                if idx < 0 as libc::c_int {
                    return -(1 as libc::c_int);
                }
            }
            break;
        } else {
            scope_level = (*fd).parent_scope_level;
            if ((*fd).parent).is_null() {
                if (*fd).is_eval != 0 {
                    idx = 0 as libc::c_int;
                    while idx < (*fd).closure_var_count {
                        let mut cv: *mut JSClosureVar = &mut *((*fd).closure_var)
                            .offset(idx as isize) as *mut JSClosureVar;
                        if (*cv).var_name == var_name {
                            var_kind = (*cv).var_kind() as libc::c_int;
                            is_ref = TRUE as libc::c_int;
                            if fd != s {
                                idx = get_closure_var2(
                                    ctx,
                                    s,
                                    fd,
                                    FALSE as libc::c_int,
                                    (*cv).is_arg() as BOOL,
                                    idx,
                                    (*cv).var_name,
                                    (*cv).is_const() as BOOL,
                                    (*cv).is_lexical() as BOOL,
                                    (*cv).var_kind() as JSVarKindEnum,
                                );
                                if idx < 0 as libc::c_int {
                                    return -(1 as libc::c_int);
                                }
                            }
                            break 's_24;
                        } else {
                            idx += 1;
                        }
                    }
                }
                __JS_ThrowSyntaxErrorAtom(
                    ctx,
                    var_name,
                    b"undefined private field '%s'\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            } else {
                fd = (*fd).parent;
                is_ref = TRUE as libc::c_int;
            }
        }
    }
    *pis_ref = is_ref;
    *pvar_kind = var_kind;
    return idx;
}
unsafe extern "C" fn resolve_scope_private_field(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut var_name: JSAtom,
    mut scope_level: libc::c_int,
    mut op: libc::c_int,
    mut bc: *mut DynBuf,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut var_kind: libc::c_int = 0;
    let mut is_ref: BOOL = 0;
    idx = resolve_scope_private_field1(
        ctx,
        &mut is_ref,
        &mut var_kind,
        s,
        var_name,
        scope_level,
    );
    if idx < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    assert((var_kind != JS_VAR_NORMAL as libc::c_int) as libc::c_int);
    match op {
        188 | 189 => {
            match var_kind {
                5 => {
                    if op == OP_scope_get_private_field2 as libc::c_int {
                        dbuf_putc(bc, OP_dup as libc::c_int as uint8_t);
                    }
                    get_loc_or_ref(bc, is_ref, idx);
                    dbuf_putc(bc, OP_get_private_field as libc::c_int as uint8_t);
                }
                6 => {
                    get_loc_or_ref(bc, is_ref, idx);
                    dbuf_putc(bc, OP_check_brand as libc::c_int as uint8_t);
                    if op != OP_scope_get_private_field2 as libc::c_int {
                        dbuf_putc(bc, OP_nip as libc::c_int as uint8_t);
                    }
                }
                7 | 9 => {
                    if op == OP_scope_get_private_field2 as libc::c_int {
                        dbuf_putc(bc, OP_dup as libc::c_int as uint8_t);
                    }
                    get_loc_or_ref(bc, is_ref, idx);
                    dbuf_putc(bc, OP_check_brand as libc::c_int as uint8_t);
                    dbuf_putc(bc, OP_call_method as libc::c_int as uint8_t);
                    dbuf_put_u16(bc, 0 as libc::c_int as uint16_t);
                }
                8 => {
                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                }
                _ => {
                    abort();
                }
            }
        }
        190 => {
            match var_kind {
                5 => {
                    get_loc_or_ref(bc, is_ref, idx);
                    dbuf_putc(bc, OP_put_private_field as libc::c_int as uint8_t);
                }
                6 | 7 => {
                    dbuf_putc(bc, OP_throw_error as libc::c_int as uint8_t);
                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                    dbuf_putc(bc, 0 as libc::c_int as uint8_t);
                }
                8 | 9 => {
                    let mut setter_name: JSAtom = get_private_setter_name(ctx, var_name);
                    if setter_name == 0 as libc::c_int as libc::c_uint {
                        return -(1 as libc::c_int);
                    }
                    idx = resolve_scope_private_field1(
                        ctx,
                        &mut is_ref,
                        &mut var_kind,
                        s,
                        setter_name,
                        scope_level,
                    );
                    JS_FreeAtom(ctx, setter_name);
                    if idx < 0 as libc::c_int {
                        return -(1 as libc::c_int);
                    }
                    assert(
                        (var_kind == JS_VAR_PRIVATE_SETTER as libc::c_int) as libc::c_int,
                    );
                    get_loc_or_ref(bc, is_ref, idx);
                    dbuf_putc(bc, OP_swap as libc::c_int as uint8_t);
                    dbuf_putc(bc, OP_rot3r as libc::c_int as uint8_t);
                    dbuf_putc(bc, OP_check_brand as libc::c_int as uint8_t);
                    dbuf_putc(bc, OP_rot3l as libc::c_int as uint8_t);
                    dbuf_putc(bc, OP_call_method as libc::c_int as uint8_t);
                    dbuf_put_u16(bc, 1 as libc::c_int as uint16_t);
                }
                _ => {
                    abort();
                }
            }
        }
        _ => {
            abort();
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mark_eval_captured_variables(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut scope_level: libc::c_int,
) {
    let mut idx: libc::c_int = 0;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    idx = (*((*s).scopes).offset(scope_level as isize)).first;
    while idx >= 0 as libc::c_int {
        vd = &mut *((*s).vars).offset(idx as isize) as *mut JSVarDef;
        (*vd).set_is_captured(1 as libc::c_int as uint8_t);
        idx = (*vd).scope_next;
    }
}
unsafe extern "C" fn is_var_in_arg_scope(mut vd: *const JSVarDef) -> BOOL {
    return ((*vd).var_name == JS_ATOM_home_object as libc::c_int as libc::c_uint
        || (*vd).var_name == JS_ATOM_this_active_func as libc::c_int as libc::c_uint
        || (*vd).var_name == JS_ATOM_new_target as libc::c_int as libc::c_uint
        || (*vd).var_name == JS_ATOM_this as libc::c_int as libc::c_uint
        || (*vd).var_name == JS_ATOM__arg_var_ as libc::c_int as libc::c_uint
        || (*vd).var_kind() as libc::c_int == JS_VAR_FUNCTION_NAME as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn add_eval_variables(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
) {
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    let mut i: libc::c_int = 0;
    let mut scope_level: libc::c_int = 0;
    let mut scope_idx: libc::c_int = 0;
    let mut has_arguments_binding: BOOL = 0;
    let mut has_this_binding: BOOL = 0;
    let mut is_arg_scope: BOOL = 0;
    if (*s).is_eval == 0
        && (*s).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0
    {
        (*s).var_object_idx = add_var(ctx, s, JS_ATOM__var_ as libc::c_int as JSAtom);
        if (*s).has_parameter_expressions != 0 {
            (*s)
                .arg_var_object_idx = add_var(
                ctx,
                s,
                JS_ATOM__arg_var_ as libc::c_int as JSAtom,
            );
        }
    }
    has_this_binding = (*s).has_this_binding;
    if has_this_binding != 0 {
        if (*s).this_var_idx < 0 as libc::c_int {
            (*s).this_var_idx = add_var_this(ctx, s);
        }
        if (*s).new_target_var_idx < 0 as libc::c_int {
            (*s)
                .new_target_var_idx = add_var(
                ctx,
                s,
                JS_ATOM_new_target as libc::c_int as JSAtom,
            );
        }
        if (*s).is_derived_class_constructor != 0
            && (*s).this_active_func_var_idx < 0 as libc::c_int
        {
            (*s)
                .this_active_func_var_idx = add_var(
                ctx,
                s,
                JS_ATOM_this_active_func as libc::c_int as JSAtom,
            );
        }
        if (*s).has_home_object != 0 && (*s).home_object_var_idx < 0 as libc::c_int {
            (*s)
                .home_object_var_idx = add_var(
                ctx,
                s,
                JS_ATOM_home_object as libc::c_int as JSAtom,
            );
        }
    }
    has_arguments_binding = (*s).has_arguments_binding;
    if has_arguments_binding != 0 {
        add_arguments_var(ctx, s);
        if (*s).has_parameter_expressions != 0
            && (*s).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0
        {
            add_arguments_arg(ctx, s);
        }
    }
    if (*s).is_func_expr != 0 && (*s).func_name != 0 as libc::c_int as libc::c_uint {
        add_func_var(ctx, s, (*s).func_name);
    }
    assert(
        ((*s).is_eval != 0 || (*s).closure_var_count == 0 as libc::c_int) as libc::c_int,
    );
    fd = s;
    loop {
        scope_level = (*fd).parent_scope_level;
        fd = (*fd).parent;
        if fd.is_null() {
            break;
        }
        if has_this_binding == 0 && (*fd).has_this_binding != 0 {
            if (*fd).this_var_idx < 0 as libc::c_int {
                (*fd).this_var_idx = add_var_this(ctx, fd);
            }
            if (*fd).new_target_var_idx < 0 as libc::c_int {
                (*fd)
                    .new_target_var_idx = add_var(
                    ctx,
                    fd,
                    JS_ATOM_new_target as libc::c_int as JSAtom,
                );
            }
            if (*fd).is_derived_class_constructor != 0
                && (*fd).this_active_func_var_idx < 0 as libc::c_int
            {
                (*fd)
                    .this_active_func_var_idx = add_var(
                    ctx,
                    fd,
                    JS_ATOM_this_active_func as libc::c_int as JSAtom,
                );
            }
            if (*fd).has_home_object != 0 && (*fd).home_object_var_idx < 0 as libc::c_int
            {
                (*fd)
                    .home_object_var_idx = add_var(
                    ctx,
                    fd,
                    JS_ATOM_home_object as libc::c_int as JSAtom,
                );
            }
            has_this_binding = TRUE as libc::c_int;
        }
        if has_arguments_binding == 0 && (*fd).has_arguments_binding != 0 {
            add_arguments_var(ctx, fd);
            has_arguments_binding = TRUE as libc::c_int;
        }
        if (*fd).is_func_expr != 0 && (*fd).func_name != 0 as libc::c_int as libc::c_uint
        {
            add_func_var(ctx, fd, (*fd).func_name);
        }
        scope_idx = (*((*fd).scopes).offset(scope_level as isize)).first;
        while scope_idx >= 0 as libc::c_int {
            vd = &mut *((*fd).vars).offset(scope_idx as isize) as *mut JSVarDef;
            (*vd).set_is_captured(1 as libc::c_int as uint8_t);
            get_closure_var(
                ctx,
                s,
                fd,
                FALSE as libc::c_int,
                scope_idx,
                (*vd).var_name,
                (*vd).is_const() as BOOL,
                (*vd).is_lexical() as BOOL,
                (*vd).var_kind() as JSVarKindEnum,
            );
            scope_idx = (*vd).scope_next;
        }
        is_arg_scope = (scope_idx == -(2 as libc::c_int)) as libc::c_int;
        if is_arg_scope == 0 {
            i = 0 as libc::c_int;
            while i < (*fd).arg_count {
                vd = &mut *((*fd).args).offset(i as isize) as *mut JSVarDef;
                if (*vd).var_name != 0 as libc::c_int as libc::c_uint {
                    get_closure_var(
                        ctx,
                        s,
                        fd,
                        TRUE as libc::c_int,
                        i,
                        (*vd).var_name,
                        FALSE as libc::c_int,
                        FALSE as libc::c_int,
                        JS_VAR_NORMAL,
                    );
                }
                i += 1;
            }
            i = 0 as libc::c_int;
            while i < (*fd).var_count {
                vd = &mut *((*fd).vars).offset(i as isize) as *mut JSVarDef;
                if (*vd).scope_level == 0 as libc::c_int
                    && (*vd).var_name != JS_ATOM__ret_ as libc::c_int as libc::c_uint
                    && (*vd).var_name != 0 as libc::c_int as libc::c_uint
                {
                    get_closure_var(
                        ctx,
                        s,
                        fd,
                        FALSE as libc::c_int,
                        i,
                        (*vd).var_name,
                        FALSE as libc::c_int,
                        FALSE as libc::c_int,
                        JS_VAR_NORMAL,
                    );
                }
                i += 1;
            }
        } else {
            i = 0 as libc::c_int;
            while i < (*fd).var_count {
                vd = &mut *((*fd).vars).offset(i as isize) as *mut JSVarDef;
                if (*vd).scope_level == 0 as libc::c_int && is_var_in_arg_scope(vd) != 0
                {
                    get_closure_var(
                        ctx,
                        s,
                        fd,
                        FALSE as libc::c_int,
                        i,
                        (*vd).var_name,
                        FALSE as libc::c_int,
                        FALSE as libc::c_int,
                        JS_VAR_NORMAL,
                    );
                }
                i += 1;
            }
        }
        if (*fd).is_eval != 0 {
            let mut idx: libc::c_int = 0;
            idx = 0 as libc::c_int;
            while idx < (*fd).closure_var_count {
                let mut cv: *mut JSClosureVar = &mut *((*fd).closure_var)
                    .offset(idx as isize) as *mut JSClosureVar;
                get_closure_var2(
                    ctx,
                    s,
                    fd,
                    FALSE as libc::c_int,
                    (*cv).is_arg() as BOOL,
                    idx,
                    (*cv).var_name,
                    (*cv).is_const() as BOOL,
                    (*cv).is_lexical() as BOOL,
                    (*cv).var_kind() as JSVarKindEnum,
                );
                idx += 1;
            }
        }
    };
}
unsafe extern "C" fn set_closure_from_var(
    mut ctx: *mut JSContext,
    mut cv: *mut JSClosureVar,
    mut vd: *mut JSVarDef,
    mut var_idx: libc::c_int,
) {
    (*cv).set_is_local(TRUE as libc::c_int as uint8_t);
    (*cv).set_is_arg(FALSE as libc::c_int as uint8_t);
    (*cv).set_is_const((*vd).is_const());
    (*cv).set_is_lexical((*vd).is_lexical());
    (*cv).set_var_kind((*vd).var_kind());
    (*cv).var_idx = var_idx as uint16_t;
    (*cv).var_name = JS_DupAtom(ctx, (*vd).var_name);
}
unsafe extern "C" fn add_closure_variables(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut b: *mut JSFunctionBytecode,
    mut scope_idx: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut vd: *mut JSVarDef = 0 as *mut JSVarDef;
    let mut is_arg_scope: BOOL = 0;
    count = (*b).arg_count as libc::c_int + (*b).var_count as libc::c_int
        + (*b).closure_var_count;
    let ref mut fresh513 = (*s).closure_var;
    *fresh513 = 0 as *mut JSClosureVar;
    (*s).closure_var_count = 0 as libc::c_int;
    (*s).closure_var_size = count;
    if count == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    let ref mut fresh514 = (*s).closure_var;
    *fresh514 = js_malloc(
        ctx,
        (::core::mem::size_of::<JSClosureVar>() as libc::c_ulong)
            .wrapping_mul(count as libc::c_ulong),
    ) as *mut JSClosureVar;
    if ((*s).closure_var).is_null() {
        return -(1 as libc::c_int);
    }
    i = scope_idx;
    while i >= 0 as libc::c_int {
        vd = &mut *((*b).vardefs).offset(((*b).arg_count as libc::c_int + i) as isize)
            as *mut JSVarDef;
        if (*vd).scope_level > 0 as libc::c_int {
            let ref mut fresh515 = (*s).closure_var_count;
            let fresh516 = *fresh515;
            *fresh515 = *fresh515 + 1;
            let mut cv: *mut JSClosureVar = &mut *((*s).closure_var)
                .offset(fresh516 as isize) as *mut JSClosureVar;
            set_closure_from_var(ctx, cv, vd, i);
        }
        i = (*vd).scope_next;
    }
    is_arg_scope = (i == -(2 as libc::c_int)) as libc::c_int;
    if is_arg_scope == 0 {
        i = 0 as libc::c_int;
        while i < (*b).arg_count as libc::c_int {
            let ref mut fresh517 = (*s).closure_var_count;
            let fresh518 = *fresh517;
            *fresh517 = *fresh517 + 1;
            let mut cv_0: *mut JSClosureVar = &mut *((*s).closure_var)
                .offset(fresh518 as isize) as *mut JSClosureVar;
            vd = &mut *((*b).vardefs).offset(i as isize) as *mut JSVarDef;
            (*cv_0).set_is_local(TRUE as libc::c_int as uint8_t);
            (*cv_0).set_is_arg(TRUE as libc::c_int as uint8_t);
            (*cv_0).set_is_const(FALSE as libc::c_int as uint8_t);
            (*cv_0).set_is_lexical(FALSE as libc::c_int as uint8_t);
            (*cv_0).set_var_kind(JS_VAR_NORMAL as libc::c_int as uint8_t);
            (*cv_0).var_idx = i as uint16_t;
            (*cv_0).var_name = JS_DupAtom(ctx, (*vd).var_name);
            i += 1;
        }
        i = 0 as libc::c_int;
        while i < (*b).var_count as libc::c_int {
            vd = &mut *((*b).vardefs)
                .offset(((*b).arg_count as libc::c_int + i) as isize) as *mut JSVarDef;
            if (*vd).scope_level == 0 as libc::c_int
                && (*vd).var_name != JS_ATOM__ret_ as libc::c_int as libc::c_uint
            {
                let ref mut fresh519 = (*s).closure_var_count;
                let fresh520 = *fresh519;
                *fresh519 = *fresh519 + 1;
                let mut cv_1: *mut JSClosureVar = &mut *((*s).closure_var)
                    .offset(fresh520 as isize) as *mut JSClosureVar;
                set_closure_from_var(ctx, cv_1, vd, i);
            }
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while i < (*b).var_count as libc::c_int {
            vd = &mut *((*b).vardefs)
                .offset(((*b).arg_count as libc::c_int + i) as isize) as *mut JSVarDef;
            if (*vd).scope_level == 0 as libc::c_int && is_var_in_arg_scope(vd) != 0 {
                let ref mut fresh521 = (*s).closure_var_count;
                let fresh522 = *fresh521;
                *fresh521 = *fresh521 + 1;
                let mut cv_2: *mut JSClosureVar = &mut *((*s).closure_var)
                    .offset(fresh522 as isize) as *mut JSClosureVar;
                set_closure_from_var(ctx, cv_2, vd, i);
            }
            i += 1;
        }
    }
    i = 0 as libc::c_int;
    while i < (*b).closure_var_count {
        let mut cv0: *mut JSClosureVar = &mut *((*b).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        let ref mut fresh523 = (*s).closure_var_count;
        let fresh524 = *fresh523;
        *fresh523 = *fresh523 + 1;
        let mut cv_3: *mut JSClosureVar = &mut *((*s).closure_var)
            .offset(fresh524 as isize) as *mut JSClosureVar;
        (*cv_3).set_is_local(FALSE as libc::c_int as uint8_t);
        (*cv_3).set_is_arg((*cv0).is_arg());
        (*cv_3).set_is_const((*cv0).is_const());
        (*cv_3).set_is_lexical((*cv0).is_lexical());
        (*cv_3).set_var_kind((*cv0).var_kind());
        (*cv_3).var_idx = i as uint16_t;
        (*cv_3).var_name = JS_DupAtom(ctx, (*cv0).var_name);
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn code_match(
    mut s: *mut CodeContext,
    mut pos: libc::c_int,
    mut args: ...
) -> BOOL {
    let mut tab: *const uint8_t = (*s).bc_buf;
    let mut op: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut op1: libc::c_int = 0;
    let mut line_num: libc::c_int = 0;
    let mut pos_next: libc::c_int = 0;
    let mut ap: va_list = 0 as *mut libc::c_void;
    let mut ret: BOOL = FALSE as libc::c_int;
    line_num = -(1 as libc::c_int);
    ap = args.clone();
    's_27: loop {
        op1 = ap.arg::<libc::c_int>();
        if op1 == -(1 as libc::c_int) {
            (*s).pos = pos;
            (*s).line_num = line_num;
            ret = TRUE as libc::c_int;
            break;
        } else {
            loop {
                if pos >= (*s).bc_len {
                    break 's_27;
                }
                op = *tab.offset(pos as isize) as libc::c_int;
                len = opcode_info[op as usize].size as libc::c_int;
                pos_next = pos + len;
                if pos_next > (*s).bc_len {
                    break 's_27;
                }
                if !(op == OP_line_num as libc::c_int) {
                    break;
                }
                line_num = get_u32(
                    tab.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                pos = pos_next;
            }
            if op != op1 {
                if op1 == op1 as uint8_t as libc::c_int || op == 0 {
                    break;
                }
                if op != op1 as uint8_t as libc::c_int
                    && op != (op1 >> 8 as libc::c_int) as uint8_t as libc::c_int
                    && op != (op1 >> 16 as libc::c_int) as uint8_t as libc::c_int
                    && op != (op1 >> 24 as libc::c_int) as uint8_t as libc::c_int
                {
                    break;
                }
                (*s).op = op;
            }
            pos += 1;
            match opcode_info[op as usize].fmt as libc::c_int {
                7 | 5 => {
                    let mut idx: libc::c_int = *tab.offset(pos as isize) as libc::c_int;
                    let mut arg: libc::c_int = ap.arg::<libc::c_int>();
                    if arg == -(1 as libc::c_int) {
                        (*s).idx = idx;
                    } else if arg != idx {
                        break;
                    }
                }
                10 | 13 | 16 | 17 | 18 => {
                    let mut idx_0: libc::c_int = get_u16(tab.offset(pos as isize))
                        as libc::c_int;
                    let mut arg_0: libc::c_int = ap.arg::<libc::c_int>();
                    if arg_0 == -(1 as libc::c_int) {
                        (*s).idx = idx_0;
                    } else if arg_0 != idx_0 {
                        break;
                    }
                }
                20 | 19 | 22 | 21 => {
                    (*s).label = get_u32(tab.offset(pos as isize)) as libc::c_int;
                }
                28 => {
                    (*s).label = get_u32(tab.offset(pos as isize)) as libc::c_int;
                    (*s)
                        .val = get_u16(
                        tab.offset(pos as isize).offset(4 as libc::c_int as isize),
                    ) as libc::c_int;
                }
                23 => {
                    (*s).atom = get_u32(tab.offset(pos as isize));
                }
                24 => {
                    (*s).atom = get_u32(tab.offset(pos as isize));
                    (*s)
                        .val = get_u8(
                        tab.offset(pos as isize).offset(4 as libc::c_int as isize),
                    ) as libc::c_int;
                }
                25 => {
                    (*s).atom = get_u32(tab.offset(pos as isize));
                    (*s)
                        .val = get_u16(
                        tab.offset(pos as isize).offset(4 as libc::c_int as isize),
                    ) as libc::c_int;
                }
                26 => {
                    (*s).atom = get_u32(tab.offset(pos as isize));
                    (*s)
                        .label = get_u32(
                        tab.offset(pos as isize).offset(4 as libc::c_int as isize),
                    ) as libc::c_int;
                    (*s)
                        .val = get_u8(
                        tab.offset(pos as isize).offset(8 as libc::c_int as isize),
                    ) as libc::c_int;
                }
                _ => {}
            }
            pos = pos_next;
        }
    }
    return ret;
}
unsafe extern "C" fn instantiate_hoisted_definitions(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
    mut bc: *mut DynBuf,
) {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut label_next: libc::c_int = -(1 as libc::c_int);
    i = 0 as libc::c_int;
    while i < (*s).arg_count {
        let mut vd: *mut JSVarDef = &mut *((*s).args).offset(i as isize)
            as *mut JSVarDef;
        if (*vd).func_pool_idx() >= 0 as libc::c_int {
            dbuf_putc(bc, OP_fclosure as libc::c_int as uint8_t);
            dbuf_put_u32(bc, (*vd).func_pool_idx() as uint32_t);
            dbuf_putc(bc, OP_put_arg as libc::c_int as uint8_t);
            dbuf_put_u16(bc, i as uint16_t);
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*s).var_count {
        let mut vd_0: *mut JSVarDef = &mut *((*s).vars).offset(i as isize)
            as *mut JSVarDef;
        if (*vd_0).scope_level == 0 as libc::c_int
            && (*vd_0).func_pool_idx() >= 0 as libc::c_int
        {
            dbuf_putc(bc, OP_fclosure as libc::c_int as uint8_t);
            dbuf_put_u32(bc, (*vd_0).func_pool_idx() as uint32_t);
            dbuf_putc(bc, OP_put_loc as libc::c_int as uint8_t);
            dbuf_put_u16(bc, i as uint16_t);
        }
        i += 1;
    }
    if !((*s).module).is_null() {
        label_next = new_label_fd(s, -(1 as libc::c_int));
        dbuf_putc(bc, OP_push_this as libc::c_int as uint8_t);
        dbuf_putc(bc, OP_if_false as libc::c_int as uint8_t);
        dbuf_put_u32(bc, label_next as uint32_t);
        update_label(s, label_next, 1 as libc::c_int);
        let ref mut fresh525 = (*s).jump_size;
        *fresh525 += 1;
    }
    i = 0 as libc::c_int;
    while i < (*s).global_var_count {
        let mut current_block_76: u64;
        let mut hf: *mut JSGlobalVar = &mut *((*s).global_vars).offset(i as isize)
            as *mut JSGlobalVar;
        let mut has_closure: libc::c_int = 0 as libc::c_int;
        let mut force_init: BOOL = (*hf).force_init() as BOOL;
        idx = 0 as libc::c_int;
        while idx < (*s).closure_var_count {
            let mut cv: *mut JSClosureVar = &mut *((*s).closure_var).offset(idx as isize)
                as *mut JSClosureVar;
            if (*cv).var_name == (*hf).var_name {
                has_closure = 2 as libc::c_int;
                force_init = FALSE as libc::c_int;
                break;
            } else if (*cv).var_name == JS_ATOM__var_ as libc::c_int as libc::c_uint
                || (*cv).var_name == JS_ATOM__arg_var_ as libc::c_int as libc::c_uint
            {
                dbuf_putc(bc, OP_get_var_ref as libc::c_int as uint8_t);
                dbuf_put_u16(bc, idx as uint16_t);
                has_closure = 1 as libc::c_int;
                force_init = TRUE as libc::c_int;
                break;
            } else {
                idx += 1;
            }
        }
        if has_closure == 0 {
            let mut flags: libc::c_int = 0;
            flags = 0 as libc::c_int;
            if (*s).eval_type != (0 as libc::c_int) << 0 as libc::c_int {
                flags |= (1 as libc::c_int) << 0 as libc::c_int;
            }
            if (*hf).cpool_idx >= 0 as libc::c_int && (*hf).is_lexical() == 0 {
                dbuf_putc(bc, OP_fclosure as libc::c_int as uint8_t);
                dbuf_put_u32(bc, (*hf).cpool_idx as uint32_t);
                dbuf_putc(bc, OP_define_func as libc::c_int as uint8_t);
                dbuf_put_u32(bc, JS_DupAtom(ctx, (*hf).var_name));
                dbuf_putc(bc, flags as uint8_t);
                current_block_76 = 3062675486185864808;
            } else {
                if (*hf).is_lexical() != 0 {
                    flags |= (1 as libc::c_int) << 7 as libc::c_int;
                    if (*hf).is_const() == 0 {
                        flags |= (1 as libc::c_int) << 1 as libc::c_int;
                    }
                }
                dbuf_putc(bc, OP_define_var as libc::c_int as uint8_t);
                dbuf_put_u32(bc, JS_DupAtom(ctx, (*hf).var_name));
                dbuf_putc(bc, flags as uint8_t);
                current_block_76 = 4741994311446740739;
            }
        } else {
            current_block_76 = 4741994311446740739;
        }
        match current_block_76 {
            4741994311446740739 => {
                if (*hf).cpool_idx >= 0 as libc::c_int || force_init != 0 {
                    if (*hf).cpool_idx >= 0 as libc::c_int {
                        dbuf_putc(bc, OP_fclosure as libc::c_int as uint8_t);
                        dbuf_put_u32(bc, (*hf).cpool_idx as uint32_t);
                        if (*hf).var_name
                            == JS_ATOM__default_ as libc::c_int as libc::c_uint
                        {
                            dbuf_putc(bc, OP_set_name as libc::c_int as uint8_t);
                            dbuf_put_u32(
                                bc,
                                JS_DupAtom(ctx, JS_ATOM_default as libc::c_int as JSAtom),
                            );
                        }
                    } else {
                        dbuf_putc(bc, OP_undefined as libc::c_int as uint8_t);
                    }
                    if has_closure == 2 as libc::c_int {
                        dbuf_putc(bc, OP_put_var_ref as libc::c_int as uint8_t);
                        dbuf_put_u16(bc, idx as uint16_t);
                    } else if has_closure == 1 as libc::c_int {
                        dbuf_putc(bc, OP_define_field as libc::c_int as uint8_t);
                        dbuf_put_u32(bc, JS_DupAtom(ctx, (*hf).var_name));
                        dbuf_putc(bc, OP_drop as libc::c_int as uint8_t);
                    } else {
                        dbuf_putc(bc, OP_put_var as libc::c_int as uint8_t);
                        dbuf_put_u32(bc, JS_DupAtom(ctx, (*hf).var_name));
                    }
                }
            }
            _ => {}
        }
        JS_FreeAtom(ctx, (*hf).var_name);
        i += 1;
    }
    if !((*s).module).is_null() {
        dbuf_putc(bc, OP_return_undef as libc::c_int as uint8_t);
        dbuf_putc(bc, OP_label as libc::c_int as uint8_t);
        dbuf_put_u32(bc, label_next as uint32_t);
        (*((*s).label_slots).offset(label_next as isize))
            .pos2 = (*bc).size as libc::c_int;
    }
    js_free(ctx, (*s).global_vars as *mut libc::c_void);
    let ref mut fresh526 = (*s).global_vars;
    *fresh526 = 0 as *mut JSGlobalVar;
    (*s).global_var_count = 0 as libc::c_int;
    (*s).global_var_size = 0 as libc::c_int;
}
unsafe extern "C" fn skip_dead_code(
    mut s: *mut JSFunctionDef,
    mut bc_buf: *const uint8_t,
    mut bc_len: libc::c_int,
    mut pos: libc::c_int,
    mut linep: *mut libc::c_int,
) -> libc::c_int {
    let mut op: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut label: libc::c_int = 0;
    while pos < bc_len {
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[op as usize].size as libc::c_int;
        if op == OP_line_num as libc::c_int {
            *linep = get_u32(
                bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
            ) as libc::c_int;
        } else if op == OP_label as libc::c_int {
            label = get_u32(
                bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
            ) as libc::c_int;
            if update_label(s, label, 0 as libc::c_int) > 0 as libc::c_int {
                break;
            }
            assert(
                ((*((*s).label_slots).offset(label as isize)).first_reloc
                    == 0 as *mut libc::c_void as *mut RelocEntry) as libc::c_int,
            );
        } else {
            let mut atom: JSAtom = 0;
            let mut current_block_11: u64;
            match opcode_info[op as usize].fmt as libc::c_int {
                22 | 28 => {
                    label = get_u32(
                        bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    ) as libc::c_int;
                    update_label(s, label, -(1 as libc::c_int));
                    current_block_11 = 12147880666119273379;
                }
                26 | 27 => {
                    label = get_u32(
                        bc_buf.offset(pos as isize).offset(5 as libc::c_int as isize),
                    ) as libc::c_int;
                    update_label(s, label, -(1 as libc::c_int));
                    current_block_11 = 3584913726321815203;
                }
                23 | 24 | 25 => {
                    current_block_11 = 3584913726321815203;
                }
                _ => {
                    current_block_11 = 12147880666119273379;
                }
            }
            match current_block_11 {
                3584913726321815203 => {
                    atom = get_u32(
                        bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    );
                    JS_FreeAtom((*s).ctx, atom);
                }
                _ => {}
            }
        }
        pos += len;
    }
    return pos;
}
unsafe extern "C" fn get_label_pos(
    mut s: *mut JSFunctionDef,
    mut label: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 20 as libc::c_int {
        pos = (*((*s).label_slots).offset(label as isize)).pos;
        loop {
            match *((*s).byte_code.buf).offset(pos as isize) as libc::c_int {
                192 | 180 => {
                    pos += 5 as libc::c_int;
                }
                107 => {
                    label = get_u32(
                        ((*s).byte_code.buf)
                            .offset(pos as isize)
                            .offset(1 as libc::c_int as isize),
                    ) as libc::c_int;
                    break;
                }
                _ => return pos,
            }
        }
        i += 1;
    }
    return pos;
}
unsafe extern "C" fn resolve_variables(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pos: libc::c_int = 0;
    let mut pos_next: libc::c_int = 0;
    let mut bc_len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut line_num: libc::c_int = 0;
    let mut bc_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut var_name: JSAtom = 0;
    let mut bc_out: DynBuf = DynBuf {
        buf: 0 as *mut uint8_t,
        size: 0,
        allocated_size: 0,
        error: 0,
        realloc_func: None,
        opaque: 0 as *mut libc::c_void,
    };
    let mut cc: CodeContext = CodeContext {
        bc_buf: 0 as *const uint8_t,
        bc_len: 0,
        pos: 0,
        line_num: 0,
        op: 0,
        idx: 0,
        label: 0,
        val: 0,
        atom: 0,
    };
    let mut scope: libc::c_int = 0;
    bc_buf = (*s).byte_code.buf;
    cc.bc_buf = bc_buf;
    bc_len = (*s).byte_code.size as libc::c_int;
    cc.bc_len = bc_len;
    js_dbuf_init(ctx, &mut bc_out);
    i = 0 as libc::c_int;
    while i < (*s).global_var_count {
        let mut hf: *mut JSGlobalVar = &mut *((*s).global_vars).offset(i as isize)
            as *mut JSGlobalVar;
        let mut flags: libc::c_int = 0;
        idx = 0 as libc::c_int;
        loop {
            if !(idx < (*s).closure_var_count) {
                current_block = 2838571290723028321;
                break;
            }
            let mut cv: *mut JSClosureVar = &mut *((*s).closure_var).offset(idx as isize)
                as *mut JSClosureVar;
            if (*cv).var_name == (*hf).var_name {
                if (*s).eval_type == (2 as libc::c_int) << 0 as libc::c_int
                    && (*cv).is_lexical() as libc::c_int != 0
                {
                    dbuf_putc(&mut bc_out, OP_throw_error as libc::c_int as uint8_t);
                    dbuf_put_u32(&mut bc_out, JS_DupAtom(ctx, (*hf).var_name));
                    dbuf_putc(&mut bc_out, 1 as libc::c_int as uint8_t);
                }
                current_block = 4906268039856690917;
                break;
            } else {
                if (*cv).var_name == JS_ATOM__var_ as libc::c_int as libc::c_uint
                    || (*cv).var_name == JS_ATOM__arg_var_ as libc::c_int as libc::c_uint
                {
                    current_block = 4906268039856690917;
                    break;
                }
                idx += 1;
            }
        }
        match current_block {
            2838571290723028321 => {
                dbuf_putc(&mut bc_out, OP_check_define_var as libc::c_int as uint8_t);
                dbuf_put_u32(&mut bc_out, JS_DupAtom(ctx, (*hf).var_name));
                flags = 0 as libc::c_int;
                if (*hf).is_lexical() != 0 {
                    flags |= (1 as libc::c_int) << 7 as libc::c_int;
                }
                if (*hf).cpool_idx >= 0 as libc::c_int {
                    flags |= (1 as libc::c_int) << 6 as libc::c_int;
                }
                dbuf_putc(&mut bc_out, flags as uint8_t);
            }
            _ => {}
        }
        i += 1;
    }
    line_num = 0 as libc::c_int;
    pos = 0 as libc::c_int;
    loop {
        if !(pos < bc_len) {
            current_block = 12350242817162068077;
            break;
        }
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[op as usize].size as libc::c_int;
        pos_next = pos + len;
        match op {
            192 => {
                line_num = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                let ref mut fresh527 = (*s).line_number_size;
                *fresh527 += 1;
                current_block = 7690210945165507956;
            }
            49 => {
                let mut call_argc: libc::c_int = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                scope = get_u16(
                    bc_buf
                        .offset(pos as isize)
                        .offset(1 as libc::c_int as isize)
                        .offset(2 as libc::c_int as isize),
                ) as libc::c_int;
                mark_eval_captured_variables(ctx, s, scope);
                dbuf_putc(&mut bc_out, op as uint8_t);
                dbuf_put_u16(&mut bc_out, call_argc as uint16_t);
                dbuf_put_u16(
                    &mut bc_out,
                    ((*((*s).scopes).offset(scope as isize)).first + 1 as libc::c_int)
                        as uint16_t,
                );
                current_block = 17788412896529399552;
            }
            50 => {
                scope = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                mark_eval_captured_variables(ctx, s, scope);
                dbuf_putc(&mut bc_out, op as uint8_t);
                dbuf_put_u16(
                    &mut bc_out,
                    ((*((*s).scopes).offset(scope as isize)).first + 1 as libc::c_int)
                        as uint16_t,
                );
                current_block = 17788412896529399552;
            }
            181 | 182 | 183 | 184 | 186 | 187 => {
                var_name = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                scope = get_u16(
                    bc_buf.offset(pos as isize).offset(5 as libc::c_int as isize),
                ) as libc::c_int;
                pos_next = resolve_scope_var(
                    ctx,
                    s,
                    var_name,
                    scope,
                    op,
                    &mut bc_out,
                    0 as *mut uint8_t,
                    0 as *mut LabelSlot,
                    pos_next,
                );
                JS_FreeAtom(ctx, var_name);
                current_block = 17788412896529399552;
            }
            185 => {
                let mut label: libc::c_int = 0;
                let mut ls: *mut LabelSlot = 0 as *mut LabelSlot;
                var_name = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(5 as libc::c_int as isize),
                ) as libc::c_int;
                scope = get_u16(
                    bc_buf.offset(pos as isize).offset(9 as libc::c_int as isize),
                ) as libc::c_int;
                ls = &mut *((*s).label_slots).offset(label as isize) as *mut LabelSlot;
                let ref mut fresh528 = (*ls).ref_count;
                *fresh528 -= 1;
                pos_next = resolve_scope_var(
                    ctx,
                    s,
                    var_name,
                    scope,
                    op,
                    &mut bc_out,
                    bc_buf,
                    ls,
                    pos_next,
                );
                JS_FreeAtom(ctx, var_name);
                current_block = 17788412896529399552;
            }
            188 | 189 | 190 => {
                let mut ret: libc::c_int = 0;
                var_name = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                scope = get_u16(
                    bc_buf.offset(pos as isize).offset(5 as libc::c_int as isize),
                ) as libc::c_int;
                ret = resolve_scope_private_field(
                    ctx,
                    s,
                    var_name,
                    scope,
                    op,
                    &mut bc_out,
                );
                if ret < 0 as libc::c_int {
                    current_block = 17988089801593699269;
                    break;
                }
                JS_FreeAtom(ctx, var_name);
                current_block = 17788412896529399552;
            }
            109 => {
                let ref mut fresh529 = (*s).jump_size;
                *fresh529 += 1;
                let mut label_0: libc::c_int = 0;
                let mut ls_0: *mut LabelSlot = 0 as *mut LabelSlot;
                label_0 = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                assert(
                    (label_0 >= 0 as libc::c_int && label_0 < (*s).label_count)
                        as libc::c_int,
                );
                ls_0 = &mut *((*s).label_slots).offset(label_0 as isize)
                    as *mut LabelSlot;
                if code_match(
                    &mut cc as *mut CodeContext,
                    (*ls_0).pos,
                    OP_ret as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    let ref mut fresh530 = (*ls_0).ref_count;
                    *fresh530 -= 1;
                    current_block = 17788412896529399552;
                } else {
                    current_block = 7690210945165507956;
                }
            }
            22 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_put_array_el as libc::c_int
                        | (OP_put_ref_value as libc::c_int) << 8 as libc::c_int,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    dbuf_putc(&mut bc_out, cc.op as uint8_t);
                    pos_next = cc.pos;
                    if cc.line_num != -(1 as libc::c_int) && cc.line_num != line_num {
                        line_num = cc.line_num;
                        let ref mut fresh532 = (*s).line_number_size;
                        *fresh532 += 1;
                        dbuf_putc(&mut bc_out, OP_line_num as libc::c_int as uint8_t);
                        dbuf_put_u32(&mut bc_out, line_num as uint32_t);
                    }
                    current_block = 17788412896529399552;
                } else {
                    current_block = 7690210945165507956;
                }
            }
            107 => {
                let ref mut fresh533 = (*s).jump_size;
                *fresh533 += 1;
                current_block = 5697748000427295508;
            }
            35 | 37 | 40 | 41 | 47 | 48 | 110 => {
                current_block = 5697748000427295508;
            }
            180 => {
                let mut label_1: libc::c_int = 0;
                let mut ls_1: *mut LabelSlot = 0 as *mut LabelSlot;
                label_1 = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                assert(
                    (label_1 >= 0 as libc::c_int && label_1 < (*s).label_count)
                        as libc::c_int,
                );
                ls_1 = &mut *((*s).label_slots).offset(label_1 as isize)
                    as *mut LabelSlot;
                (*ls_1)
                    .pos2 = (bc_out.size)
                    .wrapping_add(opcode_info[op as usize].size as libc::c_ulong)
                    as libc::c_int;
                current_block = 7690210945165507956;
            }
            178 => {
                let mut scope_idx: libc::c_int = 0;
                let mut scope_0: libc::c_int = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if scope_0 == (*s).body_scope {
                    instantiate_hoisted_definitions(ctx, s, &mut bc_out);
                }
                scope_idx = (*((*s).scopes).offset(scope_0 as isize)).first;
                while scope_idx >= 0 as libc::c_int {
                    let mut vd: *mut JSVarDef = &mut *((*s).vars)
                        .offset(scope_idx as isize) as *mut JSVarDef;
                    if !((*vd).scope_level == scope_0) {
                        break;
                    }
                    if scope_idx != (*s).arguments_arg_idx {
                        if (*vd).var_kind() as libc::c_int
                            == JS_VAR_FUNCTION_DECL as libc::c_int
                            || (*vd).var_kind() as libc::c_int
                                == JS_VAR_NEW_FUNCTION_DECL as libc::c_int
                        {
                            dbuf_putc(
                                &mut bc_out,
                                OP_fclosure as libc::c_int as uint8_t,
                            );
                            dbuf_put_u32(&mut bc_out, (*vd).func_pool_idx() as uint32_t);
                            dbuf_putc(&mut bc_out, OP_put_loc as libc::c_int as uint8_t);
                            dbuf_put_u16(&mut bc_out, scope_idx as uint16_t);
                        } else {
                            dbuf_putc(
                                &mut bc_out,
                                OP_set_loc_uninitialized as libc::c_int as uint8_t,
                            );
                            dbuf_put_u16(&mut bc_out, scope_idx as uint16_t);
                        }
                    }
                    scope_idx = (*vd).scope_next;
                }
                current_block = 17788412896529399552;
            }
            179 => {
                let mut scope_idx_0: libc::c_int = 0;
                let mut scope_1: libc::c_int = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                scope_idx_0 = (*((*s).scopes).offset(scope_1 as isize)).first;
                while scope_idx_0 >= 0 as libc::c_int {
                    let mut vd_0: *mut JSVarDef = &mut *((*s).vars)
                        .offset(scope_idx_0 as isize) as *mut JSVarDef;
                    if !((*vd_0).scope_level == scope_1) {
                        break;
                    }
                    if (*vd_0).is_captured() != 0 {
                        dbuf_putc(&mut bc_out, OP_close_loc as libc::c_int as uint8_t);
                        dbuf_put_u16(&mut bc_out, scope_idx_0 as uint16_t);
                    }
                    scope_idx_0 = (*vd_0).scope_next;
                }
                current_block = 17788412896529399552;
            }
            77 => {
                let mut name: JSAtom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if name == 0 as libc::c_int as libc::c_uint {
                    current_block = 17788412896529399552;
                } else {
                    current_block = 7690210945165507956;
                }
            }
            105 | 106 | 108 => {
                let ref mut fresh535 = (*s).jump_size;
                *fresh535 += 1;
                current_block = 7690210945165507956;
            }
            17 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    let mut lab0: libc::c_int = 0;
                    let mut lab1: libc::c_int = 0;
                    let mut op1: libc::c_int = 0;
                    let mut pos1_0: libc::c_int = 0;
                    let mut line1_0: libc::c_int = 0;
                    let mut pos2: libc::c_int = 0;
                    lab1 = cc.label;
                    lab0 = lab1;
                    assert(
                        (lab1 >= 0 as libc::c_int && lab1 < (*s).label_count)
                            as libc::c_int,
                    );
                    op1 = cc.op;
                    pos1_0 = cc.pos;
                    line1_0 = cc.line_num;
                    loop {
                        pos2 = get_label_pos(s, lab1);
                        if !(code_match(
                            &mut cc as *mut CodeContext,
                            pos2,
                            OP_dup as libc::c_int,
                            op1,
                            OP_drop as libc::c_int,
                            -(1 as libc::c_int),
                        ) != 0)
                        {
                            break;
                        }
                        lab1 = cc.label;
                    }
                    if code_match(
                        &mut cc as *mut CodeContext,
                        pos2,
                        op1,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        let ref mut fresh536 = (*s).jump_size;
                        *fresh536 += 1;
                        update_label(s, lab0, -(1 as libc::c_int));
                        update_label(s, cc.label, 1 as libc::c_int);
                        dbuf_putc(&mut bc_out, op1 as uint8_t);
                        dbuf_put_u32(&mut bc_out, cc.label as uint32_t);
                        pos_next = pos1_0;
                        if line1_0 != -(1 as libc::c_int) && line1_0 != line_num {
                            line_num = line1_0;
                            let ref mut fresh537 = (*s).line_number_size;
                            *fresh537 += 1;
                            dbuf_putc(
                                &mut bc_out,
                                OP_line_num as libc::c_int as uint8_t,
                            );
                            dbuf_put_u32(&mut bc_out, line_num as uint32_t);
                        }
                        current_block = 17788412896529399552;
                    } else {
                        current_block = 7690210945165507956;
                    }
                } else {
                    current_block = 7690210945165507956;
                }
            }
            177 => {
                current_block = 17788412896529399552;
            }
            191 => {
                current_block = 17788412896529399552;
            }
            14 | _ => {
                current_block = 7690210945165507956;
            }
        }
        match current_block {
            5697748000427295508 => {
                let mut line: libc::c_int = -(1 as libc::c_int);
                dbuf_put(&mut bc_out, bc_buf.offset(pos as isize), len as size_t);
                pos = skip_dead_code(s, bc_buf, bc_len, pos + len, &mut line);
                pos_next = pos;
                if pos < bc_len && line >= 0 as libc::c_int && line_num != line {
                    line_num = line;
                    let ref mut fresh534 = (*s).line_number_size;
                    *fresh534 += 1;
                    dbuf_putc(&mut bc_out, OP_line_num as libc::c_int as uint8_t);
                    dbuf_put_u32(&mut bc_out, line_num as uint32_t);
                }
            }
            7690210945165507956 => {
                dbuf_put(&mut bc_out, bc_buf.offset(pos as isize), len as size_t);
            }
            _ => {}
        }
        pos = pos_next;
    }
    match current_block {
        17988089801593699269 => {
            while pos < bc_len {
                op = *bc_buf.offset(pos as isize) as libc::c_int;
                len = opcode_info[op as usize].size as libc::c_int;
                pos_next = pos + len;
                dbuf_put(&mut bc_out, bc_buf.offset(pos as isize), len as size_t);
                pos = pos_next;
            }
            dbuf_free(&mut (*s).byte_code);
            (*s).byte_code = bc_out;
            return -(1 as libc::c_int);
        }
        _ => {
            dbuf_free(&mut (*s).byte_code);
            (*s).byte_code = bc_out;
            if dbuf_error(&mut (*s).byte_code) != 0 {
                JS_ThrowOutOfMemory(ctx);
                return -(1 as libc::c_int);
            }
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn add_pc2line_info(
    mut s: *mut JSFunctionDef,
    mut pc: uint32_t,
    mut line_num: libc::c_int,
) {
    if !((*s).line_number_slots).is_null()
        && (*s).line_number_count < (*s).line_number_size
        && pc >= (*s).line_number_last_pc as libc::c_uint
        && line_num != (*s).line_number_last
    {
        (*((*s).line_number_slots).offset((*s).line_number_count as isize)).pc = pc;
        (*((*s).line_number_slots).offset((*s).line_number_count as isize))
            .line_num = line_num;
        let ref mut fresh538 = (*s).line_number_count;
        *fresh538 += 1;
        (*s).line_number_last_pc = pc as libc::c_int;
        (*s).line_number_last = line_num;
    }
}
unsafe extern "C" fn compute_pc2line_info(mut s: *mut JSFunctionDef) {
    if (*s).js_mode as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int == 0
        && !((*s).line_number_slots).is_null()
    {
        let mut last_line_num: libc::c_int = (*s).line_num;
        let mut last_pc: uint32_t = 0 as libc::c_int as uint32_t;
        let mut i: libc::c_int = 0;
        js_dbuf_init((*s).ctx, &mut (*s).pc2line);
        i = 0 as libc::c_int;
        while i < (*s).line_number_count {
            let mut pc: uint32_t = (*((*s).line_number_slots).offset(i as isize)).pc;
            let mut line_num: libc::c_int = (*((*s).line_number_slots)
                .offset(i as isize))
                .line_num;
            let mut diff_pc: libc::c_int = 0;
            let mut diff_line: libc::c_int = 0;
            if !(line_num < 0 as libc::c_int) {
                diff_pc = pc.wrapping_sub(last_pc) as libc::c_int;
                diff_line = line_num - last_line_num;
                if !(diff_line == 0 as libc::c_int || diff_pc < 0 as libc::c_int) {
                    if diff_line >= -(1 as libc::c_int)
                        && diff_line < -(1 as libc::c_int) + 5 as libc::c_int
                        && diff_pc
                            <= (255 as libc::c_int - 1 as libc::c_int) / 5 as libc::c_int
                    {
                        dbuf_putc(
                            &mut (*s).pc2line,
                            (diff_line - -(1 as libc::c_int) + diff_pc * 5 as libc::c_int
                                + 1 as libc::c_int) as uint8_t,
                        );
                    } else {
                        dbuf_putc(&mut (*s).pc2line, 0 as libc::c_int as uint8_t);
                        dbuf_put_leb128(&mut (*s).pc2line, diff_pc as uint32_t);
                        dbuf_put_sleb128(&mut (*s).pc2line, diff_line);
                    }
                    last_pc = pc;
                    last_line_num = line_num;
                }
            }
            i += 1;
        }
    }
}
unsafe extern "C" fn add_reloc(
    mut ctx: *mut JSContext,
    mut ls: *mut LabelSlot,
    mut addr: uint32_t,
    mut size: libc::c_int,
) -> *mut RelocEntry {
    let mut re: *mut RelocEntry = 0 as *mut RelocEntry;
    re = js_malloc(ctx, ::core::mem::size_of::<RelocEntry>() as libc::c_ulong)
        as *mut RelocEntry;
    if re.is_null() {
        return 0 as *mut RelocEntry;
    }
    (*re).addr = addr;
    (*re).size = size;
    let ref mut fresh539 = (*re).next;
    *fresh539 = (*ls).first_reloc;
    let ref mut fresh540 = (*ls).first_reloc;
    *fresh540 = re;
    return re;
}
unsafe extern "C" fn code_has_label(
    mut s: *mut CodeContext,
    mut pos: libc::c_int,
    mut label: libc::c_int,
) -> BOOL {
    while pos < (*s).bc_len {
        let mut op: libc::c_int = *((*s).bc_buf).offset(pos as isize) as libc::c_int;
        if op == OP_line_num as libc::c_int {
            pos += 5 as libc::c_int;
        } else if op == OP_label as libc::c_int {
            let mut lab: libc::c_int = get_u32(
                ((*s).bc_buf).offset(pos as isize).offset(1 as libc::c_int as isize),
            ) as libc::c_int;
            if lab == label {
                return TRUE as libc::c_int;
            }
            pos += 5 as libc::c_int;
        } else {
            if op == OP_goto as libc::c_int {
                let mut lab_0: libc::c_int = get_u32(
                    ((*s).bc_buf).offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if lab_0 == label {
                    return TRUE as libc::c_int;
                }
            }
            break;
        }
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn find_jump_target(
    mut s: *mut JSFunctionDef,
    mut label: libc::c_int,
    mut pop: *mut libc::c_int,
    mut pline: *mut libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    update_label(s, label, -(1 as libc::c_int));
    i = 0 as libc::c_int;
    's_10: while i < 10 as libc::c_int {
        assert((label >= 0 as libc::c_int && label < (*s).label_count) as libc::c_int);
        pos = (*((*s).label_slots).offset(label as isize)).pos2;
        loop {
            op = *((*s).byte_code.buf).offset(pos as isize) as libc::c_int;
            match op {
                192 => {
                    if !pline.is_null() {
                        *pline = get_u32(
                            ((*s).byte_code.buf)
                                .offset(pos as isize)
                                .offset(1 as libc::c_int as isize),
                        ) as libc::c_int;
                    }
                }
                180 => {}
                107 => {
                    label = get_u32(
                        ((*s).byte_code.buf)
                            .offset(pos as isize)
                            .offset(1 as libc::c_int as isize),
                    ) as libc::c_int;
                    break;
                }
                14 => {
                    loop {
                        pos += 1;
                        if !(*((*s).byte_code.buf).offset(pos as isize) as libc::c_int
                            == OP_drop as libc::c_int)
                        {
                            break;
                        }
                    }
                    if *((*s).byte_code.buf).offset(pos as isize) as libc::c_int
                        == OP_return_undef as libc::c_int
                    {
                        op = OP_return_undef as libc::c_int;
                    }
                    break 's_10;
                }
                _ => {
                    break 's_10;
                }
            }
            pos += opcode_info[op as usize].size as libc::c_int;
        }
        i += 1;
    }
    *pop = op;
    update_label(s, label, 1 as libc::c_int);
    return label;
}
unsafe extern "C" fn push_short_int(mut bc_out: *mut DynBuf, mut val: libc::c_int) {
    if val >= -(1 as libc::c_int) && val <= 7 as libc::c_int {
        dbuf_putc(bc_out, (OP_push_0 as libc::c_int + val) as uint8_t);
        return;
    }
    if val == val as int8_t as libc::c_int {
        dbuf_putc(bc_out, OP_push_i8 as libc::c_int as uint8_t);
        dbuf_putc(bc_out, val as uint8_t);
        return;
    }
    if val == val as int16_t as libc::c_int {
        dbuf_putc(bc_out, OP_push_i16 as libc::c_int as uint8_t);
        dbuf_put_u16(bc_out, val as uint16_t);
        return;
    }
    dbuf_putc(bc_out, OP_push_i32 as libc::c_int as uint8_t);
    dbuf_put_u32(bc_out, val as uint32_t);
}
unsafe extern "C" fn put_short_code(
    mut bc_out: *mut DynBuf,
    mut op: libc::c_int,
    mut idx: libc::c_int,
) {
    if idx < 4 as libc::c_int {
        match op {
            88 => {
                dbuf_putc(bc_out, (OP_get_loc0 as libc::c_int + idx) as uint8_t);
                return;
            }
            89 => {
                dbuf_putc(bc_out, (OP_put_loc0 as libc::c_int + idx) as uint8_t);
                return;
            }
            90 => {
                dbuf_putc(bc_out, (OP_set_loc0 as libc::c_int + idx) as uint8_t);
                return;
            }
            91 => {
                dbuf_putc(bc_out, (OP_get_arg0 as libc::c_int + idx) as uint8_t);
                return;
            }
            92 => {
                dbuf_putc(bc_out, (OP_put_arg0 as libc::c_int + idx) as uint8_t);
                return;
            }
            93 => {
                dbuf_putc(bc_out, (OP_set_arg0 as libc::c_int + idx) as uint8_t);
                return;
            }
            94 => {
                dbuf_putc(bc_out, (OP_get_var_ref0 as libc::c_int + idx) as uint8_t);
                return;
            }
            95 => {
                dbuf_putc(bc_out, (OP_put_var_ref0 as libc::c_int + idx) as uint8_t);
                return;
            }
            96 => {
                dbuf_putc(bc_out, (OP_set_var_ref0 as libc::c_int + idx) as uint8_t);
                return;
            }
            34 => {
                dbuf_putc(bc_out, (OP_call0 as libc::c_int + idx) as uint8_t);
                return;
            }
            _ => {}
        }
    }
    if idx < 256 as libc::c_int {
        match op {
            88 => {
                dbuf_putc(bc_out, OP_get_loc8 as libc::c_int as uint8_t);
                dbuf_putc(bc_out, idx as uint8_t);
                return;
            }
            89 => {
                dbuf_putc(bc_out, OP_put_loc8 as libc::c_int as uint8_t);
                dbuf_putc(bc_out, idx as uint8_t);
                return;
            }
            90 => {
                dbuf_putc(bc_out, OP_set_loc8 as libc::c_int as uint8_t);
                dbuf_putc(bc_out, idx as uint8_t);
                return;
            }
            _ => {}
        }
    }
    dbuf_putc(bc_out, op as uint8_t);
    dbuf_put_u16(bc_out, idx as uint16_t);
}
unsafe extern "C" fn resolve_labels(
    mut ctx: *mut JSContext,
    mut s: *mut JSFunctionDef,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pos: libc::c_int = 0;
    let mut pos_next: libc::c_int = 0;
    let mut bc_len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut op1: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut line_num: libc::c_int = 0;
    let mut bc_buf: *const uint8_t = 0 as *const uint8_t;
    let mut bc_out: DynBuf = DynBuf {
        buf: 0 as *mut uint8_t,
        size: 0,
        allocated_size: 0,
        error: 0,
        realloc_func: None,
        opaque: 0 as *mut libc::c_void,
    };
    let mut label_slots: *mut LabelSlot = 0 as *mut LabelSlot;
    let mut ls: *mut LabelSlot = 0 as *mut LabelSlot;
    let mut re: *mut RelocEntry = 0 as *mut RelocEntry;
    let mut re_next: *mut RelocEntry = 0 as *mut RelocEntry;
    let mut cc: CodeContext = CodeContext {
        bc_buf: 0 as *const uint8_t,
        bc_len: 0,
        pos: 0,
        line_num: 0,
        op: 0,
        idx: 0,
        label: 0,
        val: 0,
        atom: 0,
    };
    let mut label: libc::c_int = 0;
    let mut jp: *mut JumpSlot = 0 as *mut JumpSlot;
    label_slots = (*s).label_slots;
    line_num = (*s).line_num;
    bc_buf = (*s).byte_code.buf;
    cc.bc_buf = bc_buf;
    bc_len = (*s).byte_code.size as libc::c_int;
    cc.bc_len = bc_len;
    js_dbuf_init(ctx, &mut bc_out);
    if (*s).jump_size != 0 {
        let ref mut fresh541 = (*s).jump_slots;
        *fresh541 = js_mallocz(
            (*s).ctx,
            (::core::mem::size_of::<JumpSlot>() as libc::c_ulong)
                .wrapping_mul((*s).jump_size as libc::c_ulong),
        ) as *mut JumpSlot;
        if ((*s).jump_slots).is_null() {
            return -(1 as libc::c_int);
        }
    }
    if (*s).line_number_size != 0
        && (*s).js_mode as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int == 0
    {
        let ref mut fresh542 = (*s).line_number_slots;
        *fresh542 = js_mallocz(
            (*s).ctx,
            (::core::mem::size_of::<LineNumberSlot>() as libc::c_ulong)
                .wrapping_mul((*s).line_number_size as libc::c_ulong),
        ) as *mut LineNumberSlot;
        if ((*s).line_number_slots).is_null() {
            return -(1 as libc::c_int);
        }
        (*s).line_number_last = (*s).line_num;
        (*s).line_number_last_pc = 0 as libc::c_int;
    }
    if (*s).home_object_var_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_HOME_OBJECT as libc::c_int as uint8_t);
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).home_object_var_idx);
    }
    if (*s).this_active_func_var_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_THIS_FUNC as libc::c_int as uint8_t);
        put_short_code(
            &mut bc_out,
            OP_put_loc as libc::c_int,
            (*s).this_active_func_var_idx,
        );
    }
    if (*s).new_target_var_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_NEW_TARGET as libc::c_int as uint8_t);
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).new_target_var_idx);
    }
    if (*s).this_var_idx >= 0 as libc::c_int {
        if (*s).is_derived_class_constructor != 0 {
            dbuf_putc(&mut bc_out, OP_set_loc_uninitialized as libc::c_int as uint8_t);
            dbuf_put_u16(&mut bc_out, (*s).this_var_idx as uint16_t);
        } else {
            dbuf_putc(&mut bc_out, OP_push_this as libc::c_int as uint8_t);
            put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).this_var_idx);
        }
    }
    if (*s).arguments_var_idx >= 0 as libc::c_int {
        if (*s).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
            || (*s).has_simple_parameter_list == 0
        {
            dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
            dbuf_putc(
                &mut bc_out,
                OP_SPECIAL_OBJECT_ARGUMENTS as libc::c_int as uint8_t,
            );
        } else {
            dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
            dbuf_putc(
                &mut bc_out,
                OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS as libc::c_int as uint8_t,
            );
        }
        if (*s).arguments_arg_idx >= 0 as libc::c_int {
            put_short_code(
                &mut bc_out,
                OP_set_loc as libc::c_int,
                (*s).arguments_arg_idx,
            );
        }
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).arguments_var_idx);
    }
    if (*s).func_var_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_THIS_FUNC as libc::c_int as uint8_t);
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).func_var_idx);
    }
    if (*s).var_object_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT as libc::c_int as uint8_t);
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).var_object_idx);
    }
    if (*s).arg_var_object_idx >= 0 as libc::c_int {
        dbuf_putc(&mut bc_out, OP_special_object as libc::c_int as uint8_t);
        dbuf_putc(&mut bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT as libc::c_int as uint8_t);
        put_short_code(&mut bc_out, OP_put_loc as libc::c_int, (*s).arg_var_object_idx);
    }
    pos = 0 as libc::c_int;
    loop {
        if !(pos < bc_len) {
            current_block = 13660867329937171269;
            break;
        }
        let mut val: libc::c_int = 0;
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[op as usize].size as libc::c_int;
        pos_next = pos + len;
        match op {
            192 => {
                line_num = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                current_block = 317151059986244064;
            }
            180 => {
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                assert(
                    (label >= 0 as libc::c_int && label < (*s).label_count)
                        as libc::c_int,
                );
                ls = &mut *label_slots.offset(label as isize) as *mut LabelSlot;
                assert(((*ls).addr == -(1 as libc::c_int)) as libc::c_int);
                (*ls).addr = bc_out.size as libc::c_int;
                re = (*ls).first_reloc;
                while !re.is_null() {
                    let mut diff: libc::c_int = ((*ls).addr as libc::c_uint)
                        .wrapping_sub((*re).addr) as libc::c_int;
                    re_next = (*re).next;
                    match (*re).size {
                        4 => {
                            put_u32(
                                (bc_out.buf).offset((*re).addr as isize),
                                diff as uint32_t,
                            );
                        }
                        2 => {
                            assert(
                                (diff == diff as int16_t as libc::c_int) as libc::c_int,
                            );
                            put_u16(
                                (bc_out.buf).offset((*re).addr as isize),
                                diff as uint16_t,
                            );
                        }
                        1 => {
                            assert(
                                (diff == diff as int8_t as libc::c_int) as libc::c_int,
                            );
                            put_u8(
                                (bc_out.buf).offset((*re).addr as isize),
                                diff as uint8_t,
                            );
                        }
                        _ => {}
                    }
                    js_free(ctx, re as *mut libc::c_void);
                    re = re_next;
                }
                let ref mut fresh543 = (*ls).first_reloc;
                *fresh543 = 0 as *mut RelocEntry;
                current_block = 317151059986244064;
            }
            34 | 36 => {
                let mut argc: libc::c_int = 0;
                argc = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_return as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    put_short_code(&mut bc_out, op + 1 as libc::c_int, argc);
                    pos_next = skip_dead_code(s, bc_buf, bc_len, cc.pos, &mut line_num);
                } else {
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    put_short_code(&mut bc_out, op, argc);
                }
                current_block = 317151059986244064;
            }
            40 | 41 | 46 | 47 | 48 => {
                pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &mut line_num);
                current_block = 2329107529480457108;
            }
            107 => {
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                current_block = 14483658890531361756;
            }
            109 => {
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if 0 as libc::c_int != 0 && 1 as libc::c_int != 0 {
                    label = find_jump_target(s, label, &mut op1, 0 as *mut libc::c_int);
                    if op1 == OP_ret as libc::c_int {
                        update_label(s, label, -(1 as libc::c_int));
                        current_block = 317151059986244064;
                    } else {
                        current_block = 3095897807344712179;
                    }
                } else {
                    current_block = 3095897807344712179;
                }
            }
            108 => {
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                current_block = 3095897807344712179;
            }
            106 | 105 => {
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                label = find_jump_target(s, label, &mut op1, 0 as *mut libc::c_int);
                if code_has_label(&mut cc, pos_next, label) != 0 {
                    update_label(s, label, -(1 as libc::c_int));
                    dbuf_putc(&mut bc_out, OP_drop as libc::c_int as uint8_t);
                    current_block = 317151059986244064;
                } else {
                    if code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_goto as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        let mut pos1: libc::c_int = cc.pos;
                        let mut line1_0: libc::c_int = cc.line_num;
                        if code_has_label(&mut cc, pos1, label) != 0 {
                            if line1_0 >= 0 as libc::c_int {
                                line_num = line1_0;
                            }
                            pos_next = pos1;
                            update_label(s, label, -(1 as libc::c_int));
                            label = cc.label;
                            op ^= OP_if_true as libc::c_int ^ OP_if_false as libc::c_int;
                        }
                    }
                    current_block = 3095897807344712179;
                }
            }
            114 | 115 | 116 | 117 | 118 | 119 => {
                let mut atom: JSAtom = 0;
                let mut is_with: libc::c_int = 0;
                atom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                label = get_u32(
                    bc_buf.offset(pos as isize).offset(5 as libc::c_int as isize),
                ) as libc::c_int;
                is_with = *bc_buf.offset((pos + 9 as libc::c_int) as isize)
                    as libc::c_int;
                label = find_jump_target(s, label, &mut op1, 0 as *mut libc::c_int);
                assert(
                    (label >= 0 as libc::c_int && label < (*s).label_count)
                        as libc::c_int,
                );
                ls = &mut *label_slots.offset(label as isize) as *mut LabelSlot;
                add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                let ref mut fresh546 = (*s).jump_count;
                let fresh547 = *fresh546;
                *fresh546 = *fresh546 + 1;
                jp = &mut *((*s).jump_slots).offset(fresh547 as isize) as *mut JumpSlot;
                (*jp).op = op;
                (*jp).size = 4 as libc::c_int;
                (*jp)
                    .pos = (bc_out.size).wrapping_add(5 as libc::c_int as libc::c_ulong)
                    as libc::c_int;
                (*jp).label = label;
                dbuf_putc(&mut bc_out, op as uint8_t);
                dbuf_put_u32(&mut bc_out, atom);
                dbuf_put_u32(
                    &mut bc_out,
                    ((*ls).addr as libc::c_ulong).wrapping_sub(bc_out.size) as uint32_t,
                );
                if (*ls).addr == -(1 as libc::c_int) {
                    if (add_reloc(
                        ctx,
                        ls,
                        (bc_out.size).wrapping_sub(4 as libc::c_int as libc::c_ulong)
                            as uint32_t,
                        4 as libc::c_int,
                    ))
                        .is_null()
                    {
                        current_block = 13937986802215865503;
                        break;
                    }
                }
                dbuf_putc(&mut bc_out, is_with as uint8_t);
                current_block = 317151059986244064;
            }
            14 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_return_undef as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            7 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_strict_eq as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_is_null as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_strict_neq as libc::c_int,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_is_null as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    label = cc.label;
                    op = cc.op ^ OP_if_false as libc::c_int ^ OP_if_true as libc::c_int;
                    current_block = 3095897807344712179;
                } else {
                    current_block = 7372525359518355110;
                }
            }
            9 | 10 => {
                current_block = 7372525359518355110;
            }
            1 => {
                val = get_i32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if val as libc::c_uint != 0x80000000 as libc::c_uint
                    && val != 0 as libc::c_int
                    && code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_neg as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    if code_match(
                        &mut cc as *mut CodeContext,
                        cc.pos,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                    } else {
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        push_short_int(&mut bc_out, -val);
                    }
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    val = (val != 0 as libc::c_int) as libc::c_int;
                    current_block = 1883420370212779012;
                } else {
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    push_short_int(&mut bc_out, val);
                    current_block = 317151059986244064;
                }
            }
            2 | 3 => {
                let mut idx: libc::c_int = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if idx < 256 as libc::c_int {
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(
                        &mut bc_out,
                        (OP_push_const8 as libc::c_int + op
                            - OP_push_const as libc::c_int) as uint8_t,
                    );
                    dbuf_putc(&mut bc_out, idx as uint8_t);
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            65 => {
                let mut atom_0: JSAtom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if atom_0 == JS_ATOM_length as libc::c_int as libc::c_uint {
                    JS_FreeAtom(ctx, atom_0);
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_get_length as libc::c_int as uint8_t);
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            4 => {
                let mut atom_1: JSAtom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    JS_FreeAtom(ctx, atom_1);
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if atom_1 == JS_ATOM_empty_string as libc::c_int as libc::c_uint {
                    JS_FreeAtom(ctx, atom_1);
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(
                        &mut bc_out,
                        OP_push_empty_string as libc::c_int as uint8_t,
                    );
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            112 | 113 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_get_loc as libc::c_int
                        | (OP_get_arg as libc::c_int) << 8 as libc::c_int
                        | (OP_get_var_ref as libc::c_int) << 16 as libc::c_int,
                    -(1 as libc::c_int),
                    OP_put_array_el as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                    || code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_push_i32 as libc::c_int
                            | (OP_push_const as libc::c_int) << 8 as libc::c_int
                            | (OP_push_atom_value as libc::c_int) << 16 as libc::c_int,
                        OP_put_array_el as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    || code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_undefined as libc::c_int
                            | (OP_null as libc::c_int) << 8 as libc::c_int
                            | (OP_push_true as libc::c_int) << 16 as libc::c_int
                            | (OP_push_false as libc::c_int) << 24 as libc::c_int,
                        OP_put_array_el as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                {
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            6 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_return as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_return_undef as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    val = 0 as libc::c_int;
                    current_block = 1883420370212779012;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_strict_eq as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_is_undefined as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_strict_neq as libc::c_int,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, OP_is_undefined as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    label = cc.label;
                    op = cc.op ^ OP_if_false as libc::c_int ^ OP_if_true as libc::c_int;
                    current_block = 3095897807344712179;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            21 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_put_field as libc::c_int
                        | (OP_put_var_strict as libc::c_int) << 8 as libc::c_int,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, cc.op as uint8_t);
                    dbuf_put_u32(&mut bc_out, cc.atom);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            17 => {
                let mut op1_0: libc::c_int = 0;
                let mut line2: libc::c_int = -(1 as libc::c_int);
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_put_loc as libc::c_int
                        | (OP_put_arg as libc::c_int) << 8 as libc::c_int
                        | (OP_put_var_ref as libc::c_int) << 16 as libc::c_int,
                    -(1 as libc::c_int),
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    op1_0 = cc.op + 1 as libc::c_int;
                    pos_next = cc.pos;
                    if code_match(
                        &mut cc as *mut CodeContext,
                        cc.pos,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        op1_0 -= 1 as libc::c_int;
                        pos_next = cc.pos;
                        if code_match(
                            &mut cc as *mut CodeContext,
                            cc.pos,
                            op1_0 - 1 as libc::c_int,
                            cc.idx,
                            -(1 as libc::c_int),
                        ) != 0
                        {
                            line2 = cc.line_num;
                            op1_0 += 1 as libc::c_int;
                            pos_next = cc.pos;
                        }
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    put_short_code(&mut bc_out, op1_0, cc.idx);
                    if line2 >= 0 as libc::c_int {
                        line_num = line2;
                    }
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            88 => {
                let mut idx_0: libc::c_int = 0;
                idx_0 = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if idx_0 >= 256 as libc::c_int {
                    current_block = 2329107529480457108;
                } else {
                    if code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_post_dec as libc::c_int
                            | (OP_post_inc as libc::c_int) << 8 as libc::c_int,
                        OP_put_loc as libc::c_int,
                        idx_0,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                        || code_match(
                            &mut cc as *mut CodeContext,
                            pos_next,
                            OP_dec as libc::c_int
                                | (OP_inc as libc::c_int) << 8 as libc::c_int,
                            OP_dup as libc::c_int,
                            OP_put_loc as libc::c_int,
                            idx_0,
                            OP_drop as libc::c_int,
                            -(1 as libc::c_int),
                        ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        dbuf_putc(
                            &mut bc_out,
                            (if cc.op == OP_inc as libc::c_int
                                || cc.op == OP_post_inc as libc::c_int
                            {
                                OP_inc_loc as libc::c_int
                            } else {
                                OP_dec_loc as libc::c_int
                            }) as uint8_t,
                        );
                        dbuf_putc(&mut bc_out, idx_0 as uint8_t);
                        pos_next = cc.pos;
                    } else if code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_push_atom_value as libc::c_int,
                        OP_add as libc::c_int,
                        OP_dup as libc::c_int,
                        OP_put_loc as libc::c_int,
                        idx_0,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        if cc.atom == JS_ATOM_empty_string as libc::c_int as libc::c_uint
                        {
                            JS_FreeAtom(ctx, cc.atom);
                            dbuf_putc(
                                &mut bc_out,
                                OP_push_empty_string as libc::c_int as uint8_t,
                            );
                        } else {
                            dbuf_putc(
                                &mut bc_out,
                                OP_push_atom_value as libc::c_int as uint8_t,
                            );
                            dbuf_put_u32(&mut bc_out, cc.atom);
                        }
                        dbuf_putc(&mut bc_out, OP_add_loc as libc::c_int as uint8_t);
                        dbuf_putc(&mut bc_out, idx_0 as uint8_t);
                        pos_next = cc.pos;
                    } else if code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_push_i32 as libc::c_int,
                        OP_add as libc::c_int,
                        OP_dup as libc::c_int,
                        OP_put_loc as libc::c_int,
                        idx_0,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        push_short_int(&mut bc_out, cc.label);
                        dbuf_putc(&mut bc_out, OP_add_loc as libc::c_int as uint8_t);
                        dbuf_putc(&mut bc_out, idx_0 as uint8_t);
                        pos_next = cc.pos;
                    } else if code_match(
                        &mut cc as *mut CodeContext,
                        pos_next,
                        OP_get_loc as libc::c_int
                            | (OP_get_arg as libc::c_int) << 8 as libc::c_int
                            | (OP_get_var_ref as libc::c_int) << 16 as libc::c_int,
                        -(1 as libc::c_int),
                        OP_add as libc::c_int,
                        OP_dup as libc::c_int,
                        OP_put_loc as libc::c_int,
                        idx_0,
                        OP_drop as libc::c_int,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        put_short_code(&mut bc_out, cc.op, cc.idx);
                        dbuf_putc(&mut bc_out, OP_add_loc as libc::c_int as uint8_t);
                        dbuf_putc(&mut bc_out, idx_0 as uint8_t);
                        pos_next = cc.pos;
                    } else {
                        add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                        put_short_code(&mut bc_out, op, idx_0);
                    }
                    current_block = 317151059986244064;
                }
            }
            91 | 94 => {
                let mut idx_1: libc::c_int = 0;
                idx_1 = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                put_short_code(&mut bc_out, op, idx_1);
                current_block = 317151059986244064;
            }
            89 | 92 | 95 => {
                let mut idx_2: libc::c_int = 0;
                idx_2 = get_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                ) as libc::c_int;
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    op - 1 as libc::c_int,
                    idx_2,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    put_short_code(&mut bc_out, op + 1 as libc::c_int, idx_2);
                    pos_next = cc.pos;
                } else {
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    put_short_code(&mut bc_out, op, idx_2);
                }
                current_block = 317151059986244064;
            }
            145 | 144 => {
                let mut op1_1: libc::c_int = 0;
                let mut idx_3: libc::c_int = 0;
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_put_loc as libc::c_int
                        | (OP_put_arg as libc::c_int) << 8 as libc::c_int
                        | (OP_put_var_ref as libc::c_int) << 16 as libc::c_int,
                    -(1 as libc::c_int),
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    op1_1 = cc.op;
                    idx_3 = cc.idx;
                    pos_next = cc.pos;
                    if code_match(
                        &mut cc as *mut CodeContext,
                        cc.pos,
                        op1_1 - 1 as libc::c_int,
                        idx_3,
                        -(1 as libc::c_int),
                    ) != 0
                    {
                        if cc.line_num >= 0 as libc::c_int {
                            line_num = cc.line_num;
                        }
                        op1_1 += 1 as libc::c_int;
                        pos_next = cc.pos;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(
                        &mut bc_out,
                        (OP_dec as libc::c_int + (op - OP_post_dec as libc::c_int))
                            as uint8_t,
                    );
                    put_short_code(&mut bc_out, op1_1, idx_3);
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_perm3 as libc::c_int,
                    OP_put_field as libc::c_int
                        | (OP_put_var_strict as libc::c_int) << 8 as libc::c_int,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(
                        &mut bc_out,
                        (OP_dec as libc::c_int + (op - OP_post_dec as libc::c_int))
                            as uint8_t,
                    );
                    dbuf_putc(&mut bc_out, cc.op as uint8_t);
                    dbuf_put_u32(&mut bc_out, cc.atom);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_perm4 as libc::c_int,
                    OP_put_array_el as libc::c_int,
                    OP_drop as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(
                        &mut bc_out,
                        (OP_dec as libc::c_int + (op - OP_post_dec as libc::c_int))
                            as uint8_t,
                    );
                    dbuf_putc(&mut bc_out, OP_put_array_el as libc::c_int as uint8_t);
                    pos_next = cc.pos;
                    current_block = 317151059986244064;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            151 => {
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_push_atom_value as libc::c_int,
                    OP_strict_eq as libc::c_int
                        | (OP_strict_neq as libc::c_int) << 8 as libc::c_int
                        | (OP_eq as libc::c_int) << 16 as libc::c_int
                        | (OP_neq as libc::c_int) << 24 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    if cc.line_num >= 0 as libc::c_int {
                        line_num = cc.line_num;
                    }
                    let mut op1_2: libc::c_int = if cc.op == OP_strict_eq as libc::c_int
                        || cc.op == OP_eq as libc::c_int
                    {
                        OP_strict_eq as libc::c_int
                    } else {
                        OP_strict_neq as libc::c_int
                    };
                    let mut op2: libc::c_int = -(1 as libc::c_int);
                    match cc.atom {
                        69 => {
                            op2 = OP_typeof_is_undefined as libc::c_int;
                        }
                        27 => {
                            op2 = OP_typeof_is_function as libc::c_int;
                        }
                        _ => {}
                    }
                    if op2 >= 0 as libc::c_int {
                        if op1_2 == OP_strict_eq as libc::c_int {
                            add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                            dbuf_putc(&mut bc_out, op2 as uint8_t);
                            JS_FreeAtom(ctx, cc.atom);
                            pos_next = cc.pos;
                            current_block = 317151059986244064;
                        } else if op1_2 == OP_strict_neq as libc::c_int
                            && code_match(
                                &mut cc as *mut CodeContext,
                                cc.pos,
                                OP_if_false as libc::c_int,
                                -(1 as libc::c_int),
                            ) != 0
                        {
                            if cc.line_num >= 0 as libc::c_int {
                                line_num = cc.line_num;
                            }
                            add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                            dbuf_putc(&mut bc_out, op2 as uint8_t);
                            JS_FreeAtom(ctx, cc.atom);
                            pos_next = cc.pos;
                            label = cc.label;
                            op = OP_if_true as libc::c_int;
                            current_block = 3095897807344712179;
                        } else {
                            current_block = 2329107529480457108;
                        }
                    } else {
                        current_block = 2329107529480457108;
                    }
                } else {
                    current_block = 2329107529480457108;
                }
            }
            _ => {
                current_block = 2329107529480457108;
            }
        }
        match current_block {
            7372525359518355110 => {
                val = (op == OP_push_true as libc::c_int) as libc::c_int;
                if code_match(
                    &mut cc as *mut CodeContext,
                    pos_next,
                    OP_if_false as libc::c_int
                        | (OP_if_true as libc::c_int) << 8 as libc::c_int,
                    -(1 as libc::c_int),
                ) != 0
                {
                    current_block = 1883420370212779012;
                } else {
                    current_block = 2329107529480457108;
                }
            }
            _ => {}
        }
        match current_block {
            1883420370212779012 => {
                if cc.line_num >= 0 as libc::c_int {
                    line_num = cc.line_num;
                }
                if val == cc.op - OP_if_false as libc::c_int {
                    pos_next = cc.pos;
                    op = OP_goto as libc::c_int;
                    label = cc.label;
                    current_block = 14483658890531361756;
                } else {
                    pos_next = cc.pos;
                    update_label(s, cc.label, -(1 as libc::c_int));
                    current_block = 317151059986244064;
                }
            }
            2329107529480457108 => {
                add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                dbuf_put(&mut bc_out, bc_buf.offset(pos as isize), len as size_t);
                current_block = 317151059986244064;
            }
            _ => {}
        }
        match current_block {
            14483658890531361756 => {
                let mut line1: libc::c_int = -(1 as libc::c_int);
                label = find_jump_target(s, label, &mut op1, &mut line1);
                if code_has_label(&mut cc, pos_next, label) != 0 {
                    update_label(s, label, -(1 as libc::c_int));
                    current_block = 317151059986244064;
                } else if op1 == OP_return as libc::c_int
                    || op1 == OP_return_undef as libc::c_int
                    || op1 == OP_throw as libc::c_int
                {
                    update_label(s, label, -(1 as libc::c_int));
                    add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                    dbuf_putc(&mut bc_out, op1 as uint8_t);
                    pos_next = skip_dead_code(
                        s,
                        bc_buf,
                        bc_len,
                        pos_next,
                        &mut line_num,
                    );
                    current_block = 317151059986244064;
                } else {
                    current_block = 3095897807344712179;
                }
            }
            _ => {}
        }
        match current_block {
            3095897807344712179 => {
                add_pc2line_info(s, bc_out.size as uint32_t, line_num);
                if op == OP_goto as libc::c_int {
                    pos_next = skip_dead_code(
                        s,
                        bc_buf,
                        bc_len,
                        pos_next,
                        &mut line_num,
                    );
                }
                assert(
                    (label >= 0 as libc::c_int && label < (*s).label_count)
                        as libc::c_int,
                );
                ls = &mut *label_slots.offset(label as isize) as *mut LabelSlot;
                let ref mut fresh544 = (*s).jump_count;
                let fresh545 = *fresh544;
                *fresh544 = *fresh544 + 1;
                jp = &mut *((*s).jump_slots).offset(fresh545 as isize) as *mut JumpSlot;
                (*jp).op = op;
                (*jp).size = 4 as libc::c_int;
                (*jp)
                    .pos = (bc_out.size).wrapping_add(1 as libc::c_int as libc::c_ulong)
                    as libc::c_int;
                (*jp).label = label;
                if (*ls).addr == -(1 as libc::c_int) {
                    let mut diff_0: libc::c_int = (*ls).pos2 - pos - 1 as libc::c_int;
                    if diff_0 < 128 as libc::c_int
                        && (op == OP_if_false as libc::c_int
                            || op == OP_if_true as libc::c_int
                            || op == OP_goto as libc::c_int)
                    {
                        (*jp).size = 1 as libc::c_int;
                        (*jp)
                            .op = OP_if_false8 as libc::c_int
                            + (op - OP_if_false as libc::c_int);
                        dbuf_putc(
                            &mut bc_out,
                            (OP_if_false8 as libc::c_int
                                + (op - OP_if_false as libc::c_int)) as uint8_t,
                        );
                        dbuf_putc(&mut bc_out, 0 as libc::c_int as uint8_t);
                        if (add_reloc(
                            ctx,
                            ls,
                            (bc_out.size).wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                as uint32_t,
                            1 as libc::c_int,
                        ))
                            .is_null()
                        {
                            current_block = 13937986802215865503;
                            break;
                        }
                        current_block = 317151059986244064;
                    } else if diff_0 < 32768 as libc::c_int
                        && op == OP_goto as libc::c_int
                    {
                        (*jp).size = 2 as libc::c_int;
                        (*jp).op = OP_goto16 as libc::c_int;
                        dbuf_putc(&mut bc_out, OP_goto16 as libc::c_int as uint8_t);
                        dbuf_put_u16(&mut bc_out, 0 as libc::c_int as uint16_t);
                        if (add_reloc(
                            ctx,
                            ls,
                            (bc_out.size).wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                as uint32_t,
                            2 as libc::c_int,
                        ))
                            .is_null()
                        {
                            current_block = 13937986802215865503;
                            break;
                        }
                        current_block = 317151059986244064;
                    } else {
                        current_block = 7238532450961708898;
                    }
                } else {
                    let mut diff_1: libc::c_int = ((*ls).addr as libc::c_ulong)
                        .wrapping_sub(bc_out.size)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                    if diff_1 == diff_1 as int8_t as libc::c_int
                        && (op == OP_if_false as libc::c_int
                            || op == OP_if_true as libc::c_int
                            || op == OP_goto as libc::c_int)
                    {
                        (*jp).size = 1 as libc::c_int;
                        (*jp)
                            .op = OP_if_false8 as libc::c_int
                            + (op - OP_if_false as libc::c_int);
                        dbuf_putc(
                            &mut bc_out,
                            (OP_if_false8 as libc::c_int
                                + (op - OP_if_false as libc::c_int)) as uint8_t,
                        );
                        dbuf_putc(&mut bc_out, diff_1 as uint8_t);
                        current_block = 317151059986244064;
                    } else if diff_1 == diff_1 as int16_t as libc::c_int
                        && op == OP_goto as libc::c_int
                    {
                        (*jp).size = 2 as libc::c_int;
                        (*jp).op = OP_goto16 as libc::c_int;
                        dbuf_putc(&mut bc_out, OP_goto16 as libc::c_int as uint8_t);
                        dbuf_put_u16(&mut bc_out, diff_1 as uint16_t);
                        current_block = 317151059986244064;
                    } else {
                        current_block = 7238532450961708898;
                    }
                }
                match current_block {
                    317151059986244064 => {}
                    _ => {
                        dbuf_putc(&mut bc_out, op as uint8_t);
                        dbuf_put_u32(
                            &mut bc_out,
                            ((*ls).addr as libc::c_ulong).wrapping_sub(bc_out.size)
                                as uint32_t,
                        );
                        if (*ls).addr == -(1 as libc::c_int) {
                            if (add_reloc(
                                ctx,
                                ls,
                                (bc_out.size)
                                    .wrapping_sub(4 as libc::c_int as libc::c_ulong)
                                    as uint32_t,
                                4 as libc::c_int,
                            ))
                                .is_null()
                            {
                                current_block = 13937986802215865503;
                                break;
                            }
                        }
                    }
                }
            }
            _ => {}
        }
        pos = pos_next;
    }
    match current_block {
        13937986802215865503 => {
            dbuf_free(&mut bc_out);
            return -(1 as libc::c_int);
        }
        _ => {
            i = 0 as libc::c_int;
            while i < (*s).label_count {
                assert(
                    ((*label_slots.offset(i as isize)).first_reloc
                        == 0 as *mut libc::c_void as *mut RelocEntry) as libc::c_int,
                );
                i += 1;
            }
            let mut patch_offsets: libc::c_int = 0 as libc::c_int;
            let mut current_block_398: u64;
            i = 0 as libc::c_int;
            jp = (*s).jump_slots;
            while i < (*s).jump_count {
                let mut ls_0: *mut LabelSlot = 0 as *mut LabelSlot;
                let mut jp1: *mut JumpSlot = 0 as *mut JumpSlot;
                let mut j: libc::c_int = 0;
                let mut pos_0: libc::c_int = 0;
                let mut diff_2: libc::c_int = 0;
                let mut delta: libc::c_int = 0;
                delta = 3 as libc::c_int;
                op = (*jp).op;
                match op {
                    235 => {
                        delta = 1 as libc::c_int;
                        current_block_398 = 15197086279027951466;
                    }
                    105 | 106 | 107 => {
                        current_block_398 = 15197086279027951466;
                    }
                    _ => {
                        current_block_398 = 14410773951667535844;
                    }
                }
                match current_block_398 {
                    15197086279027951466 => {
                        pos_0 = (*jp).pos;
                        diff_2 = (*((*s).label_slots).offset((*jp).label as isize)).addr
                            - pos_0;
                        if diff_2 >= -(128 as libc::c_int)
                            && diff_2 <= 127 as libc::c_int + delta
                        {
                            (*jp).size = 1 as libc::c_int;
                            if op == OP_goto16 as libc::c_int {
                                let ref mut fresh548 = (*jp).op;
                                *fresh548 = OP_goto8 as libc::c_int;
                                *(bc_out.buf)
                                    .offset(
                                        (pos_0 - 1 as libc::c_int) as isize,
                                    ) = *fresh548 as uint8_t;
                            } else {
                                let ref mut fresh549 = (*jp).op;
                                *fresh549 = OP_if_false8 as libc::c_int
                                    + (op - OP_if_false as libc::c_int);
                                *(bc_out.buf)
                                    .offset(
                                        (pos_0 - 1 as libc::c_int) as isize,
                                    ) = *fresh549 as uint8_t;
                            }
                            current_block_398 = 5333365582345311329;
                        } else if diff_2 == diff_2 as int16_t as libc::c_int
                            && op == OP_goto as libc::c_int
                        {
                            (*jp).size = 2 as libc::c_int;
                            delta = 2 as libc::c_int;
                            let ref mut fresh550 = (*jp).op;
                            *fresh550 = OP_goto16 as libc::c_int;
                            *(bc_out.buf)
                                .offset(
                                    (pos_0 - 1 as libc::c_int) as isize,
                                ) = *fresh550 as uint8_t;
                            current_block_398 = 5333365582345311329;
                        } else {
                            current_block_398 = 14410773951667535844;
                        }
                        match current_block_398 {
                            14410773951667535844 => {}
                            _ => {
                                memmove(
                                    (bc_out.buf)
                                        .offset(pos_0 as isize)
                                        .offset((*jp).size as isize) as *mut libc::c_void,
                                    (bc_out.buf)
                                        .offset(pos_0 as isize)
                                        .offset((*jp).size as isize)
                                        .offset(delta as isize) as *const libc::c_void,
                                    (bc_out.size)
                                        .wrapping_sub(pos_0 as libc::c_ulong)
                                        .wrapping_sub((*jp).size as libc::c_ulong)
                                        .wrapping_sub(delta as libc::c_ulong),
                                );
                                bc_out
                                    .size = (bc_out.size as libc::c_ulong)
                                    .wrapping_sub(delta as libc::c_ulong) as size_t as size_t;
                                patch_offsets += 1;
                                j = 0 as libc::c_int;
                                ls_0 = (*s).label_slots;
                                while j < (*s).label_count {
                                    if (*ls_0).addr > pos_0 {
                                        (*ls_0).addr -= delta;
                                    }
                                    j += 1;
                                    ls_0 = ls_0.offset(1);
                                }
                                j = i + 1 as libc::c_int;
                                jp1 = jp.offset(1 as libc::c_int as isize);
                                while j < (*s).jump_count {
                                    if (*jp1).pos > pos_0 {
                                        (*jp1).pos -= delta;
                                    }
                                    j += 1;
                                    jp1 = jp1.offset(1);
                                }
                                j = 0 as libc::c_int;
                                while j < (*s).line_number_count {
                                    if (*((*s).line_number_slots).offset(j as isize)).pc
                                        > pos_0 as libc::c_uint
                                    {
                                        let ref mut fresh551 = (*((*s).line_number_slots)
                                            .offset(j as isize))
                                            .pc;
                                        *fresh551 = (*fresh551 as libc::c_uint)
                                            .wrapping_sub(delta as libc::c_uint) as uint32_t
                                            as uint32_t;
                                    }
                                    j += 1;
                                }
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
                jp = jp.offset(1);
            }
            if patch_offsets != 0 {
                let mut jp1_0: *mut JumpSlot = 0 as *mut JumpSlot;
                let mut j_0: libc::c_int = 0;
                j_0 = 0 as libc::c_int;
                jp1_0 = (*s).jump_slots;
                while j_0 < (*s).jump_count {
                    let mut diff1: libc::c_int = (*((*s).label_slots)
                        .offset((*jp1_0).label as isize))
                        .addr - (*jp1_0).pos;
                    match (*jp1_0).size {
                        1 => {
                            put_u8(
                                (bc_out.buf).offset((*jp1_0).pos as isize),
                                diff1 as uint8_t,
                            );
                        }
                        2 => {
                            put_u16(
                                (bc_out.buf).offset((*jp1_0).pos as isize),
                                diff1 as uint16_t,
                            );
                        }
                        4 => {
                            put_u32(
                                (bc_out.buf).offset((*jp1_0).pos as isize),
                                diff1 as uint32_t,
                            );
                        }
                        _ => {}
                    }
                    j_0 += 1;
                    jp1_0 = jp1_0.offset(1);
                }
            }
            js_free(ctx, (*s).jump_slots as *mut libc::c_void);
            let ref mut fresh552 = (*s).jump_slots;
            *fresh552 = 0 as *mut JumpSlot;
            js_free(ctx, (*s).label_slots as *mut libc::c_void);
            let ref mut fresh553 = (*s).label_slots;
            *fresh553 = 0 as *mut LabelSlot;
            compute_pc2line_info(s);
            js_free(ctx, (*s).line_number_slots as *mut libc::c_void);
            let ref mut fresh554 = (*s).line_number_slots;
            *fresh554 = 0 as *mut LineNumberSlot;
            dbuf_free(&mut (*s).byte_code);
            (*s).byte_code = bc_out;
            (*s).use_short_opcodes = TRUE as libc::c_int;
            if dbuf_error(&mut (*s).byte_code) != 0 {
                JS_ThrowOutOfMemory(ctx);
                return -(1 as libc::c_int);
            }
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn ss_check(
    mut ctx: *mut JSContext,
    mut s: *mut StackSizeState,
    mut pos: libc::c_int,
    mut op: libc::c_int,
    mut stack_len: libc::c_int,
) -> libc::c_int {
    if pos as libc::c_uint >= (*s).bc_len as libc::c_uint {
        JS_ThrowInternalError(
            ctx,
            b"bytecode buffer overflow (op=%d, pc=%d)\0" as *const u8
                as *const libc::c_char,
            op,
            pos,
        );
        return -(1 as libc::c_int);
    }
    if stack_len > (*s).stack_len_max {
        (*s).stack_len_max = stack_len;
        if (*s).stack_len_max > 65534 as libc::c_int {
            JS_ThrowInternalError(
                ctx,
                b"stack overflow (op=%d, pc=%d)\0" as *const u8 as *const libc::c_char,
                op,
                pos,
            );
            return -(1 as libc::c_int);
        }
    }
    if *((*s).stack_level_tab).offset(pos as isize) as libc::c_int
        != 0xffff as libc::c_int
    {
        if *((*s).stack_level_tab).offset(pos as isize) as libc::c_int != stack_len {
            JS_ThrowInternalError(
                ctx,
                b"unconsistent stack size: %d %d (pc=%d)\0" as *const u8
                    as *const libc::c_char,
                *((*s).stack_level_tab).offset(pos as isize) as libc::c_int,
                stack_len,
                pos,
            );
            return -(1 as libc::c_int);
        } else {
            return 0 as libc::c_int
        }
    }
    *((*s).stack_level_tab).offset(pos as isize) = stack_len as uint16_t;
    if js_resize_array(
        ctx,
        &mut (*s).pc_stack as *mut *mut libc::c_int as *mut *mut libc::c_void,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
        &mut (*s).pc_stack_size,
        (*s).pc_stack_len + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh555 = (*s).pc_stack_len;
    let fresh556 = *fresh555;
    *fresh555 = *fresh555 + 1;
    *((*s).pc_stack).offset(fresh556 as isize) = pos;
    return 0 as libc::c_int;
}
unsafe extern "C" fn compute_stack_size(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
    mut pstack_size: *mut libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s_s: StackSizeState = StackSizeState {
        bc_len: 0,
        stack_len_max: 0,
        stack_level_tab: 0 as *mut uint16_t,
        pc_stack: 0 as *mut libc::c_int,
        pc_stack_len: 0,
        pc_stack_size: 0,
    };
    let mut s: *mut StackSizeState = &mut s_s;
    let mut i: libc::c_int = 0;
    let mut diff: libc::c_int = 0;
    let mut n_pop: libc::c_int = 0;
    let mut pos_next: libc::c_int = 0;
    let mut stack_len: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut oi: *const JSOpCode = 0 as *const JSOpCode;
    let mut bc_buf: *const uint8_t = 0 as *const uint8_t;
    bc_buf = (*fd).byte_code.buf;
    (*s).bc_len = (*fd).byte_code.size as libc::c_int;
    let ref mut fresh557 = (*s).stack_level_tab;
    *fresh557 = js_malloc(
        ctx,
        (::core::mem::size_of::<uint16_t>() as libc::c_ulong)
            .wrapping_mul((*s).bc_len as libc::c_ulong),
    ) as *mut uint16_t;
    if ((*s).stack_level_tab).is_null() {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int;
    while i < (*s).bc_len {
        *((*s).stack_level_tab).offset(i as isize) = 0xffff as libc::c_int as uint16_t;
        i += 1;
    }
    (*s).stack_len_max = 0 as libc::c_int;
    let ref mut fresh558 = (*s).pc_stack;
    *fresh558 = 0 as *mut libc::c_int;
    (*s).pc_stack_len = 0 as libc::c_int;
    (*s).pc_stack_size = 0 as libc::c_int;
    if ss_check(ctx, s, 0 as libc::c_int, OP_invalid as libc::c_int, 0 as libc::c_int)
        != 0
    {
        current_block = 6313189554087213484;
    } else {
        current_block = 3512920355445576850;
    }
    loop {
        match current_block {
            6313189554087213484 => {
                js_free(ctx, (*s).stack_level_tab as *mut libc::c_void);
                js_free(ctx, (*s).pc_stack as *mut libc::c_void);
                *pstack_size = 0 as libc::c_int;
                return -(1 as libc::c_int);
            }
            _ => {
                if (*s).pc_stack_len > 0 as libc::c_int {
                    let ref mut fresh559 = (*s).pc_stack_len;
                    *fresh559 -= 1;
                    pos = *((*s).pc_stack).offset(*fresh559 as isize);
                    stack_len = *((*s).stack_level_tab).offset(pos as isize)
                        as libc::c_int;
                    op = *bc_buf.offset(pos as isize) as libc::c_int;
                    if op == 0 as libc::c_int || op >= OP_COUNT as libc::c_int {
                        JS_ThrowInternalError(
                            ctx,
                            b"invalid opcode (op=%d, pc=%d)\0" as *const u8
                                as *const libc::c_char,
                            op,
                            pos,
                        );
                        current_block = 6313189554087213484;
                    } else {
                        oi = &*opcode_info
                            .as_ptr()
                            .offset(
                                (if op >= OP_TEMP_START as libc::c_int {
                                    op
                                        + (OP_TEMP_END as libc::c_int
                                            - OP_TEMP_START as libc::c_int)
                                } else {
                                    op
                                }) as isize,
                            ) as *const JSOpCode;
                        pos_next = pos + (*oi).size as libc::c_int;
                        if pos_next > (*s).bc_len {
                            JS_ThrowInternalError(
                                ctx,
                                b"bytecode buffer overflow (op=%d, pc=%d)\0" as *const u8
                                    as *const libc::c_char,
                                op,
                                pos,
                            );
                            current_block = 6313189554087213484;
                        } else {
                            n_pop = (*oi).n_pop as libc::c_int;
                            if (*oi).fmt as libc::c_int == OP_FMT_npop as libc::c_int
                                || (*oi).fmt as libc::c_int
                                    == OP_FMT_npop_u16 as libc::c_int
                            {
                                n_pop = (n_pop as libc::c_uint)
                                    .wrapping_add(
                                        get_u16(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(1 as libc::c_int as isize),
                                        ),
                                    ) as libc::c_int as libc::c_int;
                            } else if (*oi).fmt as libc::c_int
                                == OP_FMT_npopx as libc::c_int
                            {
                                n_pop += op - OP_call0 as libc::c_int;
                            }
                            if stack_len < n_pop {
                                JS_ThrowInternalError(
                                    ctx,
                                    b"stack underflow (op=%d, pc=%d)\0" as *const u8
                                        as *const libc::c_char,
                                    op,
                                    pos,
                                );
                                current_block = 6313189554087213484;
                            } else {
                                stack_len += (*oi).n_push as libc::c_int - n_pop;
                                if stack_len > (*s).stack_len_max {
                                    (*s).stack_len_max = stack_len;
                                    if (*s).stack_len_max > 65534 as libc::c_int {
                                        JS_ThrowInternalError(
                                            ctx,
                                            b"stack overflow (op=%d, pc=%d)\0" as *const u8
                                                as *const libc::c_char,
                                            op,
                                            pos,
                                        );
                                        current_block = 6313189554087213484;
                                        continue;
                                    }
                                }
                                match op {
                                    35 | 37 | 40 | 41 | 46 | 47 | 48 | 110 => {
                                        current_block = 3512920355445576850;
                                        continue;
                                    }
                                    107 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(1 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        pos_next = pos + 1 as libc::c_int + diff;
                                    }
                                    235 => {
                                        diff = get_u16(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(1 as libc::c_int as isize),
                                        ) as int16_t as libc::c_int;
                                        pos_next = pos + 1 as libc::c_int + diff;
                                    }
                                    234 => {
                                        diff = *bc_buf.offset((pos + 1 as libc::c_int) as isize)
                                            as int8_t as libc::c_int;
                                        pos_next = pos + 1 as libc::c_int + diff;
                                    }
                                    233 | 232 => {
                                        diff = *bc_buf.offset((pos + 1 as libc::c_int) as isize)
                                            as int8_t as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 1 as libc::c_int + diff,
                                            op,
                                            stack_len,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    106 | 105 | 108 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(1 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 1 as libc::c_int + diff,
                                            op,
                                            stack_len,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    109 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(1 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 1 as libc::c_int + diff,
                                            op,
                                            stack_len + 1 as libc::c_int,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    114 | 116 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(5 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 5 as libc::c_int + diff,
                                            op,
                                            stack_len + 1 as libc::c_int,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    117 | 118 | 119 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(5 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 5 as libc::c_int + diff,
                                            op,
                                            stack_len + 2 as libc::c_int,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    115 => {
                                        diff = get_u32(
                                            bc_buf
                                                .offset(pos as isize)
                                                .offset(5 as libc::c_int as isize),
                                        ) as libc::c_int;
                                        if ss_check(
                                            ctx,
                                            s,
                                            pos + 5 as libc::c_int + diff,
                                            op,
                                            stack_len - 1 as libc::c_int,
                                        ) != 0
                                        {
                                            current_block = 6313189554087213484;
                                            continue;
                                        }
                                    }
                                    _ => {}
                                }
                                if ss_check(ctx, s, pos_next, op, stack_len) != 0 {
                                    current_block = 6313189554087213484;
                                } else {
                                    current_block = 3512920355445576850;
                                }
                            }
                        }
                    }
                } else {
                    js_free(ctx, (*s).stack_level_tab as *mut libc::c_void);
                    js_free(ctx, (*s).pc_stack as *mut libc::c_void);
                    *pstack_size = (*s).stack_len_max;
                    return 0 as libc::c_int;
                }
            }
        }
    };
}
unsafe extern "C" fn add_module_variables(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut m: *mut JSModuleDef = (*fd).module;
    let mut me: *mut JSExportEntry = 0 as *mut JSExportEntry;
    let mut hf: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
    i = 0 as libc::c_int;
    while i < (*fd).global_var_count {
        hf = &mut *((*fd).global_vars).offset(i as isize) as *mut JSGlobalVar;
        if add_closure_var(
            ctx,
            fd,
            TRUE as libc::c_int,
            FALSE as libc::c_int,
            i,
            (*hf).var_name,
            (*hf).is_const() as BOOL,
            (*hf).is_lexical() as BOOL,
            FALSE as libc::c_int as JSVarKindEnum,
        ) < 0 as libc::c_int
        {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        me = &mut *((*m).export_entries).offset(i as isize) as *mut JSExportEntry;
        if (*me).export_type as libc::c_uint
            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
        {
            idx = find_closure_var(ctx, fd, (*me).local_name);
            if idx < 0 as libc::c_int {
                __JS_ThrowSyntaxErrorAtom(
                    ctx,
                    (*me).local_name,
                    b"exported variable '%s' does not exist\0" as *const u8
                        as *const libc::c_char,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            (*me).u.local.var_idx = idx;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_create_function(
    mut ctx: *mut JSContext,
    mut fd: *mut JSFunctionDef,
) -> JSValue {
    let mut current_block: u64;
    let mut func_obj: JSValue = 0;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut stack_size: libc::c_int = 0;
    let mut scope: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut function_size: libc::c_int = 0;
    let mut byte_code_offset: libc::c_int = 0;
    let mut cpool_offset: libc::c_int = 0;
    let mut closure_var_offset: libc::c_int = 0;
    let mut vardefs_offset: libc::c_int = 0;
    scope = 0 as libc::c_int;
    while scope < (*fd).scope_count {
        (*((*fd).scopes).offset(scope as isize)).first = -(1 as libc::c_int);
        scope += 1;
    }
    if (*fd).has_parameter_expressions != 0 {
        (*((*fd).scopes).offset(1 as libc::c_int as isize)).first = -(2 as libc::c_int);
    }
    idx = 0 as libc::c_int;
    while idx < (*fd).var_count {
        let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(idx as isize)
            as *mut JSVarDef;
        (*vd).scope_next = (*((*fd).scopes).offset((*vd).scope_level as isize)).first;
        (*((*fd).scopes).offset((*vd).scope_level as isize)).first = idx;
        idx += 1;
    }
    scope = 2 as libc::c_int;
    while scope < (*fd).scope_count {
        let mut sd: *mut JSVarScope = &mut *((*fd).scopes).offset(scope as isize)
            as *mut JSVarScope;
        if (*sd).first < 0 as libc::c_int {
            (*sd).first = (*((*fd).scopes).offset((*sd).parent as isize)).first;
        }
        scope += 1;
    }
    idx = 0 as libc::c_int;
    while idx < (*fd).var_count {
        let mut vd_0: *mut JSVarDef = &mut *((*fd).vars).offset(idx as isize)
            as *mut JSVarDef;
        if (*vd_0).scope_next < 0 as libc::c_int
            && (*vd_0).scope_level > 1 as libc::c_int
        {
            scope = (*((*fd).scopes).offset((*vd_0).scope_level as isize)).parent;
            (*vd_0).scope_next = (*((*fd).scopes).offset(scope as isize)).first;
        }
        idx += 1;
    }
    if (*fd).has_eval_call != 0 {
        add_eval_variables(ctx, fd);
    }
    if !((*fd).module).is_null() {
        if add_module_variables(ctx, fd) != 0 {
            current_block = 14075697604350670413;
        } else {
            current_block = 14136749492126903395;
        }
    } else {
        current_block = 14136749492126903395;
    }
    match current_block {
        14136749492126903395 => {
            el = (*fd).child_list.next;
            el1 = (*el).next;
            loop {
                if !(el != &mut (*fd).child_list as *mut list_head) {
                    current_block = 3222590281903869779;
                    break;
                }
                let mut fd1: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
                let mut cpool_idx: libc::c_int = 0;
                fd1 = (el as *mut uint8_t).offset(-(24 as libc::c_ulong as isize))
                    as *mut JSFunctionDef;
                cpool_idx = (*fd1).parent_cpool_idx;
                func_obj = js_create_function(ctx, fd1);
                if JS_IsException(func_obj) != 0 {
                    current_block = 14075697604350670413;
                    break;
                }
                assert((cpool_idx >= 0 as libc::c_int) as libc::c_int);
                *((*fd).cpool).offset(cpool_idx as isize) = func_obj;
                el = el1;
                el1 = (*el).next;
            }
            match current_block {
                14075697604350670413 => {}
                _ => {
                    if !(resolve_variables(ctx, fd) != 0) {
                        if !(resolve_labels(ctx, fd) != 0) {
                            if !(compute_stack_size(ctx, fd, &mut stack_size)
                                < 0 as libc::c_int)
                            {
                                if (*fd).js_mode as libc::c_int
                                    & (1 as libc::c_int) << 1 as libc::c_int != 0
                                {
                                    function_size = 64 as libc::c_ulong as libc::c_int;
                                } else {
                                    function_size = ::core::mem::size_of::<JSFunctionBytecode>()
                                        as libc::c_ulong as libc::c_int;
                                }
                                cpool_offset = function_size;
                                function_size = (function_size as libc::c_ulong)
                                    .wrapping_add(
                                        ((*fd).cpool_count as libc::c_ulong)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                            ),
                                    ) as libc::c_int as libc::c_int;
                                vardefs_offset = function_size;
                                if (*fd).js_mode as libc::c_int
                                    & (1 as libc::c_int) << 1 as libc::c_int == 0
                                    || (*fd).has_eval_call != 0
                                {
                                    function_size = (function_size as libc::c_ulong)
                                        .wrapping_add(
                                            (((*fd).arg_count + (*fd).var_count) as libc::c_ulong)
                                                .wrapping_mul(
                                                    ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
                                                ),
                                        ) as libc::c_int as libc::c_int;
                                }
                                closure_var_offset = function_size;
                                function_size = (function_size as libc::c_ulong)
                                    .wrapping_add(
                                        ((*fd).closure_var_count as libc::c_ulong)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<JSClosureVar>() as libc::c_ulong,
                                            ),
                                    ) as libc::c_int as libc::c_int;
                                byte_code_offset = function_size;
                                function_size = (function_size as libc::c_ulong)
                                    .wrapping_add((*fd).byte_code.size) as libc::c_int
                                    as libc::c_int;
                                b = js_mallocz(ctx, function_size as size_t)
                                    as *mut JSFunctionBytecode;
                                if !b.is_null() {
                                    (*b).header.ref_count = 1 as libc::c_int;
                                    let ref mut fresh560 = (*b).byte_code_buf;
                                    *fresh560 = (b as *mut uint8_t)
                                        .offset(byte_code_offset as isize) as *mut libc::c_void
                                        as *mut uint8_t;
                                    (*b).byte_code_len = (*fd).byte_code.size as libc::c_int;
                                    memcpy(
                                        (*b).byte_code_buf as *mut libc::c_void,
                                        (*fd).byte_code.buf as *const libc::c_void,
                                        (*fd).byte_code.size,
                                    );
                                    js_free(ctx, (*fd).byte_code.buf as *mut libc::c_void);
                                    let ref mut fresh561 = (*fd).byte_code.buf;
                                    *fresh561 = 0 as *mut uint8_t;
                                    (*b).func_name = (*fd).func_name;
                                    if (*fd).arg_count + (*fd).var_count > 0 as libc::c_int {
                                        if (*fd).js_mode as libc::c_int
                                            & (1 as libc::c_int) << 1 as libc::c_int != 0
                                            && (*fd).has_eval_call == 0
                                        {
                                            let mut i: libc::c_int = 0;
                                            i = 0 as libc::c_int;
                                            while i < (*fd).var_count {
                                                JS_FreeAtom(
                                                    ctx,
                                                    (*((*fd).vars).offset(i as isize)).var_name,
                                                );
                                                i += 1;
                                            }
                                            i = 0 as libc::c_int;
                                            while i < (*fd).arg_count {
                                                JS_FreeAtom(
                                                    ctx,
                                                    (*((*fd).args).offset(i as isize)).var_name,
                                                );
                                                i += 1;
                                            }
                                            i = 0 as libc::c_int;
                                            while i < (*fd).closure_var_count {
                                                JS_FreeAtom(
                                                    ctx,
                                                    (*((*fd).closure_var).offset(i as isize)).var_name,
                                                );
                                                (*((*fd).closure_var).offset(i as isize))
                                                    .var_name = 0 as libc::c_int as JSAtom;
                                                i += 1;
                                            }
                                        } else {
                                            let ref mut fresh562 = (*b).vardefs;
                                            *fresh562 = (b as *mut uint8_t)
                                                .offset(vardefs_offset as isize) as *mut libc::c_void
                                                as *mut JSVarDef;
                                            memcpy(
                                                (*b).vardefs as *mut libc::c_void,
                                                (*fd).args as *const libc::c_void,
                                                ((*fd).arg_count as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
                                                    ),
                                            );
                                            memcpy(
                                                ((*b).vardefs).offset((*fd).arg_count as isize)
                                                    as *mut libc::c_void,
                                                (*fd).vars as *const libc::c_void,
                                                ((*fd).var_count as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
                                                    ),
                                            );
                                        }
                                        (*b).var_count = (*fd).var_count as uint16_t;
                                        (*b).arg_count = (*fd).arg_count as uint16_t;
                                        (*b)
                                            .defined_arg_count = (*fd).defined_arg_count as uint16_t;
                                        js_free(ctx, (*fd).args as *mut libc::c_void);
                                        js_free(ctx, (*fd).vars as *mut libc::c_void);
                                    }
                                    (*b).cpool_count = (*fd).cpool_count;
                                    if (*b).cpool_count != 0 {
                                        let ref mut fresh563 = (*b).cpool;
                                        *fresh563 = (b as *mut uint8_t)
                                            .offset(cpool_offset as isize) as *mut libc::c_void
                                            as *mut JSValue;
                                        memcpy(
                                            (*b).cpool as *mut libc::c_void,
                                            (*fd).cpool as *const libc::c_void,
                                            ((*b).cpool_count as libc::c_ulong)
                                                .wrapping_mul(
                                                    ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                                ),
                                        );
                                    }
                                    js_free(ctx, (*fd).cpool as *mut libc::c_void);
                                    let ref mut fresh564 = (*fd).cpool;
                                    *fresh564 = 0 as *mut JSValue;
                                    (*b).stack_size = stack_size as uint16_t;
                                    if (*fd).js_mode as libc::c_int
                                        & (1 as libc::c_int) << 1 as libc::c_int != 0
                                    {
                                        JS_FreeAtom(ctx, (*fd).filename);
                                        dbuf_free(&mut (*fd).pc2line);
                                    } else {
                                        (*b).set_has_debug(1 as libc::c_int as uint8_t);
                                        (*b).debug.filename = (*fd).filename;
                                        (*b).debug.line_num = (*fd).line_num;
                                        let ref mut fresh565 = (*b).debug.pc2line_buf;
                                        *fresh565 = js_realloc(
                                            ctx,
                                            (*fd).pc2line.buf as *mut libc::c_void,
                                            (*fd).pc2line.size,
                                        ) as *mut uint8_t;
                                        if ((*b).debug.pc2line_buf).is_null() {
                                            let ref mut fresh566 = (*b).debug.pc2line_buf;
                                            *fresh566 = (*fd).pc2line.buf;
                                        }
                                        (*b).debug.pc2line_len = (*fd).pc2line.size as libc::c_int;
                                        let ref mut fresh567 = (*b).debug.source;
                                        *fresh567 = (*fd).source;
                                        (*b).debug.source_len = (*fd).source_len;
                                    }
                                    if (*fd).scopes != ((*fd).def_scope_array).as_mut_ptr() {
                                        js_free(ctx, (*fd).scopes as *mut libc::c_void);
                                    }
                                    (*b).closure_var_count = (*fd).closure_var_count;
                                    if (*b).closure_var_count != 0 {
                                        let ref mut fresh568 = (*b).closure_var;
                                        *fresh568 = (b as *mut uint8_t)
                                            .offset(closure_var_offset as isize) as *mut libc::c_void
                                            as *mut JSClosureVar;
                                        memcpy(
                                            (*b).closure_var as *mut libc::c_void,
                                            (*fd).closure_var as *const libc::c_void,
                                            ((*b).closure_var_count as libc::c_ulong)
                                                .wrapping_mul(
                                                    ::core::mem::size_of::<JSClosureVar>() as libc::c_ulong,
                                                ),
                                        );
                                    }
                                    js_free(ctx, (*fd).closure_var as *mut libc::c_void);
                                    let ref mut fresh569 = (*fd).closure_var;
                                    *fresh569 = 0 as *mut JSClosureVar;
                                    (*b).set_has_prototype((*fd).has_prototype as uint8_t);
                                    (*b)
                                        .set_has_simple_parameter_list(
                                            (*fd).has_simple_parameter_list as uint8_t,
                                        );
                                    (*b).js_mode = (*fd).js_mode;
                                    (*b)
                                        .set_is_derived_class_constructor(
                                            (*fd).is_derived_class_constructor as uint8_t,
                                        );
                                    (*b).set_func_kind((*fd).func_kind() as uint8_t);
                                    (*b)
                                        .set_need_home_object(
                                            ((*fd).home_object_var_idx >= 0 as libc::c_int
                                                || (*fd).need_home_object != 0) as libc::c_int as uint8_t,
                                        );
                                    (*b)
                                        .set_new_target_allowed(
                                            (*fd).new_target_allowed as uint8_t,
                                        );
                                    (*b)
                                        .set_super_call_allowed(
                                            (*fd).super_call_allowed as uint8_t,
                                        );
                                    (*b).set_super_allowed((*fd).super_allowed as uint8_t);
                                    (*b)
                                        .set_arguments_allowed((*fd).arguments_allowed as uint8_t);
                                    (*b)
                                        .set_backtrace_barrier((*fd).backtrace_barrier as uint8_t);
                                    let ref mut fresh570 = (*b).realm;
                                    *fresh570 = JS_DupContext(ctx);
                                    add_gc_object(
                                        (*ctx).rt,
                                        &mut (*b).header,
                                        JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,
                                    );
                                    if !((*fd).parent).is_null() {
                                        list_del(&mut (*fd).link);
                                    }
                                    js_free(ctx, fd as *mut libc::c_void);
                                    return (JS_TAG_FUNCTION_BYTECODE as libc::c_int as uint64_t)
                                        << 32 as libc::c_int | b as uintptr_t as libc::c_ulonglong;
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    js_free_function_def(ctx, fd);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn free_function_bytecode(
    mut rt: *mut JSRuntime,
    mut b: *mut JSFunctionBytecode,
) {
    let mut i: libc::c_int = 0;
    free_bytecode_atoms(rt, (*b).byte_code_buf, (*b).byte_code_len, TRUE as libc::c_int);
    if !((*b).vardefs).is_null() {
        i = 0 as libc::c_int;
        while i < (*b).arg_count as libc::c_int + (*b).var_count as libc::c_int {
            JS_FreeAtomRT(rt, (*((*b).vardefs).offset(i as isize)).var_name);
            i += 1;
        }
    }
    i = 0 as libc::c_int;
    while i < (*b).cpool_count {
        JS_FreeValueRT(rt, *((*b).cpool).offset(i as isize));
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < (*b).closure_var_count {
        let mut cv: *mut JSClosureVar = &mut *((*b).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        JS_FreeAtomRT(rt, (*cv).var_name);
        i += 1;
    }
    if !((*b).realm).is_null() {
        JS_FreeContext((*b).realm);
    }
    JS_FreeAtomRT(rt, (*b).func_name);
    if (*b).has_debug() != 0 {
        JS_FreeAtomRT(rt, (*b).debug.filename);
        js_free_rt(rt, (*b).debug.pc2line_buf as *mut libc::c_void);
        js_free_rt(rt, (*b).debug.source as *mut libc::c_void);
    }
    remove_gc_object(&mut (*b).header);
    if (*rt).gc_phase() as libc::c_int == JS_GC_PHASE_REMOVE_CYCLES as libc::c_int
        && (*b).header.ref_count != 0 as libc::c_int
    {
        list_add_tail(&mut (*b).header.link, &mut (*rt).gc_zero_ref_count_list);
    } else {
        js_free_rt(rt, b as *mut libc::c_void);
    };
}
unsafe extern "C" fn js_parse_directives(mut s: *mut JSParseState) -> libc::c_int {
    let mut str: [libc::c_char; 20] = [0; 20];
    let mut pos: JSParsePos = JSParsePos {
        last_line_num: 0,
        line_num: 0,
        got_lf: 0,
        ptr: 0 as *const uint8_t,
    };
    let mut has_semi: BOOL = 0;
    if (*s).token.val != TOK_STRING as libc::c_int {
        return 0 as libc::c_int;
    }
    js_parse_get_pos(s, &mut pos);
    while (*s).token.val == TOK_STRING as libc::c_int {
        snprintf(
            str.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            b"%.*s\0" as *const u8 as *const libc::c_char,
            (((*s).buf_ptr).offset_from((*s).token.ptr) as libc::c_long
                - 2 as libc::c_int as libc::c_long) as libc::c_int,
            ((*s).token.ptr).offset(1 as libc::c_int as isize),
        );
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        has_semi = FALSE as libc::c_int;
        match (*s).token.val {
            59 => {
                if next_token(s) != 0 {
                    return -(1 as libc::c_int);
                }
                has_semi = TRUE as libc::c_int;
            }
            125 | -86 => {
                has_semi = TRUE as libc::c_int;
            }
            -128 | -127 | -126 | -125 | -124 | -108 | -107 | -85 | -84 | -83 | -82 | -80
            | -79 | -78 | -77 | -75 | -74 | -71 | -70 | -69 | -66 | -63 | -62 | -59 | -58
            | -57 | -56 | -55 | -54 | -53 | -51 | -50 | -48 | -47 | -46 | -45 | -44 | -43
            | -42 => {
                if (*s).got_lf != 0 {
                    has_semi = TRUE as libc::c_int;
                }
            }
            _ => {}
        }
        if has_semi == 0 {
            break;
        }
        if strcmp(str.as_mut_ptr(), b"use strict\0" as *const u8 as *const libc::c_char)
            == 0
        {
            (*(*s).cur_func).has_use_strict = TRUE as libc::c_int;
            let ref mut fresh571 = (*(*s).cur_func).js_mode;
            *fresh571 = (*fresh571 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t;
        } else if strcmp(
            str.as_mut_ptr(),
            b"use strip\0" as *const u8 as *const libc::c_char,
        ) == 0
        {
            let ref mut fresh572 = (*(*s).cur_func).js_mode;
            *fresh572 = (*fresh572 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int) as uint8_t;
        }
    }
    return js_parse_seek_token(s, &mut pos);
}
unsafe extern "C" fn js_parse_function_check_names(
    mut s: *mut JSParseState,
    mut fd: *mut JSFunctionDef,
    mut func_name: JSAtom,
) -> libc::c_int {
    let mut current_block: u64;
    let mut name: JSAtom = 0;
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    if (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        if (*fd).has_simple_parameter_list == 0 && (*fd).has_use_strict != 0 {
            return js_parse_error(
                s,
                b"\"use strict\" not allowed in function with default or destructuring parameter\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        if func_name == JS_ATOM_eval as libc::c_int as libc::c_uint
            || func_name == JS_ATOM_arguments as libc::c_int as libc::c_uint
        {
            return js_parse_error(
                s,
                b"invalid function name in strict code\0" as *const u8
                    as *const libc::c_char,
            );
        }
        idx = 0 as libc::c_int;
        while idx < (*fd).arg_count {
            name = (*((*fd).args).offset(idx as isize)).var_name;
            if name == JS_ATOM_eval as libc::c_int as libc::c_uint
                || name == JS_ATOM_arguments as libc::c_int as libc::c_uint
            {
                return js_parse_error(
                    s,
                    b"invalid argument name in strict code\0" as *const u8
                        as *const libc::c_char,
                );
            }
            idx += 1;
        }
    }
    if (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
        || (*fd).has_simple_parameter_list == 0
        || (*fd).func_type() as libc::c_int == JS_PARSE_FUNC_METHOD as libc::c_int
            && (*fd).func_kind() as libc::c_int == JS_FUNC_ASYNC as libc::c_int
        || (*fd).func_type() as libc::c_int == JS_PARSE_FUNC_ARROW as libc::c_int
        || (*fd).func_type() as libc::c_int == JS_PARSE_FUNC_METHOD as libc::c_int
    {
        idx = 0 as libc::c_int;
        's_79: loop {
            if !(idx < (*fd).arg_count) {
                current_block = 16924917904204750491;
                break;
            }
            name = (*((*fd).args).offset(idx as isize)).var_name;
            if name != 0 as libc::c_int as libc::c_uint {
                i = 0 as libc::c_int;
                while i < idx {
                    if (*((*fd).args).offset(i as isize)).var_name == name {
                        current_block = 7068565124448988329;
                        break 's_79;
                    }
                    i += 1;
                }
                i = 0 as libc::c_int;
                while i < (*fd).var_count {
                    if (*((*fd).vars).offset(i as isize)).var_name == name
                        && (*((*fd).vars).offset(i as isize)).scope_level
                            == 0 as libc::c_int
                    {
                        current_block = 7068565124448988329;
                        break 's_79;
                    }
                    i += 1;
                }
            }
            idx += 1;
        }
        match current_block {
            16924917904204750491 => {}
            _ => {
                return js_parse_error(
                    s,
                    b"duplicate argument names not allowed in this context\0"
                        as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_function_class_fields_init(
    mut s: *mut JSParseState,
) -> *mut JSFunctionDef {
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    fd = js_new_function_def(
        (*s).ctx,
        (*s).cur_func,
        FALSE as libc::c_int,
        FALSE as libc::c_int,
        (*s).filename,
        0 as libc::c_int,
    );
    if fd.is_null() {
        return 0 as *mut JSFunctionDef;
    }
    (*fd).func_name = 0 as libc::c_int as JSAtom;
    (*fd).has_prototype = FALSE as libc::c_int;
    (*fd).has_home_object = TRUE as libc::c_int;
    (*fd).has_arguments_binding = FALSE as libc::c_int;
    (*fd).has_this_binding = TRUE as libc::c_int;
    (*fd).is_derived_class_constructor = FALSE as libc::c_int;
    (*fd).new_target_allowed = TRUE as libc::c_int;
    (*fd).super_call_allowed = FALSE as libc::c_int;
    (*fd).super_allowed = (*fd).has_home_object;
    (*fd).arguments_allowed = FALSE as libc::c_int;
    (*fd).set_func_kind(JS_FUNC_NORMAL);
    (*fd).set_func_type(JS_PARSE_FUNC_METHOD);
    return fd;
}
unsafe extern "C" fn js_parse_function_decl2(
    mut s: *mut JSParseState,
    mut func_type: JSParseFunctionEnum,
    mut func_kind: JSFunctionKindEnum,
    mut func_name: JSAtom,
    mut ptr: *const uint8_t,
    mut function_line_num: libc::c_int,
    mut export_flag: JSParseExportEnum,
    mut pfd: *mut *mut JSFunctionDef,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut is_expr: BOOL = 0;
    let mut func_idx: libc::c_int = 0;
    let mut lexical_func_idx: libc::c_int = -(1 as libc::c_int);
    let mut has_opt_arg: BOOL = 0;
    let mut create_func_var: BOOL = FALSE as libc::c_int;
    is_expr = (func_type as libc::c_uint
        != JS_PARSE_FUNC_STATEMENT as libc::c_int as libc::c_uint
        && func_type as libc::c_uint != JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint)
        as libc::c_int;
    if func_type as libc::c_uint
        == JS_PARSE_FUNC_STATEMENT as libc::c_int as libc::c_uint
        || func_type as libc::c_uint == JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint
        || func_type as libc::c_uint == JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint
    {
        if func_kind as libc::c_uint == JS_FUNC_NORMAL as libc::c_int as libc::c_uint
            && token_is_pseudo_keyword(s, JS_ATOM_async as libc::c_int as JSAtom) != 0
            && peek_token(s, TRUE as libc::c_int) != '\n' as i32
        {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            func_kind = JS_FUNC_ASYNC;
        }
        if next_token(s) != 0 {
            return -(1 as libc::c_int);
        }
        if (*s).token.val == '*' as i32 {
            if next_token(s) != 0 {
                return -(1 as libc::c_int);
            }
            func_kind = ::core::mem::transmute::<
                libc::c_uint,
                JSFunctionKindEnum,
            >(
                func_kind as libc::c_uint
                    | JS_FUNC_GENERATOR as libc::c_int as libc::c_uint,
            );
        }
        if (*s).token.val == TOK_IDENT as libc::c_int {
            if (*s).token.u.ident.is_reserved != 0
                || (*s).token.u.ident.atom
                    == JS_ATOM_yield as libc::c_int as libc::c_uint
                    && func_type as libc::c_uint
                        == JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint
                    && func_kind as libc::c_uint
                        & JS_FUNC_GENERATOR as libc::c_int as libc::c_uint != 0
                || (*s).token.u.ident.atom
                    == JS_ATOM_await as libc::c_int as libc::c_uint
                    && func_type as libc::c_uint
                        == JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint
                    && func_kind as libc::c_uint
                        & JS_FUNC_ASYNC as libc::c_int as libc::c_uint != 0
            {
                return js_parse_error_reserved_identifier(s);
            }
        }
        if (*s).token.val == TOK_IDENT as libc::c_int
            || ((*s).token.val == TOK_YIELD as libc::c_int
                && (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int
                    == 0
                || (*s).token.val == TOK_AWAIT as libc::c_int && (*s).is_module == 0)
                && func_type as libc::c_uint
                    == JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint
        {
            func_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
            if next_token(s) != 0 {
                JS_FreeAtom(ctx, func_name);
                return -(1 as libc::c_int);
            }
        } else if func_type as libc::c_uint
            != JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint
            && export_flag as libc::c_uint
                != JS_PARSE_EXPORT_DEFAULT as libc::c_int as libc::c_uint
        {
            return js_parse_error(
                s,
                b"function name expected\0" as *const u8 as *const libc::c_char,
            )
        }
    } else if func_type as libc::c_uint
        != JS_PARSE_FUNC_ARROW as libc::c_int as libc::c_uint
    {
        func_name = JS_DupAtom(ctx, func_name);
    }
    if (*fd).is_eval != 0 && (*fd).eval_type == (1 as libc::c_int) << 0 as libc::c_int
        && (func_type as libc::c_uint
            == JS_PARSE_FUNC_STATEMENT as libc::c_int as libc::c_uint
            || func_type as libc::c_uint
                == JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint)
    {
        let mut hf: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
        hf = find_global_var(fd, func_name);
        if !hf.is_null() && (*hf).scope_level == (*fd).scope_level {
            js_parse_error(
                s,
                b"invalid redefinition of global identifier in module code\0"
                    as *const u8 as *const libc::c_char,
            );
            JS_FreeAtom(ctx, func_name);
            return -(1 as libc::c_int);
        }
    }
    if func_type as libc::c_uint == JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint {
        if (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0
            && func_kind as libc::c_uint == JS_FUNC_NORMAL as libc::c_int as libc::c_uint
            && find_lexical_decl(
                ctx,
                fd,
                func_name,
                (*fd).scope_first,
                FALSE as libc::c_int,
            ) < 0 as libc::c_int
            && {
                func_idx = find_var(ctx, fd, func_name);
                !(func_idx >= 0 as libc::c_int
                    && func_idx & 0x20000000 as libc::c_int != 0)
            }
            && !(func_name == JS_ATOM_arguments as libc::c_int as libc::c_uint
                && (*fd).has_arguments_binding != 0)
        {
            create_func_var = TRUE as libc::c_int;
        }
        if (*fd).is_eval != 0
            && ((*fd).eval_type == (0 as libc::c_int) << 0 as libc::c_int
                || (*fd).eval_type == (1 as libc::c_int) << 0 as libc::c_int)
            && (*fd).scope_level == (*fd).body_scope
        {
            let mut hf_0: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
            hf_0 = find_global_var(fd, func_name);
            if !hf_0.is_null() && (*hf_0).scope_level == (*fd).scope_level {
                js_parse_error(
                    s,
                    b"invalid redefinition of global identifier\0" as *const u8
                        as *const libc::c_char,
                );
                JS_FreeAtom(ctx, func_name);
                return -(1 as libc::c_int);
            }
        } else {
            lexical_func_idx = define_var(
                s,
                fd,
                func_name,
                (if func_kind as libc::c_uint
                    != JS_FUNC_NORMAL as libc::c_int as libc::c_uint
                {
                    JS_VAR_DEF_NEW_FUNCTION_DECL as libc::c_int
                } else {
                    JS_VAR_DEF_FUNCTION_DECL as libc::c_int
                }) as JSVarDefEnum,
            );
            if lexical_func_idx < 0 as libc::c_int {
                JS_FreeAtom(ctx, func_name);
                return -(1 as libc::c_int);
            }
        }
    }
    fd = js_new_function_def(
        ctx,
        fd,
        FALSE as libc::c_int,
        is_expr,
        (*s).filename,
        function_line_num,
    );
    if fd.is_null() {
        JS_FreeAtom(ctx, func_name);
        return -(1 as libc::c_int);
    }
    if !pfd.is_null() {
        *pfd = fd;
    }
    let ref mut fresh573 = (*s).cur_func;
    *fresh573 = fd;
    (*fd).func_name = func_name;
    (*fd)
        .has_prototype = ((func_type as libc::c_uint
        == JS_PARSE_FUNC_STATEMENT as libc::c_int as libc::c_uint
        || func_type as libc::c_uint == JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_EXPR as libc::c_int as libc::c_uint)
        && func_kind as libc::c_uint == JS_FUNC_NORMAL as libc::c_int as libc::c_uint)
        as libc::c_int;
    (*fd)
        .has_home_object = (func_type as libc::c_uint
        == JS_PARSE_FUNC_METHOD as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_GETTER as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_SETTER as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint)
        as libc::c_int;
    (*fd)
        .has_arguments_binding = (func_type as libc::c_uint
        != JS_PARSE_FUNC_ARROW as libc::c_int as libc::c_uint) as libc::c_int;
    (*fd).has_this_binding = (*fd).has_arguments_binding;
    (*fd)
        .is_derived_class_constructor = (func_type as libc::c_uint
        == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint)
        as libc::c_int;
    if func_type as libc::c_uint == JS_PARSE_FUNC_ARROW as libc::c_int as libc::c_uint {
        (*fd).new_target_allowed = (*(*fd).parent).new_target_allowed;
        (*fd).super_call_allowed = (*(*fd).parent).super_call_allowed;
        (*fd).super_allowed = (*(*fd).parent).super_allowed;
        (*fd).arguments_allowed = (*(*fd).parent).arguments_allowed;
    } else {
        (*fd).new_target_allowed = TRUE as libc::c_int;
        (*fd).super_call_allowed = (*fd).is_derived_class_constructor;
        (*fd).super_allowed = (*fd).has_home_object;
        (*fd).arguments_allowed = TRUE as libc::c_int;
    }
    (*fd).set_func_kind(func_kind);
    (*fd).set_func_type(func_type);
    if func_type as libc::c_uint
        == JS_PARSE_FUNC_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint
        || func_type as libc::c_uint
            == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint
    {
        emit_op(s, OP_check_ctor as libc::c_int as uint8_t);
    }
    if func_type as libc::c_uint
        == JS_PARSE_FUNC_CLASS_CONSTRUCTOR as libc::c_int as libc::c_uint
    {
        emit_class_field_init(s);
    }
    (*fd).has_simple_parameter_list = TRUE as libc::c_int;
    (*fd).has_parameter_expressions = FALSE as libc::c_int;
    has_opt_arg = FALSE as libc::c_int;
    if func_type as libc::c_uint == JS_PARSE_FUNC_ARROW as libc::c_int as libc::c_uint
        && (*s).token.val == TOK_IDENT as libc::c_int
    {
        let mut name: JSAtom = 0;
        if (*s).token.u.ident.is_reserved != 0 {
            js_parse_error_reserved_identifier(s);
            current_block = 2285588670367447424;
        } else {
            name = (*s).token.u.ident.atom;
            if add_arg(ctx, fd, name) < 0 as libc::c_int {
                current_block = 2285588670367447424;
            } else {
                (*fd).defined_arg_count = 1 as libc::c_int;
                current_block = 9467764101860050311;
            }
        }
    } else {
        if (*s).token.val == '(' as i32 {
            let mut skip_bits: libc::c_int = 0;
            js_parse_skip_parens_token(s, &mut skip_bits, FALSE as libc::c_int);
            if skip_bits & (1 as libc::c_int) << 2 as libc::c_int != 0 {
                (*fd).has_parameter_expressions = TRUE as libc::c_int;
            }
            if next_token(s) != 0 {
                current_block = 2285588670367447424;
            } else {
                current_block = 17372050596571538954;
            }
        } else if js_parse_expect(s, '(' as i32) != 0 {
            current_block = 2285588670367447424;
        } else {
            current_block = 17372050596571538954;
        }
        match current_block {
            2285588670367447424 => {}
            _ => {
                if (*fd).has_parameter_expressions != 0 {
                    (*fd).scope_level = -(1 as libc::c_int);
                    if push_scope(s) < 0 as libc::c_int {
                        return -(1 as libc::c_int);
                    }
                }
                loop {
                    if !((*s).token.val != ')' as i32) {
                        current_block = 1131197912709891142;
                        break;
                    }
                    let mut name_0: JSAtom = 0;
                    let mut rest: BOOL = FALSE as libc::c_int;
                    let mut idx: libc::c_int = 0;
                    let mut has_initializer: libc::c_int = 0;
                    if (*s).token.val == TOK_ELLIPSIS as libc::c_int {
                        (*fd).has_simple_parameter_list = FALSE as libc::c_int;
                        rest = TRUE as libc::c_int;
                        if next_token(s) != 0 {
                            current_block = 2285588670367447424;
                            break;
                        }
                    }
                    if (*s).token.val == '[' as i32 || (*s).token.val == '{' as i32 {
                        (*fd).has_simple_parameter_list = FALSE as libc::c_int;
                        if rest != 0 {
                            emit_op(s, OP_rest as libc::c_int as uint8_t);
                            emit_u16(s, (*fd).arg_count as uint16_t);
                        } else {
                            idx = add_arg(ctx, fd, 0 as libc::c_int as JSAtom);
                            emit_op(s, OP_get_arg as libc::c_int as uint8_t);
                            emit_u16(s, idx as uint16_t);
                        }
                        has_initializer = js_parse_destructuring_element(
                            s,
                            if (*fd).has_parameter_expressions != 0 {
                                TOK_LET as libc::c_int
                            } else {
                                TOK_VAR as libc::c_int
                            },
                            1 as libc::c_int,
                            TRUE as libc::c_int,
                            -(1 as libc::c_int),
                            TRUE as libc::c_int,
                        );
                        if has_initializer < 0 as libc::c_int {
                            current_block = 2285588670367447424;
                            break;
                        }
                        if has_initializer != 0 {
                            has_opt_arg = TRUE as libc::c_int;
                        }
                        if has_opt_arg == 0 {
                            let ref mut fresh574 = (*fd).defined_arg_count;
                            *fresh574 += 1;
                        }
                    } else if (*s).token.val == TOK_IDENT as libc::c_int {
                        if (*s).token.u.ident.is_reserved != 0 {
                            js_parse_error_reserved_identifier(s);
                            current_block = 2285588670367447424;
                            break;
                        } else {
                            name_0 = (*s).token.u.ident.atom;
                            if name_0 == JS_ATOM_yield as libc::c_int as libc::c_uint
                                && (*fd).func_kind() as libc::c_int
                                    == JS_FUNC_GENERATOR as libc::c_int
                            {
                                js_parse_error_reserved_identifier(s);
                                current_block = 2285588670367447424;
                                break;
                            } else {
                                if (*fd).has_parameter_expressions != 0 {
                                    if define_var(s, fd, name_0, JS_VAR_DEF_LET)
                                        < 0 as libc::c_int
                                    {
                                        current_block = 2285588670367447424;
                                        break;
                                    }
                                }
                                idx = add_arg(ctx, fd, name_0);
                                if idx < 0 as libc::c_int {
                                    current_block = 2285588670367447424;
                                    break;
                                }
                                if next_token(s) != 0 {
                                    current_block = 2285588670367447424;
                                    break;
                                }
                                if rest != 0 {
                                    emit_op(s, OP_rest as libc::c_int as uint8_t);
                                    emit_u16(s, idx as uint16_t);
                                    if (*fd).has_parameter_expressions != 0 {
                                        emit_op(s, OP_dup as libc::c_int as uint8_t);
                                        emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                        emit_atom(s, name_0);
                                        emit_u16(s, (*fd).scope_level as uint16_t);
                                    }
                                    emit_op(s, OP_put_arg as libc::c_int as uint8_t);
                                    emit_u16(s, idx as uint16_t);
                                    (*fd).has_simple_parameter_list = FALSE as libc::c_int;
                                    has_opt_arg = TRUE as libc::c_int;
                                } else if (*s).token.val == '=' as i32 {
                                    let mut label: libc::c_int = 0;
                                    (*fd).has_simple_parameter_list = FALSE as libc::c_int;
                                    has_opt_arg = TRUE as libc::c_int;
                                    if next_token(s) != 0 {
                                        current_block = 2285588670367447424;
                                        break;
                                    }
                                    label = new_label(s);
                                    emit_op(s, OP_get_arg as libc::c_int as uint8_t);
                                    emit_u16(s, idx as uint16_t);
                                    emit_op(s, OP_dup as libc::c_int as uint8_t);
                                    emit_op(s, OP_undefined as libc::c_int as uint8_t);
                                    emit_op(s, OP_strict_eq as libc::c_int as uint8_t);
                                    emit_goto(s, OP_if_false as libc::c_int, label);
                                    emit_op(s, OP_drop as libc::c_int as uint8_t);
                                    if js_parse_assign_expr(s) != 0 {
                                        current_block = 2285588670367447424;
                                        break;
                                    }
                                    set_object_name(s, name_0);
                                    emit_op(s, OP_dup as libc::c_int as uint8_t);
                                    emit_op(s, OP_put_arg as libc::c_int as uint8_t);
                                    emit_u16(s, idx as uint16_t);
                                    emit_label(s, label);
                                    emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                    emit_atom(s, name_0);
                                    emit_u16(s, (*fd).scope_level as uint16_t);
                                } else {
                                    if has_opt_arg == 0 {
                                        let ref mut fresh575 = (*fd).defined_arg_count;
                                        *fresh575 += 1;
                                    }
                                    if (*fd).has_parameter_expressions != 0 {
                                        emit_op(s, OP_get_arg as libc::c_int as uint8_t);
                                        emit_u16(s, idx as uint16_t);
                                        emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                        emit_atom(s, name_0);
                                        emit_u16(s, (*fd).scope_level as uint16_t);
                                    }
                                }
                            }
                        }
                    } else {
                        js_parse_error(
                            s,
                            b"missing formal parameter\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 2285588670367447424;
                        break;
                    }
                    if rest != 0 && (*s).token.val != ')' as i32 {
                        js_parse_expect(s, ')' as i32);
                        current_block = 2285588670367447424;
                        break;
                    } else {
                        if (*s).token.val == ')' as i32 {
                            current_block = 1131197912709891142;
                            break;
                        }
                        if js_parse_expect(s, ',' as i32) != 0 {
                            current_block = 2285588670367447424;
                            break;
                        }
                    }
                }
                match current_block {
                    2285588670367447424 => {}
                    _ => {
                        if func_type as libc::c_uint
                            == JS_PARSE_FUNC_GETTER as libc::c_int as libc::c_uint
                            && (*fd).arg_count != 0 as libc::c_int
                            || func_type as libc::c_uint
                                == JS_PARSE_FUNC_SETTER as libc::c_int as libc::c_uint
                                && (*fd).arg_count != 1 as libc::c_int
                        {
                            js_parse_error(
                                s,
                                b"invalid number of arguments for getter or setter\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 2285588670367447424;
                        } else {
                            current_block = 9467764101860050311;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        9467764101860050311 => {
            if (*fd).has_parameter_expressions != 0 {
                let mut idx_0: libc::c_int = 0;
                idx_0 = (*((*fd).scopes).offset((*fd).scope_level as isize)).first;
                loop {
                    if !(idx_0 >= 0 as libc::c_int) {
                        current_block = 13164310931121142693;
                        break;
                    }
                    let mut vd: *mut JSVarDef = &mut *((*fd).vars).offset(idx_0 as isize)
                        as *mut JSVarDef;
                    if (*vd).scope_level != (*fd).scope_level {
                        current_block = 13164310931121142693;
                        break;
                    }
                    if find_var(ctx, fd, (*vd).var_name) < 0 as libc::c_int {
                        if add_var(ctx, fd, (*vd).var_name) < 0 as libc::c_int {
                            current_block = 2285588670367447424;
                            break;
                        }
                        vd = &mut *((*fd).vars).offset(idx_0 as isize) as *mut JSVarDef;
                        emit_op(s, OP_scope_get_var as libc::c_int as uint8_t);
                        emit_atom(s, (*vd).var_name);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                        emit_op(s, OP_scope_put_var as libc::c_int as uint8_t);
                        emit_atom(s, (*vd).var_name);
                        emit_u16(s, 0 as libc::c_int as uint16_t);
                    }
                    idx_0 = (*vd).scope_next;
                }
                match current_block {
                    2285588670367447424 => {}
                    _ => {
                        emit_op(s, OP_leave_scope as libc::c_int as uint8_t);
                        emit_u16(s, (*fd).scope_level as uint16_t);
                        (*fd).scope_level = 0 as libc::c_int;
                        (*fd)
                            .scope_first = (*((*fd).scopes)
                            .offset((*fd).scope_level as isize))
                            .first;
                        current_block = 259606973132676092;
                    }
                }
            } else {
                current_block = 259606973132676092;
            }
            match current_block {
                2285588670367447424 => {}
                _ => {
                    if !(next_token(s) != 0) {
                        if func_kind as libc::c_uint
                            == JS_FUNC_GENERATOR as libc::c_int as libc::c_uint
                            || func_kind as libc::c_uint
                                == JS_FUNC_ASYNC_GENERATOR as libc::c_int as libc::c_uint
                        {
                            emit_op(s, OP_initial_yield as libc::c_int as uint8_t);
                        }
                        (*fd).in_function_body = TRUE as libc::c_int;
                        push_scope(s);
                        (*fd).body_scope = (*fd).scope_level;
                        if (*s).token.val == TOK_ARROW as libc::c_int {
                            if next_token(s) != 0 {
                                current_block = 2285588670367447424;
                            } else if (*s).token.val != '{' as i32 {
                                if js_parse_function_check_names(s, fd, func_name) != 0 {
                                    current_block = 2285588670367447424;
                                } else if js_parse_assign_expr(s) != 0 {
                                    current_block = 2285588670367447424;
                                } else {
                                    if func_kind as libc::c_uint
                                        != JS_FUNC_NORMAL as libc::c_int as libc::c_uint
                                    {
                                        emit_op(s, OP_return_async as libc::c_int as uint8_t);
                                    } else {
                                        emit_op(s, OP_return as libc::c_int as uint8_t);
                                    }
                                    if (*fd).js_mode as libc::c_int
                                        & (1 as libc::c_int) << 1 as libc::c_int == 0
                                    {
                                        (*fd)
                                            .source_len = ((*s).last_ptr).offset_from(ptr)
                                            as libc::c_long as libc::c_int;
                                        let ref mut fresh576 = (*fd).source;
                                        *fresh576 = js_strndup(
                                            ctx,
                                            ptr as *const libc::c_char,
                                            (*fd).source_len as size_t,
                                        );
                                        if ((*fd).source).is_null() {
                                            current_block = 2285588670367447424;
                                        } else {
                                            current_block = 770142169658313507;
                                        }
                                    } else {
                                        current_block = 770142169658313507;
                                    }
                                }
                            } else {
                                current_block = 11889020335300612420;
                            }
                        } else {
                            current_block = 11889020335300612420;
                        }
                        match current_block {
                            2285588670367447424 => {}
                            _ => {
                                match current_block {
                                    11889020335300612420 => {
                                        if js_parse_expect(s, '{' as i32) != 0 {
                                            current_block = 2285588670367447424;
                                        } else if js_parse_directives(s) != 0 {
                                            current_block = 2285588670367447424;
                                        } else if js_parse_function_check_names(s, fd, func_name)
                                            != 0
                                        {
                                            current_block = 2285588670367447424;
                                        } else {
                                            loop {
                                                if !((*s).token.val != '}' as i32) {
                                                    current_block = 613454377845503748;
                                                    break;
                                                }
                                                if js_parse_source_element(s) != 0 {
                                                    current_block = 2285588670367447424;
                                                    break;
                                                }
                                            }
                                            match current_block {
                                                2285588670367447424 => {}
                                                _ => {
                                                    if (*fd).js_mode as libc::c_int
                                                        & (1 as libc::c_int) << 1 as libc::c_int == 0
                                                    {
                                                        (*fd)
                                                            .source_len = ((*s).buf_ptr).offset_from(ptr)
                                                            as libc::c_long as libc::c_int;
                                                        let ref mut fresh577 = (*fd).source;
                                                        *fresh577 = js_strndup(
                                                            ctx,
                                                            ptr as *const libc::c_char,
                                                            (*fd).source_len as size_t,
                                                        );
                                                        if ((*fd).source).is_null() {
                                                            current_block = 2285588670367447424;
                                                        } else {
                                                            current_block = 6055351187523413397;
                                                        }
                                                    } else {
                                                        current_block = 6055351187523413397;
                                                    }
                                                    match current_block {
                                                        2285588670367447424 => {}
                                                        _ => {
                                                            if next_token(s) != 0 {
                                                                current_block = 2285588670367447424;
                                                            } else {
                                                                if js_is_live_code(s) != 0 {
                                                                    emit_return(s, FALSE as libc::c_int);
                                                                }
                                                                current_block = 770142169658313507;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                match current_block {
                                    2285588670367447424 => {}
                                    _ => {
                                        let ref mut fresh578 = (*s).cur_func;
                                        *fresh578 = (*fd).parent;
                                        let mut idx_1: libc::c_int = 0;
                                        let mut func_name_0: JSAtom = (*fd).func_name;
                                        idx_1 = cpool_add(
                                            s,
                                            (JS_TAG_NULL as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                        );
                                        (*fd).parent_cpool_idx = idx_1;
                                        if is_expr != 0 {
                                            if func_type as libc::c_uint
                                                != JS_PARSE_FUNC_CLASS_CONSTRUCTOR as libc::c_int
                                                    as libc::c_uint
                                                && func_type as libc::c_uint
                                                    != JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR as libc::c_int
                                                        as libc::c_uint
                                            {
                                                emit_op(s, OP_fclosure as libc::c_int as uint8_t);
                                                emit_u32(s, idx_1 as uint32_t);
                                                if func_name_0 == 0 as libc::c_int as libc::c_uint {
                                                    emit_op(s, OP_set_name as libc::c_int as uint8_t);
                                                    emit_u32(s, 0 as libc::c_int as uint32_t);
                                                }
                                            }
                                            current_block = 10878888195156817878;
                                        } else if func_type as libc::c_uint
                                            == JS_PARSE_FUNC_VAR as libc::c_int as libc::c_uint
                                        {
                                            emit_op(s, OP_fclosure as libc::c_int as uint8_t);
                                            emit_u32(s, idx_1 as uint32_t);
                                            if create_func_var != 0 {
                                                if (*(*s).cur_func).is_global_var != 0 {
                                                    let mut hf_1: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
                                                    hf_1 = add_global_var(ctx, (*s).cur_func, func_name_0);
                                                    if hf_1.is_null() {
                                                        current_block = 2285588670367447424;
                                                    } else {
                                                        (*hf_1).scope_level = 0 as libc::c_int;
                                                        (*hf_1)
                                                            .set_force_init(
                                                                ((*(*s).cur_func).js_mode as libc::c_int
                                                                    & (1 as libc::c_int) << 0 as libc::c_int
                                                                    != 0 as libc::c_int) as libc::c_int as uint8_t,
                                                            );
                                                        emit_op(s, OP_dup as libc::c_int as uint8_t);
                                                        emit_op(s, OP_scope_put_var as libc::c_int as uint8_t);
                                                        emit_atom(s, func_name_0);
                                                        emit_u16(s, 0 as libc::c_int as uint16_t);
                                                        current_block = 15306500312484564201;
                                                    }
                                                } else {
                                                    func_idx = find_var(ctx, (*s).cur_func, func_name_0);
                                                    if func_idx < 0 as libc::c_int {
                                                        func_idx = add_var(ctx, (*s).cur_func, func_name_0);
                                                        if func_idx < 0 as libc::c_int {
                                                            current_block = 2285588670367447424;
                                                        } else {
                                                            current_block = 4839309778395429725;
                                                        }
                                                    } else {
                                                        current_block = 4839309778395429725;
                                                    }
                                                    match current_block {
                                                        2285588670367447424 => {}
                                                        _ => {
                                                            emit_op(s, OP_dup as libc::c_int as uint8_t);
                                                            emit_op(s, OP_scope_put_var as libc::c_int as uint8_t);
                                                            emit_atom(s, func_name_0);
                                                            emit_u16(s, 0 as libc::c_int as uint16_t);
                                                            current_block = 15306500312484564201;
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block = 15306500312484564201;
                                            }
                                            match current_block {
                                                2285588670367447424 => {}
                                                _ => {
                                                    if lexical_func_idx >= 0 as libc::c_int {
                                                        let ref mut fresh579 = *((*(*s).cur_func).vars)
                                                            .offset(lexical_func_idx as isize);
                                                        (*fresh579).set_func_pool_idx(idx_1);
                                                        emit_op(s, OP_drop as libc::c_int as uint8_t);
                                                    } else {
                                                        emit_op(s, OP_scope_put_var_init as libc::c_int as uint8_t);
                                                        emit_atom(s, func_name_0);
                                                        emit_u16(s, (*(*s).cur_func).scope_level as uint16_t);
                                                    }
                                                    current_block = 10878888195156817878;
                                                }
                                            }
                                        } else if (*(*s).cur_func).is_global_var == 0 {
                                            let mut var_idx: libc::c_int = define_var(
                                                s,
                                                (*s).cur_func,
                                                func_name_0,
                                                JS_VAR_DEF_VAR,
                                            );
                                            if var_idx < 0 as libc::c_int {
                                                current_block = 2285588670367447424;
                                            } else {
                                                if var_idx & 0x20000000 as libc::c_int != 0 {
                                                    let ref mut fresh580 = *((*(*s).cur_func).args)
                                                        .offset((var_idx - 0x20000000 as libc::c_int) as isize);
                                                    (*fresh580).set_func_pool_idx(idx_1);
                                                } else {
                                                    let ref mut fresh581 = *((*(*s).cur_func).vars)
                                                        .offset(var_idx as isize);
                                                    (*fresh581).set_func_pool_idx(idx_1);
                                                }
                                                current_block = 10878888195156817878;
                                            }
                                        } else {
                                            let mut func_var_name: JSAtom = 0;
                                            let mut hf_2: *mut JSGlobalVar = 0 as *mut JSGlobalVar;
                                            if func_name_0 == 0 as libc::c_int as libc::c_uint {
                                                func_var_name = JS_ATOM__default_ as libc::c_int as JSAtom;
                                            } else {
                                                func_var_name = func_name_0;
                                            }
                                            hf_2 = add_global_var(ctx, (*s).cur_func, func_var_name);
                                            if hf_2.is_null() {
                                                current_block = 2285588670367447424;
                                            } else {
                                                (*hf_2).cpool_idx = idx_1;
                                                if export_flag as libc::c_uint
                                                    != JS_PARSE_EXPORT_NONE as libc::c_int as libc::c_uint
                                                {
                                                    if (add_export_entry(
                                                        s,
                                                        (*(*s).cur_func).module,
                                                        func_var_name,
                                                        if export_flag as libc::c_uint
                                                            == JS_PARSE_EXPORT_NAMED as libc::c_int as libc::c_uint
                                                        {
                                                            func_var_name
                                                        } else {
                                                            JS_ATOM_default as libc::c_int as libc::c_uint
                                                        },
                                                        JS_EXPORT_TYPE_LOCAL,
                                                    ))
                                                        .is_null()
                                                    {
                                                        current_block = 2285588670367447424;
                                                    } else {
                                                        current_block = 10878888195156817878;
                                                    }
                                                } else {
                                                    current_block = 10878888195156817878;
                                                }
                                            }
                                        }
                                        match current_block {
                                            2285588670367447424 => {}
                                            _ => return 0 as libc::c_int,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    let ref mut fresh582 = (*s).cur_func;
    *fresh582 = (*fd).parent;
    js_free_function_def(ctx, fd);
    if !pfd.is_null() {
        *pfd = 0 as *mut JSFunctionDef;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_parse_function_decl(
    mut s: *mut JSParseState,
    mut func_type: JSParseFunctionEnum,
    mut func_kind: JSFunctionKindEnum,
    mut func_name: JSAtom,
    mut ptr: *const uint8_t,
    mut function_line_num: libc::c_int,
) -> libc::c_int {
    return js_parse_function_decl2(
        s,
        func_type,
        func_kind,
        func_name,
        ptr,
        function_line_num,
        JS_PARSE_EXPORT_NONE,
        0 as *mut *mut JSFunctionDef,
    );
}
unsafe extern "C" fn js_parse_program(mut s: *mut JSParseState) -> libc::c_int {
    let mut fd: *mut JSFunctionDef = (*s).cur_func;
    let mut idx: libc::c_int = 0;
    if next_token(s) != 0 {
        return -(1 as libc::c_int);
    }
    if js_parse_directives(s) != 0 {
        return -(1 as libc::c_int);
    }
    (*fd)
        .is_global_var = ((*fd).eval_type == (0 as libc::c_int) << 0 as libc::c_int
        || (*fd).eval_type == (1 as libc::c_int) << 0 as libc::c_int
        || (*fd).js_mode as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0)
        as libc::c_int;
    if (*s).is_module == 0 {
        idx = add_var((*s).ctx, fd, JS_ATOM__ret_ as libc::c_int as JSAtom);
        (*fd).eval_ret_idx = idx;
        if idx < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
    }
    while (*s).token.val != TOK_EOF as libc::c_int {
        if js_parse_source_element(s) != 0 {
            return -(1 as libc::c_int);
        }
    }
    if (*s).is_module == 0 {
        emit_op(s, OP_get_loc as libc::c_int as uint8_t);
        emit_u16(s, (*fd).eval_ret_idx as uint16_t);
        emit_op(s, OP_return as libc::c_int as uint8_t);
    } else {
        emit_op(s, OP_return_undef as libc::c_int as uint8_t);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_parse_init(
    mut ctx: *mut JSContext,
    mut s: *mut JSParseState,
    mut input: *const libc::c_char,
    mut input_len: size_t,
    mut filename: *const libc::c_char,
) {
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSParseState>() as libc::c_ulong,
    );
    let ref mut fresh583 = (*s).ctx;
    *fresh583 = ctx;
    let ref mut fresh584 = (*s).filename;
    *fresh584 = filename;
    (*s).line_num = 1 as libc::c_int;
    let ref mut fresh585 = (*s).buf_ptr;
    *fresh585 = input as *const uint8_t;
    let ref mut fresh586 = (*s).buf_end;
    *fresh586 = ((*s).buf_ptr).offset(input_len as isize);
    (*s).token.val = ' ' as i32;
    (*s).token.line_num = 1 as libc::c_int;
}
unsafe extern "C" fn JS_EvalFunctionInternal(
    mut ctx: *mut JSContext,
    mut fun_obj: JSValue,
    mut this_obj: JSValue,
    mut var_refs: *mut *mut JSVarRef,
    mut sf: *mut JSStackFrame,
) -> JSValue {
    let mut current_block: u64;
    let mut ret_val: JSValue = 0;
    let mut tag: uint32_t = 0;
    tag = (fun_obj >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag == JS_TAG_FUNCTION_BYTECODE as libc::c_int as libc::c_uint {
        fun_obj = js_closure(ctx, fun_obj, var_refs, sf);
        ret_val = JS_CallFree(
            ctx,
            fun_obj,
            this_obj,
            0 as libc::c_int,
            0 as *mut JSValue,
        );
    } else if tag == JS_TAG_MODULE as libc::c_int as libc::c_uint {
        let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
        m = fun_obj as intptr_t as *mut libc::c_void as *mut JSModuleDef;
        JS_FreeValue(ctx, fun_obj);
        if js_create_module_function(ctx, m) < 0 as libc::c_int {
            current_block = 11552053230292989738;
        } else if js_link_module(ctx, m) < 0 as libc::c_int {
            current_block = 11552053230292989738;
        } else {
            ret_val = js_evaluate_module(ctx, m);
            if JS_IsException(ret_val) != 0 {
                current_block = 11552053230292989738;
            } else {
                current_block = 6009453772311597924;
            }
        }
        match current_block {
            6009453772311597924 => {}
            _ => {
                js_free_modules(ctx, JS_FREE_MODULE_NOT_EVALUATED);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    } else {
        JS_FreeValue(ctx, fun_obj);
        ret_val = JS_ThrowTypeError(
            ctx,
            b"bytecode function expected\0" as *const u8 as *const libc::c_char,
        );
    }
    return ret_val;
}
#[no_mangle]
pub unsafe extern "C" fn JS_EvalFunction(
    mut ctx: *mut JSContext,
    mut fun_obj: JSValue,
) -> JSValue {
    return JS_EvalFunctionInternal(
        ctx,
        fun_obj,
        (*ctx).global_obj,
        0 as *mut *mut JSVarRef,
        0 as *mut JSStackFrame,
    );
}
unsafe extern "C" fn skip_shebang(mut s: *mut JSParseState) {
    let mut p: *const uint8_t = (*s).buf_ptr;
    let mut c: libc::c_int = 0;
    if *p.offset(0 as libc::c_int as isize) as libc::c_int == '#' as i32
        && *p.offset(1 as libc::c_int as isize) as libc::c_int == '!' as i32
    {
        p = p.offset(2 as libc::c_int as isize);
        while p < (*s).buf_end {
            if *p as libc::c_int == '\n' as i32 || *p as libc::c_int == '\r' as i32 {
                break;
            }
            if *p as libc::c_int >= 0x80 as libc::c_int {
                c = unicode_from_utf8(p, 6 as libc::c_int, &mut p);
                if c == 0x2028 as libc::c_int || c == 0x2029 as libc::c_int {
                    break;
                }
                if c == -(1 as libc::c_int) {
                    p = p.offset(1);
                }
            } else {
                p = p.offset(1);
            }
        }
        let ref mut fresh587 = (*s).buf_ptr;
        *fresh587 = p;
    }
}
unsafe extern "C" fn __JS_EvalInternal(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut input: *const libc::c_char,
    mut input_len: size_t,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
    mut scope_idx: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut s1: JSParseState = JSParseState {
        ctx: 0 as *mut JSContext,
        last_line_num: 0,
        line_num: 0,
        filename: 0 as *const libc::c_char,
        token: JSToken {
            val: 0,
            line_num: 0,
            ptr: 0 as *const uint8_t,
            u: C2RustUnnamed_31 {
                str_0: C2RustUnnamed_35 {
                    str_0: 0,
                    sep: 0,
                },
            },
        },
        got_lf: 0,
        last_ptr: 0 as *const uint8_t,
        buf_ptr: 0 as *const uint8_t,
        buf_end: 0 as *const uint8_t,
        cur_func: 0 as *mut JSFunctionDef,
        is_module: 0,
        allow_html_comments: 0,
        ext_json: 0,
    };
    let mut s: *mut JSParseState = &mut s1;
    let mut err: libc::c_int = 0;
    let mut js_mode: libc::c_int = 0;
    let mut eval_type: libc::c_int = 0;
    let mut fun_obj: JSValue = 0;
    let mut ret_val: JSValue = 0;
    let mut sf: *mut JSStackFrame = 0 as *mut JSStackFrame;
    let mut var_refs: *mut *mut JSVarRef = 0 as *mut *mut JSVarRef;
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut fd: *mut JSFunctionDef = 0 as *mut JSFunctionDef;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    js_parse_init(ctx, s, input, input_len, filename);
    skip_shebang(s);
    eval_type = flags & (3 as libc::c_int) << 0 as libc::c_int;
    m = 0 as *mut JSModuleDef;
    if eval_type == (2 as libc::c_int) << 0 as libc::c_int {
        let mut p: *mut JSObject = 0 as *mut JSObject;
        sf = (*(*ctx).rt).current_stack_frame;
        assert((sf != 0 as *mut libc::c_void as *mut JSStackFrame) as libc::c_int);
        assert(
            (((*sf).cur_func >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_OBJECT as libc::c_int) as libc::c_int,
        );
        p = (*sf).cur_func as intptr_t as *mut libc::c_void as *mut JSObject;
        assert(
            js_class_has_bytecode(
                (*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID,
            ),
        );
        b = (*p).u.func.function_bytecode;
        var_refs = (*p).u.func.var_refs;
        js_mode = (*b).js_mode as libc::c_int;
    } else {
        sf = 0 as *mut JSStackFrame;
        b = 0 as *mut JSFunctionBytecode;
        var_refs = 0 as *mut *mut JSVarRef;
        js_mode = 0 as libc::c_int;
        if flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
            js_mode |= (1 as libc::c_int) << 0 as libc::c_int;
        }
        if flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
            js_mode |= (1 as libc::c_int) << 1 as libc::c_int;
        }
        if eval_type == (1 as libc::c_int) << 0 as libc::c_int {
            let mut module_name: JSAtom = JS_NewAtom(ctx, filename);
            if module_name == 0 as libc::c_int as libc::c_uint {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            m = js_new_module_def(ctx, module_name);
            if m.is_null() {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            js_mode |= (1 as libc::c_int) << 0 as libc::c_int;
        }
    }
    fd = js_new_function_def(
        ctx,
        0 as *mut JSFunctionDef,
        TRUE as libc::c_int,
        FALSE as libc::c_int,
        filename,
        1 as libc::c_int,
    );
    if !fd.is_null() {
        let ref mut fresh588 = (*s).cur_func;
        *fresh588 = fd;
        (*fd).eval_type = eval_type;
        (*fd)
            .has_this_binding = (eval_type != (2 as libc::c_int) << 0 as libc::c_int)
            as libc::c_int;
        (*fd)
            .backtrace_barrier = (flags & (1 as libc::c_int) << 6 as libc::c_int
            != 0 as libc::c_int) as libc::c_int;
        if eval_type == (2 as libc::c_int) << 0 as libc::c_int {
            (*fd).new_target_allowed = (*b).new_target_allowed() as BOOL;
            (*fd).super_call_allowed = (*b).super_call_allowed() as BOOL;
            (*fd).super_allowed = (*b).super_allowed() as BOOL;
            (*fd).arguments_allowed = (*b).arguments_allowed() as BOOL;
        } else {
            (*fd).new_target_allowed = FALSE as libc::c_int;
            (*fd).super_call_allowed = FALSE as libc::c_int;
            (*fd).super_allowed = FALSE as libc::c_int;
            (*fd).arguments_allowed = TRUE as libc::c_int;
        }
        (*fd).js_mode = js_mode as uint8_t;
        (*fd).func_name = JS_DupAtom(ctx, JS_ATOM__eval_ as libc::c_int as JSAtom);
        if !b.is_null() {
            if add_closure_variables(ctx, fd, b, scope_idx) != 0 {
                current_block = 6042181247167644884;
            } else {
                current_block = 5141539773904409130;
            }
        } else {
            current_block = 5141539773904409130;
        }
        match current_block {
            5141539773904409130 => {
                let ref mut fresh589 = (*fd).module;
                *fresh589 = m;
                (*s)
                    .is_module = (m != 0 as *mut libc::c_void as *mut JSModuleDef)
                    as libc::c_int;
                (*s).allow_html_comments = ((*s).is_module == 0) as libc::c_int;
                push_scope(s);
                (*fd).body_scope = (*fd).scope_level;
                err = js_parse_program(s);
                if err != 0 {
                    current_block = 6042181247167644884;
                } else {
                    fun_obj = js_create_function(ctx, fd);
                    if JS_IsException(fun_obj) != 0 {
                        current_block = 7703745684544248735;
                    } else {
                        if !m.is_null() {
                            (*m).func_obj = fun_obj;
                            if js_resolve_module(ctx, m) < 0 as libc::c_int {
                                current_block = 7703745684544248735;
                            } else {
                                fun_obj = JS_DupValue(
                                    ctx,
                                    (JS_TAG_MODULE as libc::c_int as uint64_t)
                                        << 32 as libc::c_int | m as uintptr_t as libc::c_ulonglong,
                                );
                                current_block = 7494008139977416618;
                            }
                        } else {
                            current_block = 7494008139977416618;
                        }
                        match current_block {
                            7703745684544248735 => {}
                            _ => {
                                if flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
                                    ret_val = fun_obj;
                                } else {
                                    ret_val = JS_EvalFunctionInternal(
                                        ctx,
                                        fun_obj,
                                        this_obj,
                                        var_refs,
                                        sf,
                                    );
                                }
                                return ret_val;
                            }
                        }
                    }
                }
            }
            _ => {}
        }
        match current_block {
            7703745684544248735 => {}
            _ => {
                free_token(s, &mut (*s).token);
                js_free_function_def(ctx, fd);
            }
        }
    }
    if !m.is_null() {
        js_free_module_def(ctx, m);
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_EvalInternal(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut input: *const libc::c_char,
    mut input_len: size_t,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
    mut scope_idx: libc::c_int,
) -> JSValue {
    if ((*ctx).eval_internal).is_none() as libc::c_int as libc::c_long != 0 {
        return JS_ThrowTypeError(
            ctx,
            b"eval is not supported\0" as *const u8 as *const libc::c_char,
        );
    }
    return ((*ctx).eval_internal)
        .expect(
            "non-null function pointer",
        )(ctx, this_obj, input, input_len, filename, flags, scope_idx);
}
unsafe extern "C" fn JS_EvalObject(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut val: JSValue,
    mut flags: libc::c_int,
    mut scope_idx: libc::c_int,
) -> JSValue {
    let mut ret: JSValue = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: size_t = 0;
    if JS_IsString(val) == 0 {
        return JS_DupValue(ctx, val);
    }
    str = JS_ToCStringLen(ctx, &mut len, val);
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_EvalInternal(
        ctx,
        this_obj,
        str,
        len,
        b"<input>\0" as *const u8 as *const libc::c_char,
        flags,
        scope_idx,
    );
    JS_FreeCString(ctx, str);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_EvalThis(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut input: *const libc::c_char,
    mut input_len: size_t,
    mut filename: *const libc::c_char,
    mut eval_flags: libc::c_int,
) -> JSValue {
    let mut eval_type: libc::c_int = eval_flags & (3 as libc::c_int) << 0 as libc::c_int;
    let mut ret: JSValue = 0;
    assert(
        (eval_type == (0 as libc::c_int) << 0 as libc::c_int
            || eval_type == (1 as libc::c_int) << 0 as libc::c_int) as libc::c_int,
    );
    ret = JS_EvalInternal(
        ctx,
        this_obj,
        input,
        input_len,
        filename,
        eval_flags,
        -(1 as libc::c_int),
    );
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn JS_Eval(
    mut ctx: *mut JSContext,
    mut input: *const libc::c_char,
    mut input_len: size_t,
    mut filename: *const libc::c_char,
    mut eval_flags: libc::c_int,
) -> JSValue {
    return JS_EvalThis(ctx, (*ctx).global_obj, input, input_len, filename, eval_flags);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ResolveModule(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_MODULE as libc::c_int {
        let mut m: *mut JSModuleDef = obj as intptr_t as *mut libc::c_void
            as *mut JSModuleDef;
        if js_resolve_module(ctx, m) < 0 as libc::c_int {
            js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_object_list_init(mut s: *mut JSObjectList) {
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSObjectList>() as libc::c_ulong,
    );
}
unsafe extern "C" fn js_object_list_get_hash(
    mut p: *mut JSObject,
    mut hash_size: uint32_t,
) -> uint32_t {
    return (p as uintptr_t).wrapping_mul(3163 as libc::c_int as libc::c_uint)
        & hash_size.wrapping_sub(1 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn js_object_list_resize_hash(
    mut ctx: *mut JSContext,
    mut s: *mut JSObjectList,
    mut new_hash_size: uint32_t,
) -> libc::c_int {
    let mut e: *mut JSObjectListEntry = 0 as *mut JSObjectListEntry;
    let mut i: uint32_t = 0;
    let mut h: uint32_t = 0;
    let mut new_hash_table: *mut uint32_t = 0 as *mut uint32_t;
    new_hash_table = js_malloc(
        ctx,
        (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
            .wrapping_mul(new_hash_size as libc::c_ulong),
    ) as *mut uint32_t;
    if new_hash_table.is_null() {
        return -(1 as libc::c_int);
    }
    js_free(ctx, (*s).hash_table as *mut libc::c_void);
    let ref mut fresh590 = (*s).hash_table;
    *fresh590 = new_hash_table;
    (*s).hash_size = new_hash_size;
    i = 0 as libc::c_int as uint32_t;
    while i < (*s).hash_size {
        *((*s).hash_table).offset(i as isize) = -(1 as libc::c_int) as uint32_t;
        i = i.wrapping_add(1);
    }
    i = 0 as libc::c_int as uint32_t;
    while i < (*s).object_count as libc::c_uint {
        e = &mut *((*s).object_tab).offset(i as isize) as *mut JSObjectListEntry;
        h = js_object_list_get_hash((*e).obj, (*s).hash_size);
        (*e).hash_next = *((*s).hash_table).offset(h as isize);
        *((*s).hash_table).offset(h as isize) = i;
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_object_list_add(
    mut ctx: *mut JSContext,
    mut s: *mut JSObjectList,
    mut obj: *mut JSObject,
) -> libc::c_int {
    let mut e: *mut JSObjectListEntry = 0 as *mut JSObjectListEntry;
    let mut h: uint32_t = 0;
    let mut new_hash_size: uint32_t = 0;
    if js_resize_array(
        ctx,
        &mut (*s).object_tab as *mut *mut JSObjectListEntry as *mut libc::c_void
            as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSObjectListEntry>() as libc::c_ulong as libc::c_int,
        &mut (*s).object_size,
        (*s).object_count + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    if (((*s).object_count + 1 as libc::c_int) as libc::c_uint >= (*s).hash_size)
        as libc::c_int as libc::c_long != 0
    {
        new_hash_size = max_uint32((*s).hash_size, 4 as libc::c_int as uint32_t);
        while new_hash_size <= (*s).object_count as libc::c_uint {
            new_hash_size = (new_hash_size as libc::c_uint)
                .wrapping_mul(2 as libc::c_int as libc::c_uint) as uint32_t as uint32_t;
        }
        if js_object_list_resize_hash(ctx, s, new_hash_size) != 0 {
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh591 = (*s).object_count;
    let fresh592 = *fresh591;
    *fresh591 = *fresh591 + 1;
    e = &mut *((*s).object_tab).offset(fresh592 as isize) as *mut JSObjectListEntry;
    h = js_object_list_get_hash(obj, (*s).hash_size);
    let ref mut fresh593 = (*e).obj;
    *fresh593 = obj;
    (*e).hash_next = *((*s).hash_table).offset(h as isize);
    *((*s).hash_table)
        .offset(h as isize) = ((*s).object_count - 1 as libc::c_int) as uint32_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_object_list_find(
    mut ctx: *mut JSContext,
    mut s: *mut JSObjectList,
    mut obj: *mut JSObject,
) -> libc::c_int {
    let mut e: *mut JSObjectListEntry = 0 as *mut JSObjectListEntry;
    let mut h: uint32_t = 0;
    let mut p: uint32_t = 0;
    if (*s).object_count == 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    h = js_object_list_get_hash(obj, (*s).hash_size);
    p = *((*s).hash_table).offset(h as isize);
    while p != -(1 as libc::c_int) as libc::c_uint {
        e = &mut *((*s).object_tab).offset(p as isize) as *mut JSObjectListEntry;
        if (*e).obj == obj {
            return p as libc::c_int;
        }
        p = (*e).hash_next;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_object_list_end(
    mut ctx: *mut JSContext,
    mut s: *mut JSObjectList,
) {
    js_free(ctx, (*s).object_tab as *mut libc::c_void);
    js_free(ctx, (*s).hash_table as *mut libc::c_void);
}
unsafe extern "C" fn bc_put_u8(mut s: *mut BCWriterState, mut v: uint8_t) {
    dbuf_putc(&mut (*s).dbuf, v);
}
unsafe extern "C" fn bc_put_u16(mut s: *mut BCWriterState, mut v: uint16_t) {
    if (*s).byte_swap() != 0 {
        v = bswap16(v);
    }
    dbuf_put_u16(&mut (*s).dbuf, v);
}
unsafe extern "C" fn bc_put_u64(mut s: *mut BCWriterState, mut v: uint64_t) {
    if (*s).byte_swap() != 0 {
        v = bswap64(v);
    }
    dbuf_put(
        &mut (*s).dbuf,
        &mut v as *mut uint64_t as *mut uint8_t,
        ::core::mem::size_of::<uint64_t>() as libc::c_ulong,
    );
}
unsafe extern "C" fn bc_put_leb128(mut s: *mut BCWriterState, mut v: uint32_t) {
    dbuf_put_leb128(&mut (*s).dbuf, v);
}
unsafe extern "C" fn bc_put_sleb128(mut s: *mut BCWriterState, mut v: int32_t) {
    dbuf_put_sleb128(&mut (*s).dbuf, v);
}
unsafe extern "C" fn bc_set_flags(
    mut pflags: *mut uint32_t,
    mut pidx: *mut libc::c_int,
    mut val: uint32_t,
    mut n: libc::c_int,
) {
    *pflags = *pflags | val << *pidx;
    *pidx += n;
}
unsafe extern "C" fn bc_atom_to_idx(
    mut s: *mut BCWriterState,
    mut pres: *mut uint32_t,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut v: uint32_t = 0;
    if atom < (*s).first_atom || __JS_AtomIsTaggedInt(atom) != 0 {
        *pres = atom;
        return 0 as libc::c_int;
    }
    atom = (atom as libc::c_uint).wrapping_sub((*s).first_atom) as JSAtom as JSAtom;
    if atom < (*s).atom_to_idx_size as libc::c_uint
        && *((*s).atom_to_idx).offset(atom as isize) != 0 as libc::c_int as libc::c_uint
    {
        *pres = *((*s).atom_to_idx).offset(atom as isize);
        return 0 as libc::c_int;
    }
    if atom >= (*s).atom_to_idx_size as libc::c_uint {
        let mut old_size: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        old_size = (*s).atom_to_idx_size;
        if js_resize_array(
            (*s).ctx,
            &mut (*s).atom_to_idx as *mut *mut uint32_t as *mut *mut libc::c_void,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
            &mut (*s).atom_to_idx_size,
            atom.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
        ) != 0
        {
            return -(1 as libc::c_int);
        }
        i = old_size;
        while i < (*s).atom_to_idx_size {
            *((*s).atom_to_idx).offset(i as isize) = 0 as libc::c_int as uint32_t;
            i += 1;
        }
    }
    if js_resize_array(
        (*s).ctx,
        &mut (*s).idx_to_atom as *mut *mut JSAtom as *mut *mut libc::c_void,
        ::core::mem::size_of::<JSAtom>() as libc::c_ulong as libc::c_int,
        &mut (*s).idx_to_atom_size,
        (*s).idx_to_atom_count + 1 as libc::c_int,
    ) != 0
    {
        *pres = 0 as libc::c_int as uint32_t;
        return -(1 as libc::c_int);
    } else {
        let ref mut fresh594 = (*s).idx_to_atom_count;
        let fresh595 = *fresh594;
        *fresh594 = *fresh594 + 1;
        v = fresh595 as uint32_t;
        *((*s).idx_to_atom).offset(v as isize) = atom.wrapping_add((*s).first_atom);
        v = (v as libc::c_uint).wrapping_add((*s).first_atom) as uint32_t as uint32_t;
        *((*s).atom_to_idx).offset(atom as isize) = v;
        *pres = v;
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn bc_put_atom(
    mut s: *mut BCWriterState,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut v: uint32_t = 0;
    if __JS_AtomIsTaggedInt(atom) != 0 {
        v = __JS_AtomToUInt32(atom) << 1 as libc::c_int
            | 1 as libc::c_int as libc::c_uint;
    } else {
        if bc_atom_to_idx(s, &mut v, atom) != 0 {
            return -(1 as libc::c_int);
        }
        v <<= 1 as libc::c_int;
    }
    bc_put_leb128(s, v);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_byte_swap(mut bc_buf: *mut uint8_t, mut bc_len: libc::c_int) {
    let mut pos: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut fmt: libc::c_int = 0;
    pos = 0 as libc::c_int;
    while pos < bc_len {
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .size as libc::c_int;
        fmt = opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .fmt as libc::c_int;
        match fmt {
            10 | 11 | 12 | 13 | 16 | 17 | 18 => {
                put_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    bswap16(
                        get_u16(
                            bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        ) as uint16_t,
                    ),
                );
            }
            20 | 19 | 21 | 22 | 23 | 24 => {
                put_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    bswap32(
                        get_u32(
                            bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        ),
                    ),
                );
            }
            25 | 28 => {
                put_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    bswap32(
                        get_u32(
                            bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        ),
                    ),
                );
                put_u16(
                    bc_buf
                        .offset(pos as isize)
                        .offset(1 as libc::c_int as isize)
                        .offset(4 as libc::c_int as isize),
                    bswap16(
                        get_u16(
                            bc_buf
                                .offset(pos as isize)
                                .offset(1 as libc::c_int as isize)
                                .offset(4 as libc::c_int as isize),
                        ) as uint16_t,
                    ),
                );
            }
            26 | 27 => {
                put_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    bswap32(
                        get_u32(
                            bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        ),
                    ),
                );
                put_u32(
                    bc_buf
                        .offset(pos as isize)
                        .offset(1 as libc::c_int as isize)
                        .offset(4 as libc::c_int as isize),
                    bswap32(
                        get_u32(
                            bc_buf
                                .offset(pos as isize)
                                .offset(1 as libc::c_int as isize)
                                .offset(4 as libc::c_int as isize),
                        ),
                    ),
                );
                if fmt == OP_FMT_atom_label_u16 as libc::c_int {
                    put_u16(
                        bc_buf
                            .offset(pos as isize)
                            .offset(1 as libc::c_int as isize)
                            .offset(4 as libc::c_int as isize)
                            .offset(4 as libc::c_int as isize),
                        bswap16(
                            get_u16(
                                bc_buf
                                    .offset(pos as isize)
                                    .offset(1 as libc::c_int as isize)
                                    .offset(4 as libc::c_int as isize)
                                    .offset(4 as libc::c_int as isize),
                            ) as uint16_t,
                        ),
                    );
                }
            }
            15 => {
                put_u16(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    bswap16(
                        get_u16(
                            bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        ) as uint16_t,
                    ),
                );
                put_u16(
                    bc_buf
                        .offset(pos as isize)
                        .offset(1 as libc::c_int as isize)
                        .offset(2 as libc::c_int as isize),
                    bswap16(
                        get_u16(
                            bc_buf
                                .offset(pos as isize)
                                .offset(1 as libc::c_int as isize)
                                .offset(2 as libc::c_int as isize),
                        ) as uint16_t,
                    ),
                );
            }
            _ => {}
        }
        pos += len;
    }
}
unsafe extern "C" fn JS_WriteFunctionBytecode(
    mut s: *mut BCWriterState,
    mut bc_buf1: *const uint8_t,
    mut bc_len: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pos: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    let mut bc_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut val: uint32_t = 0;
    bc_buf = js_malloc((*s).ctx, bc_len as size_t) as *mut uint8_t;
    if bc_buf.is_null() {
        return -(1 as libc::c_int);
    }
    memcpy(
        bc_buf as *mut libc::c_void,
        bc_buf1 as *const libc::c_void,
        bc_len as libc::c_ulong,
    );
    pos = 0 as libc::c_int;
    loop {
        if !(pos < bc_len) {
            current_block = 17833034027772472439;
            break;
        }
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .size as libc::c_int;
        match opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .fmt as libc::c_int
        {
            23 | 24 | 25 | 26 | 27 => {
                atom = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if bc_atom_to_idx(s, &mut val, atom) != 0 {
                    current_block = 5884341120434697644;
                    break;
                }
                put_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                    val,
                );
            }
            _ => {}
        }
        pos += len;
    }
    match current_block {
        5884341120434697644 => {
            js_free((*s).ctx, bc_buf as *mut libc::c_void);
            return -(1 as libc::c_int);
        }
        _ => {
            if (*s).byte_swap() != 0 {
                bc_byte_swap(bc_buf, bc_len);
            }
            dbuf_put(&mut (*s).dbuf, bc_buf, bc_len as size_t);
            js_free((*s).ctx, bc_buf as *mut libc::c_void);
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn JS_WriteString(mut s: *mut BCWriterState, mut p: *mut JSString) {
    let mut i: libc::c_int = 0;
    bc_put_leb128(
        s,
        (*p).len() << 1 as libc::c_int | (*p).is_wide_char() as libc::c_uint,
    );
    if (*p).is_wide_char() != 0 {
        i = 0 as libc::c_int;
        while i < (*p).len() as libc::c_int {
            bc_put_u16(s, (*p).u.str16[i as usize]);
            i += 1;
        }
    } else {
        dbuf_put(&mut (*s).dbuf, ((*p).u.str8).as_mut_ptr(), (*p).len() as size_t);
    };
}
unsafe extern "C" fn JS_WriteFunctionTag(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut b: *mut JSFunctionBytecode = obj as intptr_t as *mut libc::c_void
        as *mut JSFunctionBytecode;
    let mut flags: uint32_t = 0;
    let mut idx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE as libc::c_int as uint8_t);
    idx = 0 as libc::c_int;
    flags = idx as uint32_t;
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).has_prototype() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).has_simple_parameter_list() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).is_derived_class_constructor() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).need_home_object() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(&mut flags, &mut idx, (*b).func_kind() as uint32_t, 2 as libc::c_int);
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).new_target_allowed() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).super_call_allowed() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).super_allowed() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).arguments_allowed() as uint32_t,
        1 as libc::c_int,
    );
    bc_set_flags(&mut flags, &mut idx, (*b).has_debug() as uint32_t, 1 as libc::c_int);
    bc_set_flags(
        &mut flags,
        &mut idx,
        (*b).backtrace_barrier() as uint32_t,
        1 as libc::c_int,
    );
    assert((idx <= 16 as libc::c_int) as libc::c_int);
    bc_put_u16(s, flags as uint16_t);
    bc_put_u8(s, (*b).js_mode);
    bc_put_atom(s, (*b).func_name);
    bc_put_leb128(s, (*b).arg_count as uint32_t);
    bc_put_leb128(s, (*b).var_count as uint32_t);
    bc_put_leb128(s, (*b).defined_arg_count as uint32_t);
    bc_put_leb128(s, (*b).stack_size as uint32_t);
    bc_put_leb128(s, (*b).closure_var_count as uint32_t);
    bc_put_leb128(s, (*b).cpool_count as uint32_t);
    bc_put_leb128(s, (*b).byte_code_len as uint32_t);
    if !((*b).vardefs).is_null() {
        bc_put_leb128(
            s,
            ((*b).arg_count as libc::c_int + (*b).var_count as libc::c_int) as uint32_t,
        );
        i = 0 as libc::c_int;
        while i < (*b).arg_count as libc::c_int + (*b).var_count as libc::c_int {
            let mut vd: *mut JSVarDef = &mut *((*b).vardefs).offset(i as isize)
                as *mut JSVarDef;
            bc_put_atom(s, (*vd).var_name);
            bc_put_leb128(s, (*vd).scope_level as uint32_t);
            bc_put_leb128(s, ((*vd).scope_next + 1 as libc::c_int) as uint32_t);
            idx = 0 as libc::c_int;
            flags = idx as uint32_t;
            bc_set_flags(
                &mut flags,
                &mut idx,
                (*vd).var_kind() as uint32_t,
                4 as libc::c_int,
            );
            bc_set_flags(
                &mut flags,
                &mut idx,
                (*vd).is_const() as uint32_t,
                1 as libc::c_int,
            );
            bc_set_flags(
                &mut flags,
                &mut idx,
                (*vd).is_lexical() as uint32_t,
                1 as libc::c_int,
            );
            bc_set_flags(
                &mut flags,
                &mut idx,
                (*vd).is_captured() as uint32_t,
                1 as libc::c_int,
            );
            assert((idx <= 8 as libc::c_int) as libc::c_int);
            bc_put_u8(s, flags as uint8_t);
            i += 1;
        }
    } else {
        bc_put_leb128(s, 0 as libc::c_int as uint32_t);
    }
    i = 0 as libc::c_int;
    while i < (*b).closure_var_count {
        let mut cv: *mut JSClosureVar = &mut *((*b).closure_var).offset(i as isize)
            as *mut JSClosureVar;
        bc_put_atom(s, (*cv).var_name);
        bc_put_leb128(s, (*cv).var_idx as uint32_t);
        idx = 0 as libc::c_int;
        flags = idx as uint32_t;
        bc_set_flags(
            &mut flags,
            &mut idx,
            (*cv).is_local() as uint32_t,
            1 as libc::c_int,
        );
        bc_set_flags(&mut flags, &mut idx, (*cv).is_arg() as uint32_t, 1 as libc::c_int);
        bc_set_flags(
            &mut flags,
            &mut idx,
            (*cv).is_const() as uint32_t,
            1 as libc::c_int,
        );
        bc_set_flags(
            &mut flags,
            &mut idx,
            (*cv).is_lexical() as uint32_t,
            1 as libc::c_int,
        );
        bc_set_flags(
            &mut flags,
            &mut idx,
            (*cv).var_kind() as uint32_t,
            4 as libc::c_int,
        );
        assert((idx <= 8 as libc::c_int) as libc::c_int);
        bc_put_u8(s, flags as uint8_t);
        i += 1;
    }
    if !(JS_WriteFunctionBytecode(s, (*b).byte_code_buf, (*b).byte_code_len) != 0) {
        if (*b).has_debug() != 0 {
            bc_put_atom(s, (*b).debug.filename);
            bc_put_leb128(s, (*b).debug.line_num as uint32_t);
            bc_put_leb128(s, (*b).debug.pc2line_len as uint32_t);
            dbuf_put(
                &mut (*s).dbuf,
                (*b).debug.pc2line_buf,
                (*b).debug.pc2line_len as size_t,
            );
        }
        i = 0 as libc::c_int;
        loop {
            if !(i < (*b).cpool_count) {
                current_block = 17728966195399430138;
                break;
            }
            if JS_WriteObjectRec(s, *((*b).cpool).offset(i as isize)) != 0 {
                current_block = 14387972137502133002;
                break;
            }
            i += 1;
        }
        match current_block {
            14387972137502133002 => {}
            _ => return 0 as libc::c_int,
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_WriteModule(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut m: *mut JSModuleDef = obj as intptr_t as *mut libc::c_void
        as *mut JSModuleDef;
    let mut i: libc::c_int = 0;
    bc_put_u8(s, BC_TAG_MODULE as libc::c_int as uint8_t);
    bc_put_atom(s, (*m).module_name);
    bc_put_leb128(s, (*m).req_module_entries_count as uint32_t);
    i = 0 as libc::c_int;
    while i < (*m).req_module_entries_count {
        let mut rme: *mut JSReqModuleEntry = &mut *((*m).req_module_entries)
            .offset(i as isize) as *mut JSReqModuleEntry;
        bc_put_atom(s, (*rme).module_name);
        i += 1;
    }
    bc_put_leb128(s, (*m).export_entries_count as uint32_t);
    i = 0 as libc::c_int;
    while i < (*m).export_entries_count {
        let mut me: *mut JSExportEntry = &mut *((*m).export_entries).offset(i as isize)
            as *mut JSExportEntry;
        bc_put_u8(s, (*me).export_type as uint8_t);
        if (*me).export_type as libc::c_uint
            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
        {
            bc_put_leb128(s, (*me).u.local.var_idx as uint32_t);
        } else {
            bc_put_leb128(s, (*me).u.req_module_idx as uint32_t);
            bc_put_atom(s, (*me).local_name);
        }
        bc_put_atom(s, (*me).export_name);
        i += 1;
    }
    bc_put_leb128(s, (*m).star_export_entries_count as uint32_t);
    i = 0 as libc::c_int;
    while i < (*m).star_export_entries_count {
        let mut se: *mut JSStarExportEntry = &mut *((*m).star_export_entries)
            .offset(i as isize) as *mut JSStarExportEntry;
        bc_put_leb128(s, (*se).req_module_idx as uint32_t);
        i += 1;
    }
    bc_put_leb128(s, (*m).import_entries_count as uint32_t);
    i = 0 as libc::c_int;
    while i < (*m).import_entries_count {
        let mut mi: *mut JSImportEntry = &mut *((*m).import_entries).offset(i as isize)
            as *mut JSImportEntry;
        bc_put_leb128(s, (*mi).var_idx as uint32_t);
        bc_put_atom(s, (*mi).import_name);
        bc_put_leb128(s, (*mi).req_module_idx as uint32_t);
        i += 1;
    }
    if JS_WriteObjectRec(s, (*m).func_obj) != 0 {
        return -(1 as libc::c_int)
    } else {
        return 0 as libc::c_int
    };
}
unsafe extern "C" fn JS_WriteArray(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut i: uint32_t = 0;
    let mut len: uint32_t = 0;
    let mut val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut is_template: BOOL = 0;
    if (*s).allow_bytecode() != 0
        && ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
    {
        bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT as libc::c_int as uint8_t);
        is_template = TRUE as libc::c_int;
    } else {
        bc_put_u8(s, BC_TAG_ARRAY as libc::c_int as uint8_t);
        is_template = FALSE as libc::c_int;
    }
    if !(js_get_length32((*s).ctx, &mut len, obj) != 0) {
        bc_put_leb128(s, len);
        i = 0 as libc::c_int as uint32_t;
        loop {
            if !(i < len) {
                current_block = 15904375183555213903;
                break;
            }
            val = JS_GetPropertyUint32((*s).ctx, obj, i);
            if JS_IsException(val) != 0 {
                current_block = 7648951849459231996;
                break;
            }
            ret = JS_WriteObjectRec(s, val);
            JS_FreeValue((*s).ctx, val);
            if ret != 0 {
                current_block = 7648951849459231996;
                break;
            }
            i = i.wrapping_add(1);
        }
        match current_block {
            7648951849459231996 => {}
            _ => {
                if is_template != 0 {
                    val = JS_GetProperty(
                        (*s).ctx,
                        obj,
                        JS_ATOM_raw as libc::c_int as JSAtom,
                    );
                    if JS_IsException(val) != 0 {
                        current_block = 7648951849459231996;
                    } else {
                        ret = JS_WriteObjectRec(s, val);
                        JS_FreeValue((*s).ctx, val);
                        if ret != 0 {
                            current_block = 7648951849459231996;
                        } else {
                            current_block = 15768484401365413375;
                        }
                    }
                } else {
                    current_block = 15768484401365413375;
                }
                match current_block {
                    7648951849459231996 => {}
                    _ => return 0 as libc::c_int,
                }
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_WriteObjectTag(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut i: uint32_t = 0;
    let mut prop_count: uint32_t = 0;
    let mut sh: *mut JSShape = 0 as *mut JSShape;
    let mut pr: *mut JSShapeProperty = 0 as *mut JSShapeProperty;
    let mut pass: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    bc_put_u8(s, BC_TAG_OBJECT as libc::c_int as uint8_t);
    prop_count = 0 as libc::c_int as uint32_t;
    sh = (*p).shape;
    pass = 0 as libc::c_int;
    's_33: loop {
        if !(pass < 2 as libc::c_int) {
            current_block = 11298138898191919651;
            break;
        }
        if pass == 1 as libc::c_int {
            bc_put_leb128(s, prop_count);
        }
        i = 0 as libc::c_int as uint32_t;
        pr = get_shape_prop(sh);
        while i < (*sh).prop_count as libc::c_uint {
            atom = (*pr).atom;
            if atom != 0 as libc::c_int as libc::c_uint
                && JS_AtomIsString((*s).ctx, atom) != 0
                && (*pr).flags() as libc::c_int & (1 as libc::c_int) << 2 as libc::c_int
                    != 0
            {
                if (*pr).flags() as libc::c_int & (3 as libc::c_int) << 4 as libc::c_int
                    != 0
                {
                    JS_ThrowTypeError(
                        (*s).ctx,
                        b"only value properties are supported\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 7470893475317519020;
                    break 's_33;
                } else if pass == 0 as libc::c_int {
                    prop_count = prop_count.wrapping_add(1);
                } else {
                    bc_put_atom(s, atom);
                    if JS_WriteObjectRec(s, (*((*p).prop).offset(i as isize)).u.value)
                        != 0
                    {
                        current_block = 7470893475317519020;
                        break 's_33;
                    }
                }
            }
            i = i.wrapping_add(1);
            pr = pr.offset(1);
        }
        pass += 1;
    }
    match current_block {
        11298138898191919651 => return 0 as libc::c_int,
        _ => return -(1 as libc::c_int),
    };
}
unsafe extern "C" fn JS_WriteTypedArray(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut ta: *mut JSTypedArray = (*p).u.typed_array;
    bc_put_u8(s, BC_TAG_TYPED_ARRAY as libc::c_int as uint8_t);
    bc_put_u8(
        s,
        ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            - JS_CLASS_UINT8C_ARRAY as libc::c_int) as uint8_t,
    );
    bc_put_leb128(s, (*p).u.array.count);
    bc_put_leb128(s, (*ta).offset);
    if JS_WriteObjectRec(
        s,
        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*ta).buffer as uintptr_t as libc::c_ulonglong,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_WriteArrayBuffer(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut abuf: *mut JSArrayBuffer = (*p).u.array_buffer;
    if (*abuf).detached != 0 {
        JS_ThrowTypeErrorDetachedArrayBuffer((*s).ctx);
        return -(1 as libc::c_int);
    }
    bc_put_u8(s, BC_TAG_ARRAY_BUFFER as libc::c_int as uint8_t);
    bc_put_leb128(s, (*abuf).byte_length as uint32_t);
    dbuf_put(&mut (*s).dbuf, (*abuf).data, (*abuf).byte_length as size_t);
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_WriteSharedArrayBuffer(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut abuf: *mut JSArrayBuffer = (*p).u.array_buffer;
    assert(((*abuf).detached == 0) as libc::c_int);
    bc_put_u8(s, BC_TAG_SHARED_ARRAY_BUFFER as libc::c_int as uint8_t);
    bc_put_leb128(s, (*abuf).byte_length as uint32_t);
    bc_put_u64(s, (*abuf).data as uintptr_t as uint64_t);
    if js_resize_array(
        (*s).ctx,
        &mut (*s).sab_tab as *mut *mut *mut uint8_t as *mut *mut libc::c_void,
        ::core::mem::size_of::<*mut uint8_t>() as libc::c_ulong as libc::c_int,
        &mut (*s).sab_tab_size,
        (*s).sab_tab_len + 1 as libc::c_int,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    let ref mut fresh596 = (*s).sab_tab_len;
    let fresh597 = *fresh596;
    *fresh596 = *fresh596 + 1;
    let ref mut fresh598 = *((*s).sab_tab).offset(fresh597 as isize);
    *fresh598 = (*abuf).data;
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_WriteObjectRec(
    mut s: *mut BCWriterState,
    mut obj: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut tag: uint32_t = 0;
    if js_check_stack_overflow((*(*s).ctx).rt, 0 as libc::c_int as size_t) != 0 {
        JS_ThrowStackOverflow((*s).ctx);
        return -(1 as libc::c_int);
    }
    tag = JS_VALUE_GET_NORM_TAG(obj) as uint32_t;
    match tag {
        2 => {
            bc_put_u8(s, BC_TAG_NULL as libc::c_int as uint8_t);
            current_block = 5028470053297453708;
        }
        3 => {
            bc_put_u8(s, BC_TAG_UNDEFINED as libc::c_int as uint8_t);
            current_block = 5028470053297453708;
        }
        1 => {
            bc_put_u8(
                s,
                (BC_TAG_BOOL_FALSE as libc::c_int + obj as libc::c_int) as uint8_t,
            );
            current_block = 5028470053297453708;
        }
        0 => {
            bc_put_u8(s, BC_TAG_INT32 as libc::c_int as uint8_t);
            bc_put_sleb128(s, obj as libc::c_int);
            current_block = 5028470053297453708;
        }
        7 => {
            let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
            bc_put_u8(s, BC_TAG_FLOAT64 as libc::c_int as uint8_t);
            u.d = JS_VALUE_GET_FLOAT64(obj);
            bc_put_u64(s, u.u64_0);
            current_block = 5028470053297453708;
        }
        4294967289 => {
            let mut p: *mut JSString = obj as intptr_t as *mut libc::c_void
                as *mut JSString;
            bc_put_u8(s, BC_TAG_STRING as libc::c_int as uint8_t);
            JS_WriteString(s, p);
            current_block = 5028470053297453708;
        }
        4294967294 => {
            if (*s).allow_bytecode() == 0 {
                current_block = 14817499789583438828;
            } else if JS_WriteFunctionTag(s, obj) != 0 {
                current_block = 6942501819942179001;
            } else {
                current_block = 5028470053297453708;
            }
        }
        4294967293 => {
            if (*s).allow_bytecode() == 0 {
                current_block = 14817499789583438828;
            } else if JS_WriteModule(s, obj) != 0 {
                current_block = 6942501819942179001;
            } else {
                current_block = 5028470053297453708;
            }
        }
        4294967295 => {
            let mut p_0: *mut JSObject = obj as intptr_t as *mut libc::c_void
                as *mut JSObject;
            let mut ret: libc::c_int = 0;
            let mut idx: libc::c_int = 0;
            if (*s).allow_reference() != 0 {
                idx = js_object_list_find((*s).ctx, &mut (*s).object_list, p_0);
                if idx >= 0 as libc::c_int {
                    bc_put_u8(s, BC_TAG_OBJECT_REFERENCE as libc::c_int as uint8_t);
                    bc_put_leb128(s, idx as uint32_t);
                    current_block = 5028470053297453708;
                } else if js_object_list_add((*s).ctx, &mut (*s).object_list, p_0) != 0 {
                    current_block = 6942501819942179001;
                } else {
                    current_block = 572715077006366937;
                }
            } else if ((*p_0).c2rust_unnamed.c2rust_unnamed).tmp_mark() != 0 {
                JS_ThrowTypeError(
                    (*s).ctx,
                    b"circular reference\0" as *const u8 as *const libc::c_char,
                );
                current_block = 6942501819942179001;
            } else {
                let ref mut fresh599 = (*p_0).c2rust_unnamed.c2rust_unnamed;
                (*fresh599).set_tmp_mark(1 as libc::c_int as uint8_t);
                current_block = 572715077006366937;
            }
            match current_block {
                6942501819942179001 => {}
                5028470053297453708 => {}
                _ => {
                    match (*p_0).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
                        2 => {
                            ret = JS_WriteArray(s, obj);
                            current_block = 1623252117315916725;
                        }
                        1 => {
                            ret = JS_WriteObjectTag(s, obj);
                            current_block = 1623252117315916725;
                        }
                        19 => {
                            ret = JS_WriteArrayBuffer(s, obj);
                            current_block = 1623252117315916725;
                        }
                        20 => {
                            if (*s).allow_sab() == 0 {
                                current_block = 14817499789583438828;
                            } else {
                                ret = JS_WriteSharedArrayBuffer(s, obj);
                                current_block = 1623252117315916725;
                            }
                        }
                        10 => {
                            bc_put_u8(s, BC_TAG_DATE as libc::c_int as uint8_t);
                            ret = JS_WriteObjectRec(s, (*p_0).u.object_data);
                            current_block = 1623252117315916725;
                        }
                        4 | 5 | 6 => {
                            bc_put_u8(s, BC_TAG_OBJECT_VALUE as libc::c_int as uint8_t);
                            ret = JS_WriteObjectRec(s, (*p_0).u.object_data);
                            current_block = 1623252117315916725;
                        }
                        _ => {
                            if (*p_0).c2rust_unnamed.c2rust_unnamed.class_id
                                as libc::c_int >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                                && (*p_0).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                            {
                                ret = JS_WriteTypedArray(s, obj);
                            } else {
                                JS_ThrowTypeError(
                                    (*s).ctx,
                                    b"unsupported object class\0" as *const u8
                                        as *const libc::c_char,
                                );
                                ret = -(1 as libc::c_int);
                            }
                            current_block = 1623252117315916725;
                        }
                    }
                    match current_block {
                        14817499789583438828 => {}
                        _ => {
                            let ref mut fresh600 = (*p_0).c2rust_unnamed.c2rust_unnamed;
                            (*fresh600).set_tmp_mark(0 as libc::c_int as uint8_t);
                            if ret != 0 {
                                current_block = 6942501819942179001;
                            } else {
                                current_block = 5028470053297453708;
                            }
                        }
                    }
                }
            }
        }
        _ => {
            current_block = 14817499789583438828;
        }
    }
    match current_block {
        14817499789583438828 => {
            JS_ThrowInternalError(
                (*s).ctx,
                b"unsupported tag (%d)\0" as *const u8 as *const libc::c_char,
                tag,
            );
        }
        5028470053297453708 => return 0 as libc::c_int,
        _ => {}
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_WriteObjectAtoms(mut s: *mut BCWriterState) -> libc::c_int {
    let mut rt: *mut JSRuntime = (*(*s).ctx).rt;
    let mut dbuf1: DynBuf = DynBuf {
        buf: 0 as *mut uint8_t,
        size: 0,
        allocated_size: 0,
        error: 0,
        realloc_func: None,
        opaque: 0 as *mut libc::c_void,
    };
    let mut i: libc::c_int = 0;
    let mut atoms_size: libc::c_int = 0;
    let mut version: uint8_t = 0;
    dbuf1 = (*s).dbuf;
    js_dbuf_init((*s).ctx, &mut (*s).dbuf);
    version = 1 as libc::c_int as uint8_t;
    if (*s).byte_swap() != 0 {
        version = (version as libc::c_int ^ 0x40 as libc::c_int) as uint8_t;
    }
    bc_put_u8(s, version);
    bc_put_leb128(s, (*s).idx_to_atom_count as uint32_t);
    i = 0 as libc::c_int;
    while i < (*s).idx_to_atom_count {
        let mut p: *mut JSAtomStruct = *((*rt).atom_array)
            .offset(*((*s).idx_to_atom).offset(i as isize) as isize);
        JS_WriteString(s, p);
        i += 1;
    }
    atoms_size = (*s).dbuf.size as libc::c_int;
    if dbuf_realloc(&mut dbuf1, (dbuf1.size).wrapping_add(atoms_size as libc::c_ulong))
        != 0
    {
        dbuf_free(&mut dbuf1);
        return -(1 as libc::c_int);
    } else {
        memmove(
            (dbuf1.buf).offset(atoms_size as isize) as *mut libc::c_void,
            dbuf1.buf as *const libc::c_void,
            dbuf1.size,
        );
        memcpy(
            dbuf1.buf as *mut libc::c_void,
            (*s).dbuf.buf as *const libc::c_void,
            atoms_size as libc::c_ulong,
        );
        dbuf1
            .size = (dbuf1.size as libc::c_ulong)
            .wrapping_add(atoms_size as libc::c_ulong) as size_t as size_t;
        dbuf_free(&mut (*s).dbuf);
        (*s).dbuf = dbuf1;
        return 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_WriteObject2(
    mut ctx: *mut JSContext,
    mut psize: *mut size_t,
    mut obj: JSValue,
    mut flags: libc::c_int,
    mut psab_tab: *mut *mut *mut uint8_t,
    mut psab_tab_len: *mut size_t,
) -> *mut uint8_t {
    let mut ss: BCWriterState = BCWriterState {
        ctx: 0 as *mut JSContext,
        dbuf: DynBuf {
            buf: 0 as *mut uint8_t,
            size: 0,
            allocated_size: 0,
            error: 0,
            realloc_func: None,
            opaque: 0 as *mut libc::c_void,
        },
        byte_swap_allow_bytecode_allow_sab_allow_reference: [0; 4],
        first_atom: 0,
        atom_to_idx: 0 as *mut uint32_t,
        atom_to_idx_size: 0,
        idx_to_atom: 0 as *mut JSAtom,
        idx_to_atom_count: 0,
        idx_to_atom_size: 0,
        sab_tab: 0 as *mut *mut uint8_t,
        sab_tab_len: 0,
        sab_tab_size: 0,
        object_list: JSObjectList {
            object_tab: 0 as *mut JSObjectListEntry,
            object_count: 0,
            object_size: 0,
            hash_table: 0 as *mut uint32_t,
            hash_size: 0,
        },
    };
    let mut s: *mut BCWriterState = &mut ss;
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<BCWriterState>() as libc::c_ulong,
    );
    let ref mut fresh601 = (*s).ctx;
    *fresh601 = ctx;
    (*s)
        .set_byte_swap(
            (flags & (1 as libc::c_int) << 1 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_allow_bytecode(
            (flags & (1 as libc::c_int) << 0 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_allow_sab(
            (flags & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_allow_reference(
            (flags & (1 as libc::c_int) << 3 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    if (*s).allow_bytecode() != 0 {
        (*s).first_atom = JS_ATOM_END as libc::c_int as uint32_t;
    } else {
        (*s).first_atom = 1 as libc::c_int as uint32_t;
    }
    js_dbuf_init(ctx, &mut (*s).dbuf);
    js_object_list_init(&mut (*s).object_list);
    if !(JS_WriteObjectRec(s, obj) != 0) {
        if !(JS_WriteObjectAtoms(s) != 0) {
            js_object_list_end(ctx, &mut (*s).object_list);
            js_free(ctx, (*s).atom_to_idx as *mut libc::c_void);
            js_free(ctx, (*s).idx_to_atom as *mut libc::c_void);
            *psize = (*s).dbuf.size;
            if !psab_tab.is_null() {
                *psab_tab = (*s).sab_tab;
            }
            if !psab_tab_len.is_null() {
                *psab_tab_len = (*s).sab_tab_len as size_t;
            }
            return (*s).dbuf.buf;
        }
    }
    js_object_list_end(ctx, &mut (*s).object_list);
    js_free(ctx, (*s).atom_to_idx as *mut libc::c_void);
    js_free(ctx, (*s).idx_to_atom as *mut libc::c_void);
    dbuf_free(&mut (*s).dbuf);
    *psize = 0 as libc::c_int as size_t;
    if !psab_tab.is_null() {
        *psab_tab = 0 as *mut *mut uint8_t;
    }
    if !psab_tab_len.is_null() {
        *psab_tab_len = 0 as libc::c_int as size_t;
    }
    return 0 as *mut uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn JS_WriteObject(
    mut ctx: *mut JSContext,
    mut psize: *mut size_t,
    mut obj: JSValue,
    mut flags: libc::c_int,
) -> *mut uint8_t {
    return JS_WriteObject2(
        ctx,
        psize,
        obj,
        flags,
        0 as *mut *mut *mut uint8_t,
        0 as *mut size_t,
    );
}
unsafe extern "C" fn bc_read_error_end(mut s: *mut BCReaderState) -> libc::c_int {
    if (*s).error_state == 0 {
        JS_ThrowSyntaxError(
            (*s).ctx,
            b"read after the end of the buffer\0" as *const u8 as *const libc::c_char,
        );
    }
    let ref mut fresh602 = (*s).error_state;
    *fresh602 = -(1 as libc::c_int);
    return *fresh602;
}
unsafe extern "C" fn bc_get_u8(
    mut s: *mut BCReaderState,
    mut pval: *mut uint8_t,
) -> libc::c_int {
    if ((((*s).buf_end).offset_from((*s).ptr) as libc::c_long)
        < 1 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0
    {
        *pval = 0 as libc::c_int as uint8_t;
        return bc_read_error_end(s);
    }
    let ref mut fresh603 = (*s).ptr;
    let fresh604 = *fresh603;
    *fresh603 = (*fresh603).offset(1);
    *pval = *fresh604;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_u16(
    mut s: *mut BCReaderState,
    mut pval: *mut uint16_t,
) -> libc::c_int {
    if ((((*s).buf_end).offset_from((*s).ptr) as libc::c_long)
        < 2 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0
    {
        *pval = 0 as libc::c_int as uint16_t;
        return bc_read_error_end(s);
    }
    *pval = get_u16((*s).ptr) as uint16_t;
    let ref mut fresh605 = (*s).ptr;
    *fresh605 = (*fresh605).offset(2 as libc::c_int as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_u64(
    mut s: *mut BCReaderState,
    mut pval: *mut uint64_t,
) -> libc::c_int {
    if ((((*s).buf_end).offset_from((*s).ptr) as libc::c_long)
        < 8 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0
    {
        *pval = 0 as libc::c_int as uint64_t;
        return bc_read_error_end(s);
    }
    *pval = get_u64((*s).ptr);
    let ref mut fresh606 = (*s).ptr;
    *fresh606 = (*fresh606).offset(8 as libc::c_int as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_leb128(
    mut s: *mut BCReaderState,
    mut pval: *mut uint32_t,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    ret = get_leb128(pval, (*s).ptr, (*s).buf_end);
    if (ret < 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        return bc_read_error_end(s);
    }
    let ref mut fresh607 = (*s).ptr;
    *fresh607 = (*fresh607).offset(ret as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_sleb128(
    mut s: *mut BCReaderState,
    mut pval: *mut int32_t,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    ret = get_sleb128(pval, (*s).ptr, (*s).buf_end);
    if (ret < 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        return bc_read_error_end(s);
    }
    let ref mut fresh608 = (*s).ptr;
    *fresh608 = (*fresh608).offset(ret as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_leb128_int(
    mut s: *mut BCReaderState,
    mut pval: *mut libc::c_int,
) -> libc::c_int {
    return bc_get_leb128(s, pval as *mut uint32_t);
}
unsafe extern "C" fn bc_get_leb128_u16(
    mut s: *mut BCReaderState,
    mut pval: *mut uint16_t,
) -> libc::c_int {
    let mut val: uint32_t = 0;
    if bc_get_leb128(s, &mut val) != 0 {
        *pval = 0 as libc::c_int as uint16_t;
        return -(1 as libc::c_int);
    }
    *pval = val as uint16_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_buf(
    mut s: *mut BCReaderState,
    mut buf: *mut uint8_t,
    mut buf_len: uint32_t,
) -> libc::c_int {
    if buf_len != 0 as libc::c_int as libc::c_uint {
        if (buf.is_null()
            || (((*s).buf_end).offset_from((*s).ptr) as libc::c_long as libc::c_ulong)
                < buf_len as libc::c_ulong) as libc::c_int as libc::c_long != 0
        {
            return bc_read_error_end(s);
        }
        memcpy(
            buf as *mut libc::c_void,
            (*s).ptr as *const libc::c_void,
            buf_len as libc::c_ulong,
        );
        let ref mut fresh609 = (*s).ptr;
        *fresh609 = (*fresh609).offset(buf_len as isize);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_idx_to_atom(
    mut s: *mut BCReaderState,
    mut patom: *mut JSAtom,
    mut idx: uint32_t,
) -> libc::c_int {
    let mut atom: JSAtom = 0;
    if __JS_AtomIsTaggedInt(idx) != 0 {
        atom = idx;
    } else if idx < (*s).first_atom {
        atom = JS_DupAtom((*s).ctx, idx);
    } else {
        idx = (idx as libc::c_uint).wrapping_sub((*s).first_atom) as uint32_t
            as uint32_t;
        if idx >= (*s).idx_to_atom_count {
            JS_ThrowSyntaxError(
                (*s).ctx,
                b"invalid atom index (pos=%u)\0" as *const u8 as *const libc::c_char,
                ((*s).ptr).offset_from((*s).buf_start) as libc::c_long as libc::c_uint,
            );
            *patom = 0 as libc::c_int as JSAtom;
            let ref mut fresh610 = (*s).error_state;
            *fresh610 = -(1 as libc::c_int);
            return *fresh610;
        }
        atom = JS_DupAtom((*s).ctx, *((*s).idx_to_atom).offset(idx as isize));
    }
    *patom = atom;
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_get_atom(
    mut s: *mut BCReaderState,
    mut patom: *mut JSAtom,
) -> libc::c_int {
    let mut v: uint32_t = 0;
    if bc_get_leb128(s, &mut v) != 0 {
        return -(1 as libc::c_int);
    }
    if v & 1 as libc::c_int as libc::c_uint != 0 {
        *patom = __JS_AtomFromUInt32(v >> 1 as libc::c_int);
        return 0 as libc::c_int;
    } else {
        return bc_idx_to_atom(s, patom, v >> 1 as libc::c_int)
    };
}
unsafe extern "C" fn JS_ReadString(mut s: *mut BCReaderState) -> *mut JSString {
    let mut len: uint32_t = 0;
    let mut size: size_t = 0;
    let mut is_wide_char: BOOL = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    if bc_get_leb128(s, &mut len) != 0 {
        return 0 as *mut JSString;
    }
    is_wide_char = (len & 1 as libc::c_int as libc::c_uint) as BOOL;
    len >>= 1 as libc::c_int;
    p = js_alloc_string((*s).ctx, len as libc::c_int, is_wide_char);
    if p.is_null() {
        (*s).error_state = -(1 as libc::c_int);
        return 0 as *mut JSString;
    }
    size = (len as size_t) << is_wide_char;
    if (((*s).buf_end).offset_from((*s).ptr) as libc::c_long as libc::c_ulong) < size {
        bc_read_error_end(s);
        js_free_string((*(*s).ctx).rt, p);
        return 0 as *mut JSString;
    }
    memcpy(
        ((*p).u.str8).as_mut_ptr() as *mut libc::c_void,
        (*s).ptr as *const libc::c_void,
        size,
    );
    let ref mut fresh611 = (*s).ptr;
    *fresh611 = (*fresh611).offset(size as isize);
    if is_wide_char == 0 {
        (*p).u.str8[size as usize] = '\0' as i32 as uint8_t;
    }
    return p;
}
unsafe extern "C" fn bc_get_flags(
    mut flags: uint32_t,
    mut pidx: *mut libc::c_int,
    mut n: libc::c_int,
) -> uint32_t {
    let mut val: uint32_t = 0;
    val = flags >> *pidx
        & ((1 as libc::c_uint) << n).wrapping_sub(1 as libc::c_int as libc::c_uint);
    *pidx += n;
    return val;
}
unsafe extern "C" fn JS_ReadFunctionBytecode(
    mut s: *mut BCReaderState,
    mut b: *mut JSFunctionBytecode,
    mut byte_code_offset: libc::c_int,
    mut bc_len: uint32_t,
) -> libc::c_int {
    let mut bc_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut pos: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut op: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    let mut idx: uint32_t = 0;
    if (*s).is_rom_data() != 0 {
        if ((((*s).buf_end).offset_from((*s).ptr) as libc::c_long as libc::c_ulong)
            < bc_len as libc::c_ulong) as libc::c_int as libc::c_long != 0
        {
            return bc_read_error_end(s);
        }
        bc_buf = (*s).ptr as *mut uint8_t;
        let ref mut fresh612 = (*s).ptr;
        *fresh612 = (*fresh612).offset(bc_len as isize);
    } else {
        bc_buf = (b as *mut uint8_t).offset(byte_code_offset as isize)
            as *mut libc::c_void as *mut uint8_t;
        if bc_get_buf(s, bc_buf, bc_len) != 0 {
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh613 = (*b).byte_code_buf;
    *fresh613 = bc_buf;
    pos = 0 as libc::c_int;
    while (pos as libc::c_uint) < bc_len {
        op = *bc_buf.offset(pos as isize) as libc::c_int;
        len = opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .size as libc::c_int;
        match opcode_info[(if op >= OP_TEMP_START as libc::c_int {
                op + (OP_TEMP_END as libc::c_int - OP_TEMP_START as libc::c_int)
            } else {
                op
            }) as usize]
            .fmt as libc::c_int
        {
            23 | 24 | 25 | 26 | 27 => {
                idx = get_u32(
                    bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                );
                if (*s).is_rom_data() != 0 {
                    JS_DupAtom((*s).ctx, idx);
                } else {
                    if bc_idx_to_atom(s, &mut atom, idx) != 0 {
                        (*b).byte_code_len = pos;
                        return -(1 as libc::c_int);
                    }
                    put_u32(
                        bc_buf.offset(pos as isize).offset(1 as libc::c_int as isize),
                        atom,
                    );
                }
            }
            _ => {}
        }
        pos += len;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn BC_add_object_ref1(
    mut s: *mut BCReaderState,
    mut p: *mut JSObject,
) -> libc::c_int {
    if (*s).allow_reference() != 0 {
        if js_resize_array(
            (*s).ctx,
            &mut (*s).objects as *mut *mut *mut JSObject as *mut libc::c_void
                as *mut *mut libc::c_void,
            ::core::mem::size_of::<*mut JSObject>() as libc::c_ulong as libc::c_int,
            &mut (*s).objects_size,
            (*s).objects_count + 1 as libc::c_int,
        ) != 0
        {
            return -(1 as libc::c_int);
        }
        let ref mut fresh614 = (*s).objects_count;
        let fresh615 = *fresh614;
        *fresh614 = *fresh614 + 1;
        let ref mut fresh616 = *((*s).objects).offset(fresh615 as isize);
        *fresh616 = p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn BC_add_object_ref(
    mut s: *mut BCReaderState,
    mut obj: JSValue,
) -> libc::c_int {
    return BC_add_object_ref1(s, obj as intptr_t as *mut libc::c_void as *mut JSObject);
}
unsafe extern "C" fn JS_ReadFunctionTag(mut s: *mut BCReaderState) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut bc: JSFunctionBytecode = JSFunctionBytecode {
        header: JSGCObjectHeader {
            ref_count: 0,
            gc_obj_type_mark: [0; 1],
            dummy1: 0,
            dummy2: 0,
            link: list_head {
                prev: 0 as *mut list_head,
                next: 0 as *mut list_head,
            },
        },
        js_mode: 0,
        has_prototype_has_simple_parameter_list_is_derived_class_constructor_need_home_object_func_kind_new_target_allowed_super_call_allowed_super_allowed_arguments_allowed_has_debug_backtrace_barrier_read_only_bytecode: [0; 2],
        c2rust_padding: [0; 1],
        byte_code_buf: 0 as *mut uint8_t,
        byte_code_len: 0,
        func_name: 0,
        vardefs: 0 as *mut JSVarDef,
        closure_var: 0 as *mut JSClosureVar,
        arg_count: 0,
        var_count: 0,
        defined_arg_count: 0,
        stack_size: 0,
        realm: 0 as *mut JSContext,
        cpool: 0 as *mut JSValue,
        cpool_count: 0,
        closure_var_count: 0,
        debug: C2RustUnnamed_9 {
            filename: 0,
            line_num: 0,
            source_len: 0,
            pc2line_len: 0,
            pc2line_buf: 0 as *mut uint8_t,
            source: 0 as *mut libc::c_char,
        },
    };
    let mut b: *mut JSFunctionBytecode = 0 as *mut JSFunctionBytecode;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut v16: uint16_t = 0;
    let mut v8: uint8_t = 0;
    let mut idx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut local_count: libc::c_int = 0;
    let mut function_size: libc::c_int = 0;
    let mut cpool_offset: libc::c_int = 0;
    let mut byte_code_offset: libc::c_int = 0;
    let mut closure_var_offset: libc::c_int = 0;
    let mut vardefs_offset: libc::c_int = 0;
    memset(
        &mut bc as *mut JSFunctionBytecode as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<JSFunctionBytecode>() as libc::c_ulong,
    );
    bc.header.ref_count = 1 as libc::c_int;
    if !(bc_get_u16(s, &mut v16) != 0) {
        idx = 0 as libc::c_int;
        bc.set_has_prototype(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_has_simple_parameter_list(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_is_derived_class_constructor(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_need_home_object(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_func_kind(
            bc_get_flags(v16 as uint32_t, &mut idx, 2 as libc::c_int) as uint8_t,
        );
        bc.set_new_target_allowed(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_super_call_allowed(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_super_allowed(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_arguments_allowed(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_has_debug(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_backtrace_barrier(
            bc_get_flags(v16 as uint32_t, &mut idx, 1 as libc::c_int) as uint8_t,
        );
        bc.set_read_only_bytecode((*s).is_rom_data() as uint8_t);
        if !(bc_get_u8(s, &mut v8) != 0) {
            bc.js_mode = v8;
            if !(bc_get_atom(s, &mut bc.func_name) != 0) {
                if !(bc_get_leb128_u16(s, &mut bc.arg_count) != 0) {
                    if !(bc_get_leb128_u16(s, &mut bc.var_count) != 0) {
                        if !(bc_get_leb128_u16(s, &mut bc.defined_arg_count) != 0) {
                            if !(bc_get_leb128_u16(s, &mut bc.stack_size) != 0) {
                                if !(bc_get_leb128_int(s, &mut bc.closure_var_count) != 0) {
                                    if !(bc_get_leb128_int(s, &mut bc.cpool_count) != 0) {
                                        if !(bc_get_leb128_int(s, &mut bc.byte_code_len) != 0) {
                                            if !(bc_get_leb128_int(s, &mut local_count) != 0) {
                                                if bc.has_debug() != 0 {
                                                    function_size = ::core::mem::size_of::<JSFunctionBytecode>()
                                                        as libc::c_ulong as libc::c_int;
                                                } else {
                                                    function_size = 64 as libc::c_ulong as libc::c_int;
                                                }
                                                cpool_offset = function_size;
                                                function_size = (function_size as libc::c_ulong)
                                                    .wrapping_add(
                                                        (bc.cpool_count as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                                                            ),
                                                    ) as libc::c_int as libc::c_int;
                                                vardefs_offset = function_size;
                                                function_size = (function_size as libc::c_ulong)
                                                    .wrapping_add(
                                                        (local_count as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::core::mem::size_of::<JSVarDef>() as libc::c_ulong,
                                                            ),
                                                    ) as libc::c_int as libc::c_int;
                                                closure_var_offset = function_size;
                                                function_size = (function_size as libc::c_ulong)
                                                    .wrapping_add(
                                                        (bc.closure_var_count as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::core::mem::size_of::<JSClosureVar>() as libc::c_ulong,
                                                            ),
                                                    ) as libc::c_int as libc::c_int;
                                                byte_code_offset = function_size;
                                                if bc.read_only_bytecode() == 0 {
                                                    function_size += bc.byte_code_len;
                                                }
                                                b = js_mallocz(ctx, function_size as size_t)
                                                    as *mut JSFunctionBytecode;
                                                if b.is_null() {
                                                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                                        << 32 as libc::c_int
                                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                                }
                                                memcpy(
                                                    b as *mut libc::c_void,
                                                    &mut bc as *mut JSFunctionBytecode as *const libc::c_void,
                                                    64 as libc::c_ulong,
                                                );
                                                (*b).header.ref_count = 1 as libc::c_int;
                                                if local_count != 0 as libc::c_int {
                                                    let ref mut fresh617 = (*b).vardefs;
                                                    *fresh617 = (b as *mut uint8_t)
                                                        .offset(vardefs_offset as isize) as *mut libc::c_void
                                                        as *mut JSVarDef;
                                                }
                                                if (*b).closure_var_count != 0 as libc::c_int {
                                                    let ref mut fresh618 = (*b).closure_var;
                                                    *fresh618 = (b as *mut uint8_t)
                                                        .offset(closure_var_offset as isize) as *mut libc::c_void
                                                        as *mut JSClosureVar;
                                                }
                                                if (*b).cpool_count != 0 as libc::c_int {
                                                    let ref mut fresh619 = (*b).cpool;
                                                    *fresh619 = (b as *mut uint8_t)
                                                        .offset(cpool_offset as isize) as *mut libc::c_void
                                                        as *mut JSValue;
                                                }
                                                add_gc_object(
                                                    (*ctx).rt,
                                                    &mut (*b).header,
                                                    JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,
                                                );
                                                obj = (JS_TAG_FUNCTION_BYTECODE as libc::c_int as uint64_t)
                                                    << 32 as libc::c_int | b as uintptr_t as libc::c_ulonglong;
                                                if local_count != 0 as libc::c_int {
                                                    i = 0 as libc::c_int;
                                                    loop {
                                                        if !(i < local_count) {
                                                            current_block = 3736434875406665187;
                                                            break;
                                                        }
                                                        let mut vd: *mut JSVarDef = &mut *((*b).vardefs)
                                                            .offset(i as isize) as *mut JSVarDef;
                                                        if bc_get_atom(s, &mut (*vd).var_name) != 0 {
                                                            current_block = 10472951759519272038;
                                                            break;
                                                        }
                                                        if bc_get_leb128_int(s, &mut (*vd).scope_level) != 0 {
                                                            current_block = 10472951759519272038;
                                                            break;
                                                        }
                                                        if bc_get_leb128_int(s, &mut (*vd).scope_next) != 0 {
                                                            current_block = 10472951759519272038;
                                                            break;
                                                        }
                                                        let ref mut fresh620 = (*vd).scope_next;
                                                        *fresh620 -= 1;
                                                        if bc_get_u8(s, &mut v8) != 0 {
                                                            current_block = 10472951759519272038;
                                                            break;
                                                        }
                                                        idx = 0 as libc::c_int;
                                                        (*vd)
                                                            .set_var_kind(
                                                                bc_get_flags(v8 as uint32_t, &mut idx, 4 as libc::c_int)
                                                                    as uint8_t,
                                                            );
                                                        (*vd)
                                                            .set_is_const(
                                                                bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                    as uint8_t,
                                                            );
                                                        (*vd)
                                                            .set_is_lexical(
                                                                bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                    as uint8_t,
                                                            );
                                                        (*vd)
                                                            .set_is_captured(
                                                                bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                    as uint8_t,
                                                            );
                                                        i += 1;
                                                    }
                                                } else {
                                                    current_block = 3736434875406665187;
                                                }
                                                match current_block {
                                                    10472951759519272038 => {}
                                                    _ => {
                                                        if (*b).closure_var_count != 0 as libc::c_int {
                                                            i = 0 as libc::c_int;
                                                            loop {
                                                                if !(i < (*b).closure_var_count) {
                                                                    current_block = 11071260907632769126;
                                                                    break;
                                                                }
                                                                let mut cv: *mut JSClosureVar = &mut *((*b).closure_var)
                                                                    .offset(i as isize) as *mut JSClosureVar;
                                                                let mut var_idx: libc::c_int = 0;
                                                                if bc_get_atom(s, &mut (*cv).var_name) != 0 {
                                                                    current_block = 10472951759519272038;
                                                                    break;
                                                                }
                                                                if bc_get_leb128_int(s, &mut var_idx) != 0 {
                                                                    current_block = 10472951759519272038;
                                                                    break;
                                                                }
                                                                (*cv).var_idx = var_idx as uint16_t;
                                                                if bc_get_u8(s, &mut v8) != 0 {
                                                                    current_block = 10472951759519272038;
                                                                    break;
                                                                }
                                                                idx = 0 as libc::c_int;
                                                                (*cv)
                                                                    .set_is_local(
                                                                        bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                            as uint8_t,
                                                                    );
                                                                (*cv)
                                                                    .set_is_arg(
                                                                        bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                            as uint8_t,
                                                                    );
                                                                (*cv)
                                                                    .set_is_const(
                                                                        bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                            as uint8_t,
                                                                    );
                                                                (*cv)
                                                                    .set_is_lexical(
                                                                        bc_get_flags(v8 as uint32_t, &mut idx, 1 as libc::c_int)
                                                                            as uint8_t,
                                                                    );
                                                                (*cv)
                                                                    .set_var_kind(
                                                                        bc_get_flags(v8 as uint32_t, &mut idx, 4 as libc::c_int)
                                                                            as uint8_t,
                                                                    );
                                                                i += 1;
                                                            }
                                                        } else {
                                                            current_block = 11071260907632769126;
                                                        }
                                                        match current_block {
                                                            10472951759519272038 => {}
                                                            _ => {
                                                                if !(JS_ReadFunctionBytecode(
                                                                    s,
                                                                    b,
                                                                    byte_code_offset,
                                                                    (*b).byte_code_len as uint32_t,
                                                                ) != 0)
                                                                {
                                                                    if (*b).has_debug() != 0 {
                                                                        if bc_get_atom(s, &mut (*b).debug.filename) != 0 {
                                                                            current_block = 10472951759519272038;
                                                                        } else if bc_get_leb128_int(s, &mut (*b).debug.line_num)
                                                                            != 0
                                                                        {
                                                                            current_block = 10472951759519272038;
                                                                        } else if bc_get_leb128_int(s, &mut (*b).debug.pc2line_len)
                                                                            != 0
                                                                        {
                                                                            current_block = 10472951759519272038;
                                                                        } else if (*b).debug.pc2line_len != 0 {
                                                                            let ref mut fresh621 = (*b).debug.pc2line_buf;
                                                                            *fresh621 = js_mallocz(
                                                                                ctx,
                                                                                (*b).debug.pc2line_len as size_t,
                                                                            ) as *mut uint8_t;
                                                                            if ((*b).debug.pc2line_buf).is_null() {
                                                                                current_block = 10472951759519272038;
                                                                            } else if bc_get_buf(
                                                                                s,
                                                                                (*b).debug.pc2line_buf,
                                                                                (*b).debug.pc2line_len as uint32_t,
                                                                            ) != 0
                                                                            {
                                                                                current_block = 10472951759519272038;
                                                                            } else {
                                                                                current_block = 11865390570819897086;
                                                                            }
                                                                        } else {
                                                                            current_block = 11865390570819897086;
                                                                        }
                                                                    } else {
                                                                        current_block = 11865390570819897086;
                                                                    }
                                                                    match current_block {
                                                                        10472951759519272038 => {}
                                                                        _ => {
                                                                            if (*b).cpool_count != 0 as libc::c_int {
                                                                                i = 0 as libc::c_int;
                                                                                loop {
                                                                                    if !(i < (*b).cpool_count) {
                                                                                        current_block = 1739363794695357236;
                                                                                        break;
                                                                                    }
                                                                                    let mut val: JSValue = 0;
                                                                                    val = JS_ReadObjectRec(s);
                                                                                    if JS_IsException(val) != 0 {
                                                                                        current_block = 10472951759519272038;
                                                                                        break;
                                                                                    }
                                                                                    *((*b).cpool).offset(i as isize) = val;
                                                                                    i += 1;
                                                                                }
                                                                            } else {
                                                                                current_block = 1739363794695357236;
                                                                            }
                                                                            match current_block {
                                                                                10472951759519272038 => {}
                                                                                _ => {
                                                                                    let ref mut fresh622 = (*b).realm;
                                                                                    *fresh622 = JS_DupContext(ctx);
                                                                                    return obj;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadModule(mut s: *mut BCReaderState) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut obj: JSValue = 0;
    let mut m: *mut JSModuleDef = 0 as *mut JSModuleDef;
    let mut module_name: JSAtom = 0;
    let mut i: libc::c_int = 0;
    let mut v8: uint8_t = 0;
    if !(bc_get_atom(s, &mut module_name) != 0) {
        m = js_new_module_def(ctx, module_name);
        if !m.is_null() {
            obj = JS_DupValue(
                ctx,
                (JS_TAG_MODULE as libc::c_int as uint64_t) << 32 as libc::c_int
                    | m as uintptr_t as libc::c_ulonglong,
            );
            if !(bc_get_leb128_int(s, &mut (*m).req_module_entries_count) != 0) {
                if (*m).req_module_entries_count != 0 as libc::c_int {
                    (*m).req_module_entries_size = (*m).req_module_entries_count;
                    let ref mut fresh623 = (*m).req_module_entries;
                    *fresh623 = js_mallocz(
                        ctx,
                        (::core::mem::size_of::<JSReqModuleEntry>() as libc::c_ulong)
                            .wrapping_mul((*m).req_module_entries_size as libc::c_ulong),
                    ) as *mut JSReqModuleEntry;
                    if ((*m).req_module_entries).is_null() {
                        current_block = 12799285838808684261;
                    } else {
                        i = 0 as libc::c_int;
                        loop {
                            if !(i < (*m).req_module_entries_count) {
                                current_block = 17833034027772472439;
                                break;
                            }
                            let mut rme: *mut JSReqModuleEntry = &mut *((*m)
                                .req_module_entries)
                                .offset(i as isize) as *mut JSReqModuleEntry;
                            if bc_get_atom(s, &mut (*rme).module_name) != 0 {
                                current_block = 12799285838808684261;
                                break;
                            }
                            i += 1;
                        }
                    }
                } else {
                    current_block = 17833034027772472439;
                }
                match current_block {
                    12799285838808684261 => {}
                    _ => {
                        if !(bc_get_leb128_int(s, &mut (*m).export_entries_count) != 0) {
                            if (*m).export_entries_count != 0 as libc::c_int {
                                (*m).export_entries_size = (*m).export_entries_count;
                                let ref mut fresh624 = (*m).export_entries;
                                *fresh624 = js_mallocz(
                                    ctx,
                                    (::core::mem::size_of::<JSExportEntry>() as libc::c_ulong)
                                        .wrapping_mul((*m).export_entries_size as libc::c_ulong),
                                ) as *mut JSExportEntry;
                                if ((*m).export_entries).is_null() {
                                    current_block = 12799285838808684261;
                                } else {
                                    i = 0 as libc::c_int;
                                    loop {
                                        if !(i < (*m).export_entries_count) {
                                            current_block = 17184638872671510253;
                                            break;
                                        }
                                        let mut me: *mut JSExportEntry = &mut *((*m).export_entries)
                                            .offset(i as isize) as *mut JSExportEntry;
                                        if bc_get_u8(s, &mut v8) != 0 {
                                            current_block = 12799285838808684261;
                                            break;
                                        }
                                        (*me).export_type = v8 as JSExportTypeEnum;
                                        if (*me).export_type as libc::c_uint
                                            == JS_EXPORT_TYPE_LOCAL as libc::c_int as libc::c_uint
                                        {
                                            if bc_get_leb128_int(s, &mut (*me).u.local.var_idx) != 0 {
                                                current_block = 12799285838808684261;
                                                break;
                                            }
                                        } else {
                                            if bc_get_leb128_int(s, &mut (*me).u.req_module_idx) != 0 {
                                                current_block = 12799285838808684261;
                                                break;
                                            }
                                            if bc_get_atom(s, &mut (*me).local_name) != 0 {
                                                current_block = 12799285838808684261;
                                                break;
                                            }
                                        }
                                        if bc_get_atom(s, &mut (*me).export_name) != 0 {
                                            current_block = 12799285838808684261;
                                            break;
                                        }
                                        i += 1;
                                    }
                                }
                            } else {
                                current_block = 17184638872671510253;
                            }
                            match current_block {
                                12799285838808684261 => {}
                                _ => {
                                    if !(bc_get_leb128_int(
                                        s,
                                        &mut (*m).star_export_entries_count,
                                    ) != 0)
                                    {
                                        if (*m).star_export_entries_count != 0 as libc::c_int {
                                            (*m)
                                                .star_export_entries_size = (*m).star_export_entries_count;
                                            let ref mut fresh625 = (*m).star_export_entries;
                                            *fresh625 = js_mallocz(
                                                ctx,
                                                (::core::mem::size_of::<JSStarExportEntry>()
                                                    as libc::c_ulong)
                                                    .wrapping_mul(
                                                        (*m).star_export_entries_size as libc::c_ulong,
                                                    ),
                                            ) as *mut JSStarExportEntry;
                                            if ((*m).star_export_entries).is_null() {
                                                current_block = 12799285838808684261;
                                            } else {
                                                i = 0 as libc::c_int;
                                                loop {
                                                    if !(i < (*m).star_export_entries_count) {
                                                        current_block = 12381812505308290051;
                                                        break;
                                                    }
                                                    let mut se: *mut JSStarExportEntry = &mut *((*m)
                                                        .star_export_entries)
                                                        .offset(i as isize) as *mut JSStarExportEntry;
                                                    if bc_get_leb128_int(s, &mut (*se).req_module_idx) != 0 {
                                                        current_block = 12799285838808684261;
                                                        break;
                                                    }
                                                    i += 1;
                                                }
                                            }
                                        } else {
                                            current_block = 12381812505308290051;
                                        }
                                        match current_block {
                                            12799285838808684261 => {}
                                            _ => {
                                                if !(bc_get_leb128_int(s, &mut (*m).import_entries_count)
                                                    != 0)
                                                {
                                                    if (*m).import_entries_count != 0 as libc::c_int {
                                                        (*m).import_entries_size = (*m).import_entries_count;
                                                        let ref mut fresh626 = (*m).import_entries;
                                                        *fresh626 = js_mallocz(
                                                            ctx,
                                                            (::core::mem::size_of::<JSImportEntry>() as libc::c_ulong)
                                                                .wrapping_mul((*m).import_entries_size as libc::c_ulong),
                                                        ) as *mut JSImportEntry;
                                                        if ((*m).import_entries).is_null() {
                                                            current_block = 12799285838808684261;
                                                        } else {
                                                            i = 0 as libc::c_int;
                                                            loop {
                                                                if !(i < (*m).import_entries_count) {
                                                                    current_block = 9859671972921157070;
                                                                    break;
                                                                }
                                                                let mut mi: *mut JSImportEntry = &mut *((*m).import_entries)
                                                                    .offset(i as isize) as *mut JSImportEntry;
                                                                if bc_get_leb128_int(s, &mut (*mi).var_idx) != 0 {
                                                                    current_block = 12799285838808684261;
                                                                    break;
                                                                }
                                                                if bc_get_atom(s, &mut (*mi).import_name) != 0 {
                                                                    current_block = 12799285838808684261;
                                                                    break;
                                                                }
                                                                if bc_get_leb128_int(s, &mut (*mi).req_module_idx) != 0 {
                                                                    current_block = 12799285838808684261;
                                                                    break;
                                                                }
                                                                i += 1;
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 9859671972921157070;
                                                    }
                                                    match current_block {
                                                        12799285838808684261 => {}
                                                        _ => {
                                                            (*m).func_obj = JS_ReadObjectRec(s);
                                                            if !(JS_IsException((*m).func_obj) != 0) {
                                                                return obj;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if !m.is_null() {
        js_free_module_def(ctx, m);
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadObjectTag(mut s: *mut BCReaderState) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut obj: JSValue = 0;
    let mut prop_count: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut atom: JSAtom = 0;
    let mut val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    obj = JS_NewObject(ctx);
    if !(BC_add_object_ref(s, obj) != 0) {
        if !(bc_get_leb128(s, &mut prop_count) != 0) {
            i = 0 as libc::c_int as uint32_t;
            loop {
                if !(i < prop_count) {
                    current_block = 5143058163439228106;
                    break;
                }
                if bc_get_atom(s, &mut atom) != 0 {
                    current_block = 12053707601639243943;
                    break;
                }
                val = JS_ReadObjectRec(s);
                if JS_IsException(val) != 0 {
                    JS_FreeAtom(ctx, atom);
                    current_block = 12053707601639243943;
                    break;
                } else {
                    ret = JS_DefinePropertyValue(
                        ctx,
                        obj,
                        atom,
                        val,
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int,
                    );
                    JS_FreeAtom(ctx, atom);
                    if ret < 0 as libc::c_int {
                        current_block = 12053707601639243943;
                        break;
                    }
                    i = i.wrapping_add(1);
                }
            }
            match current_block {
                12053707601639243943 => {}
                _ => return obj,
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadArray(
    mut s: *mut BCReaderState,
    mut tag: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut obj: JSValue = 0;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut prop_flags: libc::c_int = 0;
    let mut is_template: BOOL = 0;
    obj = JS_NewArray(ctx);
    if !(BC_add_object_ref(s, obj) != 0) {
        is_template = (tag == BC_TAG_TEMPLATE_OBJECT as libc::c_int) as libc::c_int;
        if !(bc_get_leb128(s, &mut len) != 0) {
            i = 0 as libc::c_int as uint32_t;
            loop {
                if !(i < len) {
                    current_block = 5143058163439228106;
                    break;
                }
                val = JS_ReadObjectRec(s);
                if JS_IsException(val) != 0 {
                    current_block = 14985496230117265215;
                    break;
                }
                if is_template != 0 {
                    prop_flags = (1 as libc::c_int) << 2 as libc::c_int;
                } else {
                    prop_flags = (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int;
                }
                ret = JS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags);
                if ret < 0 as libc::c_int {
                    current_block = 14985496230117265215;
                    break;
                }
                i = i.wrapping_add(1);
            }
            match current_block {
                14985496230117265215 => {}
                _ => {
                    if is_template != 0 {
                        val = JS_ReadObjectRec(s);
                        if JS_IsException(val) != 0 {
                            current_block = 14985496230117265215;
                        } else {
                            if JS_IsUndefined(val) == 0 {
                                ret = JS_DefinePropertyValue(
                                    ctx,
                                    obj,
                                    JS_ATOM_raw as libc::c_int as JSAtom,
                                    val,
                                    0 as libc::c_int,
                                );
                                if ret < 0 as libc::c_int {
                                    current_block = 14985496230117265215;
                                } else {
                                    current_block = 5634871135123216486;
                                }
                            } else {
                                current_block = 5634871135123216486;
                            }
                            match current_block {
                                14985496230117265215 => {}
                                _ => {
                                    JS_PreventExtensions(ctx, obj);
                                    current_block = 2719512138335094285;
                                }
                            }
                        }
                    } else {
                        current_block = 2719512138335094285;
                    }
                    match current_block {
                        14985496230117265215 => {}
                        _ => return obj,
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadTypedArray(mut s: *mut BCReaderState) -> JSValue {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut array_buffer: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut array_tag: uint8_t = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut offset: uint32_t = 0;
    let mut len: uint32_t = 0;
    let mut idx: uint32_t = 0;
    if bc_get_u8(s, &mut array_tag) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if array_tag as libc::c_int
        >= JS_CLASS_FLOAT64_ARRAY as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int
            + 1 as libc::c_int
    {
        return JS_ThrowTypeError(
            ctx,
            b"invalid typed array\0" as *const u8 as *const libc::c_char,
        );
    }
    if bc_get_leb128(s, &mut len) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if bc_get_leb128(s, &mut offset) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    idx = (*s).objects_count as uint32_t;
    if !(BC_add_object_ref1(s, 0 as *mut JSObject) != 0) {
        array_buffer = JS_ReadObjectRec(s);
        if JS_IsException(array_buffer) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if (js_get_array_buffer(ctx, array_buffer)).is_null() {
            JS_FreeValue(ctx, array_buffer);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        args[0 as libc::c_int as usize] = array_buffer;
        args[1 as libc::c_int as usize] = JS_NewInt64(ctx, offset as int64_t);
        args[2 as libc::c_int as usize] = JS_NewInt64(ctx, len as int64_t);
        obj = js_typed_array_constructor(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            3 as libc::c_int,
            args.as_mut_ptr(),
            JS_CLASS_UINT8C_ARRAY as libc::c_int + array_tag as libc::c_int,
        );
        if !(JS_IsException(obj) != 0) {
            if (*s).allow_reference() != 0 {
                let ref mut fresh627 = *((*s).objects).offset(idx as isize);
                *fresh627 = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            }
            JS_FreeValue(ctx, array_buffer);
            return obj;
        }
    }
    JS_FreeValue(ctx, array_buffer);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadArrayBuffer(mut s: *mut BCReaderState) -> JSValue {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut byte_length: uint32_t = 0;
    let mut obj: JSValue = 0;
    if bc_get_leb128(s, &mut byte_length) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if ((((*s).buf_end).offset_from((*s).ptr) as libc::c_long as libc::c_ulong)
        < byte_length as libc::c_ulong) as libc::c_int as libc::c_long != 0
    {
        bc_read_error_end(s);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    obj = JS_NewArrayBufferCopy(ctx, (*s).ptr, byte_length as size_t);
    if !(JS_IsException(obj) != 0) {
        if !(BC_add_object_ref(s, obj) != 0) {
            let ref mut fresh628 = (*s).ptr;
            *fresh628 = (*fresh628).offset(byte_length as isize);
            return obj;
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadSharedArrayBuffer(mut s: *mut BCReaderState) -> JSValue {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut byte_length: uint32_t = 0;
    let mut data_ptr: *mut uint8_t = 0 as *mut uint8_t;
    let mut obj: JSValue = 0;
    let mut u64: uint64_t = 0;
    if bc_get_leb128(s, &mut byte_length) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if bc_get_u64(s, &mut u64) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    data_ptr = u64 as uintptr_t as *mut uint8_t;
    obj = js_array_buffer_constructor3(
        ctx,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        byte_length as uint64_t,
        JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as JSClassID,
        data_ptr,
        None,
        0 as *mut libc::c_void,
        FALSE as libc::c_int,
    );
    if !(JS_IsException(obj) != 0) {
        if !(BC_add_object_ref(s, obj) != 0) {
            return obj;
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadDate(mut s: *mut BCReaderState) -> JSValue {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut val: JSValue = 0;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = JS_ReadObjectRec(s);
    if !(JS_IsException(val) != 0) {
        if JS_IsNumber(val) == 0 {
            JS_ThrowTypeError(
                ctx,
                b"Number tag expected for date\0" as *const u8 as *const libc::c_char,
            );
        } else {
            obj = JS_NewObjectProtoClass(
                ctx,
                *((*ctx).class_proto).offset(JS_CLASS_DATE as libc::c_int as isize),
                JS_CLASS_DATE as libc::c_int as JSClassID,
            );
            if !(JS_IsException(obj) != 0) {
                if !(BC_add_object_ref(s, obj) != 0) {
                    JS_SetObjectData(ctx, obj, val);
                    return obj;
                }
            }
        }
    }
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadObjectValue(mut s: *mut BCReaderState) -> JSValue {
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut val: JSValue = 0;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = JS_ReadObjectRec(s);
    if !(JS_IsException(val) != 0) {
        obj = JS_ToObject(ctx, val);
        if !(JS_IsException(obj) != 0) {
            if !(BC_add_object_ref(s, obj) != 0) {
                JS_FreeValue(ctx, val);
                return obj;
            }
        }
    }
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ReadObjectRec(mut s: *mut BCReaderState) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut tag: uint8_t = 0;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if js_check_stack_overflow((*ctx).rt, 0 as libc::c_int as size_t) != 0 {
        return JS_ThrowStackOverflow(ctx);
    }
    if bc_get_u8(s, &mut tag) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    match tag as libc::c_int {
        1 => {
            obj = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            current_block = 6721012065216013753;
        }
        2 => {
            obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            current_block = 6721012065216013753;
        }
        3 | 4 => {
            obj = JS_NewBool(ctx, tag as libc::c_int - BC_TAG_BOOL_FALSE as libc::c_int);
            current_block = 6721012065216013753;
        }
        5 => {
            let mut val: int32_t = 0;
            if bc_get_sleb128(s, &mut val) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            obj = JS_NewInt32(ctx, val);
            current_block = 6721012065216013753;
        }
        6 => {
            let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
            if bc_get_u64(s, &mut u.u64_0) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            obj = __JS_NewFloat64(ctx, u.d);
            current_block = 6721012065216013753;
        }
        7 => {
            let mut p: *mut JSString = 0 as *mut JSString;
            p = JS_ReadString(s);
            if p.is_null() {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            obj = (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | p as uintptr_t as libc::c_ulonglong;
            current_block = 6721012065216013753;
        }
        14 => {
            if (*s).allow_bytecode() == 0 {
                current_block = 2634587621037286904;
            } else {
                obj = JS_ReadFunctionTag(s);
                current_block = 6721012065216013753;
            }
        }
        15 => {
            if (*s).allow_bytecode() == 0 {
                current_block = 2634587621037286904;
            } else {
                obj = JS_ReadModule(s);
                current_block = 6721012065216013753;
            }
        }
        8 => {
            obj = JS_ReadObjectTag(s);
            current_block = 6721012065216013753;
        }
        9 | 13 => {
            obj = JS_ReadArray(s, tag as libc::c_int);
            current_block = 6721012065216013753;
        }
        16 => {
            obj = JS_ReadTypedArray(s);
            current_block = 6721012065216013753;
        }
        17 => {
            obj = JS_ReadArrayBuffer(s);
            current_block = 6721012065216013753;
        }
        18 => {
            if (*s).allow_sab() == 0 || ((*(*ctx).rt).sab_funcs.sab_dup).is_none() {
                current_block = 2634587621037286904;
            } else {
                obj = JS_ReadSharedArrayBuffer(s);
                current_block = 6721012065216013753;
            }
        }
        19 => {
            obj = JS_ReadDate(s);
            current_block = 6721012065216013753;
        }
        20 => {
            obj = JS_ReadObjectValue(s);
            current_block = 6721012065216013753;
        }
        21 => {
            let mut val_0: uint32_t = 0;
            if (*s).allow_reference() == 0 {
                return JS_ThrowSyntaxError(
                    ctx,
                    b"object references are not allowed\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if bc_get_leb128(s, &mut val_0) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if val_0 >= (*s).objects_count as libc::c_uint {
                return JS_ThrowSyntaxError(
                    ctx,
                    b"invalid object reference (%u >= %u)\0" as *const u8
                        as *const libc::c_char,
                    val_0,
                    (*s).objects_count,
                );
            }
            obj = JS_DupValue(
                ctx,
                (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                    | *((*s).objects).offset(val_0 as isize) as uintptr_t
                        as libc::c_ulonglong,
            );
            current_block = 6721012065216013753;
        }
        _ => {
            current_block = 2634587621037286904;
        }
    }
    match current_block {
        6721012065216013753 => return obj,
        _ => {
            return JS_ThrowSyntaxError(
                ctx,
                b"invalid tag (tag=%d pos=%u)\0" as *const u8 as *const libc::c_char,
                tag as libc::c_int,
                ((*s).ptr).offset_from((*s).buf_start) as libc::c_long as libc::c_uint,
            );
        }
    };
}
unsafe extern "C" fn JS_ReadObjectAtoms(mut s: *mut BCReaderState) -> libc::c_int {
    let mut v8: uint8_t = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    if bc_get_u8(s, &mut v8) != 0 {
        return -(1 as libc::c_int);
    }
    if v8 as libc::c_int != 1 as libc::c_int {
        JS_ThrowSyntaxError(
            (*s).ctx,
            b"invalid version (%d expected=%d)\0" as *const u8 as *const libc::c_char,
            v8 as libc::c_int,
            1 as libc::c_int,
        );
        return -(1 as libc::c_int);
    }
    if bc_get_leb128(s, &mut (*s).idx_to_atom_count) != 0 {
        return -(1 as libc::c_int);
    }
    if (*s).idx_to_atom_count != 0 as libc::c_int as libc::c_uint {
        let ref mut fresh629 = (*s).idx_to_atom;
        *fresh629 = js_mallocz(
            (*s).ctx,
            ((*s).idx_to_atom_count as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<JSAtom>() as libc::c_ulong),
        ) as *mut JSAtom;
        if ((*s).idx_to_atom).is_null() {
            let ref mut fresh630 = (*s).error_state;
            *fresh630 = -(1 as libc::c_int);
            return *fresh630;
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_uint) < (*s).idx_to_atom_count {
        p = JS_ReadString(s);
        if p.is_null() {
            return -(1 as libc::c_int);
        }
        atom = JS_NewAtomStr((*s).ctx, p);
        if atom == 0 as libc::c_int as libc::c_uint {
            let ref mut fresh631 = (*s).error_state;
            *fresh631 = -(1 as libc::c_int);
            return *fresh631;
        }
        *((*s).idx_to_atom).offset(i as isize) = atom;
        if (*s).is_rom_data() != 0
            && atom != (i as libc::c_uint).wrapping_add((*s).first_atom)
        {
            (*s).set_is_rom_data(FALSE as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn bc_reader_free(mut s: *mut BCReaderState) {
    let mut i: libc::c_int = 0;
    if !((*s).idx_to_atom).is_null() {
        i = 0 as libc::c_int;
        while (i as libc::c_uint) < (*s).idx_to_atom_count {
            JS_FreeAtom((*s).ctx, *((*s).idx_to_atom).offset(i as isize));
            i += 1;
        }
        js_free((*s).ctx, (*s).idx_to_atom as *mut libc::c_void);
    }
    js_free((*s).ctx, (*s).objects as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn JS_ReadObject(
    mut ctx: *mut JSContext,
    mut buf: *const uint8_t,
    mut buf_len: size_t,
    mut flags: libc::c_int,
) -> JSValue {
    let mut ss: BCReaderState = BCReaderState {
        ctx: 0 as *mut JSContext,
        buf_start: 0 as *const uint8_t,
        ptr: 0 as *const uint8_t,
        buf_end: 0 as *const uint8_t,
        first_atom: 0,
        idx_to_atom_count: 0,
        idx_to_atom: 0 as *mut JSAtom,
        error_state: 0,
        allow_sab_allow_bytecode_is_rom_data_allow_reference: [0; 4],
        objects: 0 as *mut *mut JSObject,
        objects_count: 0,
        objects_size: 0,
    };
    let mut s: *mut BCReaderState = &mut ss;
    let mut obj: JSValue = 0;
    let ref mut fresh632 = (*ctx).binary_object_count;
    *fresh632 = (*fresh632 as libc::c_int + 1 as libc::c_int) as uint16_t;
    let ref mut fresh633 = (*ctx).binary_object_size;
    *fresh633 = (*fresh633 as libc::c_ulong).wrapping_add(buf_len) as libc::c_int
        as libc::c_int;
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<BCReaderState>() as libc::c_ulong,
    );
    let ref mut fresh634 = (*s).ctx;
    *fresh634 = ctx;
    let ref mut fresh635 = (*s).buf_start;
    *fresh635 = buf;
    let ref mut fresh636 = (*s).buf_end;
    *fresh636 = buf.offset(buf_len as isize);
    let ref mut fresh637 = (*s).ptr;
    *fresh637 = buf;
    (*s)
        .set_allow_bytecode(
            (flags & (1 as libc::c_int) << 0 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_is_rom_data(
            (flags & (1 as libc::c_int) << 1 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_allow_sab(
            (flags & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    (*s)
        .set_allow_reference(
            (flags & (1 as libc::c_int) << 3 as libc::c_int != 0 as libc::c_int)
                as libc::c_int,
        );
    if (*s).allow_bytecode() != 0 {
        (*s).first_atom = JS_ATOM_END as libc::c_int as uint32_t;
    } else {
        (*s).first_atom = 1 as libc::c_int as uint32_t;
    }
    if JS_ReadObjectAtoms(s) != 0 {
        obj = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        obj = JS_ReadObjectRec(s);
    }
    bc_reader_free(s);
    return obj;
}
unsafe extern "C" fn check_function(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    if (JS_IsFunction(ctx, obj) != 0) as libc::c_int as libc::c_long != 0 {
        return 0 as libc::c_int;
    }
    JS_ThrowTypeError(ctx, b"not a function\0" as *const u8 as *const libc::c_char);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn check_exception_free(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    JS_FreeValue(ctx, obj);
    return JS_IsException(obj);
}
unsafe extern "C" fn find_atom(
    mut ctx: *mut JSContext,
    mut name: *const libc::c_char,
) -> JSAtom {
    let mut atom: JSAtom = 0;
    let mut len: libc::c_int = 0;
    if *name as libc::c_int == '[' as i32 {
        name = name.offset(1);
        len = (strlen(name)).wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as libc::c_int;
        atom = JS_ATOM_Symbol_toPrimitive as libc::c_int as JSAtom;
        while atom < JS_ATOM_END as libc::c_int as libc::c_uint {
            let mut p: *mut JSAtomStruct = *((*(*ctx).rt).atom_array)
                .offset(atom as isize);
            let mut str: *mut JSString = p;
            if (*str).len() as libc::c_int == len
                && memcmp(
                    ((*str).u.str8).as_mut_ptr() as *const libc::c_void,
                    name as *const libc::c_void,
                    len as libc::c_ulong,
                ) == 0
            {
                return JS_DupAtom(ctx, atom);
            }
            atom = atom.wrapping_add(1);
        }
        abort();
    } else {
        atom = JS_NewAtom(ctx, name);
    }
    return atom;
}
unsafe extern "C" fn JS_InstantiateFunctionListItem2(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
    mut atom: JSAtom,
    mut opaque: *mut libc::c_void,
) -> JSValue {
    let mut e: *const JSCFunctionListEntry = opaque as *const JSCFunctionListEntry;
    let mut val: JSValue = 0;
    match (*e).def_type as libc::c_int {
        0 => {
            val = JS_NewCFunction2(
                ctx,
                (*e).u.func.cfunc.generic,
                (*e).name,
                (*e).u.func.length as libc::c_int,
                (*e).u.func.cproto as JSCFunctionEnum,
                (*e).magic as libc::c_int,
            );
        }
        3 => {
            val = JS_NewAtomString(ctx, (*e).u.str_0);
        }
        8 => {
            val = JS_NewObject(ctx);
            JS_SetPropertyFunctionList(
                ctx,
                val,
                (*e).u.prop_list.tab,
                (*e).u.prop_list.len,
            );
        }
        _ => {
            abort();
        }
    }
    return val;
}
unsafe extern "C" fn JS_InstantiateFunctionListItem(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
    mut e: *const JSCFunctionListEntry,
) -> libc::c_int {
    let mut val: JSValue = 0;
    let mut prop_flags: libc::c_int = (*e).prop_flags as libc::c_int;
    match (*e).def_type as libc::c_int {
        9 => {
            let mut atom1: JSAtom = find_atom(ctx, (*e).u.alias.name);
            match (*e).u.alias.base {
                -1 => {
                    val = JS_GetProperty(ctx, obj, atom1);
                }
                0 => {
                    val = JS_GetProperty(ctx, (*ctx).global_obj, atom1);
                }
                1 => {
                    val = JS_GetProperty(
                        ctx,
                        *((*ctx).class_proto)
                            .offset(JS_CLASS_ARRAY as libc::c_int as isize),
                        atom1,
                    );
                }
                _ => {
                    abort();
                }
            }
            JS_FreeAtom(ctx, atom1);
            if atom == JS_ATOM_Symbol_toPrimitive as libc::c_int as libc::c_uint {
                prop_flags = (1 as libc::c_int) << 0 as libc::c_int;
            } else if atom == JS_ATOM_Symbol_hasInstance as libc::c_int as libc::c_uint {
                prop_flags = 0 as libc::c_int;
            }
        }
        0 => {
            if atom == JS_ATOM_Symbol_toPrimitive as libc::c_int as libc::c_uint {
                prop_flags = (1 as libc::c_int) << 0 as libc::c_int;
            } else if atom == JS_ATOM_Symbol_hasInstance as libc::c_int as libc::c_uint {
                prop_flags = 0 as libc::c_int;
            }
            JS_DefineAutoInitProperty(
                ctx,
                obj,
                atom,
                JS_AUTOINIT_ID_PROP,
                e as *mut libc::c_void,
                prop_flags,
            );
            return 0 as libc::c_int;
        }
        1 | 2 => {
            let mut getter: JSValue = 0;
            let mut setter: JSValue = 0;
            let mut buf: [libc::c_char; 64] = [0; 64];
            getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if ((*e).u.getset.get.generic).is_some() {
                snprintf(
                    buf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    b"get %s\0" as *const u8 as *const libc::c_char,
                    (*e).name,
                );
                getter = JS_NewCFunction2(
                    ctx,
                    (*e).u.getset.get.generic,
                    buf.as_mut_ptr(),
                    0 as libc::c_int,
                    (if (*e).def_type as libc::c_int == 2 as libc::c_int {
                        JS_CFUNC_getter_magic as libc::c_int
                    } else {
                        JS_CFUNC_getter as libc::c_int
                    }) as JSCFunctionEnum,
                    (*e).magic as libc::c_int,
                );
            }
            setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if ((*e).u.getset.set.generic).is_some() {
                snprintf(
                    buf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    b"set %s\0" as *const u8 as *const libc::c_char,
                    (*e).name,
                );
                setter = JS_NewCFunction2(
                    ctx,
                    (*e).u.getset.set.generic,
                    buf.as_mut_ptr(),
                    1 as libc::c_int,
                    (if (*e).def_type as libc::c_int == 2 as libc::c_int {
                        JS_CFUNC_setter_magic as libc::c_int
                    } else {
                        JS_CFUNC_setter as libc::c_int
                    }) as JSCFunctionEnum,
                    (*e).magic as libc::c_int,
                );
            }
            JS_DefinePropertyGetSet(ctx, obj, atom, getter, setter, prop_flags);
            return 0 as libc::c_int;
        }
        4 => {
            val = JS_NewInt32(ctx, (*e).u.i32_0);
        }
        5 => {
            val = JS_NewInt64(ctx, (*e).u.i64_0);
        }
        6 => {
            val = __JS_NewFloat64(ctx, (*e).u.f64_0);
        }
        7 => {
            val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        3 | 8 => {
            JS_DefineAutoInitProperty(
                ctx,
                obj,
                atom,
                JS_AUTOINIT_ID_PROP,
                e as *mut libc::c_void,
                prop_flags,
            );
            return 0 as libc::c_int;
        }
        _ => {
            abort();
        }
    }
    JS_DefinePropertyValue(ctx, obj, atom, val, prop_flags);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetPropertyFunctionList(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut tab: *const JSCFunctionListEntry,
    mut len: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        let mut e: *const JSCFunctionListEntry = &*tab.offset(i as isize)
            as *const JSCFunctionListEntry;
        let mut atom: JSAtom = find_atom(ctx, (*e).name);
        JS_InstantiateFunctionListItem(ctx, obj, atom, e);
        JS_FreeAtom(ctx, atom);
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn JS_AddModuleExportList(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut tab: *const JSCFunctionListEntry,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        if JS_AddModuleExport(ctx, m, (*tab.offset(i as isize)).name) != 0 {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetModuleExportList(
    mut ctx: *mut JSContext,
    mut m: *mut JSModuleDef,
    mut tab: *const JSCFunctionListEntry,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut val: JSValue = 0;
    i = 0 as libc::c_int;
    while i < len {
        let mut e: *const JSCFunctionListEntry = &*tab.offset(i as isize)
            as *const JSCFunctionListEntry;
        match (*e).def_type as libc::c_int {
            0 => {
                val = JS_NewCFunction2(
                    ctx,
                    (*e).u.func.cfunc.generic,
                    (*e).name,
                    (*e).u.func.length as libc::c_int,
                    (*e).u.func.cproto as JSCFunctionEnum,
                    (*e).magic as libc::c_int,
                );
            }
            3 => {
                val = JS_NewString(ctx, (*e).u.str_0);
            }
            4 => {
                val = JS_NewInt32(ctx, (*e).u.i32_0);
            }
            5 => {
                val = JS_NewInt64(ctx, (*e).u.i64_0);
            }
            6 => {
                val = __JS_NewFloat64(ctx, (*e).u.f64_0);
            }
            8 => {
                val = JS_NewObject(ctx);
                JS_SetPropertyFunctionList(
                    ctx,
                    val,
                    (*e).u.prop_list.tab,
                    (*e).u.prop_list.len,
                );
            }
            _ => {
                abort();
            }
        }
        if JS_SetModuleExport(ctx, m, (*e).name, val) != 0 {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn JS_SetConstructor2(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut proto: JSValue,
    mut proto_flags: libc::c_int,
    mut ctor_flags: libc::c_int,
) {
    JS_DefinePropertyValue(
        ctx,
        func_obj,
        JS_ATOM_prototype as libc::c_int as JSAtom,
        JS_DupValue(ctx, proto),
        proto_flags,
    );
    JS_DefinePropertyValue(
        ctx,
        proto,
        JS_ATOM_constructor as libc::c_int as JSAtom,
        JS_DupValue(ctx, func_obj),
        ctor_flags,
    );
    set_cycle_flag(ctx, func_obj);
    set_cycle_flag(ctx, proto);
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetConstructor(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut proto: JSValue,
) {
    JS_SetConstructor2(
        ctx,
        func_obj,
        proto,
        0 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
}
unsafe extern "C" fn JS_NewGlobalCConstructor2(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut name: *const libc::c_char,
    mut proto: JSValue,
) {
    JS_DefinePropertyValueStr(
        ctx,
        (*ctx).global_obj,
        name,
        JS_DupValue(ctx, func_obj),
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_SetConstructor(ctx, func_obj, proto);
    JS_FreeValue(ctx, func_obj);
}
unsafe extern "C" fn JS_NewGlobalCConstructor(
    mut ctx: *mut JSContext,
    mut name: *const libc::c_char,
    mut func: Option::<JSCFunction>,
    mut length: libc::c_int,
    mut proto: JSValue,
) -> JSValue {
    let mut func_obj: JSValue = 0;
    func_obj = JS_NewCFunction2(
        ctx,
        func,
        name,
        length,
        JS_CFUNC_constructor_or_func,
        0 as libc::c_int,
    );
    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
    return func_obj;
}
unsafe extern "C" fn JS_NewGlobalCConstructorOnly(
    mut ctx: *mut JSContext,
    mut name: *const libc::c_char,
    mut func: Option::<JSCFunction>,
    mut length: libc::c_int,
    mut proto: JSValue,
) -> JSValue {
    let mut func_obj: JSValue = 0;
    func_obj = JS_NewCFunction2(
        ctx,
        func,
        name,
        length,
        JS_CFUNC_constructor,
        0 as libc::c_int,
    );
    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
    return func_obj;
}
unsafe extern "C" fn js_global_eval(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_EvalObject(
        ctx,
        (*ctx).global_obj,
        *argv.offset(0 as libc::c_int as isize),
        (3 as libc::c_int) << 0 as libc::c_int,
        -(1 as libc::c_int),
    );
}
unsafe extern "C" fn js_global_isNaN(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut d: libc::c_double = 0.;
    if (JS_ToFloat64(ctx, &mut d, *argv.offset(0 as libc::c_int as isize)) != 0)
        as libc::c_int as libc::c_long != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewBool(ctx, isnan(d));
}
unsafe extern "C" fn js_global_isFinite(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut res: BOOL = 0;
    let mut d: libc::c_double = 0.;
    if (JS_ToFloat64(ctx, &mut d, *argv.offset(0 as libc::c_int as isize)) != 0)
        as libc::c_int as libc::c_long != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    res = isfinite(d);
    return JS_NewBool(ctx, res);
}
unsafe extern "C" fn JS_ToObject(mut ctx: *mut JSContext, mut val: JSValue) -> JSValue {
    let mut tag: libc::c_int = JS_VALUE_GET_NORM_TAG(val);
    let mut obj: JSValue = 0;
    match tag {
        -1 | 6 => return JS_DupValue(ctx, val),
        0 | 7 => {
            obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER as libc::c_int);
        }
        -7 => {
            let mut p1: *mut JSString = val as intptr_t as *mut libc::c_void
                as *mut JSString;
            obj = JS_NewObjectClass(ctx, JS_CLASS_STRING as libc::c_int);
            JS_DefinePropertyValue(
                ctx,
                obj,
                JS_ATOM_length as libc::c_int as JSAtom,
                JS_NewInt32(ctx, (*p1).len() as int32_t),
                0 as libc::c_int,
            );
        }
        1 => {
            obj = JS_NewObjectClass(ctx, JS_CLASS_BOOLEAN as libc::c_int);
        }
        -8 => {
            obj = JS_NewObjectClass(ctx, JS_CLASS_SYMBOL as libc::c_int);
        }
        2 | 3 | _ => {
            return JS_ThrowTypeError(
                ctx,
                b"cannot convert to object\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if JS_IsException(obj) == 0 {
        JS_SetObjectData(ctx, obj, JS_DupValue(ctx, val));
    }
    return obj;
}
unsafe extern "C" fn JS_ToObjectFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    let mut obj: JSValue = JS_ToObject(ctx, val);
    JS_FreeValue(ctx, val);
    return obj;
}
unsafe extern "C" fn js_obj_to_desc(
    mut ctx: *mut JSContext,
    mut d: *mut JSPropertyDescriptor,
    mut desc: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut getter: JSValue = 0;
    let mut setter: JSValue = 0;
    let mut flags: libc::c_int = 0;
    if JS_IsObject(desc) == 0 {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    flags = 0 as libc::c_int;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if JS_HasProperty(ctx, desc, JS_ATOM_configurable as libc::c_int as JSAtom) != 0 {
        let mut prop: JSValue = JS_GetProperty(
            ctx,
            desc,
            JS_ATOM_configurable as libc::c_int as JSAtom,
        );
        if JS_IsException(prop) != 0 {
            current_block = 3745119261685168996;
        } else {
            flags |= (1 as libc::c_int) << 8 as libc::c_int;
            if JS_ToBoolFree(ctx, prop) != 0 {
                flags |= (1 as libc::c_int) << 0 as libc::c_int;
            }
            current_block = 12800627514080957624;
        }
    } else {
        current_block = 12800627514080957624;
    }
    match current_block {
        12800627514080957624 => {
            if JS_HasProperty(ctx, desc, JS_ATOM_writable as libc::c_int as JSAtom) != 0
            {
                let mut prop_0: JSValue = JS_GetProperty(
                    ctx,
                    desc,
                    JS_ATOM_writable as libc::c_int as JSAtom,
                );
                if JS_IsException(prop_0) != 0 {
                    current_block = 3745119261685168996;
                } else {
                    flags |= (1 as libc::c_int) << 9 as libc::c_int;
                    if JS_ToBoolFree(ctx, prop_0) != 0 {
                        flags |= (1 as libc::c_int) << 1 as libc::c_int;
                    }
                    current_block = 7175849428784450219;
                }
            } else {
                current_block = 7175849428784450219;
            }
            match current_block {
                3745119261685168996 => {}
                _ => {
                    if JS_HasProperty(
                        ctx,
                        desc,
                        JS_ATOM_enumerable as libc::c_int as JSAtom,
                    ) != 0
                    {
                        let mut prop_1: JSValue = JS_GetProperty(
                            ctx,
                            desc,
                            JS_ATOM_enumerable as libc::c_int as JSAtom,
                        );
                        if JS_IsException(prop_1) != 0 {
                            current_block = 3745119261685168996;
                        } else {
                            flags |= (1 as libc::c_int) << 10 as libc::c_int;
                            if JS_ToBoolFree(ctx, prop_1) != 0 {
                                flags |= (1 as libc::c_int) << 2 as libc::c_int;
                            }
                            current_block = 16203760046146113240;
                        }
                    } else {
                        current_block = 16203760046146113240;
                    }
                    match current_block {
                        3745119261685168996 => {}
                        _ => {
                            if JS_HasProperty(
                                ctx,
                                desc,
                                JS_ATOM_value as libc::c_int as JSAtom,
                            ) != 0
                            {
                                flags |= (1 as libc::c_int) << 13 as libc::c_int;
                                val = JS_GetProperty(
                                    ctx,
                                    desc,
                                    JS_ATOM_value as libc::c_int as JSAtom,
                                );
                                if JS_IsException(val) != 0 {
                                    current_block = 3745119261685168996;
                                } else {
                                    current_block = 5689316957504528238;
                                }
                            } else {
                                current_block = 5689316957504528238;
                            }
                            match current_block {
                                3745119261685168996 => {}
                                _ => {
                                    if JS_HasProperty(
                                        ctx,
                                        desc,
                                        JS_ATOM_get as libc::c_int as JSAtom,
                                    ) != 0
                                    {
                                        flags |= (1 as libc::c_int) << 11 as libc::c_int;
                                        getter = JS_GetProperty(
                                            ctx,
                                            desc,
                                            JS_ATOM_get as libc::c_int as JSAtom,
                                        );
                                        if JS_IsException(getter) != 0
                                            || !(JS_IsUndefined(getter) != 0
                                                || JS_IsFunction(ctx, getter) != 0)
                                        {
                                            JS_ThrowTypeError(
                                                ctx,
                                                b"invalid getter\0" as *const u8 as *const libc::c_char,
                                            );
                                            current_block = 3745119261685168996;
                                        } else {
                                            current_block = 7828949454673616476;
                                        }
                                    } else {
                                        current_block = 7828949454673616476;
                                    }
                                    match current_block {
                                        3745119261685168996 => {}
                                        _ => {
                                            if JS_HasProperty(
                                                ctx,
                                                desc,
                                                JS_ATOM_set as libc::c_int as JSAtom,
                                            ) != 0
                                            {
                                                flags |= (1 as libc::c_int) << 12 as libc::c_int;
                                                setter = JS_GetProperty(
                                                    ctx,
                                                    desc,
                                                    JS_ATOM_set as libc::c_int as JSAtom,
                                                );
                                                if JS_IsException(setter) != 0
                                                    || !(JS_IsUndefined(setter) != 0
                                                        || JS_IsFunction(ctx, setter) != 0)
                                                {
                                                    JS_ThrowTypeError(
                                                        ctx,
                                                        b"invalid setter\0" as *const u8 as *const libc::c_char,
                                                    );
                                                    current_block = 3745119261685168996;
                                                } else {
                                                    current_block = 17784502470059252271;
                                                }
                                            } else {
                                                current_block = 17784502470059252271;
                                            }
                                            match current_block {
                                                3745119261685168996 => {}
                                                _ => {
                                                    if flags
                                                        & ((1 as libc::c_int) << 12 as libc::c_int
                                                            | (1 as libc::c_int) << 11 as libc::c_int) != 0
                                                        && flags
                                                            & ((1 as libc::c_int) << 13 as libc::c_int
                                                                | (1 as libc::c_int) << 9 as libc::c_int) != 0
                                                    {
                                                        JS_ThrowTypeError(
                                                            ctx,
                                                            b"cannot have setter/getter and value or writable\0"
                                                                as *const u8 as *const libc::c_char,
                                                        );
                                                    } else {
                                                        (*d).flags = flags;
                                                        (*d).value = val;
                                                        (*d).getter = getter;
                                                        (*d).setter = setter;
                                                        return 0 as libc::c_int;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, getter);
    JS_FreeValue(ctx, setter);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_DefinePropertyDesc(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
    mut desc: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut d: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut ret: libc::c_int = 0;
    if js_obj_to_desc(ctx, &mut d, desc) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    ret = JS_DefineProperty(
        ctx,
        obj,
        prop,
        d.value,
        d.getter,
        d.setter,
        d.flags | flags,
    );
    js_free_desc(ctx, &mut d);
    return ret;
}
unsafe extern "C" fn JS_ObjectDefineProperties(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut properties: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut props: JSValue = 0;
    let mut desc: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut atoms: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut ret: libc::c_int = -(1 as libc::c_int);
    if JS_IsObject(obj) == 0 {
        JS_ThrowTypeErrorNotAnObject(ctx);
        return -(1 as libc::c_int);
    }
    desc = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    props = JS_ToObject(ctx, properties);
    if JS_IsException(props) != 0 {
        return -(1 as libc::c_int);
    }
    p = props as intptr_t as *mut libc::c_void as *mut JSObject;
    if !(JS_GetOwnPropertyNamesInternal(
        ctx,
        &mut atoms,
        &mut len,
        p,
        (1 as libc::c_int) << 4 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int,
    ) < 0 as libc::c_int)
    {
        i = 0 as libc::c_int as uint32_t;
        loop {
            if !(i < len) {
                current_block = 6009453772311597924;
                break;
            }
            JS_FreeValue(ctx, desc);
            desc = JS_GetProperty(ctx, props, (*atoms.offset(i as isize)).atom);
            if JS_IsException(desc) != 0 {
                current_block = 2804925450633090041;
                break;
            }
            if JS_DefinePropertyDesc(
                ctx,
                obj,
                (*atoms.offset(i as isize)).atom,
                desc,
                (1 as libc::c_int) << 14 as libc::c_int,
            ) < 0 as libc::c_int
            {
                current_block = 2804925450633090041;
                break;
            }
            i = i.wrapping_add(1);
        }
        match current_block {
            2804925450633090041 => {}
            _ => {
                ret = 0 as libc::c_int;
            }
        }
    }
    js_free_prop_enum(ctx, atoms, len);
    JS_FreeValue(ctx, props);
    JS_FreeValue(ctx, desc);
    return ret;
}
unsafe extern "C" fn js_object_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ret: JSValue = 0;
    if JS_IsUndefined(new_target) == 0
        && new_target as intptr_t as *mut libc::c_void as *mut JSObject
            != JS_GetActiveFunction(ctx) as intptr_t as *mut libc::c_void
                as *mut JSObject
    {
        ret = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT as libc::c_int);
    } else {
        let mut tag: libc::c_int = JS_VALUE_GET_NORM_TAG(
            *argv.offset(0 as libc::c_int as isize),
        );
        match tag {
            2 | 3 => {
                ret = JS_NewObject(ctx);
            }
            _ => {
                ret = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
            }
        }
    }
    return ret;
}
unsafe extern "C" fn js_object_create(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut proto: JSValue = 0;
    let mut props: JSValue = 0;
    let mut obj: JSValue = 0;
    proto = *argv.offset(0 as libc::c_int as isize);
    if JS_IsObject(proto) == 0 && JS_IsNull(proto) == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"not a prototype\0" as *const u8 as *const libc::c_char,
        );
    }
    obj = JS_NewObjectProto(ctx, proto);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    props = *argv.offset(1 as libc::c_int as isize);
    if JS_IsUndefined(props) == 0 {
        if JS_ObjectDefineProperties(ctx, obj, props) != 0 {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    return obj;
}
unsafe extern "C" fn js_object_getPrototypeOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut val: JSValue = 0;
    val = *argv.offset(0 as libc::c_int as isize);
    if (val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        if magic != 0
            || (val >> 32 as libc::c_int) as libc::c_int == JS_TAG_NULL as libc::c_int
            || (val >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_UNDEFINED as libc::c_int
        {
            return JS_ThrowTypeErrorNotAnObject(ctx);
        }
    }
    return JS_GetPrototype(ctx, val);
}
unsafe extern "C" fn js_object_setPrototypeOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    if JS_SetPrototypeInternal(
        ctx,
        obj,
        *argv.offset(1 as libc::c_int as isize),
        TRUE as libc::c_int,
    ) < 0 as libc::c_int
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_DupValue(ctx, obj);
}
unsafe extern "C" fn js_object_defineProperty(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut desc: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut flags: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    prop = *argv.offset(1 as libc::c_int as isize);
    desc = *argv.offset(2 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    atom = JS_ValueToAtom(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    flags = 0 as libc::c_int;
    if magic == 0 {
        flags |= (1 as libc::c_int) << 14 as libc::c_int;
    }
    ret = JS_DefinePropertyDesc(ctx, obj, atom, desc, flags);
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else if magic != 0 {
        return JS_NewBool(ctx, ret)
    } else {
        return JS_DupValue(ctx, obj)
    };
}
unsafe extern "C" fn js_object_defineProperties(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = *argv.offset(0 as libc::c_int as isize);
    if JS_ObjectDefineProperties(ctx, obj, *argv.offset(1 as libc::c_int as isize)) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_DupValue(ctx, obj)
    };
}
unsafe extern "C" fn js_object___defineGetter__(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut value: JSValue = 0;
    let mut get: JSValue = 0;
    let mut set: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut flags: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    prop = *argv.offset(0 as libc::c_int as isize);
    value = *argv.offset(1 as libc::c_int as isize);
    obj = JS_ToObject(ctx, this_val);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if check_function(ctx, value) != 0 {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    atom = JS_ValueToAtom(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    flags = (1 as libc::c_int) << 14 as libc::c_int
        | (1 as libc::c_int) << 10 as libc::c_int
        | (1 as libc::c_int) << 2 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int
        | (1 as libc::c_int) << 0 as libc::c_int;
    if magic != 0 {
        get = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        set = value;
        flags |= (1 as libc::c_int) << 12 as libc::c_int;
    } else {
        get = value;
        set = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        flags |= (1 as libc::c_int) << 11 as libc::c_int;
    }
    ret = JS_DefineProperty(
        ctx,
        obj,
        atom,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        get,
        set,
        flags,
    );
    JS_FreeValue(ctx, obj);
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    };
}
unsafe extern "C" fn js_object_getOwnPropertyDescriptor(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut prop: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut res: libc::c_int = 0;
    let mut flags: libc::c_int = 0;
    if magic != 0 {
        if (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
            != JS_TAG_OBJECT as libc::c_int
        {
            return JS_ThrowTypeErrorNotAnObject(ctx);
        }
        obj = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
    } else {
        obj = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
        if JS_IsException(obj) != 0 {
            return obj;
        }
    }
    prop = *argv.offset(1 as libc::c_int as isize);
    atom = JS_ValueToAtom(ctx, prop);
    if !((atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0)
    {
        ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
            res = JS_GetOwnPropertyInternal(
                ctx,
                &mut desc,
                obj as intptr_t as *mut libc::c_void as *mut JSObject,
                atom,
            );
            if res < 0 as libc::c_int {
                current_block = 17665172395664986280;
            } else if res != 0 {
                ret = JS_NewObject(ctx);
                if JS_IsException(ret) != 0 {
                    current_block = 17950624495473614900;
                } else {
                    flags = (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int
                        | (1 as libc::c_int) << 14 as libc::c_int;
                    if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                        if JS_DefinePropertyValue(
                            ctx,
                            ret,
                            JS_ATOM_get as libc::c_int as JSAtom,
                            JS_DupValue(ctx, desc.getter),
                            flags,
                        ) < 0 as libc::c_int
                            || JS_DefinePropertyValue(
                                ctx,
                                ret,
                                JS_ATOM_set as libc::c_int as JSAtom,
                                JS_DupValue(ctx, desc.setter),
                                flags,
                            ) < 0 as libc::c_int
                        {
                            current_block = 17950624495473614900;
                        } else {
                            current_block = 16203760046146113240;
                        }
                    } else if JS_DefinePropertyValue(
                        ctx,
                        ret,
                        JS_ATOM_value as libc::c_int as JSAtom,
                        JS_DupValue(ctx, desc.value),
                        flags,
                    ) < 0 as libc::c_int
                        || JS_DefinePropertyValue(
                            ctx,
                            ret,
                            JS_ATOM_writable as libc::c_int as JSAtom,
                            JS_NewBool(
                                ctx,
                                (desc.flags & (1 as libc::c_int) << 1 as libc::c_int
                                    != 0 as libc::c_int) as libc::c_int,
                            ),
                            flags,
                        ) < 0 as libc::c_int
                    {
                        current_block = 17950624495473614900;
                    } else {
                        current_block = 16203760046146113240;
                    }
                    match current_block {
                        17950624495473614900 => {}
                        _ => {
                            if JS_DefinePropertyValue(
                                ctx,
                                ret,
                                JS_ATOM_enumerable as libc::c_int as JSAtom,
                                JS_NewBool(
                                    ctx,
                                    (desc.flags & (1 as libc::c_int) << 2 as libc::c_int
                                        != 0 as libc::c_int) as libc::c_int,
                                ),
                                flags,
                            ) < 0 as libc::c_int
                                || JS_DefinePropertyValue(
                                    ctx,
                                    ret,
                                    JS_ATOM_configurable as libc::c_int as JSAtom,
                                    JS_NewBool(
                                        ctx,
                                        (desc.flags & (1 as libc::c_int) << 0 as libc::c_int
                                            != 0 as libc::c_int) as libc::c_int,
                                    ),
                                    flags,
                                ) < 0 as libc::c_int
                            {
                                current_block = 17950624495473614900;
                            } else {
                                js_free_desc(ctx, &mut desc);
                                current_block = 16924917904204750491;
                            }
                        }
                    }
                }
                match current_block {
                    16924917904204750491 => {}
                    _ => {
                        js_free_desc(ctx, &mut desc);
                        JS_FreeValue(ctx, ret);
                        current_block = 17665172395664986280;
                    }
                }
            } else {
                current_block = 16924917904204750491;
            }
        } else {
            current_block = 16924917904204750491;
        }
        match current_block {
            17665172395664986280 => {}
            _ => {
                JS_FreeAtom(ctx, atom);
                JS_FreeValue(ctx, obj);
                return ret;
            }
        }
    }
    JS_FreeAtom(ctx, atom);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_object_getOwnPropertyDescriptors(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut r: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut props: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    r = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if !(JS_GetOwnPropertyNamesInternal(
        ctx,
        &mut props,
        &mut len,
        p,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int,
    ) != 0)
    {
        r = JS_NewObject(ctx);
        if !(JS_IsException(r) != 0) {
            i = 0 as libc::c_int as uint32_t;
            loop {
                if !(i < len) {
                    current_block = 14576567515993809846;
                    break;
                }
                let mut atomValue: JSValue = 0;
                let mut desc: JSValue = 0;
                let mut args: [JSValue; 2] = [0; 2];
                atomValue = JS_AtomToValue(ctx, (*props.offset(i as isize)).atom);
                if JS_IsException(atomValue) != 0 {
                    current_block = 12882712674866931258;
                    break;
                }
                args[0 as libc::c_int as usize] = obj;
                args[1 as libc::c_int as usize] = atomValue;
                desc = js_object_getOwnPropertyDescriptor(
                    ctx,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    2 as libc::c_int,
                    args.as_mut_ptr(),
                    0 as libc::c_int,
                );
                JS_FreeValue(ctx, atomValue);
                if JS_IsException(desc) != 0 {
                    current_block = 12882712674866931258;
                    break;
                }
                if JS_IsUndefined(desc) == 0 {
                    if JS_DefinePropertyValue(
                        ctx,
                        r,
                        (*props.offset(i as isize)).atom,
                        desc,
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 14 as libc::c_int,
                    ) < 0 as libc::c_int
                    {
                        current_block = 12882712674866931258;
                        break;
                    }
                }
                i = i.wrapping_add(1);
            }
            match current_block {
                12882712674866931258 => {}
                _ => {
                    js_free_prop_enum(ctx, props, len);
                    JS_FreeValue(ctx, obj);
                    return r;
                }
            }
        }
    }
    js_free_prop_enum(ctx, props, len);
    JS_FreeValue(ctx, obj);
    JS_FreeValue(ctx, r);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_GetOwnPropertyNames2(
    mut ctx: *mut JSContext,
    mut obj1: JSValue,
    mut flags: libc::c_int,
    mut kind: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut r: JSValue = 0;
    let mut val: JSValue = 0;
    let mut key: JSValue = 0;
    let mut value: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut atoms: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut j: uint32_t = 0;
    r = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, obj1);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if JS_GetOwnPropertyNamesInternal(
        ctx,
        &mut atoms,
        &mut len,
        p,
        flags & !((1 as libc::c_int) << 4 as libc::c_int),
    ) != 0
    {
        current_block = 4699803155735158062;
    } else {
        r = JS_NewArray(ctx);
        if JS_IsException(r) != 0 {
            current_block = 4699803155735158062;
        } else {
            i = 0 as libc::c_int as uint32_t;
            j = i;
            loop {
                if !(i < len) {
                    current_block = 1963993491182818044;
                    break;
                }
                let mut atom: JSAtom = (*atoms.offset(i as isize)).atom;
                if flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
                        flags: 0,
                        value: 0,
                        getter: 0,
                        setter: 0,
                    };
                    let mut res: libc::c_int = 0;
                    res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, atom);
                    if res < 0 as libc::c_int {
                        current_block = 4699803155735158062;
                        break;
                    }
                    if res == 0 {
                        current_block = 17965632435239708295;
                    } else {
                        js_free_desc(ctx, &mut desc);
                        if desc.flags & (1 as libc::c_int) << 2 as libc::c_int == 0 {
                            current_block = 17965632435239708295;
                        } else {
                            current_block = 12147880666119273379;
                        }
                    }
                } else {
                    current_block = 12147880666119273379;
                }
                match current_block {
                    12147880666119273379 => {
                        match kind {
                            1 => {
                                val = JS_GetProperty(ctx, obj, atom);
                                if JS_IsException(val) != 0 {
                                    current_block = 4699803155735158062;
                                    break;
                                }
                            }
                            2 => {
                                val = JS_NewArray(ctx);
                                if JS_IsException(val) != 0 {
                                    current_block = 4699803155735158062;
                                    break;
                                }
                                key = JS_AtomToValue(ctx, atom);
                                if JS_IsException(key) != 0 {
                                    current_block = 6141561026404586482;
                                    break;
                                }
                                if JS_CreateDataPropertyUint32(
                                    ctx,
                                    val,
                                    0 as libc::c_int as int64_t,
                                    key,
                                    (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 6141561026404586482;
                                    break;
                                }
                                value = JS_GetProperty(ctx, obj, atom);
                                if JS_IsException(value) != 0 {
                                    current_block = 6141561026404586482;
                                    break;
                                }
                                if JS_CreateDataPropertyUint32(
                                    ctx,
                                    val,
                                    1 as libc::c_int as int64_t,
                                    value,
                                    (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 6141561026404586482;
                                    break;
                                }
                            }
                            0 | _ => {
                                val = JS_AtomToValue(ctx, atom);
                                if JS_IsException(val) != 0 {
                                    current_block = 4699803155735158062;
                                    break;
                                }
                            }
                        }
                        let fresh638 = j;
                        j = j.wrapping_add(1);
                        if JS_CreateDataPropertyUint32(
                            ctx,
                            r,
                            fresh638 as int64_t,
                            val,
                            0 as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            current_block = 4699803155735158062;
                            break;
                        }
                    }
                    _ => {}
                }
                i = i.wrapping_add(1);
            }
            match current_block {
                4699803155735158062 => {}
                1963993491182818044 => {}
                _ => {
                    JS_FreeValue(ctx, val);
                    current_block = 4699803155735158062;
                }
            }
        }
    }
    match current_block {
        4699803155735158062 => {
            JS_FreeValue(ctx, r);
            r = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    js_free_prop_enum(ctx, atoms, len);
    JS_FreeValue(ctx, obj);
    return r;
}
unsafe extern "C" fn js_object_getOwnPropertyNames(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_GetOwnPropertyNames2(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        (1 as libc::c_int) << 0 as libc::c_int,
        JS_ITERATOR_KIND_KEY as libc::c_int,
    );
}
unsafe extern "C" fn js_object_getOwnPropertySymbols(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_GetOwnPropertyNames2(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        (1 as libc::c_int) << 1 as libc::c_int,
        JS_ITERATOR_KIND_KEY as libc::c_int,
    );
}
unsafe extern "C" fn js_object_keys(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut kind: libc::c_int,
) -> JSValue {
    return JS_GetOwnPropertyNames2(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        (1 as libc::c_int) << 4 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
        kind,
    );
}
unsafe extern "C" fn js_object_isExtensible(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut reflect: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut ret: libc::c_int = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        if reflect != 0 {
            return JS_ThrowTypeErrorNotAnObject(ctx)
        } else {
            return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong
        }
    }
    ret = JS_IsExtensible(ctx, obj);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_object_preventExtensions(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut reflect: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut ret: libc::c_int = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        if reflect != 0 {
            return JS_ThrowTypeErrorNotAnObject(ctx)
        } else {
            return JS_DupValue(ctx, obj)
        }
    }
    ret = JS_PreventExtensions(ctx, obj);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if reflect != 0 {
        return JS_NewBool(ctx, ret)
    } else {
        if ret == 0 {
            return JS_ThrowTypeError(
                ctx,
                b"proxy preventExtensions handler returned false\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return JS_DupValue(ctx, obj);
    };
}
unsafe extern "C" fn js_object_hasOwnProperty(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ret: BOOL = 0;
    atom = JS_ValueToAtom(ctx, *argv.offset(0 as libc::c_int as isize));
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    obj = JS_ToObject(ctx, this_val);
    if JS_IsException(obj) != 0 {
        JS_FreeAtom(ctx, atom);
        return obj;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    ret = JS_GetOwnPropertyInternal(ctx, 0 as *mut JSPropertyDescriptor, p, atom);
    JS_FreeAtom(ctx, atom);
    JS_FreeValue(ctx, obj);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_object_hasOwn(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ret: BOOL = 0;
    obj = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(obj) != 0 {
        return obj;
    }
    atom = JS_ValueToAtom(ctx, *argv.offset(1 as libc::c_int as isize));
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    ret = JS_GetOwnPropertyInternal(ctx, 0 as *mut JSPropertyDescriptor, p, atom);
    JS_FreeAtom(ctx, atom);
    JS_FreeValue(ctx, obj);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_object_valueOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_ToObject(ctx, this_val);
}
unsafe extern "C" fn js_object_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut tag: JSValue = 0;
    let mut is_array: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if JS_IsNull(this_val) != 0 {
        tag = JS_NewString(ctx, b"Null\0" as *const u8 as *const libc::c_char);
    } else if JS_IsUndefined(this_val) != 0 {
        tag = JS_NewString(ctx, b"Undefined\0" as *const u8 as *const libc::c_char);
    } else {
        obj = JS_ToObject(ctx, this_val);
        if JS_IsException(obj) != 0 {
            return obj;
        }
        is_array = JS_IsArray(ctx, obj);
        if is_array < 0 as libc::c_int {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if is_array != 0 {
            atom = JS_ATOM_Array as libc::c_int as JSAtom;
        } else if JS_IsFunction(ctx, obj) != 0 {
            atom = JS_ATOM_Function as libc::c_int as JSAtom;
        } else {
            p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
                5 | 8 | 9 | 3 | 6 | 4 | 10 | 18 => {
                    atom = (*((*(*ctx).rt).class_array)
                        .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
                        .class_name;
                }
                _ => {
                    atom = JS_ATOM_Object as libc::c_int as JSAtom;
                }
            }
        }
        tag = JS_GetProperty(
            ctx,
            obj,
            JS_ATOM_Symbol_toStringTag as libc::c_int as JSAtom,
        );
        JS_FreeValue(ctx, obj);
        if JS_IsException(tag) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if JS_IsString(tag) == 0 {
            JS_FreeValue(ctx, tag);
            tag = JS_AtomToString(ctx, atom);
        }
    }
    return JS_ConcatString3(
        ctx,
        b"[object \0" as *const u8 as *const libc::c_char,
        tag,
        b"]\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn js_object_toLocaleString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_Invoke(
        ctx,
        this_val,
        JS_ATOM_toString as libc::c_int as JSAtom,
        0 as libc::c_int,
        0 as *mut JSValue,
    );
}
unsafe extern "C" fn js_object_assign(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut s: JSValue = 0;
    let mut i: libc::c_int = 0;
    s = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(obj) != 0) {
        i = 1 as libc::c_int;
        loop {
            if !(i < argc) {
                current_block = 5399440093318478209;
                break;
            }
            if JS_IsNull(*argv.offset(i as isize)) == 0
                && JS_IsUndefined(*argv.offset(i as isize)) == 0
            {
                s = JS_ToObject(ctx, *argv.offset(i as isize));
                if JS_IsException(s) != 0 {
                    current_block = 3168206554217710679;
                    break;
                }
                if JS_CopyDataProperties(
                    ctx,
                    obj,
                    s,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    TRUE as libc::c_int,
                ) != 0
                {
                    current_block = 3168206554217710679;
                    break;
                }
                JS_FreeValue(ctx, s);
            }
            i += 1;
        }
        match current_block {
            3168206554217710679 => {}
            _ => return obj,
        }
    }
    JS_FreeValue(ctx, obj);
    JS_FreeValue(ctx, s);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_object_seal(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut freeze_flag: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut props: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut flags: libc::c_int = 0;
    let mut desc_flags: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    if JS_IsObject(obj) == 0 {
        return JS_DupValue(ctx, obj);
    }
    res = JS_PreventExtensions(ctx, obj);
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"proxy preventExtensions handler returned false\0" as *const u8
                as *const libc::c_char,
        );
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    flags = (1 as libc::c_int) << 0 as libc::c_int
        | (1 as libc::c_int) << 1 as libc::c_int;
    if JS_GetOwnPropertyNamesInternal(ctx, &mut props, &mut len, p, flags) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = 0 as libc::c_int as uint32_t;
    loop {
        if !(i < len) {
            current_block = 7056779235015430508;
            break;
        }
        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
            flags: 0,
            value: 0,
            getter: 0,
            setter: 0,
        };
        let mut prop: JSAtom = (*props.offset(i as isize)).atom;
        desc_flags = (1 as libc::c_int) << 14 as libc::c_int
            | (1 as libc::c_int) << 8 as libc::c_int;
        if freeze_flag != 0 {
            res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, prop);
            if res < 0 as libc::c_int {
                current_block = 9520749709997159250;
                break;
            }
            if res != 0 {
                if desc.flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
                    desc_flags |= (1 as libc::c_int) << 9 as libc::c_int;
                }
                js_free_desc(ctx, &mut desc);
            }
        }
        if JS_DefineProperty(
            ctx,
            obj,
            prop,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            desc_flags,
        ) < 0 as libc::c_int
        {
            current_block = 9520749709997159250;
            break;
        }
        i = i.wrapping_add(1);
    }
    match current_block {
        9520749709997159250 => {
            js_free_prop_enum(ctx, props, len);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {
            js_free_prop_enum(ctx, props, len);
            return JS_DupValue(ctx, obj);
        }
    };
}
unsafe extern "C" fn js_object_isSealed(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut is_frozen: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut props: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut flags: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    if JS_IsObject(obj) == 0 {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    flags = (1 as libc::c_int) << 0 as libc::c_int
        | (1 as libc::c_int) << 1 as libc::c_int;
    if JS_GetOwnPropertyNamesInternal(ctx, &mut props, &mut len, p, flags) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = 0 as libc::c_int as uint32_t;
    loop {
        if !(i < len) {
            current_block = 15904375183555213903;
            break;
        }
        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
            flags: 0,
            value: 0,
            getter: 0,
            setter: 0,
        };
        let mut prop: JSAtom = (*props.offset(i as isize)).atom;
        res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, prop);
        if res < 0 as libc::c_int {
            current_block = 12202201913303106861;
            break;
        }
        if res != 0 {
            js_free_desc(ctx, &mut desc);
            if desc.flags & (1 as libc::c_int) << 0 as libc::c_int != 0
                || is_frozen != 0
                    && desc.flags & (1 as libc::c_int) << 1 as libc::c_int != 0
            {
                res = FALSE as libc::c_int;
                current_block = 14908918415808095305;
                break;
            }
        }
        i = i.wrapping_add(1);
    }
    match current_block {
        15904375183555213903 => {
            res = JS_IsExtensible(ctx, obj);
            if res < 0 as libc::c_int {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            res ^= 1 as libc::c_int;
        }
        12202201913303106861 => {
            js_free_prop_enum(ctx, props, len);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    js_free_prop_enum(ctx, props, len);
    return JS_NewBool(ctx, res);
}
unsafe extern "C" fn js_object_fromEntries(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut iter: JSValue = 0;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut iterable: JSValue = 0;
    let mut done: BOOL = 0;
    iterable = *argv.offset(0 as libc::c_int as isize);
    obj = JS_NewObject(ctx);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    iter = JS_GetIterator(ctx, iterable, FALSE as libc::c_int);
    if !(JS_IsException(iter) != 0) {
        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next as libc::c_int as JSAtom);
        if !(JS_IsException(next_method) != 0) {
            loop {
                let mut key: JSValue = 0;
                let mut value: JSValue = 0;
                let mut item: JSValue = 0;
                item = JS_IteratorNext(
                    ctx,
                    iter,
                    next_method,
                    0 as libc::c_int,
                    0 as *mut JSValue,
                    &mut done,
                );
                if JS_IsException(item) != 0 {
                    current_block = 12467410779676580314;
                    break;
                }
                if done != 0 {
                    JS_FreeValue(ctx, item);
                    current_block = 4488286894823169796;
                    break;
                } else {
                    key = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    if JS_IsObject(item) == 0 {
                        JS_ThrowTypeErrorNotAnObject(ctx);
                    } else {
                        key = JS_GetPropertyUint32(
                            ctx,
                            item,
                            0 as libc::c_int as uint32_t,
                        );
                        if !(JS_IsException(key) != 0) {
                            value = JS_GetPropertyUint32(
                                ctx,
                                item,
                                1 as libc::c_int as uint32_t,
                            );
                            if JS_IsException(value) != 0 {
                                JS_FreeValue(ctx, key);
                            } else if !(JS_DefinePropertyValueValue(
                                ctx,
                                obj,
                                key,
                                value,
                                (1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int
                                    | (1 as libc::c_int) << 14 as libc::c_int,
                            ) < 0 as libc::c_int)
                            {
                                JS_FreeValue(ctx, item);
                                continue;
                            }
                        }
                    }
                    JS_FreeValue(ctx, item);
                    current_block = 12467410779676580314;
                    break;
                }
            }
            match current_block {
                12467410779676580314 => {}
                _ => {
                    JS_FreeValue(ctx, next_method);
                    JS_FreeValue(ctx, iter);
                    return obj;
                }
            }
        }
    }
    if JS_IsObject(iter) != 0 {
        JS_IteratorClose(ctx, iter, TRUE as libc::c_int);
    }
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_object___getClass(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut atom: JSAtom = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut tag: uint32_t = 0;
    let mut class_id: libc::c_int = 0;
    tag = JS_VALUE_GET_NORM_TAG(*argv.offset(0 as libc::c_int as isize)) as uint32_t;
    if tag == JS_TAG_OBJECT as libc::c_int as libc::c_uint {
        p = *argv.offset(0 as libc::c_int as isize) as intptr_t as *mut libc::c_void
            as *mut JSObject;
        class_id = (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int;
        if class_id == JS_CLASS_PROXY as libc::c_int
            && JS_IsFunction(ctx, *argv.offset(0 as libc::c_int as isize)) != 0
        {
            class_id = JS_CLASS_BYTECODE_FUNCTION as libc::c_int;
        }
        atom = (*((*(*ctx).rt).class_array).offset(class_id as isize)).class_name;
    } else {
        atom = JS_ATOM_empty_string as libc::c_int as JSAtom;
    }
    return JS_AtomToString(ctx, atom);
}
unsafe extern "C" fn js_object_is(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_NewBool(
        ctx,
        js_same_value(
            ctx,
            *argv.offset(0 as libc::c_int as isize),
            *argv.offset(1 as libc::c_int as isize),
        ),
    );
}
unsafe extern "C" fn JS_SpeciesConstructor(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut defaultConstructor: JSValue,
) -> JSValue {
    let mut ctor: JSValue = 0;
    let mut species: JSValue = 0;
    if JS_IsObject(obj) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor as libc::c_int as JSAtom);
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    if JS_IsUndefined(ctor) != 0 {
        return JS_DupValue(ctx, defaultConstructor);
    }
    if JS_IsObject(ctor) == 0 {
        JS_FreeValue(ctx, ctor);
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species as libc::c_int as JSAtom);
    JS_FreeValue(ctx, ctor);
    if JS_IsException(species) != 0 {
        return species;
    }
    if JS_IsUndefined(species) != 0 || JS_IsNull(species) != 0 {
        return JS_DupValue(ctx, defaultConstructor);
    }
    if JS_IsConstructor(ctx, species) == 0 {
        JS_FreeValue(ctx, species);
        return JS_ThrowTypeError(
            ctx,
            b"not a constructor\0" as *const u8 as *const libc::c_char,
        );
    }
    return species;
}
unsafe extern "C" fn js_object_get___proto__(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    val = JS_ToObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    ret = JS_GetPrototype(ctx, val);
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn js_object_set___proto__(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut proto: JSValue,
) -> JSValue {
    if JS_IsUndefined(this_val) != 0 || JS_IsNull(this_val) != 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if JS_IsObject(proto) == 0 && JS_IsNull(proto) == 0 {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_SetPrototypeInternal(ctx, this_val, proto, TRUE as libc::c_int)
        < 0 as libc::c_int
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    };
}
unsafe extern "C" fn js_object_isPrototypeOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut v1: JSValue = 0;
    let mut v: JSValue = 0;
    let mut res: libc::c_int = 0;
    v = *argv.offset(0 as libc::c_int as isize);
    if JS_IsObject(v) == 0 {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    obj = JS_ToObject(ctx, this_val);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    v1 = JS_DupValue(ctx, v);
    loop {
        v1 = JS_GetPrototypeFree(ctx, v1);
        if JS_IsException(v1) != 0 {
            current_block = 14192625076617013872;
            break;
        }
        if JS_IsNull(v1) != 0 {
            res = FALSE as libc::c_int;
            current_block = 8457315219000651999;
            break;
        } else if obj as intptr_t as *mut libc::c_void as *mut JSObject
            == v1 as intptr_t as *mut libc::c_void as *mut JSObject
        {
            res = TRUE as libc::c_int;
            current_block = 8457315219000651999;
            break;
        } else if js_poll_interrupts(ctx) != 0 {
            current_block = 14192625076617013872;
            break;
        }
    }
    match current_block {
        14192625076617013872 => {
            JS_FreeValue(ctx, v1);
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {
            JS_FreeValue(ctx, v1);
            JS_FreeValue(ctx, obj);
            return JS_NewBool(ctx, res);
        }
    };
}
unsafe extern "C" fn js_object_propertyIsEnumerable(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut res: JSValue = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut prop: JSAtom = 0 as libc::c_int as JSAtom;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut has_prop: libc::c_int = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(JS_IsException(obj) != 0) {
        prop = JS_ValueToAtom(ctx, *argv.offset(0 as libc::c_int as isize));
        if !((prop == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long
            != 0)
        {
            has_prop = JS_GetOwnPropertyInternal(
                ctx,
                &mut desc,
                obj as intptr_t as *mut libc::c_void as *mut JSObject,
                prop,
            );
            if !(has_prop < 0 as libc::c_int) {
                if has_prop != 0 {
                    res = JS_NewBool(
                        ctx,
                        (desc.flags & (1 as libc::c_int) << 2 as libc::c_int
                            != 0 as libc::c_int) as libc::c_int,
                    );
                    js_free_desc(ctx, &mut desc);
                } else {
                    res = (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
            }
        }
    }
    JS_FreeAtom(ctx, prop);
    JS_FreeValue(ctx, obj);
    return res;
}
unsafe extern "C" fn js_object___lookupGetter__(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut setter: libc::c_int,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut res: JSValue = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut prop: JSAtom = 0 as libc::c_int as JSAtom;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut has_prop: libc::c_int = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(JS_IsException(obj) != 0) {
        prop = JS_ValueToAtom(ctx, *argv.offset(0 as libc::c_int as isize));
        if !((prop == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long
            != 0)
        {
            loop {
                has_prop = JS_GetOwnPropertyInternal(
                    ctx,
                    &mut desc,
                    obj as intptr_t as *mut libc::c_void as *mut JSObject,
                    prop,
                );
                if has_prop < 0 as libc::c_int {
                    break;
                }
                if has_prop != 0 {
                    if desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                        res = JS_DupValue(
                            ctx,
                            if setter != 0 { desc.setter } else { desc.getter },
                        );
                    } else {
                        res = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                    js_free_desc(ctx, &mut desc);
                    break;
                } else {
                    obj = JS_GetPrototypeFree(ctx, obj);
                    if JS_IsException(obj) != 0 {
                        break;
                    }
                    if JS_IsNull(obj) != 0 {
                        res = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        break;
                    } else if js_poll_interrupts(ctx) != 0 {
                        break;
                    }
                }
            }
        }
    }
    JS_FreeAtom(ctx, prop);
    JS_FreeValue(ctx, obj);
    return res;
}
static mut js_object_funcs: [JSCFunctionListEntry; 23] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"create\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_create
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getPrototypeOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_getPrototypeOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setPrototypeOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_setPrototypeOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"defineProperty\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_defineProperty
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"defineProperties\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_defineProperties
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getOwnPropertyNames\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_getOwnPropertyNames
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getOwnPropertySymbols\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_getOwnPropertySymbols
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_keys
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"values\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_keys
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"entries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY_AND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_keys
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isExtensible\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_isExtensible
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"preventExtensions\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_preventExtensions
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getOwnPropertyDescriptor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_getOwnPropertyDescriptor
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getOwnPropertyDescriptors\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_getOwnPropertyDescriptors
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"is\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_is
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"assign\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_assign
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"seal\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_seal
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"freeze\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_seal
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isSealed\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_isSealed
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isFrozen\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_isSealed
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__getClass\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object___getClass
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fromEntries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_fromEntries
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"hasOwn\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_hasOwn
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_object_proto_funcs: [JSCFunctionListEntry; 11] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_toLocaleString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_valueOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"hasOwnProperty\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_hasOwnProperty
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isPrototypeOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_isPrototypeOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"propertyIsEnumerable\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_object_propertyIsEnumerable
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__proto__\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_object_get___proto__
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter: Some(
                                    js_object_set___proto__
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__defineGetter__\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object___defineGetter__
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__defineSetter__\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object___defineGetter__
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__lookupGetter__\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object___lookupGetter__
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__lookupSetter__\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object___lookupGetter__
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_function_proto(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_function_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut func_kind: JSFunctionKindEnum = magic as JSFunctionKindEnum;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut s: JSValue = 0;
    let mut proto: JSValue = 0;
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    string_buffer_init(ctx, b, 0 as libc::c_int);
    string_buffer_putc8(b, '(' as i32 as uint32_t);
    if func_kind as libc::c_uint == JS_FUNC_ASYNC as libc::c_int as libc::c_uint
        || func_kind as libc::c_uint
            == JS_FUNC_ASYNC_GENERATOR as libc::c_int as libc::c_uint
    {
        string_buffer_puts8(b, b"async \0" as *const u8 as *const libc::c_char);
    }
    string_buffer_puts8(b, b"function\0" as *const u8 as *const libc::c_char);
    if func_kind as libc::c_uint == JS_FUNC_GENERATOR as libc::c_int as libc::c_uint
        || func_kind as libc::c_uint
            == JS_FUNC_ASYNC_GENERATOR as libc::c_int as libc::c_uint
    {
        string_buffer_putc8(b, '*' as i32 as uint32_t);
    }
    string_buffer_puts8(b, b" anonymous(\0" as *const u8 as *const libc::c_char);
    n = argc - 1 as libc::c_int;
    i = 0 as libc::c_int;
    loop {
        if !(i < n) {
            current_block = 15904375183555213903;
            break;
        }
        if i != 0 as libc::c_int {
            string_buffer_putc8(b, ',' as i32 as uint32_t);
        }
        if string_buffer_concat_value(b, *argv.offset(i as isize)) != 0 {
            current_block = 14786414530448519100;
            break;
        }
        i += 1;
    }
    match current_block {
        15904375183555213903 => {
            string_buffer_puts8(b, b"\n) {\n\0" as *const u8 as *const libc::c_char);
            if n >= 0 as libc::c_int {
                if string_buffer_concat_value(b, *argv.offset(n as isize)) != 0 {
                    current_block = 14786414530448519100;
                } else {
                    current_block = 11042950489265723346;
                }
            } else {
                current_block = 11042950489265723346;
            }
            match current_block {
                14786414530448519100 => {}
                _ => {
                    string_buffer_puts8(
                        b,
                        b"\n})\0" as *const u8 as *const libc::c_char,
                    );
                    s = string_buffer_end(b);
                    if JS_IsException(s) != 0 {
                        current_block = 4370166028406608807;
                    } else {
                        obj = JS_EvalObject(
                            ctx,
                            (*ctx).global_obj,
                            s,
                            (3 as libc::c_int) << 0 as libc::c_int,
                            -(1 as libc::c_int),
                        );
                        JS_FreeValue(ctx, s);
                        if JS_IsException(obj) != 0 {
                            current_block = 4370166028406608807;
                        } else {
                            if JS_IsUndefined(new_target) == 0 {
                                proto = JS_GetProperty(
                                    ctx,
                                    new_target,
                                    JS_ATOM_prototype as libc::c_int as JSAtom,
                                );
                                if JS_IsException(proto) != 0 {
                                    current_block = 4370166028406608807;
                                } else {
                                    if JS_IsObject(proto) == 0 {
                                        let mut realm: *mut JSContext = 0 as *mut JSContext;
                                        JS_FreeValue(ctx, proto);
                                        realm = JS_GetFunctionRealm(ctx, new_target);
                                        if realm.is_null() {
                                            current_block = 4370166028406608807;
                                        } else {
                                            proto = JS_DupValue(
                                                ctx,
                                                *((*realm).class_proto)
                                                    .offset(func_kind_to_class_id[func_kind as usize] as isize),
                                            );
                                            current_block = 1836292691772056875;
                                        }
                                    } else {
                                        current_block = 1836292691772056875;
                                    }
                                    match current_block {
                                        4370166028406608807 => {}
                                        _ => {
                                            ret = JS_SetPrototypeInternal(
                                                ctx,
                                                obj,
                                                proto,
                                                TRUE as libc::c_int,
                                            );
                                            JS_FreeValue(ctx, proto);
                                            if ret < 0 as libc::c_int {
                                                current_block = 4370166028406608807;
                                            } else {
                                                current_block = 15090052786889560393;
                                            }
                                        }
                                    }
                                }
                            } else {
                                current_block = 15090052786889560393;
                            }
                            match current_block {
                                4370166028406608807 => {}
                                _ => return obj,
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        14786414530448519100 => {
            string_buffer_free(b);
        }
        _ => {}
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_get_length32(
    mut ctx: *mut JSContext,
    mut pres: *mut uint32_t,
    mut obj: JSValue,
) -> libc::c_int {
    let mut len_val: JSValue = 0;
    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length as libc::c_int as JSAtom);
    if JS_IsException(len_val) != 0 {
        *pres = 0 as libc::c_int as uint32_t;
        return -(1 as libc::c_int);
    }
    return JS_ToUint32Free(ctx, pres, len_val);
}
unsafe extern "C" fn js_get_length64(
    mut ctx: *mut JSContext,
    mut pres: *mut int64_t,
    mut obj: JSValue,
) -> libc::c_int {
    let mut len_val: JSValue = 0;
    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length as libc::c_int as JSAtom);
    if JS_IsException(len_val) != 0 {
        *pres = 0 as libc::c_int as int64_t;
        return -(1 as libc::c_int);
    }
    return JS_ToLengthFree(ctx, pres, len_val);
}
unsafe extern "C" fn free_arg_list(
    mut ctx: *mut JSContext,
    mut tab: *mut JSValue,
    mut len: uint32_t,
) {
    let mut i: uint32_t = 0;
    i = 0 as libc::c_int as uint32_t;
    while i < len {
        JS_FreeValue(ctx, *tab.offset(i as isize));
        i = i.wrapping_add(1);
    }
    js_free(ctx, tab as *mut libc::c_void);
}
unsafe extern "C" fn build_arg_list(
    mut ctx: *mut JSContext,
    mut plen: *mut uint32_t,
    mut array_arg: JSValue,
) -> *mut JSValue {
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut tab: *mut JSValue = 0 as *mut JSValue;
    let mut ret: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (array_arg >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        JS_ThrowTypeError(ctx, b"not a object\0" as *const u8 as *const libc::c_char);
        return 0 as *mut JSValue;
    }
    if js_get_length32(ctx, &mut len, array_arg) != 0 {
        return 0 as *mut JSValue;
    }
    if len > 65536 as libc::c_int as libc::c_uint {
        JS_ThrowInternalError(
            ctx,
            b"too many arguments\0" as *const u8 as *const libc::c_char,
        );
        return 0 as *mut JSValue;
    }
    tab = js_mallocz(
        ctx,
        (::core::mem::size_of::<JSValue>() as libc::c_ulong)
            .wrapping_mul(max_uint32(1 as libc::c_int as uint32_t, len) as libc::c_ulong),
    ) as *mut JSValue;
    if tab.is_null() {
        return 0 as *mut JSValue;
    }
    p = array_arg as intptr_t as *mut libc::c_void as *mut JSObject;
    if ((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_ARRAY as libc::c_int
        || (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARGUMENTS as libc::c_int)
        && ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
        && len == (*p).u.array.count
    {
        i = 0 as libc::c_int as uint32_t;
        while i < len {
            *tab
                .offset(
                    i as isize,
                ) = JS_DupValue(ctx, *((*p).u.array.u.values).offset(i as isize));
            i = i.wrapping_add(1);
        }
    } else {
        i = 0 as libc::c_int as uint32_t;
        while i < len {
            ret = JS_GetPropertyUint32(ctx, array_arg, i);
            if JS_IsException(ret) != 0 {
                free_arg_list(ctx, tab, i);
                return 0 as *mut JSValue;
            }
            *tab.offset(i as isize) = ret;
            i = i.wrapping_add(1);
        }
    }
    *plen = len;
    return tab;
}
unsafe extern "C" fn js_function_apply(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut this_arg: JSValue = 0;
    let mut array_arg: JSValue = 0;
    let mut len: uint32_t = 0;
    let mut tab: *mut JSValue = 0 as *mut JSValue;
    let mut ret: JSValue = 0;
    if check_function(ctx, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    this_arg = *argv.offset(0 as libc::c_int as isize);
    array_arg = *argv.offset(1 as libc::c_int as isize);
    if ((array_arg >> 32 as libc::c_int) as libc::c_int
        == JS_TAG_UNDEFINED as libc::c_int
        || (array_arg >> 32 as libc::c_int) as libc::c_int == JS_TAG_NULL as libc::c_int)
        && magic != 2 as libc::c_int
    {
        return JS_Call(ctx, this_val, this_arg, 0 as libc::c_int, 0 as *mut JSValue);
    }
    tab = build_arg_list(ctx, &mut len, array_arg);
    if tab.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if magic & 1 as libc::c_int != 0 {
        ret = JS_CallConstructor2(ctx, this_val, this_arg, len as libc::c_int, tab);
    } else {
        ret = JS_Call(ctx, this_val, this_arg, len as libc::c_int, tab);
    }
    free_arg_list(ctx, tab, len);
    return ret;
}
unsafe extern "C" fn js_function_call(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    if argc <= 0 as libc::c_int {
        return JS_Call(
            ctx,
            this_val,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            0 as libc::c_int,
            0 as *mut JSValue,
        )
    } else {
        return JS_Call(
            ctx,
            this_val,
            *argv.offset(0 as libc::c_int as isize),
            argc - 1 as libc::c_int,
            argv.offset(1 as libc::c_int as isize),
        )
    };
}
unsafe extern "C" fn js_function_bind(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut bf: *mut JSBoundFunction = 0 as *mut JSBoundFunction;
    let mut func_obj: JSValue = 0;
    let mut name1: JSValue = 0;
    let mut len_val: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut arg_count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    if check_function(ctx, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    func_obj = JS_NewObjectProtoClass(
        ctx,
        (*ctx).function_proto,
        JS_CLASS_BOUND_FUNCTION as libc::c_int as JSClassID,
    );
    if JS_IsException(func_obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = func_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    let ref mut fresh639 = (*p).c2rust_unnamed.c2rust_unnamed;
    (*fresh639).set_is_constructor(JS_IsConstructor(ctx, this_val) as uint8_t);
    arg_count = max_int(0 as libc::c_int, argc - 1 as libc::c_int);
    bf = js_malloc(
        ctx,
        (::core::mem::size_of::<JSBoundFunction>() as libc::c_ulong)
            .wrapping_add(
                (arg_count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<JSValue>() as libc::c_ulong),
            ),
    ) as *mut JSBoundFunction;
    if !bf.is_null() {
        (*bf).func_obj = JS_DupValue(ctx, this_val);
        (*bf).this_val = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
        (*bf).argc = arg_count;
        i = 0 as libc::c_int;
        while i < arg_count {
            *((*bf).argv)
                .as_mut_ptr()
                .offset(
                    i as isize,
                ) = JS_DupValue(ctx, *argv.offset((i + 1 as libc::c_int) as isize));
            i += 1;
        }
        let ref mut fresh640 = (*p).u.bound_function;
        *fresh640 = bf;
        ret = JS_GetOwnProperty(
            ctx,
            0 as *mut JSPropertyDescriptor,
            this_val,
            JS_ATOM_length as libc::c_int as JSAtom,
        );
        if !(ret < 0 as libc::c_int) {
            if ret == 0 {
                len_val = JS_NewInt32(ctx, 0 as libc::c_int);
                current_block = 1356832168064818221;
            } else {
                len_val = JS_GetProperty(
                    ctx,
                    this_val,
                    JS_ATOM_length as libc::c_int as JSAtom,
                );
                if JS_IsException(len_val) != 0 {
                    current_block = 7015572954721317448;
                } else {
                    if (len_val >> 32 as libc::c_int) as libc::c_int
                        == JS_TAG_INT as libc::c_int
                    {
                        let mut len1: libc::c_int = len_val as libc::c_int;
                        if len1 <= arg_count {
                            len1 = 0 as libc::c_int;
                        } else {
                            len1 -= arg_count;
                        }
                        len_val = JS_NewInt32(ctx, len1);
                    } else if JS_VALUE_GET_NORM_TAG(len_val)
                        == JS_TAG_FLOAT64 as libc::c_int
                    {
                        let mut d: libc::c_double = JS_VALUE_GET_FLOAT64(len_val);
                        if isnan(d) != 0 {
                            d = 0.0f64;
                        } else {
                            d = trunc(d);
                            if d <= arg_count as libc::c_double {
                                d = 0.0f64;
                            } else {
                                d -= arg_count as libc::c_double;
                            }
                        }
                        len_val = JS_NewFloat64(ctx, d);
                    } else {
                        JS_FreeValue(ctx, len_val);
                        len_val = JS_NewInt32(ctx, 0 as libc::c_int);
                    }
                    current_block = 1356832168064818221;
                }
            }
            match current_block {
                7015572954721317448 => {}
                _ => {
                    JS_DefinePropertyValue(
                        ctx,
                        func_obj,
                        JS_ATOM_length as libc::c_int as JSAtom,
                        len_val,
                        (1 as libc::c_int) << 0 as libc::c_int,
                    );
                    name1 = JS_GetProperty(
                        ctx,
                        this_val,
                        JS_ATOM_name as libc::c_int as JSAtom,
                    );
                    if !(JS_IsException(name1) != 0) {
                        if JS_IsString(name1) == 0 {
                            JS_FreeValue(ctx, name1);
                            name1 = JS_AtomToString(
                                ctx,
                                JS_ATOM_empty_string as libc::c_int as JSAtom,
                            );
                        }
                        name1 = JS_ConcatString3(
                            ctx,
                            b"bound \0" as *const u8 as *const libc::c_char,
                            name1,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        if !(JS_IsException(name1) != 0) {
                            JS_DefinePropertyValue(
                                ctx,
                                func_obj,
                                JS_ATOM_name as libc::c_int as JSAtom,
                                name1,
                                (1 as libc::c_int) << 0 as libc::c_int,
                            );
                            return func_obj;
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, func_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_function_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut func_kind: JSFunctionKindEnum = JS_FUNC_NORMAL;
    if check_function(ctx, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
    if js_class_has_bytecode((*p).c2rust_unnamed.c2rust_unnamed.class_id as JSClassID)
        != 0
    {
        let mut b: *mut JSFunctionBytecode = (*p).u.func.function_bytecode;
        if (*b).has_debug() as libc::c_int != 0 && !((*b).debug.source).is_null() {
            return JS_NewStringLen(
                ctx,
                (*b).debug.source,
                (*b).debug.source_len as size_t,
            );
        }
        func_kind = (*b).func_kind() as JSFunctionKindEnum;
    }
    let mut name: JSValue = 0;
    let mut pref: *const libc::c_char = 0 as *const libc::c_char;
    let mut suff: *const libc::c_char = 0 as *const libc::c_char;
    match func_kind as libc::c_uint {
        1 => {
            pref = b"function *\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            pref = b"async function \0" as *const u8 as *const libc::c_char;
        }
        3 => {
            pref = b"async function *\0" as *const u8 as *const libc::c_char;
        }
        0 | _ => {
            pref = b"function \0" as *const u8 as *const libc::c_char;
        }
    }
    suff = b"() {\n    [native code]\n}\0" as *const u8 as *const libc::c_char;
    name = JS_GetProperty(ctx, this_val, JS_ATOM_name as libc::c_int as JSAtom);
    if JS_IsUndefined(name) != 0 {
        name = JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    }
    return JS_ConcatString3(ctx, pref, name, suff);
}
unsafe extern "C" fn js_function_hasInstance(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ret: libc::c_int = 0;
    ret = JS_OrdinaryIsInstanceOf(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        this_val,
    );
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
static mut js_function_proto_funcs: [JSCFunctionListEntry; 7] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"call\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_function_call
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"apply\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_function_apply
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"bind\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_function_bind
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_function_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.hasInstance]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_function_hasInstance
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fileName\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_function_proto_fileName
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"lineNumber\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_function_proto_lineNumber
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn iterator_to_array(
    mut ctx: *mut JSContext,
    mut items: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut iter: JSValue = 0;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut v: JSValue = 0;
    let mut r: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut k: int64_t = 0;
    let mut done: BOOL = 0;
    iter = JS_GetIterator(ctx, items, FALSE as libc::c_int);
    if JS_IsException(iter) != 0 {
        current_block = 17341844812715864958;
    } else {
        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next as libc::c_int as JSAtom);
        if JS_IsException(next_method) != 0 {
            current_block = 17341844812715864958;
        } else {
            r = JS_NewArray(ctx);
            if JS_IsException(r) != 0 {
                current_block = 17341844812715864958;
            } else {
                k = 0 as libc::c_int as int64_t;
                loop {
                    v = JS_IteratorNext(
                        ctx,
                        iter,
                        next_method,
                        0 as libc::c_int,
                        0 as *mut JSValue,
                        &mut done,
                    );
                    if JS_IsException(v) != 0 {
                        current_block = 15105927315498901750;
                        break;
                    }
                    if done != 0 {
                        current_block = 947451007573925172;
                        break;
                    }
                    if JS_DefinePropertyValueInt64(
                        ctx,
                        r,
                        k,
                        v,
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 14 as libc::c_int,
                    ) < 0 as libc::c_int
                    {
                        current_block = 15105927315498901750;
                        break;
                    }
                    k += 1;
                }
                match current_block {
                    947451007573925172 => {}
                    _ => {
                        JS_IteratorClose(ctx, iter, TRUE as libc::c_int);
                        current_block = 17341844812715864958;
                    }
                }
            }
        }
    }
    match current_block {
        17341844812715864958 => {
            JS_FreeValue(ctx, r);
            r = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    return r;
}
unsafe extern "C" fn js_error_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut msg: JSValue = 0;
    let mut proto: JSValue = 0;
    let mut message: JSValue = 0;
    if JS_IsUndefined(new_target) != 0 {
        new_target = JS_GetActiveFunction(ctx);
    }
    proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype as libc::c_int as JSAtom);
    if JS_IsException(proto) != 0 {
        return proto;
    }
    if JS_IsObject(proto) == 0 {
        let mut realm: *mut JSContext = 0 as *mut JSContext;
        let mut proto1: JSValue = 0;
        JS_FreeValue(ctx, proto);
        realm = JS_GetFunctionRealm(ctx, new_target);
        if realm.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if magic < 0 as libc::c_int {
            proto1 = *((*realm).class_proto)
                .offset(JS_CLASS_ERROR as libc::c_int as isize);
        } else {
            proto1 = (*realm).native_error_proto[magic as usize];
        }
        proto = JS_DupValue(ctx, proto1);
    }
    obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_ERROR as libc::c_int as JSClassID);
    JS_FreeValue(ctx, proto);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    if magic == JS_AGGREGATE_ERROR as libc::c_int {
        message = *argv.offset(1 as libc::c_int as isize);
    } else {
        message = *argv.offset(0 as libc::c_int as isize);
    }
    if JS_IsUndefined(message) == 0 {
        msg = JS_ToString(ctx, message);
        if (JS_IsException(msg) != 0) as libc::c_int as libc::c_long != 0 {
            current_block = 9145552596935862149;
        } else {
            JS_DefinePropertyValue(
                ctx,
                obj,
                JS_ATOM_message as libc::c_int as JSAtom,
                msg,
                (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int,
            );
            current_block = 4775909272756257391;
        }
    } else {
        current_block = 4775909272756257391;
    }
    match current_block {
        4775909272756257391 => {
            if magic == JS_AGGREGATE_ERROR as libc::c_int {
                let mut error_list: JSValue = iterator_to_array(
                    ctx,
                    *argv.offset(0 as libc::c_int as isize),
                );
                if JS_IsException(error_list) != 0 {
                    current_block = 9145552596935862149;
                } else {
                    JS_DefinePropertyValue(
                        ctx,
                        obj,
                        JS_ATOM_errors as libc::c_int as JSAtom,
                        error_list,
                        (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int,
                    );
                    current_block = 8704759739624374314;
                }
            } else {
                current_block = 8704759739624374314;
            }
            match current_block {
                9145552596935862149 => {}
                _ => {
                    build_backtrace(
                        ctx,
                        obj,
                        0 as *const libc::c_char,
                        0 as libc::c_int,
                        (1 as libc::c_int) << 0 as libc::c_int,
                    );
                    return obj;
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_error_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut name: JSValue = 0;
    let mut msg: JSValue = 0;
    if JS_IsObject(this_val) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    name = JS_GetProperty(ctx, this_val, JS_ATOM_name as libc::c_int as JSAtom);
    if JS_IsUndefined(name) != 0 {
        name = JS_AtomToString(ctx, JS_ATOM_Error as libc::c_int as JSAtom);
    } else {
        name = JS_ToStringFree(ctx, name);
    }
    if JS_IsException(name) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    msg = JS_GetProperty(ctx, this_val, JS_ATOM_message as libc::c_int as JSAtom);
    if JS_IsUndefined(msg) != 0 {
        msg = JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    } else {
        msg = JS_ToStringFree(ctx, msg);
    }
    if JS_IsException(msg) != 0 {
        JS_FreeValue(ctx, name);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsEmptyString(name) == 0 && JS_IsEmptyString(msg) == 0 {
        name = JS_ConcatString3(
            ctx,
            b"\0" as *const u8 as *const libc::c_char,
            name,
            b": \0" as *const u8 as *const libc::c_char,
        );
    }
    return JS_ConcatString(ctx, name, msg);
}
static mut js_error_proto_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_error_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"name\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Error\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"message\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_aggregate_error_constructor(
    mut ctx: *mut JSContext,
    mut errors: JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    obj = JS_NewObjectProtoClass(
        ctx,
        (*ctx).native_error_proto[JS_AGGREGATE_ERROR as libc::c_int as usize],
        JS_CLASS_ERROR as libc::c_int as JSClassID,
    );
    if JS_IsException(obj) != 0 {
        return obj;
    }
    JS_DefinePropertyValue(
        ctx,
        obj,
        JS_ATOM_errors as libc::c_int as JSAtom,
        JS_DupValue(ctx, errors),
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    return obj;
}
unsafe extern "C" fn JS_CopySubArray(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut to_pos: int64_t,
    mut from_pos: int64_t,
    mut count: int64_t,
    mut dir: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut i: int64_t = 0;
    let mut from: int64_t = 0;
    let mut to: int64_t = 0;
    let mut len: int64_t = 0;
    let mut val: JSValue = 0;
    let mut fromPresent: libc::c_int = 0;
    p = 0 as *mut JSObject;
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_ARRAY as libc::c_int
            || ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() == 0
        {
            p = 0 as *mut JSObject;
        }
    }
    i = 0 as libc::c_int as int64_t;
    loop {
        if !(i < count) {
            current_block = 3938820862080741272;
            break;
        }
        if dir < 0 as libc::c_int {
            from = from_pos + count - i - 1 as libc::c_int as libc::c_longlong;
            to = to_pos + count - i - 1 as libc::c_int as libc::c_longlong;
        } else {
            from = from_pos + i;
            to = to_pos + i;
        }
        if !p.is_null()
            && ((*p).c2rust_unnamed.c2rust_unnamed).fast_array() as libc::c_int != 0
            && from >= 0 as libc::c_int as libc::c_longlong
            && {
                len = (*p).u.array.count as int64_t;
                from < len
            } && to >= 0 as libc::c_int as libc::c_longlong && to < len
        {
            let mut l: int64_t = 0;
            let mut j: int64_t = 0;
            l = count - i;
            if dir < 0 as libc::c_int {
                l = min_int64(l, from + 1 as libc::c_int as libc::c_longlong);
                l = min_int64(l, to + 1 as libc::c_int as libc::c_longlong);
                j = 0 as libc::c_int as int64_t;
                while j < l {
                    set_value(
                        ctx,
                        &mut *((*p).u.array.u.values).offset((to - j) as isize),
                        JS_DupValue(
                            ctx,
                            *((*p).u.array.u.values).offset((from - j) as isize),
                        ),
                    );
                    j += 1;
                }
            } else {
                l = min_int64(l, len - from);
                l = min_int64(l, len - to);
                j = 0 as libc::c_int as int64_t;
                while j < l {
                    set_value(
                        ctx,
                        &mut *((*p).u.array.u.values).offset((to + j) as isize),
                        JS_DupValue(
                            ctx,
                            *((*p).u.array.u.values).offset((from + j) as isize),
                        ),
                    );
                    j += 1;
                }
            }
            i += l;
        } else {
            fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &mut val);
            if fromPresent < 0 as libc::c_int {
                current_block = 8978828221399928736;
                break;
            }
            if fromPresent != 0 {
                if JS_SetPropertyInt64(ctx, obj, to, val) < 0 as libc::c_int {
                    current_block = 8978828221399928736;
                    break;
                }
            } else if JS_DeletePropertyInt64(
                ctx,
                obj,
                to,
                (1 as libc::c_int) << 14 as libc::c_int,
            ) < 0 as libc::c_int
            {
                current_block = 8978828221399928736;
                break;
            }
            i += 1;
        }
    }
    match current_block {
        3938820862080741272 => return 0 as libc::c_int,
        _ => return -(1 as libc::c_int),
    };
}
unsafe extern "C" fn js_array_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut i: libc::c_int = 0;
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_ARRAY as libc::c_int);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    if argc == 1 as libc::c_int
        && JS_IsNumber(*argv.offset(0 as libc::c_int as isize)) != 0
    {
        let mut len: uint32_t = 0;
        if JS_ToArrayLengthFree(
            ctx,
            &mut len,
            JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
            TRUE as libc::c_int,
        ) != 0
        {
            current_block = 10103610204058624428;
        } else if JS_SetProperty(
            ctx,
            obj,
            JS_ATOM_length as libc::c_int as JSAtom,
            JS_NewUint32(ctx, len),
        ) < 0 as libc::c_int
        {
            current_block = 10103610204058624428;
        } else {
            current_block = 2979737022853876585;
        }
    } else {
        i = 0 as libc::c_int;
        loop {
            if !(i < argc) {
                current_block = 2979737022853876585;
                break;
            }
            if JS_SetPropertyUint32(
                ctx,
                obj,
                i as uint32_t,
                JS_DupValue(ctx, *argv.offset(i as isize)),
            ) < 0 as libc::c_int
            {
                current_block = 10103610204058624428;
                break;
            }
            i += 1;
        }
    }
    match current_block {
        2979737022853876585 => return obj,
        _ => {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    };
}
unsafe extern "C" fn js_array_from(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut items: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut mapfn: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut stack: [JSValue; 2] = [0; 2];
    let mut iter: JSValue = 0;
    let mut r: JSValue = 0;
    let mut v: JSValue = 0;
    let mut v2: JSValue = 0;
    let mut arrayLike: JSValue = 0;
    let mut k: int64_t = 0;
    let mut len: int64_t = 0;
    let mut done: libc::c_int = 0;
    let mut mapping: libc::c_int = 0;
    mapping = FALSE as libc::c_int;
    mapfn = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    r = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    arrayLike = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    stack[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    stack[1 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if argc > 1 as libc::c_int {
        mapfn = *argv.offset(1 as libc::c_int as isize);
        if JS_IsUndefined(mapfn) == 0 {
            if check_function(ctx, mapfn) != 0 {
                current_block = 16347696086848805369;
            } else {
                mapping = 1 as libc::c_int;
                if argc > 2 as libc::c_int {
                    this_arg = *argv.offset(2 as libc::c_int as isize);
                }
                current_block = 5143058163439228106;
            }
        } else {
            current_block = 5143058163439228106;
        }
    } else {
        current_block = 5143058163439228106;
    }
    match current_block {
        5143058163439228106 => {
            iter = JS_GetProperty(
                ctx,
                items,
                JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
            );
            if JS_IsException(iter) != 0 {
                current_block = 16347696086848805369;
            } else {
                if JS_IsUndefined(iter) == 0 {
                    JS_FreeValue(ctx, iter);
                    if JS_IsConstructor(ctx, this_val) != 0 {
                        r = JS_CallConstructor(
                            ctx,
                            this_val,
                            0 as libc::c_int,
                            0 as *mut JSValue,
                        );
                    } else {
                        r = JS_NewArray(ctx);
                    }
                    if JS_IsException(r) != 0 {
                        current_block = 16347696086848805369;
                    } else {
                        stack[0 as libc::c_int as usize] = JS_DupValue(ctx, items);
                        if js_for_of_start(
                            ctx,
                            &mut *stack.as_mut_ptr().offset(1 as libc::c_int as isize),
                            FALSE as libc::c_int,
                        ) != 0
                        {
                            current_block = 16347696086848805369;
                        } else {
                            k = 0 as libc::c_int as int64_t;
                            loop {
                                v = JS_IteratorNext(
                                    ctx,
                                    stack[0 as libc::c_int as usize],
                                    stack[1 as libc::c_int as usize],
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                    &mut done,
                                );
                                if JS_IsException(v) != 0 {
                                    current_block = 8014661254562214057;
                                    break;
                                }
                                if done != 0 {
                                    current_block = 7494008139977416618;
                                    break;
                                }
                                if mapping != 0 {
                                    args[0 as libc::c_int as usize] = v;
                                    args[1 as libc::c_int
                                        as usize] = JS_NewInt32(ctx, k as int32_t);
                                    v2 = JS_Call(
                                        ctx,
                                        mapfn,
                                        this_arg,
                                        2 as libc::c_int,
                                        args.as_mut_ptr(),
                                    );
                                    JS_FreeValue(ctx, v);
                                    v = v2;
                                    if JS_IsException(v) != 0 {
                                        current_block = 8014661254562214057;
                                        break;
                                    }
                                }
                                if JS_DefinePropertyValueInt64(
                                    ctx,
                                    r,
                                    k,
                                    v,
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int
                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 8014661254562214057;
                                    break;
                                }
                                k += 1;
                            }
                            match current_block {
                                7494008139977416618 => {}
                                _ => {
                                    if JS_IsUndefined(stack[0 as libc::c_int as usize]) == 0 {
                                        JS_IteratorClose(
                                            ctx,
                                            stack[0 as libc::c_int as usize],
                                            TRUE as libc::c_int,
                                        );
                                    }
                                    current_block = 16347696086848805369;
                                }
                            }
                        }
                    }
                } else {
                    arrayLike = JS_ToObject(ctx, items);
                    if JS_IsException(arrayLike) != 0 {
                        current_block = 16347696086848805369;
                    } else if js_get_length64(ctx, &mut len, arrayLike)
                        < 0 as libc::c_int
                    {
                        current_block = 16347696086848805369;
                    } else {
                        v = JS_NewInt64(ctx, len);
                        args[0 as libc::c_int as usize] = v;
                        if JS_IsConstructor(ctx, this_val) != 0 {
                            r = JS_CallConstructor(
                                ctx,
                                this_val,
                                1 as libc::c_int,
                                args.as_mut_ptr(),
                            );
                        } else {
                            r = js_array_constructor(
                                ctx,
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                1 as libc::c_int,
                                args.as_mut_ptr(),
                            );
                        }
                        JS_FreeValue(ctx, v);
                        if JS_IsException(r) != 0 {
                            current_block = 16347696086848805369;
                        } else {
                            k = 0 as libc::c_int as int64_t;
                            loop {
                                if !(k < len) {
                                    current_block = 7494008139977416618;
                                    break;
                                }
                                v = JS_GetPropertyInt64(ctx, arrayLike, k);
                                if JS_IsException(v) != 0 {
                                    current_block = 16347696086848805369;
                                    break;
                                }
                                if mapping != 0 {
                                    args[0 as libc::c_int as usize] = v;
                                    args[1 as libc::c_int
                                        as usize] = JS_NewInt32(ctx, k as int32_t);
                                    v2 = JS_Call(
                                        ctx,
                                        mapfn,
                                        this_arg,
                                        2 as libc::c_int,
                                        args.as_mut_ptr(),
                                    );
                                    JS_FreeValue(ctx, v);
                                    v = v2;
                                    if JS_IsException(v) != 0 {
                                        current_block = 16347696086848805369;
                                        break;
                                    }
                                }
                                if JS_DefinePropertyValueInt64(
                                    ctx,
                                    r,
                                    k,
                                    v,
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int
                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 16347696086848805369;
                                    break;
                                }
                                k += 1;
                            }
                        }
                    }
                }
                match current_block {
                    16347696086848805369 => {}
                    _ => {
                        if JS_SetProperty(
                            ctx,
                            r,
                            JS_ATOM_length as libc::c_int as JSAtom,
                            JS_NewUint32(ctx, k as uint32_t),
                        ) < 0 as libc::c_int
                        {
                            current_block = 16347696086848805369;
                        } else {
                            current_block = 9580007492617731451;
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        16347696086848805369 => {
            JS_FreeValue(ctx, r);
            r = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    JS_FreeValue(ctx, arrayLike);
    JS_FreeValue(ctx, stack[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, stack[1 as libc::c_int as usize]);
    return r;
}
unsafe extern "C" fn js_array_of(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut args: [JSValue; 1] = [0; 1];
    let mut i: libc::c_int = 0;
    if JS_IsConstructor(ctx, this_val) != 0 {
        args[0 as libc::c_int as usize] = JS_NewInt32(ctx, argc);
        obj = JS_CallConstructor(ctx, this_val, 1 as libc::c_int, args.as_mut_ptr());
    } else {
        obj = JS_NewArray(ctx);
    }
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = 0 as libc::c_int;
    loop {
        if !(i < argc) {
            current_block = 1856101646708284338;
            break;
        }
        if JS_CreateDataPropertyUint32(
            ctx,
            obj,
            i as int64_t,
            JS_DupValue(ctx, *argv.offset(i as isize)),
            (1 as libc::c_int) << 14 as libc::c_int,
        ) < 0 as libc::c_int
        {
            current_block = 13874301155860935490;
            break;
        }
        i += 1;
    }
    match current_block {
        1856101646708284338 => {
            if !(JS_SetProperty(
                ctx,
                obj,
                JS_ATOM_length as libc::c_int as JSAtom,
                JS_NewUint32(ctx, argc as uint32_t),
            ) < 0 as libc::c_int)
            {
                return obj;
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_isArray(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ret: libc::c_int = 0;
    ret = JS_IsArray(ctx, *argv.offset(0 as libc::c_int as isize));
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_get_this(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn JS_ArraySpeciesCreate(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut len_val: JSValue,
) -> JSValue {
    let mut ctor: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut species: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut realm: *mut JSContext = 0 as *mut JSContext;
    res = JS_IsArray(ctx, obj);
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res == 0 {
        return js_array_constructor(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut len_val,
        );
    }
    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor as libc::c_int as JSAtom);
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    if JS_IsConstructor(ctx, ctor) != 0 {
        realm = JS_GetFunctionRealm(ctx, ctor);
        if realm.is_null() {
            JS_FreeValue(ctx, ctor);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if realm != ctx && js_same_value(ctx, ctor, (*realm).array_ctor) != 0 {
            JS_FreeValue(ctx, ctor);
            ctor = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if JS_IsObject(ctor) != 0 {
        species = JS_GetProperty(
            ctx,
            ctor,
            JS_ATOM_Symbol_species as libc::c_int as JSAtom,
        );
        JS_FreeValue(ctx, ctor);
        if JS_IsException(species) != 0 {
            return species;
        }
        ctor = species;
        if JS_IsNull(ctor) != 0 {
            ctor = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if JS_IsUndefined(ctor) != 0 {
        return js_array_constructor(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut len_val,
        )
    } else {
        ret = JS_CallConstructor(ctx, ctor, 1 as libc::c_int, &mut len_val);
        JS_FreeValue(ctx, ctor);
        return ret;
    };
}
static mut js_array_funcs: [JSCFunctionListEntry; 4] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"isArray\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_isArray
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"from\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_from
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"of\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_of
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn JS_isConcatSpreadable(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut val: JSValue = 0;
    if JS_IsObject(obj) == 0 {
        return FALSE as libc::c_int;
    }
    val = JS_GetProperty(
        ctx,
        obj,
        JS_ATOM_Symbol_isConcatSpreadable as libc::c_int as JSAtom,
    );
    if JS_IsException(val) != 0 {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(val) == 0 {
        return JS_ToBoolFree(ctx, val);
    }
    return JS_IsArray(ctx, obj);
}
unsafe extern "C" fn js_array_concat(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut arr: JSValue = 0;
    let mut val: JSValue = 0;
    let mut e: JSValue = 0;
    let mut len: int64_t = 0;
    let mut k: int64_t = 0;
    let mut n: int64_t = 0;
    let mut i: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    if !(JS_IsException(obj) != 0) {
        arr = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0 as libc::c_int));
        if !(JS_IsException(arr) != 0) {
            n = 0 as libc::c_int as int64_t;
            i = -(1 as libc::c_int);
            's_43: loop {
                if !(i < argc) {
                    current_block = 14136749492126903395;
                    break;
                }
                if i < 0 as libc::c_int {
                    e = obj;
                } else {
                    e = *argv.offset(i as isize);
                }
                res = JS_isConcatSpreadable(ctx, e);
                if res < 0 as libc::c_int {
                    current_block = 7163151045727362960;
                    break;
                }
                if res != 0 {
                    if js_get_length64(ctx, &mut len, e) != 0 {
                        current_block = 7163151045727362960;
                        break;
                    }
                    if n + len
                        > ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                            - 1 as libc::c_int as libc::c_longlong
                    {
                        JS_ThrowTypeError(
                            ctx,
                            b"Array loo long\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 7163151045727362960;
                        break;
                    } else {
                        k = 0 as libc::c_int as int64_t;
                        while k < len {
                            res = JS_TryGetPropertyInt64(ctx, e, k, &mut val);
                            if res < 0 as libc::c_int {
                                current_block = 7163151045727362960;
                                break 's_43;
                            }
                            if res != 0 {
                                if JS_DefinePropertyValueInt64(
                                    ctx,
                                    arr,
                                    n,
                                    val,
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int
                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 7163151045727362960;
                                    break 's_43;
                                }
                            }
                            k += 1;
                            n += 1;
                        }
                    }
                } else if n
                    >= ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                        - 1 as libc::c_int as libc::c_longlong
                {
                    JS_ThrowTypeError(
                        ctx,
                        b"Array loo long\0" as *const u8 as *const libc::c_char,
                    );
                    current_block = 7163151045727362960;
                    break;
                } else {
                    if JS_DefinePropertyValueInt64(
                        ctx,
                        arr,
                        n,
                        JS_DupValue(ctx, e),
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 14 as libc::c_int,
                    ) < 0 as libc::c_int
                    {
                        current_block = 7163151045727362960;
                        break;
                    }
                    n += 1;
                }
                i += 1;
            }
            match current_block {
                7163151045727362960 => {}
                _ => {
                    if !(JS_SetProperty(
                        ctx,
                        arr,
                        JS_ATOM_length as libc::c_int as JSAtom,
                        JS_NewInt64(ctx, n),
                    ) < 0 as libc::c_int)
                    {
                        JS_FreeValue(ctx, obj);
                        return arr;
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, arr);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_every(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut special: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut index_val: JSValue = 0;
    let mut res: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut func: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut len: int64_t = 0;
    let mut k: int64_t = 0;
    let mut n: int64_t = 0;
    let mut present: libc::c_int = 0;
    ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if special & 8 as libc::c_int != 0 {
        obj = JS_DupValue(ctx, this_val);
        len = js_typed_array_get_length_internal(ctx, obj) as int64_t;
        if len < 0 as libc::c_int as libc::c_longlong {
            current_block = 17070224896744043443;
        } else {
            current_block = 2968425633554183086;
        }
    } else {
        obj = JS_ToObject(ctx, this_val);
        if js_get_length64(ctx, &mut len, obj) != 0 {
            current_block = 17070224896744043443;
        } else {
            current_block = 2968425633554183086;
        }
    }
    match current_block {
        2968425633554183086 => {
            func = *argv.offset(0 as libc::c_int as isize);
            this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if argc > 1 as libc::c_int {
                this_arg = *argv.offset(1 as libc::c_int as isize);
            }
            if !(check_function(ctx, func) != 0) {
                match special {
                    0 | 8 => {
                        ret = (JS_TAG_BOOL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 9853141518545631134;
                    }
                    1 | 9 => {
                        ret = (JS_TAG_BOOL as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 9853141518545631134;
                    }
                    3 => {
                        ret = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt64(ctx, len));
                        if JS_IsException(ret) != 0 {
                            current_block = 17070224896744043443;
                        } else {
                            current_block = 9853141518545631134;
                        }
                    }
                    4 => {
                        ret = JS_ArraySpeciesCreate(
                            ctx,
                            obj,
                            JS_NewInt32(ctx, 0 as libc::c_int),
                        );
                        if JS_IsException(ret) != 0 {
                            current_block = 17070224896744043443;
                        } else {
                            current_block = 9853141518545631134;
                        }
                    }
                    11 => {
                        args[0 as libc::c_int as usize] = obj;
                        args[1 as libc::c_int
                            as usize] = JS_NewInt32(ctx, len as int32_t);
                        ret = js_typed_array___speciesCreate(
                            ctx,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            2 as libc::c_int,
                            args.as_mut_ptr(),
                        );
                        if JS_IsException(ret) != 0 {
                            current_block = 17070224896744043443;
                        } else {
                            current_block = 9853141518545631134;
                        }
                    }
                    12 => {
                        ret = JS_NewArray(ctx);
                        if JS_IsException(ret) != 0 {
                            current_block = 17070224896744043443;
                        } else {
                            current_block = 9853141518545631134;
                        }
                    }
                    _ => {
                        current_block = 9853141518545631134;
                    }
                }
                match current_block {
                    17070224896744043443 => {}
                    _ => {
                        n = 0 as libc::c_int as int64_t;
                        k = 0 as libc::c_int as int64_t;
                        loop {
                            if !(k < len) {
                                current_block = 3278890969395720953;
                                break;
                            }
                            if special & 8 as libc::c_int != 0 {
                                val = JS_GetPropertyInt64(ctx, obj, k);
                                if JS_IsException(val) != 0 {
                                    current_block = 17070224896744043443;
                                    break;
                                }
                                present = TRUE as libc::c_int;
                            } else {
                                present = JS_TryGetPropertyInt64(ctx, obj, k, &mut val);
                                if present < 0 as libc::c_int {
                                    current_block = 17070224896744043443;
                                    break;
                                }
                            }
                            if present != 0 {
                                index_val = JS_NewInt64(ctx, k);
                                if JS_IsException(index_val) != 0 {
                                    current_block = 17070224896744043443;
                                    break;
                                }
                                args[0 as libc::c_int as usize] = val;
                                args[1 as libc::c_int as usize] = index_val;
                                args[2 as libc::c_int as usize] = obj;
                                res = JS_Call(
                                    ctx,
                                    func,
                                    this_arg,
                                    3 as libc::c_int,
                                    args.as_mut_ptr(),
                                );
                                JS_FreeValue(ctx, index_val);
                                if JS_IsException(res) != 0 {
                                    current_block = 17070224896744043443;
                                    break;
                                }
                                match special {
                                    0 | 8 => {
                                        if JS_ToBoolFree(ctx, res) == 0 {
                                            ret = (JS_TAG_BOOL as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                            current_block = 3278890969395720953;
                                            break;
                                        }
                                    }
                                    1 | 9 => {
                                        if JS_ToBoolFree(ctx, res) != 0 {
                                            ret = (JS_TAG_BOOL as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
                                            current_block = 3278890969395720953;
                                            break;
                                        }
                                    }
                                    3 => {
                                        if JS_DefinePropertyValueInt64(
                                            ctx,
                                            ret,
                                            k,
                                            res,
                                            (1 as libc::c_int) << 0 as libc::c_int
                                                | (1 as libc::c_int) << 1 as libc::c_int
                                                | (1 as libc::c_int) << 2 as libc::c_int
                                                | (1 as libc::c_int) << 14 as libc::c_int,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 17070224896744043443;
                                            break;
                                        }
                                    }
                                    11 => {
                                        if JS_SetPropertyValue(
                                            ctx,
                                            ret,
                                            JS_NewInt32(ctx, k as int32_t),
                                            res,
                                            (1 as libc::c_int) << 14 as libc::c_int,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 17070224896744043443;
                                            break;
                                        }
                                    }
                                    4 | 12 => {
                                        if JS_ToBoolFree(ctx, res) != 0 {
                                            let fresh641 = n;
                                            n = n + 1;
                                            if JS_DefinePropertyValueInt64(
                                                ctx,
                                                ret,
                                                fresh641,
                                                JS_DupValue(ctx, val),
                                                (1 as libc::c_int) << 0 as libc::c_int
                                                    | (1 as libc::c_int) << 1 as libc::c_int
                                                    | (1 as libc::c_int) << 2 as libc::c_int
                                                    | (1 as libc::c_int) << 14 as libc::c_int,
                                            ) < 0 as libc::c_int
                                            {
                                                current_block = 17070224896744043443;
                                                break;
                                            }
                                        }
                                    }
                                    _ => {
                                        JS_FreeValue(ctx, res);
                                    }
                                }
                                JS_FreeValue(ctx, val);
                                val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                            }
                            k += 1;
                        }
                        match current_block {
                            17070224896744043443 => {}
                            _ => {
                                if special == 4 as libc::c_int | 8 as libc::c_int {
                                    let mut arr: JSValue = 0;
                                    args[0 as libc::c_int as usize] = obj;
                                    args[1 as libc::c_int
                                        as usize] = JS_NewInt32(ctx, n as int32_t);
                                    arr = js_typed_array___speciesCreate(
                                        ctx,
                                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                        2 as libc::c_int,
                                        args.as_mut_ptr(),
                                    );
                                    if JS_IsException(arr) != 0 {
                                        current_block = 17070224896744043443;
                                    } else {
                                        args[0 as libc::c_int as usize] = ret;
                                        res = JS_Invoke(
                                            ctx,
                                            arr,
                                            JS_ATOM_set as libc::c_int as JSAtom,
                                            1 as libc::c_int,
                                            args.as_mut_ptr(),
                                        );
                                        if check_exception_free(ctx, res) != 0 {
                                            current_block = 17070224896744043443;
                                        } else {
                                            JS_FreeValue(ctx, ret);
                                            ret = arr;
                                            current_block = 15855550149339537395;
                                        }
                                    }
                                } else {
                                    current_block = 15855550149339537395;
                                }
                                match current_block {
                                    17070224896744043443 => {}
                                    _ => {
                                        JS_FreeValue(ctx, val);
                                        JS_FreeValue(ctx, obj);
                                        return ret;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, ret);
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_reduce(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut special: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut index_val: JSValue = 0;
    let mut acc: JSValue = 0;
    let mut acc1: JSValue = 0;
    let mut args: [JSValue; 4] = [0; 4];
    let mut func: JSValue = 0;
    let mut len: int64_t = 0;
    let mut k: int64_t = 0;
    let mut k1: int64_t = 0;
    let mut present: libc::c_int = 0;
    acc = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if special & 8 as libc::c_int != 0 {
        obj = JS_DupValue(ctx, this_val);
        len = js_typed_array_get_length_internal(ctx, obj) as int64_t;
        if len < 0 as libc::c_int as libc::c_longlong {
            current_block = 9295644380502404165;
        } else {
            current_block = 2968425633554183086;
        }
    } else {
        obj = JS_ToObject(ctx, this_val);
        if js_get_length64(ctx, &mut len, obj) != 0 {
            current_block = 9295644380502404165;
        } else {
            current_block = 2968425633554183086;
        }
    }
    match current_block {
        2968425633554183086 => {
            func = *argv.offset(0 as libc::c_int as isize);
            if !(check_function(ctx, func) != 0) {
                k = 0 as libc::c_int as int64_t;
                if argc > 1 as libc::c_int {
                    acc = JS_DupValue(ctx, *argv.offset(1 as libc::c_int as isize));
                    current_block = 18377268871191777778;
                } else {
                    loop {
                        if k >= len {
                            JS_ThrowTypeError(
                                ctx,
                                b"empty array\0" as *const u8 as *const libc::c_char,
                            );
                            current_block = 9295644380502404165;
                            break;
                        } else {
                            k1 = if special & 1 as libc::c_int != 0 {
                                len - k - 1 as libc::c_int as libc::c_longlong
                            } else {
                                k
                            };
                            k += 1;
                            if special & 8 as libc::c_int != 0 {
                                acc = JS_GetPropertyInt64(ctx, obj, k1);
                                if JS_IsException(acc) != 0 {
                                    current_block = 9295644380502404165;
                                    break;
                                } else {
                                    current_block = 18377268871191777778;
                                    break;
                                }
                            } else {
                                present = JS_TryGetPropertyInt64(ctx, obj, k1, &mut acc);
                                if present < 0 as libc::c_int {
                                    current_block = 9295644380502404165;
                                    break;
                                }
                                if present != 0 {
                                    current_block = 18377268871191777778;
                                    break;
                                }
                            }
                        }
                    }
                }
                match current_block {
                    9295644380502404165 => {}
                    _ => {
                        loop {
                            if !(k < len) {
                                current_block = 9353995356876505083;
                                break;
                            }
                            k1 = if special & 1 as libc::c_int != 0 {
                                len - k - 1 as libc::c_int as libc::c_longlong
                            } else {
                                k
                            };
                            if special & 8 as libc::c_int != 0 {
                                val = JS_GetPropertyInt64(ctx, obj, k1);
                                if JS_IsException(val) != 0 {
                                    current_block = 9295644380502404165;
                                    break;
                                }
                                present = TRUE as libc::c_int;
                            } else {
                                present = JS_TryGetPropertyInt64(ctx, obj, k1, &mut val);
                                if present < 0 as libc::c_int {
                                    current_block = 9295644380502404165;
                                    break;
                                }
                            }
                            if present != 0 {
                                index_val = JS_NewInt64(ctx, k1);
                                if JS_IsException(index_val) != 0 {
                                    current_block = 9295644380502404165;
                                    break;
                                }
                                args[0 as libc::c_int as usize] = acc;
                                args[1 as libc::c_int as usize] = val;
                                args[2 as libc::c_int as usize] = index_val;
                                args[3 as libc::c_int as usize] = obj;
                                acc1 = JS_Call(
                                    ctx,
                                    func,
                                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                    4 as libc::c_int,
                                    args.as_mut_ptr(),
                                );
                                JS_FreeValue(ctx, index_val);
                                JS_FreeValue(ctx, val);
                                val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                if JS_IsException(acc1) != 0 {
                                    current_block = 9295644380502404165;
                                    break;
                                }
                                JS_FreeValue(ctx, acc);
                                acc = acc1;
                            }
                            k += 1;
                        }
                        match current_block {
                            9295644380502404165 => {}
                            _ => {
                                JS_FreeValue(ctx, obj);
                                return acc;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, acc);
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_fill(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut len: int64_t = 0;
    let mut start: int64_t = 0;
    let mut end: int64_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        start = 0 as libc::c_int as int64_t;
        if argc > 1 as libc::c_int
            && JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0
        {
            if JS_ToInt64Clamp(
                ctx,
                &mut start,
                *argv.offset(1 as libc::c_int as isize),
                0 as libc::c_int as int64_t,
                len,
                len,
            ) != 0
            {
                current_block = 8865198073044636411;
            } else {
                current_block = 2473556513754201174;
            }
        } else {
            current_block = 2473556513754201174;
        }
        match current_block {
            8865198073044636411 => {}
            _ => {
                end = len;
                if argc > 2 as libc::c_int
                    && JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) == 0
                {
                    if JS_ToInt64Clamp(
                        ctx,
                        &mut end,
                        *argv.offset(2 as libc::c_int as isize),
                        0 as libc::c_int as int64_t,
                        len,
                        len,
                    ) != 0
                    {
                        current_block = 8865198073044636411;
                    } else {
                        current_block = 2868539653012386629;
                    }
                } else {
                    current_block = 2868539653012386629;
                }
                match current_block {
                    8865198073044636411 => {}
                    _ => {
                        loop {
                            if !(start < end) {
                                current_block = 3512920355445576850;
                                break;
                            }
                            if JS_SetPropertyInt64(
                                ctx,
                                obj,
                                start,
                                JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                            ) < 0 as libc::c_int
                            {
                                current_block = 8865198073044636411;
                                break;
                            }
                            start += 1;
                        }
                        match current_block {
                            8865198073044636411 => {}
                            _ => return obj,
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_includes(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut len: int64_t = 0;
    let mut n: int64_t = 0;
    let mut res: int64_t = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut count: uint32_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        res = FALSE as libc::c_int as int64_t;
        if len > 0 as libc::c_int as libc::c_longlong {
            n = 0 as libc::c_int as int64_t;
            if argc > 1 as libc::c_int {
                if JS_ToInt64Clamp(
                    ctx,
                    &mut n,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int as int64_t,
                    len,
                    len,
                ) != 0
                {
                    current_block = 12793914168086882172;
                } else {
                    current_block = 13183875560443969876;
                }
            } else {
                current_block = 13183875560443969876;
            }
            match current_block {
                12793914168086882172 => {}
                _ => {
                    if js_get_fast_array(ctx, obj, &mut arrp, &mut count) != 0 {
                        loop {
                            if !(n < count as libc::c_longlong) {
                                current_block = 12039483399334584727;
                                break;
                            }
                            if js_strict_eq2(
                                ctx,
                                JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                                JS_DupValue(ctx, *arrp.offset(n as isize)),
                                JS_EQ_SAME_VALUE_ZERO,
                            ) != 0
                            {
                                res = TRUE as libc::c_int as int64_t;
                                current_block = 17876704038207792083;
                                break;
                            } else {
                                n += 1;
                            }
                        }
                    } else {
                        current_block = 12039483399334584727;
                    }
                    match current_block {
                        17876704038207792083 => {}
                        _ => {
                            loop {
                                if !(n < len) {
                                    current_block = 17876704038207792083;
                                    break;
                                }
                                val = JS_GetPropertyInt64(ctx, obj, n);
                                if JS_IsException(val) != 0 {
                                    current_block = 12793914168086882172;
                                    break;
                                }
                                if js_strict_eq2(
                                    ctx,
                                    JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                                    val,
                                    JS_EQ_SAME_VALUE_ZERO,
                                ) != 0
                                {
                                    res = TRUE as libc::c_int as int64_t;
                                    current_block = 17876704038207792083;
                                    break;
                                } else {
                                    n += 1;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            current_block = 17876704038207792083;
        }
        match current_block {
            12793914168086882172 => {}
            _ => {
                JS_FreeValue(ctx, obj);
                return JS_NewBool(ctx, res as libc::c_int);
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_indexOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut len: int64_t = 0;
    let mut n: int64_t = 0;
    let mut res: int64_t = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut count: uint32_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        res = -(1 as libc::c_int) as int64_t;
        if len > 0 as libc::c_int as libc::c_longlong {
            n = 0 as libc::c_int as int64_t;
            if argc > 1 as libc::c_int {
                if JS_ToInt64Clamp(
                    ctx,
                    &mut n,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int as int64_t,
                    len,
                    len,
                ) != 0
                {
                    current_block = 4624693889497437834;
                } else {
                    current_block = 13183875560443969876;
                }
            } else {
                current_block = 13183875560443969876;
            }
            match current_block {
                4624693889497437834 => {}
                _ => {
                    if js_get_fast_array(ctx, obj, &mut arrp, &mut count) != 0 {
                        loop {
                            if !(n < count as libc::c_longlong) {
                                current_block = 12039483399334584727;
                                break;
                            }
                            if js_strict_eq2(
                                ctx,
                                JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                                JS_DupValue(ctx, *arrp.offset(n as isize)),
                                JS_EQ_STRICT,
                            ) != 0
                            {
                                res = n;
                                current_block = 2562411805215962485;
                                break;
                            } else {
                                n += 1;
                            }
                        }
                    } else {
                        current_block = 12039483399334584727;
                    }
                    match current_block {
                        2562411805215962485 => {}
                        _ => {
                            loop {
                                if !(n < len) {
                                    current_block = 2562411805215962485;
                                    break;
                                }
                                let mut present: libc::c_int = JS_TryGetPropertyInt64(
                                    ctx,
                                    obj,
                                    n,
                                    &mut val,
                                );
                                if present < 0 as libc::c_int {
                                    current_block = 4624693889497437834;
                                    break;
                                }
                                if present != 0 {
                                    if js_strict_eq2(
                                        ctx,
                                        JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                                        val,
                                        JS_EQ_STRICT,
                                    ) != 0
                                    {
                                        res = n;
                                        current_block = 2562411805215962485;
                                        break;
                                    }
                                }
                                n += 1;
                            }
                        }
                    }
                }
            }
        } else {
            current_block = 2562411805215962485;
        }
        match current_block {
            4624693889497437834 => {}
            _ => {
                JS_FreeValue(ctx, obj);
                return JS_NewInt64(ctx, res);
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_lastIndexOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut len: int64_t = 0;
    let mut n: int64_t = 0;
    let mut res: int64_t = 0;
    let mut present: libc::c_int = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        res = -(1 as libc::c_int) as int64_t;
        if len > 0 as libc::c_int as libc::c_longlong {
            n = len - 1 as libc::c_int as libc::c_longlong;
            if argc > 1 as libc::c_int {
                if JS_ToInt64Clamp(
                    ctx,
                    &mut n,
                    *argv.offset(1 as libc::c_int as isize),
                    -(1 as libc::c_int) as int64_t,
                    len - 1 as libc::c_int as libc::c_longlong,
                    len,
                ) != 0
                {
                    current_block = 13316644664568650048;
                } else {
                    current_block = 13183875560443969876;
                }
            } else {
                current_block = 13183875560443969876;
            }
            match current_block {
                13316644664568650048 => {}
                _ => {
                    loop {
                        if !(n >= 0 as libc::c_int as libc::c_longlong) {
                            current_block = 6009453772311597924;
                            break;
                        }
                        present = JS_TryGetPropertyInt64(ctx, obj, n, &mut val);
                        if present < 0 as libc::c_int {
                            current_block = 13316644664568650048;
                            break;
                        }
                        if present != 0 {
                            if js_strict_eq2(
                                ctx,
                                JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                                val,
                                JS_EQ_STRICT,
                            ) != 0
                            {
                                res = n;
                                current_block = 6009453772311597924;
                                break;
                            }
                        }
                        n -= 1;
                    }
                }
            }
        } else {
            current_block = 6009453772311597924;
        }
        match current_block {
            13316644664568650048 => {}
            _ => {
                JS_FreeValue(ctx, obj);
                return JS_NewInt64(ctx, res);
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_find(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut findIndex: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut func: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut index_val: JSValue = 0;
    let mut res: JSValue = 0;
    let mut len: int64_t = 0;
    let mut k: int64_t = 0;
    index_val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        func = *argv.offset(0 as libc::c_int as isize);
        if !(check_function(ctx, func) != 0) {
            this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if argc > 1 as libc::c_int {
                this_arg = *argv.offset(1 as libc::c_int as isize);
            }
            k = 0 as libc::c_int as int64_t;
            loop {
                if !(k < len) {
                    current_block = 5494826135382683477;
                    break;
                }
                index_val = JS_NewInt64(ctx, k);
                if JS_IsException(index_val) != 0 {
                    current_block = 15546058887659986959;
                    break;
                }
                val = JS_GetPropertyValue(ctx, obj, index_val);
                if JS_IsException(val) != 0 {
                    current_block = 15546058887659986959;
                    break;
                }
                args[0 as libc::c_int as usize] = val;
                args[1 as libc::c_int as usize] = index_val;
                args[2 as libc::c_int as usize] = this_val;
                res = JS_Call(ctx, func, this_arg, 3 as libc::c_int, args.as_mut_ptr());
                if JS_IsException(res) != 0 {
                    current_block = 15546058887659986959;
                    break;
                }
                if JS_ToBoolFree(ctx, res) != 0 {
                    if findIndex != 0 {
                        JS_FreeValue(ctx, val);
                        JS_FreeValue(ctx, obj);
                        return index_val;
                    } else {
                        JS_FreeValue(ctx, index_val);
                        JS_FreeValue(ctx, obj);
                        return val;
                    }
                }
                JS_FreeValue(ctx, val);
                JS_FreeValue(ctx, index_val);
                k += 1;
            }
            match current_block {
                15546058887659986959 => {}
                _ => {
                    JS_FreeValue(ctx, obj);
                    if findIndex != 0 {
                        return JS_NewInt32(ctx, -(1 as libc::c_int))
                    } else {
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, index_val);
    JS_FreeValue(ctx, val);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    obj = JS_ToObject(ctx, this_val);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    method = JS_GetProperty(ctx, obj, JS_ATOM_join as libc::c_int as JSAtom);
    if JS_IsException(method) != 0 {
        ret = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else if JS_IsFunction(ctx, method) == 0 {
        JS_FreeValue(ctx, method);
        ret = js_object_toString(ctx, obj, 0 as libc::c_int, 0 as *mut JSValue);
    } else {
        ret = JS_CallFree(ctx, method, obj, 0 as libc::c_int, 0 as *mut JSValue);
    }
    JS_FreeValue(ctx, obj);
    return ret;
}
unsafe extern "C" fn js_array_join(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut toLocaleString: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut sep: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut el: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: int64_t = 0;
    let mut n: int64_t = 0;
    let mut c: libc::c_int = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut n, obj) != 0) {
        c = ',' as i32;
        if toLocaleString == 0 && argc > 0 as libc::c_int
            && JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) == 0
        {
            sep = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
            if JS_IsException(sep) != 0 {
                current_block = 6316400395312494500;
            } else {
                p = sep as intptr_t as *mut libc::c_void as *mut JSString;
                if (*p).len() as libc::c_int == 1 as libc::c_int
                    && (*p).is_wide_char() == 0
                {
                    c = (*p).u.str8[0 as libc::c_int as usize] as libc::c_int;
                } else {
                    c = -(1 as libc::c_int);
                }
                current_block = 1856101646708284338;
            }
        } else {
            current_block = 1856101646708284338;
        }
        match current_block {
            6316400395312494500 => {}
            _ => {
                string_buffer_init(ctx, b, 0 as libc::c_int);
                i = 0 as libc::c_int as int64_t;
                loop {
                    if !(i < n) {
                        current_block = 17788412896529399552;
                        break;
                    }
                    if i > 0 as libc::c_int as libc::c_longlong {
                        if c >= 0 as libc::c_int {
                            string_buffer_putc8(b, c as uint32_t);
                        } else {
                            string_buffer_concat(
                                b,
                                p,
                                0 as libc::c_int as uint32_t,
                                (*p).len(),
                            );
                        }
                    }
                    el = JS_GetPropertyUint32(ctx, obj, i as uint32_t);
                    if JS_IsException(el) != 0 {
                        current_block = 872469572722668357;
                        break;
                    }
                    if JS_IsNull(el) == 0 && JS_IsUndefined(el) == 0 {
                        if toLocaleString != 0 {
                            el = JS_ToLocaleStringFree(ctx, el);
                        }
                        if string_buffer_concat_value_free(b, el) != 0 {
                            current_block = 872469572722668357;
                            break;
                        }
                    }
                    i += 1;
                }
                match current_block {
                    872469572722668357 => {
                        string_buffer_free(b);
                        JS_FreeValue(ctx, sep);
                    }
                    _ => {
                        JS_FreeValue(ctx, sep);
                        JS_FreeValue(ctx, obj);
                        return string_buffer_end(b);
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_pop(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut shift: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut res: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut len: int64_t = 0;
    let mut newLen: int64_t = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut count32: uint32_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        newLen = 0 as libc::c_int as int64_t;
        if len > 0 as libc::c_int as libc::c_longlong {
            newLen = len - 1 as libc::c_int as libc::c_longlong;
            if js_get_fast_array(ctx, obj, &mut arrp, &mut count32) != 0
                && count32 as libc::c_longlong == len
            {
                let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void
                    as *mut JSObject;
                if shift != 0 {
                    res = *arrp.offset(0 as libc::c_int as isize);
                    memmove(
                        arrp as *mut libc::c_void,
                        arrp.offset(1 as libc::c_int as isize) as *const libc::c_void,
                        (count32.wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<JSValue>() as libc::c_ulong,
                            ),
                    );
                    let ref mut fresh642 = (*p).u.array.count;
                    *fresh642 = (*fresh642).wrapping_sub(1);
                } else {
                    res = *arrp
                        .offset(
                            count32.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as isize,
                        );
                    let ref mut fresh643 = (*p).u.array.count;
                    *fresh643 = (*fresh643).wrapping_sub(1);
                }
                current_block = 4068382217303356765;
            } else {
                if shift != 0 {
                    res = JS_GetPropertyInt64(ctx, obj, 0 as libc::c_int as int64_t);
                    if JS_IsException(res) != 0 {
                        current_block = 16158028991416183220;
                    } else if JS_CopySubArray(
                        ctx,
                        obj,
                        0 as libc::c_int as int64_t,
                        1 as libc::c_int as int64_t,
                        len - 1 as libc::c_int as libc::c_longlong,
                        1 as libc::c_int,
                    ) != 0
                    {
                        current_block = 16158028991416183220;
                    } else {
                        current_block = 11298138898191919651;
                    }
                } else {
                    res = JS_GetPropertyInt64(ctx, obj, newLen);
                    if JS_IsException(res) != 0 {
                        current_block = 16158028991416183220;
                    } else {
                        current_block = 11298138898191919651;
                    }
                }
                match current_block {
                    16158028991416183220 => {}
                    _ => {
                        if JS_DeletePropertyInt64(
                            ctx,
                            obj,
                            newLen,
                            (1 as libc::c_int) << 14 as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            current_block = 16158028991416183220;
                        } else {
                            current_block = 4068382217303356765;
                        }
                    }
                }
            }
        } else {
            current_block = 4068382217303356765;
        }
        match current_block {
            16158028991416183220 => {}
            _ => {
                if !(JS_SetProperty(
                    ctx,
                    obj,
                    JS_ATOM_length as libc::c_int as JSAtom,
                    JS_NewInt64(ctx, newLen),
                ) < 0 as libc::c_int)
                {
                    JS_FreeValue(ctx, obj);
                    return res;
                }
            }
        }
    }
    JS_FreeValue(ctx, res);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_push(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut unshift: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut i: libc::c_int = 0;
    let mut len: int64_t = 0;
    let mut from: int64_t = 0;
    let mut newLen: int64_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        newLen = len + argc as libc::c_longlong;
        if newLen
            > ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong
        {
            JS_ThrowTypeError(
                ctx,
                b"Array loo long\0" as *const u8 as *const libc::c_char,
            );
        } else {
            from = len;
            if unshift != 0 && argc > 0 as libc::c_int {
                if JS_CopySubArray(
                    ctx,
                    obj,
                    argc as int64_t,
                    0 as libc::c_int as int64_t,
                    len,
                    -(1 as libc::c_int),
                ) != 0
                {
                    current_block = 7984881232798200841;
                } else {
                    from = 0 as libc::c_int as int64_t;
                    current_block = 12209867499936983673;
                }
            } else {
                current_block = 12209867499936983673;
            }
            match current_block {
                7984881232798200841 => {}
                _ => {
                    i = 0 as libc::c_int;
                    loop {
                        if !(i < argc) {
                            current_block = 9606288038608642794;
                            break;
                        }
                        if JS_SetPropertyInt64(
                            ctx,
                            obj,
                            from + i as libc::c_longlong,
                            JS_DupValue(ctx, *argv.offset(i as isize)),
                        ) < 0 as libc::c_int
                        {
                            current_block = 7984881232798200841;
                            break;
                        }
                        i += 1;
                    }
                    match current_block {
                        7984881232798200841 => {}
                        _ => {
                            if !(JS_SetProperty(
                                ctx,
                                obj,
                                JS_ATOM_length as libc::c_int as JSAtom,
                                JS_NewInt64(ctx, newLen),
                            ) < 0 as libc::c_int)
                            {
                                JS_FreeValue(ctx, obj);
                                return JS_NewInt64(ctx, newLen);
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_reverse(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut lval: JSValue = 0;
    let mut hval: JSValue = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut len: int64_t = 0;
    let mut l: int64_t = 0;
    let mut h: int64_t = 0;
    let mut l_present: libc::c_int = 0;
    let mut h_present: libc::c_int = 0;
    let mut count32: uint32_t = 0;
    lval = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        if js_get_fast_array(ctx, obj, &mut arrp, &mut count32) != 0
            && count32 as libc::c_longlong == len
        {
            let mut ll: uint32_t = 0;
            let mut hh: uint32_t = 0;
            if count32 > 1 as libc::c_int as libc::c_uint {
                ll = 0 as libc::c_int as uint32_t;
                hh = count32.wrapping_sub(1 as libc::c_int as libc::c_uint);
                while ll < hh {
                    lval = *arrp.offset(ll as isize);
                    *arrp.offset(ll as isize) = *arrp.offset(hh as isize);
                    *arrp.offset(hh as isize) = lval;
                    ll = ll.wrapping_add(1);
                    hh = hh.wrapping_sub(1);
                }
            }
            return obj;
        }
        l = 0 as libc::c_int as int64_t;
        h = len - 1 as libc::c_int as libc::c_longlong;
        loop {
            if !(l < h) {
                current_block = 11743904203796629665;
                break;
            }
            l_present = JS_TryGetPropertyInt64(ctx, obj, l, &mut lval);
            if l_present < 0 as libc::c_int {
                current_block = 14842405834132355970;
                break;
            }
            h_present = JS_TryGetPropertyInt64(ctx, obj, h, &mut hval);
            if h_present < 0 as libc::c_int {
                current_block = 14842405834132355970;
                break;
            }
            if h_present != 0 {
                if JS_SetPropertyInt64(ctx, obj, l, hval) < 0 as libc::c_int {
                    current_block = 14842405834132355970;
                    break;
                }
                if l_present != 0 {
                    if JS_SetPropertyInt64(ctx, obj, h, lval) < 0 as libc::c_int {
                        lval = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                        current_block = 14842405834132355970;
                        break;
                    } else {
                        lval = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                } else if JS_DeletePropertyInt64(
                    ctx,
                    obj,
                    h,
                    (1 as libc::c_int) << 14 as libc::c_int,
                ) < 0 as libc::c_int
                {
                    current_block = 14842405834132355970;
                    break;
                }
            } else if l_present != 0 {
                if JS_DeletePropertyInt64(
                    ctx,
                    obj,
                    l,
                    (1 as libc::c_int) << 14 as libc::c_int,
                ) < 0 as libc::c_int
                {
                    current_block = 14842405834132355970;
                    break;
                }
                if JS_SetPropertyInt64(ctx, obj, h, lval) < 0 as libc::c_int {
                    lval = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    current_block = 14842405834132355970;
                    break;
                } else {
                    lval = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
            }
            l += 1;
            h -= 1;
        }
        match current_block {
            14842405834132355970 => {}
            _ => return obj,
        }
    }
    JS_FreeValue(ctx, lval);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_slice(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut splice: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut arr: JSValue = 0;
    let mut val: JSValue = 0;
    let mut len_val: JSValue = 0;
    let mut len: int64_t = 0;
    let mut start: int64_t = 0;
    let mut k: int64_t = 0;
    let mut final_0: int64_t = 0;
    let mut n: int64_t = 0;
    let mut count: int64_t = 0;
    let mut del_count: int64_t = 0;
    let mut new_len: int64_t = 0;
    let mut kPresent: libc::c_int = 0;
    let mut arrp: *mut JSValue = 0 as *mut JSValue;
    let mut count32: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut item_count: uint32_t = 0;
    arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        if !(JS_ToInt64Clamp(
            ctx,
            &mut start,
            *argv.offset(0 as libc::c_int as isize),
            0 as libc::c_int as int64_t,
            len,
            len,
        ) != 0)
        {
            if splice != 0 {
                if argc == 0 as libc::c_int {
                    item_count = 0 as libc::c_int as uint32_t;
                    del_count = 0 as libc::c_int as int64_t;
                    current_block = 15652330335145281839;
                } else if argc == 1 as libc::c_int {
                    item_count = 0 as libc::c_int as uint32_t;
                    del_count = len - start;
                    current_block = 15652330335145281839;
                } else {
                    item_count = (argc - 2 as libc::c_int) as uint32_t;
                    if JS_ToInt64Clamp(
                        ctx,
                        &mut del_count,
                        *argv.offset(1 as libc::c_int as isize),
                        0 as libc::c_int as int64_t,
                        len - start,
                        0 as libc::c_int as int64_t,
                    ) != 0
                    {
                        current_block = 16746663487748425864;
                    } else {
                        current_block = 15652330335145281839;
                    }
                }
                match current_block {
                    16746663487748425864 => {}
                    _ => {
                        if len + item_count as libc::c_longlong - del_count
                            > ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                                - 1 as libc::c_int as libc::c_longlong
                        {
                            JS_ThrowTypeError(
                                ctx,
                                b"Array loo long\0" as *const u8 as *const libc::c_char,
                            );
                            current_block = 16746663487748425864;
                        } else {
                            count = del_count;
                            current_block = 14763689060501151050;
                        }
                    }
                }
            } else {
                item_count = 0 as libc::c_int as uint32_t;
                final_0 = len;
                if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
                    if JS_ToInt64Clamp(
                        ctx,
                        &mut final_0,
                        *argv.offset(1 as libc::c_int as isize),
                        0 as libc::c_int as int64_t,
                        len,
                        len,
                    ) != 0
                    {
                        current_block = 16746663487748425864;
                    } else {
                        current_block = 18386322304582297246;
                    }
                } else {
                    current_block = 18386322304582297246;
                }
                match current_block {
                    16746663487748425864 => {}
                    _ => {
                        count = max_int64(final_0 - start, 0 as libc::c_int as int64_t);
                        current_block = 14763689060501151050;
                    }
                }
            }
            match current_block {
                16746663487748425864 => {}
                _ => {
                    len_val = JS_NewInt64(ctx, count);
                    arr = JS_ArraySpeciesCreate(ctx, obj, len_val);
                    JS_FreeValue(ctx, len_val);
                    if !(JS_IsException(arr) != 0) {
                        k = start;
                        final_0 = start + count;
                        n = 0 as libc::c_int as int64_t;
                        if js_get_fast_array(ctx, obj, &mut arrp, &mut count32) != 0
                            && js_is_fast_array(ctx, arr) != 0
                        {
                            loop {
                                if !(k < final_0 && k < count32 as libc::c_longlong) {
                                    current_block = 14072441030219150333;
                                    break;
                                }
                                if JS_CreateDataPropertyUint32(
                                    ctx,
                                    arr,
                                    n,
                                    JS_DupValue(ctx, *arrp.offset(k as isize)),
                                    (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 16746663487748425864;
                                    break;
                                }
                                k += 1;
                                n += 1;
                            }
                        } else {
                            current_block = 14072441030219150333;
                        }
                        match current_block {
                            16746663487748425864 => {}
                            _ => {
                                loop {
                                    if !(k < final_0) {
                                        current_block = 16799951812150840583;
                                        break;
                                    }
                                    kPresent = JS_TryGetPropertyInt64(ctx, obj, k, &mut val);
                                    if kPresent < 0 as libc::c_int {
                                        current_block = 16746663487748425864;
                                        break;
                                    }
                                    if kPresent != 0 {
                                        if JS_CreateDataPropertyUint32(
                                            ctx,
                                            arr,
                                            n,
                                            val,
                                            (1 as libc::c_int) << 14 as libc::c_int,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 16746663487748425864;
                                            break;
                                        }
                                    }
                                    k += 1;
                                    n += 1;
                                }
                                match current_block {
                                    16746663487748425864 => {}
                                    _ => {
                                        if !(JS_SetProperty(
                                            ctx,
                                            arr,
                                            JS_ATOM_length as libc::c_int as JSAtom,
                                            JS_NewInt64(ctx, n),
                                        ) < 0 as libc::c_int)
                                        {
                                            if splice != 0 {
                                                new_len = len + item_count as libc::c_longlong - del_count;
                                                if item_count as libc::c_longlong != del_count {
                                                    if JS_CopySubArray(
                                                        ctx,
                                                        obj,
                                                        start + item_count as libc::c_longlong,
                                                        start + del_count,
                                                        len - (start + del_count),
                                                        (if item_count as libc::c_longlong <= del_count {
                                                            1 as libc::c_int
                                                        } else {
                                                            -(1 as libc::c_int)
                                                        }),
                                                    ) < 0 as libc::c_int
                                                    {
                                                        current_block = 16746663487748425864;
                                                    } else {
                                                        k = len;
                                                        loop {
                                                            let fresh644 = k;
                                                            k = k - 1;
                                                            if !(fresh644 > new_len) {
                                                                current_block = 2500484646272006982;
                                                                break;
                                                            }
                                                            if JS_DeletePropertyInt64(
                                                                ctx,
                                                                obj,
                                                                k,
                                                                (1 as libc::c_int) << 14 as libc::c_int,
                                                            ) < 0 as libc::c_int
                                                            {
                                                                current_block = 16746663487748425864;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    current_block = 2500484646272006982;
                                                }
                                                match current_block {
                                                    16746663487748425864 => {}
                                                    _ => {
                                                        i = 0 as libc::c_int as uint32_t;
                                                        loop {
                                                            if !(i < item_count) {
                                                                current_block = 168769493162332264;
                                                                break;
                                                            }
                                                            if JS_SetPropertyInt64(
                                                                ctx,
                                                                obj,
                                                                start + i as libc::c_longlong,
                                                                JS_DupValue(
                                                                    ctx,
                                                                    *argv
                                                                        .offset(
                                                                            i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize,
                                                                        ),
                                                                ),
                                                            ) < 0 as libc::c_int
                                                            {
                                                                current_block = 16746663487748425864;
                                                                break;
                                                            }
                                                            i = i.wrapping_add(1);
                                                        }
                                                        match current_block {
                                                            16746663487748425864 => {}
                                                            _ => {
                                                                if JS_SetProperty(
                                                                    ctx,
                                                                    obj,
                                                                    JS_ATOM_length as libc::c_int as JSAtom,
                                                                    JS_NewInt64(ctx, new_len),
                                                                ) < 0 as libc::c_int
                                                                {
                                                                    current_block = 16746663487748425864;
                                                                } else {
                                                                    current_block = 7252614138838059896;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block = 7252614138838059896;
                                            }
                                            match current_block {
                                                16746663487748425864 => {}
                                                _ => {
                                                    JS_FreeValue(ctx, obj);
                                                    return arr;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    JS_FreeValue(ctx, arr);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_copyWithin(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut len: int64_t = 0;
    let mut from: int64_t = 0;
    let mut to: int64_t = 0;
    let mut final_0: int64_t = 0;
    let mut count: int64_t = 0;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut len, obj) != 0) {
        if !(JS_ToInt64Clamp(
            ctx,
            &mut to,
            *argv.offset(0 as libc::c_int as isize),
            0 as libc::c_int as int64_t,
            len,
            len,
        ) != 0)
        {
            if !(JS_ToInt64Clamp(
                ctx,
                &mut from,
                *argv.offset(1 as libc::c_int as isize),
                0 as libc::c_int as int64_t,
                len,
                len,
            ) != 0)
            {
                final_0 = len;
                if argc > 2 as libc::c_int
                    && JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) == 0
                {
                    if JS_ToInt64Clamp(
                        ctx,
                        &mut final_0,
                        *argv.offset(2 as libc::c_int as isize),
                        0 as libc::c_int as int64_t,
                        len,
                        len,
                    ) != 0
                    {
                        current_block = 3480057068544122652;
                    } else {
                        current_block = 5720623009719927633;
                    }
                } else {
                    current_block = 5720623009719927633;
                }
                match current_block {
                    3480057068544122652 => {}
                    _ => {
                        count = min_int64(final_0 - from, len - to);
                        if !(JS_CopySubArray(
                            ctx,
                            obj,
                            to,
                            from,
                            count,
                            if from < to && to < from + count {
                                -(1 as libc::c_int)
                            } else {
                                1 as libc::c_int
                            },
                        ) != 0)
                        {
                            return obj;
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_FlattenIntoArray(
    mut ctx: *mut JSContext,
    mut target: JSValue,
    mut source: JSValue,
    mut sourceLen: int64_t,
    mut targetIndex: int64_t,
    mut depth: libc::c_int,
    mut mapperFunction: JSValue,
    mut thisArg: JSValue,
) -> int64_t {
    let mut current_block: u64;
    let mut element: JSValue = 0;
    let mut sourceIndex: int64_t = 0;
    let mut elementLen: int64_t = 0;
    let mut present: libc::c_int = 0;
    let mut is_array: libc::c_int = 0;
    if js_check_stack_overflow((*ctx).rt, 0 as libc::c_int as size_t) != 0 {
        JS_ThrowStackOverflow(ctx);
        return -(1 as libc::c_int) as int64_t;
    }
    sourceIndex = 0 as libc::c_int as int64_t;
    loop {
        if !(sourceIndex < sourceLen) {
            current_block = 652864300344834934;
            break;
        }
        present = JS_TryGetPropertyInt64(ctx, source, sourceIndex, &mut element);
        if present < 0 as libc::c_int {
            return -(1 as libc::c_int) as int64_t;
        }
        if !(present == 0) {
            if JS_IsUndefined(mapperFunction) == 0 {
                let mut args: [JSValue; 3] = [
                    element,
                    JS_NewInt64(ctx, sourceIndex),
                    source,
                ];
                element = JS_Call(
                    ctx,
                    mapperFunction,
                    thisArg,
                    3 as libc::c_int,
                    args.as_mut_ptr(),
                );
                JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
                JS_FreeValue(ctx, args[1 as libc::c_int as usize]);
                if JS_IsException(element) != 0 {
                    return -(1 as libc::c_int) as int64_t;
                }
            }
            if depth > 0 as libc::c_int {
                is_array = JS_IsArray(ctx, element);
                if is_array < 0 as libc::c_int {
                    current_block = 4045068618115368510;
                    break;
                }
                if is_array != 0 {
                    if js_get_length64(ctx, &mut elementLen, element) < 0 as libc::c_int
                    {
                        current_block = 4045068618115368510;
                        break;
                    }
                    targetIndex = JS_FlattenIntoArray(
                        ctx,
                        target,
                        element,
                        elementLen,
                        targetIndex,
                        depth - 1 as libc::c_int,
                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    );
                    if targetIndex < 0 as libc::c_int as libc::c_longlong {
                        current_block = 4045068618115368510;
                        break;
                    }
                    JS_FreeValue(ctx, element);
                    current_block = 6873731126896040597;
                } else {
                    current_block = 4068382217303356765;
                }
            } else {
                current_block = 4068382217303356765;
            }
            match current_block {
                6873731126896040597 => {}
                _ => {
                    if targetIndex
                        >= ((1 as libc::c_int as int64_t) << 53 as libc::c_int)
                            - 1 as libc::c_int as libc::c_longlong
                    {
                        JS_ThrowTypeError(
                            ctx,
                            b"Array too long\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 4045068618115368510;
                        break;
                    } else {
                        if JS_DefinePropertyValueInt64(
                            ctx,
                            target,
                            targetIndex,
                            element,
                            (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 2 as libc::c_int
                                | (1 as libc::c_int) << 14 as libc::c_int,
                        ) < 0 as libc::c_int
                        {
                            return -(1 as libc::c_int) as int64_t;
                        }
                        targetIndex += 1;
                    }
                }
            }
        }
        sourceIndex += 1;
    }
    match current_block {
        652864300344834934 => return targetIndex,
        _ => {
            JS_FreeValue(ctx, element);
            return -(1 as libc::c_int) as int64_t;
        }
    };
}
unsafe extern "C" fn js_array_flatten(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut map: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut arr: JSValue = 0;
    let mut mapperFunction: JSValue = 0;
    let mut thisArg: JSValue = 0;
    let mut sourceLen: int64_t = 0;
    let mut depthNum: libc::c_int = 0;
    arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    if !(js_get_length64(ctx, &mut sourceLen, obj) != 0) {
        depthNum = 1 as libc::c_int;
        mapperFunction = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
            << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        thisArg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        if map != 0 {
            mapperFunction = *argv.offset(0 as libc::c_int as isize);
            if argc > 1 as libc::c_int {
                thisArg = *argv.offset(1 as libc::c_int as isize);
            }
            if check_function(ctx, mapperFunction) != 0 {
                current_block = 11597273254897897052;
            } else {
                current_block = 15652330335145281839;
            }
        } else if argc > 0 as libc::c_int
            && JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) == 0
        {
            if JS_ToInt32Sat(ctx, &mut depthNum, *argv.offset(0 as libc::c_int as isize))
                < 0 as libc::c_int
            {
                current_block = 11597273254897897052;
            } else {
                current_block = 15652330335145281839;
            }
        } else {
            current_block = 15652330335145281839;
        }
        match current_block {
            11597273254897897052 => {}
            _ => {
                arr = JS_ArraySpeciesCreate(
                    ctx,
                    obj,
                    JS_NewInt32(ctx, 0 as libc::c_int),
                );
                if !(JS_IsException(arr) != 0) {
                    if !(JS_FlattenIntoArray(
                        ctx,
                        arr,
                        obj,
                        sourceLen,
                        0 as libc::c_int as int64_t,
                        depthNum,
                        mapperFunction,
                        thisArg,
                    ) < 0 as libc::c_int as libc::c_longlong)
                    {
                        JS_FreeValue(ctx, obj);
                        return arr;
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    JS_FreeValue(ctx, arr);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_cmp_generic(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut current_block: u64;
    let mut psc: *mut array_sort_context = opaque as *mut array_sort_context;
    let mut ctx: *mut JSContext = (*psc).ctx;
    let mut argv: [JSValue; 2] = [0; 2];
    let mut res: JSValue = 0;
    let mut ap: *mut ValueSlot = a as *mut libc::c_void as *mut ValueSlot;
    let mut bp: *mut ValueSlot = b as *mut libc::c_void as *mut ValueSlot;
    let mut cmp: libc::c_int = 0;
    if (*psc).exception != 0 {
        return 0 as libc::c_int;
    }
    if (*psc).has_method != 0 {
        if memcmp(
            &mut (*ap).val as *mut JSValue as *const libc::c_void,
            &mut (*bp).val as *mut JSValue as *const libc::c_void,
            ::core::mem::size_of::<JSValue>() as libc::c_ulong,
        ) == 0
        {
            current_block = 13154073765173699915;
        } else {
            argv[0 as libc::c_int as usize] = (*ap).val;
            argv[1 as libc::c_int as usize] = (*bp).val;
            res = JS_Call(
                ctx,
                (*psc).method,
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                2 as libc::c_int,
                argv.as_mut_ptr(),
            );
            if JS_IsException(res) != 0 {
                current_block = 536646762289345990;
            } else if (res >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_INT as libc::c_int
            {
                let mut val: libc::c_int = res as libc::c_int;
                cmp = (val > 0 as libc::c_int) as libc::c_int
                    - (val < 0 as libc::c_int) as libc::c_int;
                current_block = 1608152415753874203;
            } else {
                let mut val_0: libc::c_double = 0.;
                if JS_ToFloat64Free(ctx, &mut val_0, res) < 0 as libc::c_int {
                    current_block = 536646762289345990;
                } else {
                    cmp = (val_0 > 0 as libc::c_int as libc::c_double) as libc::c_int
                        - (val_0 < 0 as libc::c_int as libc::c_double) as libc::c_int;
                    current_block = 1608152415753874203;
                }
            }
        }
    } else {
        if ((*ap).str_0).is_null() {
            let mut str: JSValue = JS_ToString(ctx, (*ap).val);
            if JS_IsException(str) != 0 {
                current_block = 536646762289345990;
            } else {
                let ref mut fresh645 = (*ap).str_0;
                *fresh645 = str as intptr_t as *mut libc::c_void as *mut JSString;
                current_block = 1109700713171191020;
            }
        } else {
            current_block = 1109700713171191020;
        }
        match current_block {
            536646762289345990 => {}
            _ => {
                if ((*bp).str_0).is_null() {
                    let mut str_0: JSValue = JS_ToString(ctx, (*bp).val);
                    if JS_IsException(str_0) != 0 {
                        current_block = 536646762289345990;
                    } else {
                        let ref mut fresh646 = (*bp).str_0;
                        *fresh646 = str_0 as intptr_t as *mut libc::c_void
                            as *mut JSString;
                        current_block = 15125582407903384992;
                    }
                } else {
                    current_block = 15125582407903384992;
                }
                match current_block {
                    536646762289345990 => {}
                    _ => {
                        cmp = js_string_compare(ctx, (*ap).str_0, (*bp).str_0);
                        current_block = 1608152415753874203;
                    }
                }
            }
        }
    }
    match current_block {
        536646762289345990 => {
            (*psc).exception = 1 as libc::c_int;
            return 0 as libc::c_int;
        }
        1608152415753874203 => {
            if cmp != 0 as libc::c_int {
                return cmp;
            }
        }
        _ => {}
    }
    return ((*ap).pos > (*bp).pos) as libc::c_int
        - ((*ap).pos < (*bp).pos) as libc::c_int;
}
unsafe extern "C" fn js_array_sort(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut asc: array_sort_context = {
        let mut init = array_sort_context {
            ctx: ctx,
            exception: 0 as libc::c_int,
            has_method: 0 as libc::c_int,
            method: *argv.offset(0 as libc::c_int as isize),
        };
        init
    };
    let mut obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut array: *mut ValueSlot = 0 as *mut ValueSlot;
    let mut array_size: size_t = 0 as libc::c_int as size_t;
    let mut pos: size_t = 0 as libc::c_int as size_t;
    let mut n: size_t = 0 as libc::c_int as size_t;
    let mut i: int64_t = 0;
    let mut len: int64_t = 0;
    let mut undefined_count: int64_t = 0 as libc::c_int as int64_t;
    let mut present: libc::c_int = 0;
    if JS_IsUndefined(asc.method) == 0 {
        if check_function(ctx, asc.method) != 0 {
            current_block = 12083537708326820365;
        } else {
            asc.has_method = 1 as libc::c_int;
            current_block = 10879442775620481940;
        }
    } else {
        current_block = 10879442775620481940;
    }
    match current_block {
        10879442775620481940 => {
            obj = JS_ToObject(ctx, this_val);
            if js_get_length64(ctx, &mut len, obj) != 0 {
                current_block = 12083537708326820365;
            } else {
                i = 0 as libc::c_int as int64_t;
                loop {
                    if !(i < len) {
                        current_block = 15345278821338558188;
                        break;
                    }
                    if pos >= array_size {
                        let mut new_size: size_t = 0;
                        let mut slack: size_t = 0;
                        let mut new_array: *mut ValueSlot = 0 as *mut ValueSlot;
                        new_size = array_size
                            .wrapping_add(array_size >> 1 as libc::c_int)
                            .wrapping_add(31 as libc::c_int as libc::c_ulong)
                            & !(15 as libc::c_int) as libc::c_ulong;
                        new_array = js_realloc2(
                            ctx,
                            array as *mut libc::c_void,
                            new_size
                                .wrapping_mul(
                                    ::core::mem::size_of::<ValueSlot>() as libc::c_ulong,
                                ),
                            &mut slack,
                        ) as *mut ValueSlot;
                        if new_array.is_null() {
                            current_block = 12083537708326820365;
                            break;
                        }
                        new_size = (new_size as libc::c_ulong)
                            .wrapping_add(
                                slack
                                    .wrapping_div(
                                        ::core::mem::size_of::<ValueSlot>() as libc::c_ulong,
                                    ),
                            ) as size_t as size_t;
                        array = new_array;
                        array_size = new_size;
                    }
                    present = JS_TryGetPropertyInt64(
                        ctx,
                        obj,
                        i,
                        &mut (*array.offset(pos as isize)).val,
                    );
                    if present < 0 as libc::c_int {
                        current_block = 12083537708326820365;
                        break;
                    }
                    if !(present == 0 as libc::c_int) {
                        if JS_IsUndefined((*array.offset(pos as isize)).val) != 0 {
                            undefined_count += 1;
                        } else {
                            let ref mut fresh647 = (*array.offset(pos as isize)).str_0;
                            *fresh647 = 0 as *mut JSString;
                            (*array.offset(pos as isize)).pos = i;
                            pos = pos.wrapping_add(1);
                        }
                    }
                    i += 1;
                }
                match current_block {
                    12083537708326820365 => {}
                    _ => {
                        rqsort(
                            array as *mut libc::c_void,
                            pos,
                            ::core::mem::size_of::<ValueSlot>() as libc::c_ulong,
                            Some(
                                js_array_cmp_generic
                                    as unsafe extern "C" fn(
                                        *const libc::c_void,
                                        *const libc::c_void,
                                        *mut libc::c_void,
                                    ) -> libc::c_int,
                            ),
                            &mut asc as *mut array_sort_context as *mut libc::c_void,
                        );
                        if asc.exception != 0 {
                            current_block = 12083537708326820365;
                        } else {
                            loop {
                                if !(n < pos) {
                                    current_block = 7226443171521532240;
                                    break;
                                }
                                if !((*array.offset(n as isize)).str_0).is_null() {
                                    JS_FreeValue(
                                        ctx,
                                        (JS_TAG_STRING as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | (*array.offset(n as isize)).str_0 as uintptr_t
                                                as libc::c_ulonglong,
                                    );
                                }
                                if (*array.offset(n as isize)).pos == n as libc::c_longlong
                                {
                                    JS_FreeValue(ctx, (*array.offset(n as isize)).val);
                                } else if JS_SetPropertyInt64(
                                    ctx,
                                    obj,
                                    n as int64_t,
                                    (*array.offset(n as isize)).val,
                                ) < 0 as libc::c_int
                                {
                                    n = n.wrapping_add(1);
                                    current_block = 12083537708326820365;
                                    break;
                                }
                                n = n.wrapping_add(1);
                            }
                            match current_block {
                                12083537708326820365 => {}
                                _ => {
                                    js_free(ctx, array as *mut libc::c_void);
                                    i = n as int64_t;
                                    loop {
                                        let fresh648 = undefined_count;
                                        undefined_count = undefined_count - 1;
                                        if !(fresh648 > 0 as libc::c_int as libc::c_longlong) {
                                            current_block = 11626999923138678822;
                                            break;
                                        }
                                        if JS_SetPropertyInt64(
                                            ctx,
                                            obj,
                                            i,
                                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 11410711558158616183;
                                            break;
                                        }
                                        i += 1;
                                    }
                                    match current_block {
                                        11410711558158616183 => {}
                                        _ => {
                                            loop {
                                                if !(i < len) {
                                                    current_block = 1924505913685386279;
                                                    break;
                                                }
                                                if JS_DeletePropertyInt64(
                                                    ctx,
                                                    obj,
                                                    i,
                                                    (1 as libc::c_int) << 14 as libc::c_int,
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 11410711558158616183;
                                                    break;
                                                }
                                                i += 1;
                                            }
                                            match current_block {
                                                11410711558158616183 => {}
                                                _ => return obj,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        12083537708326820365 => {
            while n < pos {
                JS_FreeValue(ctx, (*array.offset(n as isize)).val);
                if !((*array.offset(n as isize)).str_0).is_null() {
                    JS_FreeValue(
                        ctx,
                        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                            | (*array.offset(n as isize)).str_0 as uintptr_t
                                as libc::c_ulonglong,
                    );
                }
                n = n.wrapping_add(1);
            }
            js_free(ctx, array as *mut libc::c_void);
        }
        _ => {}
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_iterator_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSArrayIteratorData = (*p).u.array_iterator_data;
    if !it.is_null() {
        JS_FreeValueRT(rt, (*it).obj);
        js_free_rt(rt, it as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_array_iterator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSArrayIteratorData = (*p).u.array_iterator_data;
    if !it.is_null() {
        JS_MarkValue(rt, (*it).obj, mark_func);
    }
}
unsafe extern "C" fn js_create_array(
    mut ctx: *mut JSContext,
    mut len: libc::c_int,
    mut tab: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut i: libc::c_int = 0;
    obj = JS_NewArray(ctx);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = 0 as libc::c_int;
    while i < len {
        if JS_CreateDataPropertyUint32(
            ctx,
            obj,
            i as int64_t,
            JS_DupValue(ctx, *tab.offset(i as isize)),
            0 as libc::c_int,
        ) < 0 as libc::c_int
        {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i += 1;
    }
    return obj;
}
unsafe extern "C" fn js_create_array_iterator(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut enum_obj: JSValue = 0;
    let mut arr: JSValue = 0;
    let mut it: *mut JSArrayIteratorData = 0 as *mut JSArrayIteratorData;
    let mut kind: JSIteratorKindEnum = JS_ITERATOR_KIND_KEY;
    let mut class_id: libc::c_int = 0;
    kind = (magic & 3 as libc::c_int) as JSIteratorKindEnum;
    if magic & 4 as libc::c_int != 0 {
        arr = JS_ToStringCheckObject(ctx, this_val);
        class_id = JS_CLASS_STRING_ITERATOR as libc::c_int;
    } else {
        arr = JS_ToObject(ctx, this_val);
        class_id = JS_CLASS_ARRAY_ITERATOR as libc::c_int;
    }
    if !(JS_IsException(arr) != 0) {
        enum_obj = JS_NewObjectClass(ctx, class_id);
        if !(JS_IsException(enum_obj) != 0) {
            it = js_malloc(
                ctx,
                ::core::mem::size_of::<JSArrayIteratorData>() as libc::c_ulong,
            ) as *mut JSArrayIteratorData;
            if it.is_null() {
                JS_FreeValue(ctx, enum_obj);
            } else {
                (*it).obj = arr;
                (*it).kind = kind;
                (*it).idx = 0 as libc::c_int as uint32_t;
                JS_SetOpaque(enum_obj, it as *mut libc::c_void);
                return enum_obj;
            }
        }
    }
    JS_FreeValue(ctx, arr);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_iterator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut it: *mut JSArrayIteratorData = 0 as *mut JSArrayIteratorData;
    let mut len: uint32_t = 0;
    let mut idx: uint32_t = 0;
    let mut val: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    it = JS_GetOpaque2(
        ctx,
        this_val,
        JS_CLASS_ARRAY_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSArrayIteratorData;
    if !it.is_null() {
        if JS_IsUndefined((*it).obj) != 0 {
            current_block = 5205102895233372276;
        } else {
            p = (*it).obj as intptr_t as *mut libc::c_void as *mut JSObject;
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                    <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
            {
                if typed_array_is_detached(ctx, p) != 0 {
                    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
                    current_block = 8908838431002380999;
                } else {
                    len = (*p).u.array.count;
                    current_block = 7976072742316086414;
                }
            } else if js_get_length32(ctx, &mut len, (*it).obj) != 0 {
                current_block = 8908838431002380999;
            } else {
                current_block = 7976072742316086414;
            }
            match current_block {
                8908838431002380999 => {}
                _ => {
                    idx = (*it).idx;
                    if idx >= len {
                        JS_FreeValue(ctx, (*it).obj);
                        (*it)
                            .obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    } else {
                        (*it).idx = idx.wrapping_add(1 as libc::c_int as libc::c_uint);
                        *pdone = FALSE as libc::c_int;
                        if (*it).kind as libc::c_uint
                            == JS_ITERATOR_KIND_KEY as libc::c_int as libc::c_uint
                        {
                            return JS_NewUint32(ctx, idx)
                        } else {
                            val = JS_GetPropertyUint32(ctx, (*it).obj, idx);
                            if JS_IsException(val) != 0 {
                                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                            }
                            if (*it).kind as libc::c_uint
                                == JS_ITERATOR_KIND_VALUE as libc::c_int as libc::c_uint
                            {
                                return val
                            } else {
                                let mut args: [JSValue; 2] = [0; 2];
                                let mut num: JSValue = 0;
                                num = JS_NewUint32(ctx, idx);
                                args[0 as libc::c_int as usize] = num;
                                args[1 as libc::c_int as usize] = val;
                                obj = js_create_array(
                                    ctx,
                                    2 as libc::c_int,
                                    args.as_mut_ptr(),
                                );
                                JS_FreeValue(ctx, val);
                                JS_FreeValue(ctx, num);
                                return obj;
                            }
                        }
                    }
                    current_block = 5205102895233372276;
                }
            }
        }
        match current_block {
            8908838431002380999 => {}
            _ => {
                *pdone = TRUE as libc::c_int;
                return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    *pdone = FALSE as libc::c_int;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_iterator_proto_iterator(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_DupValue(ctx, this_val);
}
static mut js_iterator_proto_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_iterator_proto_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_array_proto_funcs: [JSCFunctionListEntry; 32] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"concat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_concat
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"every\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"some\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"forEach\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"map\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 3 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"filter\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 4 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reduce\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_reduce
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reduceRight\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_reduce
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fill\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_fill
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"find\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_find
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"findIndex\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_find
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"indexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"lastIndexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_lastIndexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"includes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_includes
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"join\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_join
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_join
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"pop\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_pop
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"push\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_push
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"shift\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_pop
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"unshift\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_push
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reverse\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_reverse
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sort\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_sort
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"slice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"splice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"copyWithin\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_copyWithin
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"flatMap\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_flatten
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"flat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_flatten
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"values\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"values\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"entries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY_AND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_array_iterator_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_array_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Array Iterator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_number_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut obj: JSValue = 0;
    if argc == 0 as libc::c_int {
        val = JS_NewInt32(ctx, 0 as libc::c_int);
    } else {
        val = JS_ToNumeric(ctx, *argv.offset(0 as libc::c_int as isize));
        if JS_IsException(val) != 0 {
            return val;
        }
        match (val >> 32 as libc::c_int) as libc::c_int {
            _ => {}
        }
    }
    if JS_IsUndefined(new_target) == 0 {
        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_NUMBER as libc::c_int);
        if JS_IsException(obj) == 0 {
            JS_SetObjectData(ctx, obj, val);
        }
        return obj;
    } else {
        return val
    };
}
unsafe extern "C" fn js_number_isNaN(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    if JS_IsNumber(*argv.offset(0 as libc::c_int as isize)) == 0 {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_global_isNaN(ctx, this_val, argc, argv);
}
unsafe extern "C" fn js_number_isFinite(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    if JS_IsNumber(*argv.offset(0 as libc::c_int as isize)) == 0 {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_global_isFinite(ctx, this_val, argc, argv);
}
unsafe extern "C" fn js_number_isInteger(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ret: libc::c_int = 0;
    ret = JS_NumberIsInteger(ctx, *argv.offset(0 as libc::c_int as isize));
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_number_isSafeInteger(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut d: libc::c_double = 0.;
    if JS_IsNumber(*argv.offset(0 as libc::c_int as isize)) == 0 {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (JS_ToFloat64(ctx, &mut d, *argv.offset(0 as libc::c_int as isize)) != 0)
        as libc::c_int as libc::c_long != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewBool(ctx, is_safe_integer(d));
}
static mut js_number_funcs: [JSCFunctionListEntry; 14] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"parseInt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"parseInt\0" as *const u8 as *const libc::c_char,
                            base: 0 as libc::c_int,
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"parseFloat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"parseFloat\0" as *const u8 as *const libc::c_char,
                            base: 0 as libc::c_int,
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isNaN\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_isNaN
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isFinite\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_isFinite
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isInteger\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_isInteger
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isSafeInteger\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_isSafeInteger
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"MAX_VALUE\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 1.7976931348623157e+308f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"MIN_VALUE\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 5e-324f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"NaN\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 9999.9999f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"NEGATIVE_INFINITY\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: -999999999.0f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"POSITIVE_INFINITY\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 999999999.0f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"EPSILON\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 2.220446049250313e-16f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"MAX_SAFE_INTEGER\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 9007199254740991.0f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"MIN_SAFE_INTEGER\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: -9007199254740991.0f64,
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_thisNumberValue(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    if JS_IsNumber(this_val) != 0 {
        return JS_DupValue(ctx, this_val);
    }
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_NUMBER as libc::c_int
        {
            if JS_IsNumber((*p).u.object_data) != 0 {
                return JS_DupValue(ctx, (*p).u.object_data);
            }
        }
    }
    return JS_ThrowTypeError(ctx, b"not a number\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn js_number_valueOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return js_thisNumberValue(ctx, this_val);
}
unsafe extern "C" fn js_get_radix(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> libc::c_int {
    let mut radix: libc::c_int = 0;
    if JS_ToInt32Sat(ctx, &mut radix, val) != 0 {
        return -(1 as libc::c_int);
    }
    if radix < 2 as libc::c_int || radix > 36 as libc::c_int {
        JS_ThrowRangeError(
            ctx,
            b"radix must be between 2 and 36\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    return radix;
}
unsafe extern "C" fn js_number_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut base: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    val = js_thisNumberValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    if magic != 0 || JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) != 0 {
        base = 10 as libc::c_int;
    } else {
        base = js_get_radix(ctx, *argv.offset(0 as libc::c_int as isize));
        if base < 0 as libc::c_int {
            JS_FreeValue(ctx, val);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_dtoa(
        ctx,
        d,
        base,
        0 as libc::c_int,
        (0 as libc::c_int) << 0 as libc::c_int,
    );
}
unsafe extern "C" fn js_number_toFixed(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut f: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    val = js_thisNumberValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32Sat(ctx, &mut f, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if f < 0 as libc::c_int || f > 100 as libc::c_int {
        return JS_ThrowRangeError(
            ctx,
            b"invalid number of digits\0" as *const u8 as *const libc::c_char,
        );
    }
    if fabs(d) >= 1e21f64 {
        return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d))
    } else {
        return js_dtoa(
            ctx,
            d,
            10 as libc::c_int,
            f,
            (2 as libc::c_int) << 0 as libc::c_int,
        )
    };
}
unsafe extern "C" fn js_number_toExponential(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut f: libc::c_int = 0;
    let mut flags: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    val = js_thisNumberValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32Sat(ctx, &mut f, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if isfinite(d) == 0 {
        return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
    }
    if JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) != 0 {
        flags = 0 as libc::c_int;
        f = 0 as libc::c_int;
    } else {
        if f < 0 as libc::c_int || f > 100 as libc::c_int {
            return JS_ThrowRangeError(
                ctx,
                b"invalid number of digits\0" as *const u8 as *const libc::c_char,
            );
        }
        f += 1;
        flags = (1 as libc::c_int) << 0 as libc::c_int;
    }
    return js_dtoa(
        ctx,
        d,
        10 as libc::c_int,
        f,
        flags | (1 as libc::c_int) << 2 as libc::c_int,
    );
}
unsafe extern "C" fn js_number_toPrecision(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut p: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    val = js_thisNumberValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    if JS_ToFloat64Free(ctx, &mut d, val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if !(JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) != 0) {
        if JS_ToInt32Sat(ctx, &mut p, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if !(isfinite(d) == 0) {
            if p < 1 as libc::c_int || p > 100 as libc::c_int {
                return JS_ThrowRangeError(
                    ctx,
                    b"invalid number of digits\0" as *const u8 as *const libc::c_char,
                );
            }
            return js_dtoa(
                ctx,
                d,
                10 as libc::c_int,
                p,
                (1 as libc::c_int) << 0 as libc::c_int,
            );
        }
    }
    return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
}
static mut js_number_proto_funcs: [JSCFunctionListEntry; 6] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"toExponential\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_toExponential
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toFixed\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_toFixed
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toPrecision\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_toPrecision
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_number_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_number_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_number_valueOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_parseInt(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut radix: libc::c_int = 0;
    let mut flags: libc::c_int = 0;
    let mut ret: JSValue = 0;
    str = JS_ToCString(ctx, *argv.offset(0 as libc::c_int as isize));
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32(ctx, &mut radix, *argv.offset(1 as libc::c_int as isize)) != 0 {
        JS_FreeCString(ctx, str);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if radix != 0 as libc::c_int
        && (radix < 2 as libc::c_int || radix > 36 as libc::c_int)
    {
        ret = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    } else {
        p = str;
        p = p.offset(skip_spaces(p) as isize);
        flags = (1 as libc::c_int) << 0 as libc::c_int
            | (1 as libc::c_int) << 10 as libc::c_int;
        ret = js_atof(ctx, p, 0 as *mut *const libc::c_char, radix, flags);
    }
    JS_FreeCString(ctx, str);
    return ret;
}
unsafe extern "C" fn js_parseFloat(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut ret: JSValue = 0;
    str = JS_ToCString(ctx, *argv.offset(0 as libc::c_int as isize));
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = str;
    p = p.offset(skip_spaces(p) as isize);
    ret = js_atof(
        ctx,
        p,
        0 as *mut *const libc::c_char,
        10 as libc::c_int,
        0 as libc::c_int,
    );
    JS_FreeCString(ctx, str);
    return ret;
}
unsafe extern "C" fn js_boolean_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut obj: JSValue = 0;
    val = JS_NewBool(ctx, JS_ToBool(ctx, *argv.offset(0 as libc::c_int as isize)));
    if JS_IsUndefined(new_target) == 0 {
        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_BOOLEAN as libc::c_int);
        if JS_IsException(obj) == 0 {
            JS_SetObjectData(ctx, obj, val);
        }
        return obj;
    } else {
        return val
    };
}
unsafe extern "C" fn js_thisBooleanValue(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_BOOL as libc::c_int {
        return JS_DupValue(ctx, this_val);
    }
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_BOOLEAN as libc::c_int
        {
            if ((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_BOOL as libc::c_int
            {
                return (*p).u.object_data;
            }
        }
    }
    return JS_ThrowTypeError(
        ctx,
        b"not a boolean\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn js_boolean_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = js_thisBooleanValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    return JS_AtomToString(
        ctx,
        (if val as libc::c_int != 0 {
            JS_ATOM_true as libc::c_int
        } else {
            JS_ATOM_false as libc::c_int
        }) as JSAtom,
    );
}
unsafe extern "C" fn js_boolean_valueOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return js_thisBooleanValue(ctx, this_val);
}
static mut js_boolean_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_boolean_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_boolean_valueOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_string_get_own_property(
    mut ctx: *mut JSContext,
    mut desc: *mut JSPropertyDescriptor,
    mut obj: JSValue,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSString = 0 as *mut JSString;
    let mut idx: uint32_t = 0;
    let mut ch: uint32_t = 0;
    if __JS_AtomIsTaggedInt(prop) != 0 {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if ((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
            == JS_TAG_STRING as libc::c_int
        {
            p1 = (*p).u.object_data as intptr_t as *mut libc::c_void as *mut JSString;
            idx = __JS_AtomToUInt32(prop);
            if idx < (*p1).len() {
                if !desc.is_null() {
                    if (*p1).is_wide_char() != 0 {
                        ch = (*p1).u.str16[idx as usize] as uint32_t;
                    } else {
                        ch = (*p1).u.str8[idx as usize] as uint32_t;
                    }
                    (*desc).flags = (1 as libc::c_int) << 2 as libc::c_int;
                    (*desc).value = js_new_string_char(ctx, ch as uint16_t);
                    (*desc)
                        .getter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    (*desc)
                        .setter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                return TRUE as libc::c_int;
            }
        }
    }
    return FALSE as libc::c_int;
}
unsafe extern "C" fn js_string_define_own_property(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut idx: uint32_t = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSString = 0 as *mut JSString;
    let mut p2: *mut JSString = 0 as *mut JSString;
    if __JS_AtomIsTaggedInt(prop) != 0 {
        idx = __JS_AtomToUInt32(prop);
        p = this_obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if !(((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
            != JS_TAG_STRING as libc::c_int)
        {
            p1 = (*p).u.object_data as intptr_t as *mut libc::c_void as *mut JSString;
            if !(idx >= (*p1).len()) {
                if !(check_define_prop_flags(
                    (1 as libc::c_int) << 2 as libc::c_int,
                    flags,
                ) == 0)
                {
                    if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                        if (val >> 32 as libc::c_int) as libc::c_int
                            != JS_TAG_STRING as libc::c_int
                        {
                            current_block = 203554884197914002;
                        } else {
                            p2 = val as intptr_t as *mut libc::c_void as *mut JSString;
                            if (*p2).len() as libc::c_int != 1 as libc::c_int {
                                current_block = 203554884197914002;
                            } else if string_get(p1, idx as libc::c_int)
                                != string_get(p2, 0 as libc::c_int)
                            {
                                current_block = 203554884197914002;
                            } else {
                                current_block = 17407779659766490442;
                            }
                        }
                    } else {
                        current_block = 17407779659766490442;
                    }
                    match current_block {
                        203554884197914002 => {}
                        _ => return TRUE as libc::c_int,
                    }
                }
                return JS_ThrowTypeErrorOrFalse(
                    ctx,
                    flags,
                    b"property is not configurable\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return JS_DefineProperty(
        ctx,
        this_obj,
        prop,
        val,
        getter,
        setter,
        flags | (1 as libc::c_int) << 17 as libc::c_int,
    );
}
unsafe extern "C" fn js_string_delete_property(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut idx: uint32_t = 0;
    if __JS_AtomIsTaggedInt(prop) != 0 {
        idx = __JS_AtomToUInt32(prop);
        if idx < js_string_obj_get_length(ctx, obj) {
            return FALSE as libc::c_int;
        }
    }
    return TRUE as libc::c_int;
}
static mut js_string_exotic_methods: JSClassExoticMethods = unsafe {
    {
        let mut init = JSClassExoticMethods {
            get_own_property: Some(
                js_string_get_own_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        *mut JSPropertyDescriptor,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            get_own_property_names: None,
            delete_property: Some(
                js_string_delete_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            define_own_property: Some(
                js_string_define_own_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                        JSValue,
                        JSValue,
                        JSValue,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            has_property: None,
            get_property: None,
            set_property: None,
        };
        init
    }
};
unsafe extern "C" fn js_string_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut obj: JSValue = 0;
    if argc == 0 as libc::c_int {
        val = JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    } else {
        if JS_IsUndefined(new_target) != 0
            && JS_IsSymbol(*argv.offset(0 as libc::c_int as isize)) != 0
        {
            let mut p: *mut JSAtomStruct = *argv.offset(0 as libc::c_int as isize)
                as intptr_t as *mut libc::c_void as *mut JSAtomStruct;
            val = JS_ConcatString3(
                ctx,
                b"Symbol(\0" as *const u8 as *const libc::c_char,
                JS_AtomToString(ctx, js_get_atom_index((*ctx).rt, p)),
                b")\0" as *const u8 as *const libc::c_char,
            );
        } else {
            val = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
        }
        if JS_IsException(val) != 0 {
            return val;
        }
    }
    if JS_IsUndefined(new_target) == 0 {
        let mut p1: *mut JSString = val as intptr_t as *mut libc::c_void
            as *mut JSString;
        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_STRING as libc::c_int);
        if JS_IsException(obj) == 0 {
            JS_SetObjectData(ctx, obj, val);
            JS_DefinePropertyValue(
                ctx,
                obj,
                JS_ATOM_length as libc::c_int as JSAtom,
                JS_NewInt32(ctx, (*p1).len() as int32_t),
                0 as libc::c_int,
            );
        }
        return obj;
    } else {
        return val
    };
}
unsafe extern "C" fn js_thisStringValue(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_STRING as libc::c_int {
        return JS_DupValue(ctx, this_val);
    }
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_STRING as libc::c_int
        {
            if ((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_STRING as libc::c_int
            {
                return JS_DupValue(ctx, (*p).u.object_data);
            }
        }
    }
    return JS_ThrowTypeError(ctx, b"not a string\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn js_string_fromCharCode(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut i: libc::c_int = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    string_buffer_init(ctx, b, argc);
    i = 0 as libc::c_int;
    while i < argc {
        let mut c: int32_t = 0;
        if JS_ToInt32(ctx, &mut c, *argv.offset(i as isize)) != 0
            || string_buffer_putc16(b, (c & 0xffff as libc::c_int) as uint32_t) != 0
        {
            string_buffer_free(b);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i += 1;
    }
    return string_buffer_end(b);
}
unsafe extern "C" fn js_string_fromCodePoint(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut d: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if !(string_buffer_init(ctx, b, argc) != 0) {
        i = 0 as libc::c_int;
        loop {
            if !(i < argc) {
                current_block = 10599921512955367680;
                break;
            }
            if (*argv.offset(i as isize) >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_INT as libc::c_int
            {
                c = *argv.offset(i as isize) as libc::c_int;
                if c < 0 as libc::c_int || c > 0x10ffff as libc::c_int {
                    current_block = 15731220795734265303;
                    break;
                }
            } else {
                if JS_ToFloat64(ctx, &mut d, *argv.offset(i as isize)) != 0 {
                    current_block = 16696435689474213941;
                    break;
                }
                if d < 0 as libc::c_int as libc::c_double
                    || d > 0x10ffff as libc::c_int as libc::c_double
                    || {
                        c = d as libc::c_int;
                        c as libc::c_double != d
                    }
                {
                    current_block = 15731220795734265303;
                    break;
                }
            }
            if string_buffer_putc(b, c as uint32_t) != 0 {
                current_block = 16696435689474213941;
                break;
            }
            i += 1;
        }
        match current_block {
            16696435689474213941 => {}
            _ => {
                match current_block {
                    10599921512955367680 => return string_buffer_end(b),
                    _ => {
                        JS_ThrowRangeError(
                            ctx,
                            b"invalid code point\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
        }
    }
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_raw(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut cooked: JSValue = 0;
    let mut val: JSValue = 0;
    let mut raw: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut i: int64_t = 0;
    let mut n: int64_t = 0;
    string_buffer_init(ctx, b, 0 as libc::c_int);
    raw = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    cooked = JS_ToObject(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(cooked) != 0) {
        raw = JS_ToObjectFree(
            ctx,
            JS_GetProperty(ctx, cooked, JS_ATOM_raw as libc::c_int as JSAtom),
        );
        if !(JS_IsException(raw) != 0) {
            if !(js_get_length64(ctx, &mut n, raw) < 0 as libc::c_int) {
                i = 0 as libc::c_int as int64_t;
                loop {
                    if !(i < n) {
                        current_block = 5143058163439228106;
                        break;
                    }
                    val = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, raw, i));
                    if JS_IsException(val) != 0 {
                        current_block = 6731039403271698762;
                        break;
                    }
                    string_buffer_concat_value_free(b, val);
                    if i < n - 1 as libc::c_int as libc::c_longlong
                        && (i + 1 as libc::c_int as libc::c_longlong)
                            < argc as libc::c_longlong
                    {
                        if string_buffer_concat_value(
                            b,
                            *argv
                                .offset((i + 1 as libc::c_int as libc::c_longlong) as isize),
                        ) != 0
                        {
                            current_block = 6731039403271698762;
                            break;
                        }
                    }
                    i += 1;
                }
                match current_block {
                    6731039403271698762 => {}
                    _ => {
                        JS_FreeValue(ctx, cooked);
                        JS_FreeValue(ctx, raw);
                        return string_buffer_end(b);
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, cooked);
    JS_FreeValue(ctx, raw);
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn js_string_codePointRange(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut start: uint32_t = 0;
    let mut end: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut n: uint32_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if JS_ToUint32(ctx, &mut start, *argv.offset(0 as libc::c_int as isize)) != 0
        || JS_ToUint32(ctx, &mut end, *argv.offset(1 as libc::c_int as isize)) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    end = min_uint32(end, (0x10ffff as libc::c_int + 1 as libc::c_int) as uint32_t);
    if start > end {
        start = end;
    }
    n = end.wrapping_sub(start);
    if end > 0x10000 as libc::c_int as libc::c_uint {
        n = (n as libc::c_uint)
            .wrapping_add(
                end.wrapping_sub(max_uint32(start, 0x10000 as libc::c_int as uint32_t)),
            ) as uint32_t as uint32_t;
    }
    if string_buffer_init2(
        ctx,
        b,
        n as libc::c_int,
        (end >= 0x100 as libc::c_int as libc::c_uint) as libc::c_int,
    ) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = start;
    while i < end {
        string_buffer_putc(b, i);
        i = i.wrapping_add(1);
    }
    return string_buffer_end(b);
}
unsafe extern "C" fn js_string_charCodeAt(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut idx: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    val = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    if JS_ToInt32Sat(ctx, &mut idx, *argv.offset(0 as libc::c_int as isize)) != 0 {
        JS_FreeValue(ctx, val);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if idx < 0 as libc::c_int || idx >= (*p).len() as libc::c_int {
        ret = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    } else {
        if (*p).is_wide_char() != 0 {
            c = (*p).u.str16[idx as usize] as libc::c_int;
        } else {
            c = (*p).u.str8[idx as usize] as libc::c_int;
        }
        ret = JS_NewInt32(ctx, c);
    }
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn js_string_charAt(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut idx: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    val = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    if JS_ToInt32Sat(ctx, &mut idx, *argv.offset(0 as libc::c_int as isize)) != 0 {
        JS_FreeValue(ctx, val);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if idx < 0 as libc::c_int || idx >= (*p).len() as libc::c_int {
        ret = js_new_string8(ctx, 0 as *const uint8_t, 0 as libc::c_int);
    } else {
        if (*p).is_wide_char() != 0 {
            c = (*p).u.str16[idx as usize] as libc::c_int;
        } else {
            c = (*p).u.str8[idx as usize] as libc::c_int;
        }
        ret = js_new_string_char(ctx, c as uint16_t);
    }
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn js_string_codePointAt(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut idx: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    val = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    if JS_ToInt32Sat(ctx, &mut idx, *argv.offset(0 as libc::c_int as isize)) != 0 {
        JS_FreeValue(ctx, val);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if idx < 0 as libc::c_int || idx >= (*p).len() as libc::c_int {
        ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        c = string_getc(p, &mut idx);
        ret = JS_NewInt32(ctx, c);
    }
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn js_string_concat(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut r: JSValue = 0;
    let mut i: libc::c_int = 0;
    r = JS_ToStringCheckObject(ctx, this_val);
    i = 0 as libc::c_int;
    while i < argc {
        if JS_IsException(r) != 0 {
            break;
        }
        r = JS_ConcatString(ctx, r, JS_DupValue(ctx, *argv.offset(i as isize)));
        i += 1;
    }
    return r;
}
unsafe extern "C" fn string_cmp(
    mut p1: *mut JSString,
    mut p2: *mut JSString,
    mut x1: libc::c_int,
    mut x2: libc::c_int,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < len {
        c1 = string_get(p1, x1 + i);
        c2 = string_get(p2, x2 + i);
        if c1 != c2 {
            return c1 - c2;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_indexof_char(
    mut p: *mut JSString,
    mut c: libc::c_int,
    mut from: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = (*p).len() as libc::c_int;
    if (*p).is_wide_char() != 0 {
        i = from;
        while i < len {
            if (*p).u.str16[i as usize] as libc::c_int == c {
                return i;
            }
            i += 1;
        }
    } else if c & !(0xff as libc::c_int) == 0 as libc::c_int {
        i = from;
        while i < len {
            if (*p).u.str8[i as usize] as libc::c_int == c as uint8_t as libc::c_int {
                return i;
            }
            i += 1;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn string_indexof(
    mut p1: *mut JSString,
    mut p2: *mut JSString,
    mut from: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut len1: libc::c_int = (*p1).len() as libc::c_int;
    let mut len2: libc::c_int = (*p2).len() as libc::c_int;
    if len2 == 0 as libc::c_int {
        return from;
    }
    i = from;
    c = string_get(p2, 0 as libc::c_int);
    while i + len2 <= len1 {
        j = string_indexof_char(p1, c, i);
        if j < 0 as libc::c_int || j + len2 > len1 {
            break;
        }
        if string_cmp(
            p1,
            p2,
            j + 1 as libc::c_int,
            1 as libc::c_int,
            len2 - 1 as libc::c_int,
        ) == 0
        {
            return j;
        }
        i = j + 1 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn string_advance_index(
    mut p: *mut JSString,
    mut index: int64_t,
    mut unicode: BOOL,
) -> int64_t {
    if unicode == 0 || index >= (*p).len() as libc::c_longlong
        || (*p).is_wide_char() == 0
    {
        index += 1;
    } else {
        let mut index32: libc::c_int = index as libc::c_int;
        string_getc(p, &mut index32);
        index = index32 as int64_t;
    }
    return index;
}
unsafe extern "C" fn js_string_indexOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut lastIndexOf: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut str: JSValue = 0;
    let mut v: JSValue = 0;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut v_len: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut stop: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut inc: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut p1: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    v = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(v) != 0) {
        p = str as intptr_t as *mut libc::c_void as *mut JSString;
        p1 = v as intptr_t as *mut libc::c_void as *mut JSString;
        len = (*p).len() as libc::c_int;
        v_len = (*p1).len() as libc::c_int;
        if lastIndexOf != 0 {
            pos = len - v_len;
            if argc > 1 as libc::c_int {
                let mut d: libc::c_double = 0.;
                if JS_ToFloat64(ctx, &mut d, *argv.offset(1 as libc::c_int as isize))
                    != 0
                {
                    current_block = 9133634545900973480;
                } else {
                    if isnan(d) == 0 {
                        if d <= 0 as libc::c_int as libc::c_double {
                            pos = 0 as libc::c_int;
                        } else if d < pos as libc::c_double {
                            pos = d as libc::c_int;
                        }
                    }
                    current_block = 11584701595673473500;
                }
            } else {
                current_block = 11584701595673473500;
            }
            match current_block {
                9133634545900973480 => {}
                _ => {
                    start = pos;
                    stop = 0 as libc::c_int;
                    inc = -(1 as libc::c_int);
                    current_block = 17788412896529399552;
                }
            }
        } else {
            pos = 0 as libc::c_int;
            if argc > 1 as libc::c_int {
                if JS_ToInt32Clamp(
                    ctx,
                    &mut pos,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                    len,
                    0 as libc::c_int,
                ) != 0
                {
                    current_block = 9133634545900973480;
                } else {
                    current_block = 14818589718467733107;
                }
            } else {
                current_block = 14818589718467733107;
            }
            match current_block {
                9133634545900973480 => {}
                _ => {
                    start = pos;
                    stop = len - v_len;
                    inc = 1 as libc::c_int;
                    current_block = 17788412896529399552;
                }
            }
        }
        match current_block {
            9133634545900973480 => {}
            _ => {
                ret = -(1 as libc::c_int);
                if len >= v_len && inc * (stop - start) >= 0 as libc::c_int {
                    i = start;
                    loop {
                        if string_cmp(p, p1, i, 0 as libc::c_int, v_len) == 0 {
                            ret = i;
                            break;
                        } else {
                            if i == stop {
                                break;
                            }
                            i += inc;
                        }
                    }
                }
                JS_FreeValue(ctx, str);
                JS_FreeValue(ctx, v);
                return JS_NewInt32(ctx, ret);
            }
        }
    }
    JS_FreeValue(ctx, str);
    JS_FreeValue(ctx, v);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_includes(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut str: JSValue = 0;
    let mut v: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut v_len: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut stop: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut p1: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    ret = js_is_regexp(ctx, *argv.offset(0 as libc::c_int as isize));
    if ret != 0 {
        if ret > 0 as libc::c_int {
            JS_ThrowTypeError(
                ctx,
                b"regex not supported\0" as *const u8 as *const libc::c_char,
            );
        }
    } else {
        v = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
        if !(JS_IsException(v) != 0) {
            p = str as intptr_t as *mut libc::c_void as *mut JSString;
            p1 = v as intptr_t as *mut libc::c_void as *mut JSString;
            len = (*p).len() as libc::c_int;
            v_len = (*p1).len() as libc::c_int;
            pos = if magic == 2 as libc::c_int { len } else { 0 as libc::c_int };
            if argc > 1 as libc::c_int
                && JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0
            {
                if JS_ToInt32Clamp(
                    ctx,
                    &mut pos,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                    len,
                    0 as libc::c_int,
                ) != 0
                {
                    current_block = 10713383827013246173;
                } else {
                    current_block = 8457315219000651999;
                }
            } else {
                current_block = 8457315219000651999;
            }
            match current_block {
                10713383827013246173 => {}
                _ => {
                    len -= v_len;
                    ret = 0 as libc::c_int;
                    if magic == 0 as libc::c_int {
                        start = pos;
                        stop = len;
                        current_block = 16924917904204750491;
                    } else {
                        if magic == 1 as libc::c_int {
                            if pos > len {
                                current_block = 5200069853662491893;
                            } else {
                                current_block = 14763689060501151050;
                            }
                        } else {
                            pos -= v_len;
                            current_block = 14763689060501151050;
                        }
                        match current_block {
                            5200069853662491893 => {}
                            _ => {
                                stop = pos;
                                start = stop;
                                current_block = 16924917904204750491;
                            }
                        }
                    }
                    match current_block {
                        16924917904204750491 => {
                            if start >= 0 as libc::c_int && start <= stop {
                                i = start;
                                loop {
                                    if string_cmp(p, p1, i, 0 as libc::c_int, v_len) == 0 {
                                        ret = 1 as libc::c_int;
                                        break;
                                    } else {
                                        if i == stop {
                                            break;
                                        }
                                        i += 1;
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    JS_FreeValue(ctx, str);
                    JS_FreeValue(ctx, v);
                    return JS_NewBool(ctx, ret);
                }
            }
        }
    }
    JS_FreeValue(ctx, str);
    JS_FreeValue(ctx, v);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn check_regexp_g_flag(
    mut ctx: *mut JSContext,
    mut regexp: JSValue,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut flags: JSValue = 0;
    ret = js_is_regexp(ctx, regexp);
    if ret < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if ret != 0 {
        flags = JS_GetProperty(ctx, regexp, JS_ATOM_flags as libc::c_int as JSAtom);
        if JS_IsException(flags) != 0 {
            return -(1 as libc::c_int);
        }
        if JS_IsUndefined(flags) != 0 || JS_IsNull(flags) != 0 {
            JS_ThrowTypeError(
                ctx,
                b"cannot convert to object\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        flags = JS_ToStringFree(ctx, flags);
        if JS_IsException(flags) != 0 {
            return -(1 as libc::c_int);
        }
        ret = string_indexof_char(
            flags as intptr_t as *mut libc::c_void as *mut JSString,
            'g' as i32,
            0 as libc::c_int,
        );
        JS_FreeValue(ctx, flags);
        if ret < 0 as libc::c_int {
            JS_ThrowTypeError(
                ctx,
                b"regexp must have the 'g' flag\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_string_match(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut atom: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut O: JSValue = this_val;
    let mut regexp: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut args: [JSValue; 2] = [0; 2];
    let mut matcher: JSValue = 0;
    let mut S: JSValue = 0;
    let mut rx: JSValue = 0;
    let mut result: JSValue = 0;
    let mut str: JSValue = 0;
    let mut args_len: libc::c_int = 0;
    if JS_IsUndefined(O) != 0 || JS_IsNull(O) != 0 {
        return JS_ThrowTypeError(
            ctx,
            b"cannot convert to object\0" as *const u8 as *const libc::c_char,
        );
    }
    if JS_IsUndefined(regexp) == 0 && JS_IsNull(regexp) == 0 {
        matcher = JS_GetProperty(ctx, regexp, atom as JSAtom);
        if JS_IsException(matcher) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if atom == JS_ATOM_Symbol_matchAll as libc::c_int {
            if check_regexp_g_flag(ctx, regexp) < 0 as libc::c_int {
                JS_FreeValue(ctx, matcher);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
        if JS_IsUndefined(matcher) == 0 && JS_IsNull(matcher) == 0 {
            return JS_CallFree(ctx, matcher, regexp, 1 as libc::c_int, &mut O);
        }
    }
    S = JS_ToString(ctx, O);
    if JS_IsException(S) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    args_len = 1 as libc::c_int;
    args[0 as libc::c_int as usize] = regexp;
    str = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if atom == JS_ATOM_Symbol_matchAll as libc::c_int {
        str = JS_NewString(ctx, b"g\0" as *const u8 as *const libc::c_char);
        if JS_IsException(str) != 0 {
            current_block = 6260775029381996811;
        } else {
            let fresh649 = args_len;
            args_len = args_len + 1;
            args[fresh649 as usize] = str;
            current_block = 13472856163611868459;
        }
    } else {
        current_block = 13472856163611868459;
    }
    match current_block {
        13472856163611868459 => {
            rx = JS_CallConstructor(
                ctx,
                (*ctx).regexp_ctor,
                args_len,
                args.as_mut_ptr(),
            );
            JS_FreeValue(ctx, str);
            if !(JS_IsException(rx) != 0) {
                result = JS_InvokeFree(
                    ctx,
                    rx,
                    atom as JSAtom,
                    1 as libc::c_int,
                    &mut S as *mut JSValue,
                );
                JS_FreeValue(ctx, S);
                return result;
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, S);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string___GetSubstitution(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut matched: JSValue = 0;
    let mut str: JSValue = 0;
    let mut captures: JSValue = 0;
    let mut namedCaptures: JSValue = 0;
    let mut rep: JSValue = 0;
    let mut capture: JSValue = 0;
    let mut name: JSValue = 0;
    let mut s: JSValue = 0;
    let mut position: uint32_t = 0;
    let mut len: uint32_t = 0;
    let mut matched_len: uint32_t = 0;
    let mut captures_len: uint32_t = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut j0: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut k1: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut sp: *mut JSString = 0 as *mut JSString;
    let mut rp: *mut JSString = 0 as *mut JSString;
    matched = *argv.offset(0 as libc::c_int as isize);
    str = *argv.offset(1 as libc::c_int as isize);
    captures = *argv.offset(3 as libc::c_int as isize);
    namedCaptures = *argv.offset(4 as libc::c_int as isize);
    rep = *argv.offset(5 as libc::c_int as isize);
    if JS_IsString(rep) == 0 || JS_IsString(str) == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"not a string\0" as *const u8 as *const libc::c_char,
        );
    }
    sp = str as intptr_t as *mut libc::c_void as *mut JSString;
    rp = rep as intptr_t as *mut libc::c_void as *mut JSString;
    string_buffer_init(ctx, b, 0 as libc::c_int);
    captures_len = 0 as libc::c_int as uint32_t;
    if JS_IsUndefined(captures) == 0 {
        if js_get_length32(ctx, &mut captures_len, captures) != 0 {
            current_block = 17986544530477099088;
        } else {
            current_block = 17407779659766490442;
        }
    } else {
        current_block = 17407779659766490442;
    }
    match current_block {
        17407779659766490442 => {
            if !(js_get_length32(ctx, &mut matched_len, matched) != 0) {
                if !(JS_ToUint32(
                    ctx,
                    &mut position,
                    *argv.offset(2 as libc::c_int as isize),
                ) < 0 as libc::c_int)
                {
                    len = (*rp).len();
                    i = 0 as libc::c_int;
                    loop {
                        j = string_indexof_char(rp, '$' as i32, i);
                        if j < 0 as libc::c_int
                            || (j + 1 as libc::c_int) as libc::c_uint >= len
                        {
                            current_block = 18038362259723567392;
                            break;
                        }
                        string_buffer_concat(b, rp, i as uint32_t, j as uint32_t);
                        let fresh650 = j;
                        j = j + 1;
                        j0 = fresh650;
                        let fresh651 = j;
                        j = j + 1;
                        c = string_get(rp, fresh651);
                        if c == '$' as i32 {
                            string_buffer_putc8(b, '$' as i32 as uint32_t);
                        } else if c == '&' as i32 {
                            if string_buffer_concat_value(b, matched) != 0 {
                                current_block = 17986544530477099088;
                                break;
                            }
                        } else if c == '`' as i32 {
                            string_buffer_concat(
                                b,
                                sp,
                                0 as libc::c_int as uint32_t,
                                position,
                            );
                        } else if c == '\'' as i32 {
                            string_buffer_concat(
                                b,
                                sp,
                                position.wrapping_add(matched_len),
                                (*sp).len(),
                            );
                        } else {
                            if c >= '0' as i32 && c <= '9' as i32 {
                                k = c - '0' as i32;
                                if (j as libc::c_uint) < len {
                                    c1 = string_get(rp, j);
                                    if c1 >= '0' as i32 && c1 <= '9' as i32 {
                                        k1 = k * 10 as libc::c_int + c1 - '0' as i32;
                                        if k1 >= 1 as libc::c_int
                                            && (k1 as libc::c_uint) < captures_len
                                        {
                                            k = k1;
                                            j += 1;
                                        }
                                    }
                                }
                                if k >= 1 as libc::c_int
                                    && (k as libc::c_uint) < captures_len
                                {
                                    s = JS_GetPropertyInt64(ctx, captures, k as int64_t);
                                    if JS_IsException(s) != 0 {
                                        current_block = 17986544530477099088;
                                        break;
                                    }
                                    if JS_IsUndefined(s) == 0 {
                                        if string_buffer_concat_value_free(b, s) != 0 {
                                            current_block = 17986544530477099088;
                                            break;
                                        }
                                        current_block = 10067844863897285902;
                                    } else {
                                        current_block = 10067844863897285902;
                                    }
                                } else {
                                    current_block = 4208286580375110047;
                                }
                            } else if c == '<' as i32
                                && JS_IsUndefined(namedCaptures) == 0
                            {
                                k = string_indexof_char(rp, '>' as i32, j);
                                if k < 0 as libc::c_int {
                                    current_block = 4208286580375110047;
                                } else {
                                    name = js_sub_string(ctx, rp, j, k);
                                    if JS_IsException(name) != 0 {
                                        current_block = 17986544530477099088;
                                        break;
                                    }
                                    capture = JS_GetPropertyValue(ctx, namedCaptures, name);
                                    if JS_IsException(capture) != 0 {
                                        current_block = 17986544530477099088;
                                        break;
                                    }
                                    if JS_IsUndefined(capture) == 0 {
                                        if string_buffer_concat_value_free(b, capture) != 0 {
                                            current_block = 17986544530477099088;
                                            break;
                                        }
                                    }
                                    j = k + 1 as libc::c_int;
                                    current_block = 10067844863897285902;
                                }
                            } else {
                                current_block = 4208286580375110047;
                            }
                            match current_block {
                                10067844863897285902 => {}
                                _ => {
                                    string_buffer_concat(b, rp, j0 as uint32_t, j as uint32_t);
                                }
                            }
                        }
                        i = j;
                    }
                    match current_block {
                        17986544530477099088 => {}
                        _ => {
                            string_buffer_concat(b, rp, i as uint32_t, (*rp).len());
                            return string_buffer_end(b);
                        }
                    }
                }
            }
        }
        _ => {}
    }
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_replace(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut is_replaceAll: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut O: JSValue = this_val;
    let mut searchValue: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut replaceValue: JSValue = *argv.offset(1 as libc::c_int as isize);
    let mut args: [JSValue; 6] = [0; 6];
    let mut str: JSValue = 0;
    let mut search_str: JSValue = 0;
    let mut replaceValue_str: JSValue = 0;
    let mut repl_str: JSValue = 0;
    let mut sp: *mut JSString = 0 as *mut JSString;
    let mut searchp: *mut JSString = 0 as *mut JSString;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut pos: libc::c_int = 0;
    let mut functionalReplace: libc::c_int = 0;
    let mut endOfLastMatch: libc::c_int = 0;
    let mut is_first: BOOL = 0;
    if JS_IsUndefined(O) != 0 || JS_IsNull(O) != 0 {
        return JS_ThrowTypeError(
            ctx,
            b"cannot convert to object\0" as *const u8 as *const libc::c_char,
        );
    }
    search_str = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    replaceValue_str = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    repl_str = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if JS_IsUndefined(searchValue) == 0 && JS_IsNull(searchValue) == 0 {
        let mut replacer: JSValue = 0;
        if is_replaceAll != 0 {
            if check_regexp_g_flag(ctx, searchValue) < 0 as libc::c_int {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
        replacer = JS_GetProperty(
            ctx,
            searchValue,
            JS_ATOM_Symbol_replace as libc::c_int as JSAtom,
        );
        if JS_IsException(replacer) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if JS_IsUndefined(replacer) == 0 && JS_IsNull(replacer) == 0 {
            args[0 as libc::c_int as usize] = O;
            args[1 as libc::c_int as usize] = replaceValue;
            return JS_CallFree(
                ctx,
                replacer,
                searchValue,
                2 as libc::c_int,
                args.as_mut_ptr(),
            );
        }
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    str = JS_ToString(ctx, O);
    if !(JS_IsException(str) != 0) {
        search_str = JS_ToString(ctx, searchValue);
        if !(JS_IsException(search_str) != 0) {
            functionalReplace = JS_IsFunction(ctx, replaceValue);
            if functionalReplace == 0 {
                replaceValue_str = JS_ToString(ctx, replaceValue);
                if JS_IsException(replaceValue_str) != 0 {
                    current_block = 14355818565372529588;
                } else {
                    current_block = 5689316957504528238;
                }
            } else {
                current_block = 5689316957504528238;
            }
            match current_block {
                14355818565372529588 => {}
                _ => {
                    sp = str as intptr_t as *mut libc::c_void as *mut JSString;
                    searchp = search_str as intptr_t as *mut libc::c_void
                        as *mut JSString;
                    endOfLastMatch = 0 as libc::c_int;
                    is_first = TRUE as libc::c_int;
                    loop {
                        if ((*searchp).len() as libc::c_int == 0 as libc::c_int)
                            as libc::c_int as libc::c_long != 0
                        {
                            if is_first != 0 {
                                pos = 0 as libc::c_int;
                            } else if endOfLastMatch >= (*sp).len() as libc::c_int {
                                pos = -(1 as libc::c_int);
                            } else {
                                pos = endOfLastMatch + 1 as libc::c_int;
                            }
                        } else {
                            pos = string_indexof(sp, searchp, endOfLastMatch);
                        }
                        if pos < 0 as libc::c_int {
                            if !(is_first != 0) {
                                current_block = 16779030619667747692;
                                break;
                            }
                            string_buffer_free(b);
                            JS_FreeValue(ctx, search_str);
                            JS_FreeValue(ctx, replaceValue_str);
                            return str;
                        } else {
                            if functionalReplace != 0 {
                                args[0 as libc::c_int as usize] = search_str;
                                args[1 as libc::c_int as usize] = JS_NewInt32(ctx, pos);
                                args[2 as libc::c_int as usize] = str;
                                repl_str = JS_ToStringFree(
                                    ctx,
                                    JS_Call(
                                        ctx,
                                        replaceValue,
                                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                        3 as libc::c_int,
                                        args.as_mut_ptr(),
                                    ),
                                );
                            } else {
                                args[0 as libc::c_int as usize] = search_str;
                                args[1 as libc::c_int as usize] = str;
                                args[2 as libc::c_int as usize] = JS_NewInt32(ctx, pos);
                                args[3 as libc::c_int
                                    as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                args[4 as libc::c_int
                                    as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                args[5 as libc::c_int as usize] = replaceValue_str;
                                repl_str = js_string___GetSubstitution(
                                    ctx,
                                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                    6 as libc::c_int,
                                    args.as_mut_ptr(),
                                );
                            }
                            if JS_IsException(repl_str) != 0 {
                                current_block = 14355818565372529588;
                                break;
                            }
                            string_buffer_concat(
                                b,
                                sp,
                                endOfLastMatch as uint32_t,
                                pos as uint32_t,
                            );
                            string_buffer_concat_value_free(b, repl_str);
                            endOfLastMatch = pos + (*searchp).len() as libc::c_int;
                            is_first = FALSE as libc::c_int;
                            if is_replaceAll == 0 {
                                current_block = 16779030619667747692;
                                break;
                            }
                        }
                    }
                    match current_block {
                        14355818565372529588 => {}
                        _ => {
                            string_buffer_concat(
                                b,
                                sp,
                                endOfLastMatch as uint32_t,
                                (*sp).len(),
                            );
                            JS_FreeValue(ctx, search_str);
                            JS_FreeValue(ctx, replaceValue_str);
                            JS_FreeValue(ctx, str);
                            return string_buffer_end(b);
                        }
                    }
                }
            }
        }
    }
    string_buffer_free(b);
    JS_FreeValue(ctx, search_str);
    JS_FreeValue(ctx, replaceValue_str);
    JS_FreeValue(ctx, str);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_split(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut O: JSValue = this_val;
    let mut separator: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut limit: JSValue = *argv.offset(1 as libc::c_int as isize);
    let mut args: [JSValue; 2] = [0; 2];
    let mut S: JSValue = 0;
    let mut A: JSValue = 0;
    let mut R: JSValue = 0;
    let mut T: JSValue = 0;
    let mut lim: uint32_t = 0;
    let mut lengthA: uint32_t = 0;
    let mut p: int64_t = 0;
    let mut q: int64_t = 0;
    let mut s: int64_t = 0;
    let mut r: int64_t = 0;
    let mut e: int64_t = 0;
    let mut sp: *mut JSString = 0 as *mut JSString;
    let mut rp: *mut JSString = 0 as *mut JSString;
    if JS_IsUndefined(O) != 0 || JS_IsNull(O) != 0 {
        return JS_ThrowTypeError(
            ctx,
            b"cannot convert to object\0" as *const u8 as *const libc::c_char,
        );
    }
    S = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    A = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    R = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if JS_IsUndefined(separator) == 0 && JS_IsNull(separator) == 0 {
        let mut splitter: JSValue = 0;
        splitter = JS_GetProperty(
            ctx,
            separator,
            JS_ATOM_Symbol_split as libc::c_int as JSAtom,
        );
        if JS_IsException(splitter) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if JS_IsUndefined(splitter) == 0 && JS_IsNull(splitter) == 0 {
            args[0 as libc::c_int as usize] = O;
            args[1 as libc::c_int as usize] = limit;
            return JS_CallFree(
                ctx,
                splitter,
                separator,
                2 as libc::c_int,
                args.as_mut_ptr(),
            );
        }
    }
    S = JS_ToString(ctx, O);
    if !(JS_IsException(S) != 0) {
        A = JS_NewArray(ctx);
        if !(JS_IsException(A) != 0) {
            lengthA = 0 as libc::c_int as uint32_t;
            if JS_IsUndefined(limit) != 0 {
                lim = 0xffffffff as libc::c_uint;
                current_block = 18386322304582297246;
            } else if JS_ToUint32(ctx, &mut lim, limit) < 0 as libc::c_int {
                current_block = 223620086940157833;
            } else {
                current_block = 18386322304582297246;
            }
            match current_block {
                223620086940157833 => {}
                _ => {
                    sp = S as intptr_t as *mut libc::c_void as *mut JSString;
                    s = (*sp).len() as int64_t;
                    R = JS_ToString(ctx, separator);
                    if !(JS_IsException(R) != 0) {
                        rp = R as intptr_t as *mut libc::c_void as *mut JSString;
                        r = (*rp).len() as int64_t;
                        p = 0 as libc::c_int as int64_t;
                        if lim == 0 as libc::c_int as libc::c_uint {
                            current_block = 12621754591585079215;
                        } else {
                            if JS_IsUndefined(separator) != 0 {
                                current_block = 12241601365992652764;
                            } else if s == 0 as libc::c_int as libc::c_longlong {
                                if r != 0 as libc::c_int as libc::c_longlong {
                                    current_block = 12241601365992652764;
                                } else {
                                    current_block = 12621754591585079215;
                                }
                            } else {
                                q = p;
                                q = p;
                                loop {
                                    q += (r == 0) as libc::c_int as libc::c_longlong;
                                    if !(q
                                        <= s - r - (r == 0) as libc::c_int as libc::c_longlong)
                                    {
                                        current_block = 12241601365992652764;
                                        break;
                                    }
                                    e = string_indexof(sp, rp, q as libc::c_int) as int64_t;
                                    if e < 0 as libc::c_int as libc::c_longlong {
                                        current_block = 12241601365992652764;
                                        break;
                                    }
                                    T = js_sub_string(
                                        ctx,
                                        sp,
                                        p as libc::c_int,
                                        e as libc::c_int,
                                    );
                                    if JS_IsException(T) != 0 {
                                        current_block = 223620086940157833;
                                        break;
                                    }
                                    let fresh652 = lengthA;
                                    lengthA = lengthA.wrapping_add(1);
                                    if JS_CreateDataPropertyUint32(
                                        ctx,
                                        A,
                                        fresh652 as int64_t,
                                        T,
                                        0 as libc::c_int,
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 223620086940157833;
                                        break;
                                    }
                                    if lengthA == lim {
                                        current_block = 12621754591585079215;
                                        break;
                                    }
                                    p = e + r;
                                    q = p;
                                }
                            }
                            match current_block {
                                12621754591585079215 => {}
                                223620086940157833 => {}
                                _ => {
                                    T = js_sub_string(
                                        ctx,
                                        sp,
                                        p as libc::c_int,
                                        s as libc::c_int,
                                    );
                                    if JS_IsException(T) != 0 {
                                        current_block = 223620086940157833;
                                    } else {
                                        let fresh653 = lengthA;
                                        lengthA = lengthA.wrapping_add(1);
                                        if JS_CreateDataPropertyUint32(
                                            ctx,
                                            A,
                                            fresh653 as int64_t,
                                            T,
                                            0 as libc::c_int,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 223620086940157833;
                                        } else {
                                            current_block = 12621754591585079215;
                                        }
                                    }
                                }
                            }
                        }
                        match current_block {
                            223620086940157833 => {}
                            _ => {
                                JS_FreeValue(ctx, S);
                                JS_FreeValue(ctx, R);
                                return A;
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, A);
    JS_FreeValue(ctx, S);
    JS_FreeValue(ctx, R);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_substring(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut end: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    if JS_ToInt32Clamp(
        ctx,
        &mut a,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        (*p).len() as libc::c_int,
        0 as libc::c_int,
    ) != 0
    {
        JS_FreeValue(ctx, str);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    b = (*p).len() as libc::c_int;
    if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
        if JS_ToInt32Clamp(
            ctx,
            &mut b,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            (*p).len() as libc::c_int,
            0 as libc::c_int,
        ) != 0
        {
            JS_FreeValue(ctx, str);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if a < b {
        start = a;
        end = b;
    } else {
        start = b;
        end = a;
    }
    ret = js_sub_string(ctx, p, start, end);
    JS_FreeValue(ctx, str);
    return ret;
}
unsafe extern "C" fn js_string_substr(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut a: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    len = (*p).len() as libc::c_int;
    if JS_ToInt32Clamp(
        ctx,
        &mut a,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        len,
        len,
    ) != 0
    {
        JS_FreeValue(ctx, str);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    n = len - a;
    if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
        if JS_ToInt32Clamp(
            ctx,
            &mut n,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            len - a,
            0 as libc::c_int,
        ) != 0
        {
            JS_FreeValue(ctx, str);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    ret = js_sub_string(ctx, p, a, a + n);
    JS_FreeValue(ctx, str);
    return ret;
}
unsafe extern "C" fn js_string_slice(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut len: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut end: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    len = (*p).len() as libc::c_int;
    if JS_ToInt32Clamp(
        ctx,
        &mut start,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        len,
        len,
    ) != 0
    {
        JS_FreeValue(ctx, str);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    end = len;
    if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
        if JS_ToInt32Clamp(
            ctx,
            &mut end,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0
        {
            JS_FreeValue(ctx, str);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    ret = js_sub_string(ctx, p, start, max_int(end, start));
    JS_FreeValue(ctx, str);
    return ret;
}
unsafe extern "C" fn js_string_pad(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut padEnd: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut str: JSValue = 0;
    let mut v: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut p1: *mut JSString = 0 as *mut JSString;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut c: libc::c_int = ' ' as i32;
    str = JS_ToStringCheckObject(ctx, this_val);
    if !(JS_IsException(str) != 0) {
        if !(JS_ToInt32Sat(ctx, &mut n, *argv.offset(0 as libc::c_int as isize)) != 0) {
            p = str as intptr_t as *mut libc::c_void as *mut JSString;
            len = (*p).len() as libc::c_int;
            if len >= n {
                return str;
            }
            if argc > 1 as libc::c_int
                && JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0
            {
                v = JS_ToString(ctx, *argv.offset(1 as libc::c_int as isize));
                if JS_IsException(v) != 0 {
                    current_block = 4495203486751060176;
                } else {
                    p1 = v as intptr_t as *mut libc::c_void as *mut JSString;
                    if (*p1).len() as libc::c_int == 0 as libc::c_int {
                        JS_FreeValue(ctx, v);
                        return str;
                    }
                    if (*p1).len() as libc::c_int == 1 as libc::c_int {
                        c = string_get(p1, 0 as libc::c_int);
                        p1 = 0 as *mut JSString;
                    }
                    current_block = 2838571290723028321;
                }
            } else {
                current_block = 2838571290723028321;
            }
            match current_block {
                4495203486751060176 => {}
                _ => {
                    if n > ((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int {
                        JS_ThrowInternalError(
                            ctx,
                            b"string too long\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        if !(string_buffer_init(ctx, b, n) != 0) {
                            n -= len;
                            if padEnd != 0 {
                                if string_buffer_concat(
                                    b,
                                    p,
                                    0 as libc::c_int as uint32_t,
                                    len as uint32_t,
                                ) != 0
                                {
                                    current_block = 10850523192633874106;
                                } else {
                                    current_block = 14818589718467733107;
                                }
                            } else {
                                current_block = 14818589718467733107;
                            }
                            match current_block {
                                14818589718467733107 => {
                                    if !p1.is_null() {
                                        loop {
                                            if !(n > 0 as libc::c_int) {
                                                current_block = 2873832966593178012;
                                                break;
                                            }
                                            let mut chunk: libc::c_int = min_int(
                                                n,
                                                (*p1).len() as libc::c_int,
                                            );
                                            if string_buffer_concat(
                                                b,
                                                p1,
                                                0 as libc::c_int as uint32_t,
                                                chunk as uint32_t,
                                            ) != 0
                                            {
                                                current_block = 10850523192633874106;
                                                break;
                                            }
                                            n -= chunk;
                                        }
                                    } else if string_buffer_fill(b, c, n) != 0 {
                                        current_block = 10850523192633874106;
                                    } else {
                                        current_block = 2873832966593178012;
                                    }
                                    match current_block {
                                        10850523192633874106 => {}
                                        _ => {
                                            if padEnd == 0 {
                                                if string_buffer_concat(
                                                    b,
                                                    p,
                                                    0 as libc::c_int as uint32_t,
                                                    len as uint32_t,
                                                ) != 0
                                                {
                                                    current_block = 10850523192633874106;
                                                } else {
                                                    current_block = 4090602189656566074;
                                                }
                                            } else {
                                                current_block = 4090602189656566074;
                                            }
                                            match current_block {
                                                10850523192633874106 => {}
                                                _ => {
                                                    JS_FreeValue(ctx, v);
                                                    JS_FreeValue(ctx, str);
                                                    return string_buffer_end(b);
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            string_buffer_free(b);
                        }
                        JS_FreeValue(ctx, v);
                    }
                }
            }
        }
        JS_FreeValue(ctx, str);
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_repeat(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut val: int64_t = 0;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    str = JS_ToStringCheckObject(ctx, this_val);
    if !(JS_IsException(str) != 0) {
        if !(JS_ToInt64Sat(ctx, &mut val, *argv.offset(0 as libc::c_int as isize)) != 0)
        {
            if val < 0 as libc::c_int as libc::c_longlong
                || val > 2147483647 as libc::c_int as libc::c_longlong
            {
                JS_ThrowRangeError(
                    ctx,
                    b"invalid repeat count\0" as *const u8 as *const libc::c_char,
                );
            } else {
                n = val as libc::c_int;
                p = str as intptr_t as *mut libc::c_void as *mut JSString;
                len = (*p).len() as libc::c_int;
                if len == 0 as libc::c_int || n == 1 as libc::c_int {
                    return str;
                }
                if val * len as libc::c_longlong
                    > (((1 as libc::c_int) << 30 as libc::c_int) - 1 as libc::c_int)
                        as libc::c_longlong
                {
                    JS_ThrowInternalError(
                        ctx,
                        b"string too long\0" as *const u8 as *const libc::c_char,
                    );
                } else if !(string_buffer_init2(
                    ctx,
                    b,
                    n * len,
                    (*p).is_wide_char() as libc::c_int,
                ) != 0)
                {
                    if len == 1 as libc::c_int {
                        string_buffer_fill(b, string_get(p, 0 as libc::c_int), n);
                    } else {
                        loop {
                            let fresh654 = n;
                            n = n - 1;
                            if !(fresh654 > 0 as libc::c_int) {
                                break;
                            }
                            string_buffer_concat(
                                b,
                                p,
                                0 as libc::c_int as uint32_t,
                                len as uint32_t,
                            );
                        }
                    }
                    JS_FreeValue(ctx, str);
                    return string_buffer_end(b);
                }
            }
        }
    }
    JS_FreeValue(ctx, str);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_trim(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    a = 0 as libc::c_int;
    len = (*p).len() as libc::c_int;
    b = len;
    if magic & 1 as libc::c_int != 0 {
        while a < len && lre_is_space(string_get(p, a)) != 0 {
            a += 1;
        }
    }
    if magic & 2 as libc::c_int != 0 {
        while b > a && lre_is_space(string_get(p, b - 1 as libc::c_int)) != 0 {
            b -= 1;
        }
    }
    ret = js_sub_string(ctx, p, a, b);
    JS_FreeValue(ctx, str);
    return ret;
}
unsafe extern "C" fn js_string___quote(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_ToQuotedString(ctx, this_val);
}
unsafe extern "C" fn string_prevc(
    mut p: *mut JSString,
    mut pidx: *mut libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    idx = *pidx;
    if idx <= 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    idx -= 1;
    if (*p).is_wide_char() != 0 {
        c = (*p).u.str16[idx as usize] as libc::c_int;
        if c >= 0xdc00 as libc::c_int && c < 0xe000 as libc::c_int
            && idx > 0 as libc::c_int
        {
            c1 = (*p).u.str16[(idx - 1 as libc::c_int) as usize] as libc::c_int;
            if c1 >= 0xd800 as libc::c_int && c1 <= 0xdc00 as libc::c_int {
                c = ((c1 & 0x3ff as libc::c_int) << 10 as libc::c_int
                    | c & 0x3ff as libc::c_int) + 0x10000 as libc::c_int;
                idx -= 1;
            }
        }
    } else {
        c = (*p).u.str8[idx as usize] as libc::c_int;
    }
    *pidx = idx;
    return c;
}
unsafe extern "C" fn test_final_sigma(
    mut p: *mut JSString,
    mut sigma_pos: libc::c_int,
) -> BOOL {
    let mut k: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    k = sigma_pos;
    loop {
        c1 = string_prevc(p, &mut k);
        if lre_is_case_ignorable(c1 as uint32_t) == 0 {
            break;
        }
    }
    if lre_is_cased(c1 as uint32_t) == 0 {
        return FALSE as libc::c_int;
    }
    k = sigma_pos + 1 as libc::c_int;
    loop {
        if k >= (*p).len() as libc::c_int {
            return TRUE as libc::c_int;
        }
        c1 = string_getc(p, &mut k);
        if lre_is_case_ignorable(c1 as uint32_t) == 0 {
            break;
        }
    }
    return (lre_is_cased(c1 as uint32_t) == 0) as libc::c_int;
}
unsafe extern "C" fn js_string_localeCompare(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut a: JSValue = 0;
    let mut b: JSValue = 0;
    let mut cmp: libc::c_int = 0;
    a = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(a) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    b = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(b) != 0 {
        JS_FreeValue(ctx, a);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    cmp = js_string_compare(
        ctx,
        a as intptr_t as *mut libc::c_void as *mut JSString,
        b as intptr_t as *mut libc::c_void as *mut JSString,
    );
    JS_FreeValue(ctx, a);
    JS_FreeValue(ctx, b);
    return JS_NewInt32(ctx, cmp);
}
unsafe extern "C" fn js_string_toLowerCase(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut to_lower: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut res: [uint32_t; 3] = [0; 3];
    val = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    if (*p).len() as libc::c_int == 0 as libc::c_int {
        return val;
    }
    if !(string_buffer_init(ctx, b, (*p).len() as libc::c_int) != 0) {
        i = 0 as libc::c_int;
        's_48: loop {
            if !(i < (*p).len() as libc::c_int) {
                current_block = 5783071609795492627;
                break;
            }
            c = string_getc(p, &mut i);
            if c == 0x3a3 as libc::c_int && to_lower != 0
                && test_final_sigma(p, i - 1 as libc::c_int) != 0
            {
                res[0 as libc::c_int as usize] = 0x3c2 as libc::c_int as uint32_t;
                l = 1 as libc::c_int;
            } else {
                l = lre_case_conv(res.as_mut_ptr(), c as uint32_t, to_lower);
            }
            j = 0 as libc::c_int;
            while j < l {
                if string_buffer_putc(b, res[j as usize]) != 0 {
                    current_block = 2870579908713634727;
                    break 's_48;
                }
                j += 1;
            }
        }
        match current_block {
            2870579908713634727 => {}
            _ => {
                JS_FreeValue(ctx, val);
                return string_buffer_end(b);
            }
        }
    }
    JS_FreeValue(ctx, val);
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_ToUTF32String(
    mut ctx: *mut JSContext,
    mut pbuf: *mut *mut uint32_t,
    mut val1: JSValue,
) -> libc::c_int {
    let mut val: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut buf: *mut uint32_t = 0 as *mut uint32_t;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    val = JS_ToString(ctx, val1);
    if JS_IsException(val) != 0 {
        return -(1 as libc::c_int);
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSString;
    len = (*p).len() as libc::c_int;
    buf = js_malloc(
        ctx,
        (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
            .wrapping_mul(max_int(len, 1 as libc::c_int) as libc::c_ulong),
    ) as *mut uint32_t;
    if buf.is_null() {
        JS_FreeValue(ctx, val);
        *pbuf = 0 as *mut uint32_t;
        return -(1 as libc::c_int);
    } else {
        j = 0 as libc::c_int;
        i = j;
        while i < len {
            let fresh655 = j;
            j = j + 1;
            *buf.offset(fresh655 as isize) = string_getc(p, &mut i) as uint32_t;
        }
        JS_FreeValue(ctx, val);
        *pbuf = buf;
        return j;
    };
}
unsafe extern "C" fn JS_NewUTF32String(
    mut ctx: *mut JSContext,
    mut buf: *const uint32_t,
    mut len: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if string_buffer_init(ctx, b, len) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    i = 0 as libc::c_int;
    loop {
        if !(i < len) {
            current_block = 2473556513754201174;
            break;
        }
        if string_buffer_putc(b, *buf.offset(i as isize)) != 0 {
            current_block = 9491985818360676362;
            break;
        }
        i += 1;
    }
    match current_block {
        2473556513754201174 => return string_buffer_end(b),
        _ => {
            string_buffer_free(b);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    };
}
unsafe extern "C" fn js_string_normalize(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut form: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut form_len: size_t = 0;
    let mut is_compat: libc::c_int = 0;
    let mut buf_len: libc::c_int = 0;
    let mut out_len: libc::c_int = 0;
    let mut n_type: UnicodeNormalizationEnum = UNICODE_NFC;
    let mut val: JSValue = 0;
    let mut buf: *mut uint32_t = 0 as *mut uint32_t;
    let mut out_buf: *mut uint32_t = 0 as *mut uint32_t;
    val = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    buf_len = JS_ToUTF32String(ctx, &mut buf, val);
    JS_FreeValue(ctx, val);
    if buf_len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if argc == 0 as libc::c_int
        || JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) != 0
    {
        n_type = UNICODE_NFC;
    } else {
        form = JS_ToCStringLen(
            ctx,
            &mut form_len,
            *argv.offset(0 as libc::c_int as isize),
        );
        if form.is_null() {
            current_block = 3585159398859474542;
        } else {
            p = form;
            if *p.offset(0 as libc::c_int as isize) as libc::c_int != 'N' as i32
                || *p.offset(1 as libc::c_int as isize) as libc::c_int != 'F' as i32
            {
                current_block = 6557613050748750094;
            } else {
                p = p.offset(2 as libc::c_int as isize);
                is_compat = FALSE as libc::c_int;
                if *p as libc::c_int == 'K' as i32 {
                    is_compat = TRUE as libc::c_int;
                    p = p.offset(1);
                }
                if *p as libc::c_int == 'C' as i32 || *p as libc::c_int == 'D' as i32 {
                    n_type = (UNICODE_NFC as libc::c_int + is_compat * 2 as libc::c_int
                        + (*p as libc::c_int - 'C' as i32)) as UnicodeNormalizationEnum;
                    if p.offset(1 as libc::c_int as isize).offset_from(form)
                        as libc::c_long as libc::c_ulong != form_len
                    {
                        current_block = 6557613050748750094;
                    } else {
                        JS_FreeCString(ctx, form);
                        current_block = 17788412896529399552;
                    }
                } else {
                    current_block = 6557613050748750094;
                }
            }
            match current_block {
                17788412896529399552 => {}
                _ => {
                    JS_FreeCString(ctx, form);
                    JS_ThrowRangeError(
                        ctx,
                        b"bad normalization form\0" as *const u8 as *const libc::c_char,
                    );
                    current_block = 3585159398859474542;
                }
            }
        }
        match current_block {
            17788412896529399552 => {}
            _ => {
                js_free(ctx, buf as *mut libc::c_void);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    out_len = unicode_normalize(
        &mut out_buf,
        buf,
        buf_len,
        n_type,
        (*ctx).rt as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut JSRuntime,
                    *mut libc::c_void,
                    size_t,
                ) -> *mut libc::c_void,
            >,
            Option::<DynBufReallocFunc>,
        >(
            Some(
                js_realloc_rt
                    as unsafe extern "C" fn(
                        *mut JSRuntime,
                        *mut libc::c_void,
                        size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
    );
    js_free(ctx, buf as *mut libc::c_void);
    if out_len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    val = JS_NewUTF32String(ctx, out_buf, out_len);
    js_free(ctx, out_buf as *mut libc::c_void);
    return val;
}
unsafe extern "C" fn js_string_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return js_thisStringValue(ctx, this_val);
}
unsafe extern "C" fn js_string_iterator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
    mut magic: libc::c_int,
) -> JSValue {
    let mut it: *mut JSArrayIteratorData = 0 as *mut JSArrayIteratorData;
    let mut idx: uint32_t = 0;
    let mut c: uint32_t = 0;
    let mut start: uint32_t = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    it = JS_GetOpaque2(
        ctx,
        this_val,
        JS_CLASS_STRING_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSArrayIteratorData;
    if it.is_null() {
        *pdone = FALSE as libc::c_int;
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if !(JS_IsUndefined((*it).obj) != 0) {
        p = (*it).obj as intptr_t as *mut libc::c_void as *mut JSString;
        idx = (*it).idx;
        if idx >= (*p).len() {
            JS_FreeValue(ctx, (*it).obj);
            (*it)
                .obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        } else {
            start = idx;
            c = string_getc(p, &mut idx as *mut uint32_t as *mut libc::c_int)
                as uint32_t;
            (*it).idx = idx;
            *pdone = FALSE as libc::c_int;
            if c <= 0xffff as libc::c_int as libc::c_uint {
                return js_new_string_char(ctx, c as uint16_t)
            } else {
                return js_new_string16(
                    ctx,
                    ((*p).u.str16).as_mut_ptr().offset(start as isize),
                    2 as libc::c_int,
                )
            }
        }
    }
    *pdone = TRUE as libc::c_int;
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_string_CreateHTML(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut p: *const JSString = 0 as *const JSString;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    static mut defs: [C2RustUnnamed_36; 13] = [
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"a\0" as *const u8 as *const libc::c_char,
                attr: b"name\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"big\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"blink\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"b\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"tt\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"font\0" as *const u8 as *const libc::c_char,
                attr: b"color\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"font\0" as *const u8 as *const libc::c_char,
                attr: b"size\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"i\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"a\0" as *const u8 as *const libc::c_char,
                attr: b"href\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"small\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"strike\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"sub\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_36 {
                tag: b"sup\0" as *const u8 as *const libc::c_char,
                attr: 0 as *const libc::c_char,
            };
            init
        },
    ];
    str = JS_ToStringCheckObject(ctx, this_val);
    if JS_IsException(str) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    string_buffer_init(ctx, b, 7 as libc::c_int);
    string_buffer_putc8(b, '<' as i32 as uint32_t);
    string_buffer_puts8(b, defs[magic as usize].tag);
    if !(defs[magic as usize].attr).is_null() {
        let mut value: JSValue = 0;
        let mut i: libc::c_int = 0;
        string_buffer_putc8(b, ' ' as i32 as uint32_t);
        string_buffer_puts8(b, defs[magic as usize].attr);
        string_buffer_puts8(b, b"=\"\0" as *const u8 as *const libc::c_char);
        value = JS_ToStringCheckObject(ctx, *argv.offset(0 as libc::c_int as isize));
        if JS_IsException(value) != 0 {
            JS_FreeValue(ctx, str);
            string_buffer_free(b);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        p = value as intptr_t as *mut libc::c_void as *mut JSString;
        i = 0 as libc::c_int;
        while i < (*p).len() as libc::c_int {
            let mut c: libc::c_int = string_get(p, i);
            if c == '"' as i32 {
                string_buffer_puts8(b, b"&quot;\0" as *const u8 as *const libc::c_char);
            } else {
                string_buffer_putc16(b, c as uint32_t);
            }
            i += 1;
        }
        JS_FreeValue(ctx, value);
        string_buffer_putc8(b, '"' as i32 as uint32_t);
    }
    string_buffer_putc8(b, '>' as i32 as uint32_t);
    string_buffer_concat_value_free(b, str);
    string_buffer_puts8(b, b"</\0" as *const u8 as *const libc::c_char);
    string_buffer_puts8(b, defs[magic as usize].tag);
    string_buffer_putc8(b, '>' as i32 as uint32_t);
    return string_buffer_end(b);
}
static mut js_string_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"fromCharCode\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_fromCharCode
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fromCodePoint\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_fromCodePoint
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"raw\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_raw
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_string_proto_funcs: [JSCFunctionListEntry; 49] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"length\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 4 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    i32_0: 0 as libc::c_int,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"charCodeAt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_charCodeAt
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"charAt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_charAt
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"concat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_concat
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"codePointAt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_codePointAt
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"indexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"lastIndexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"includes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_includes
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"endsWith\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_includes
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"startsWith\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_includes
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"match\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ATOM_Symbol_match as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_match
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"matchAll\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ATOM_Symbol_matchAll as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_match
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"search\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ATOM_Symbol_search as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_match
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"split\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_split
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"substring\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_substring
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"substr\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_substr
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"slice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"repeat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_repeat
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"replace\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_replace
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"replaceAll\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_replace
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"padEnd\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_pad
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"padStart\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_pad
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trim\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 3 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_trim
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trimEnd\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_trim
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trimRight\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"trimEnd\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trimStart\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_trim
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trimLeft\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"trimStart\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__quote\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string___quote
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"localeCompare\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_localeCompare
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLowerCase\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_toLowerCase
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toUpperCase\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_toLowerCase
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleLowerCase\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_toLowerCase
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleUpperCase\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_toLowerCase
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (JS_ITERATOR_KIND_VALUE as libc::c_int | 4 as libc::c_int)
                    as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"anchor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_anchor as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"big\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_big as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"blink\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_blink as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"bold\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_bold as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fixed\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_fixed as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fontcolor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_fontcolor as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fontsize\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_fontsize as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"italics\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_italics as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"link\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_link as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"small\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_small as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"strike\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_strike as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sub\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_sub as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sup\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: magic_string_sup as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_string_CreateHTML
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_string_iterator_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_string_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"String Iterator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_string_proto_normalize: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"normalize\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_string_normalize
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicStringNormalize(mut ctx: *mut JSContext) {
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_STRING as libc::c_int as isize),
        js_string_proto_normalize.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
}
unsafe extern "C" fn js_fmin(
    mut a: libc::c_double,
    mut b: libc::c_double,
) -> libc::c_double {
    if a == 0 as libc::c_int as libc::c_double && b == 0 as libc::c_int as libc::c_double
    {
        let mut a1: JSFloat64Union = JSFloat64Union { d: 0. };
        let mut b1: JSFloat64Union = JSFloat64Union { d: 0. };
        a1.d = a;
        b1.d = b;
        a1.u64_0 |= b1.u64_0;
        return a1.d;
    } else {
        return fmin(a, b)
    };
}
unsafe extern "C" fn js_fmax(
    mut a: libc::c_double,
    mut b: libc::c_double,
) -> libc::c_double {
    if a == 0 as libc::c_int as libc::c_double && b == 0 as libc::c_int as libc::c_double
    {
        let mut a1: JSFloat64Union = JSFloat64Union { d: 0. };
        let mut b1: JSFloat64Union = JSFloat64Union { d: 0. };
        a1.d = a;
        b1.d = b;
        a1.u64_0 &= b1.u64_0;
        return a1.d;
    } else {
        return fmax(a, b)
    };
}
unsafe extern "C" fn js_math_min_max(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut is_max: BOOL = magic;
    let mut r: libc::c_double = 0.;
    let mut a: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    let mut tag: uint32_t = 0;
    if (argc == 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        return __JS_NewFloat64(
            ctx,
            if is_max != 0 { -1.0f64 / 0.0f64 } else { 1.0f64 / 0.0f64 },
        );
    }
    tag = (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
        as uint32_t;
    let mut current_block_29: u64;
    if tag == JS_TAG_INT as libc::c_int as libc::c_uint {
        let mut a1: libc::c_int = 0;
        let mut r1: libc::c_int = *argv.offset(0 as libc::c_int as isize) as libc::c_int;
        i = 1 as libc::c_int;
        loop {
            if !(i < argc) {
                current_block_29 = 7149356873433890176;
                break;
            }
            tag = (*argv.offset(i as isize) >> 32 as libc::c_int) as libc::c_int
                as uint32_t;
            if tag != JS_TAG_INT as libc::c_int as libc::c_uint {
                r = r1 as libc::c_double;
                current_block_29 = 11653582528580798427;
                break;
            } else {
                a1 = *argv.offset(i as isize) as libc::c_int;
                if is_max != 0 {
                    r1 = max_int(r1, a1);
                } else {
                    r1 = min_int(r1, a1);
                }
                i += 1;
            }
        }
        match current_block_29 {
            11653582528580798427 => {}
            _ => return JS_NewInt32(ctx, r1),
        }
    } else {
        if JS_ToFloat64(ctx, &mut r, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i = 1 as libc::c_int;
    }
    while i < argc {
        if JS_ToFloat64(ctx, &mut a, *argv.offset(i as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if isnan(r) == 0 {
            if isnan(a) != 0 {
                r = a;
            } else if is_max != 0 {
                r = js_fmax(r, a);
            } else {
                r = js_fmin(r, a);
            }
        }
        i += 1;
    }
    return JS_NewFloat64(ctx, r);
}
unsafe extern "C" fn js_math_sign(mut a: libc::c_double) -> libc::c_double {
    if isnan(a) != 0 || a == 0.0f64 {
        return a;
    }
    if a < 0 as libc::c_int as libc::c_double {
        return -(1 as libc::c_int) as libc::c_double
    } else {
        return 1 as libc::c_int as libc::c_double
    };
}
unsafe extern "C" fn js_math_round(mut a: libc::c_double) -> libc::c_double {
    let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
    let mut frac_mask: uint64_t = 0;
    let mut one: uint64_t = 0;
    let mut e: libc::c_uint = 0;
    let mut s: libc::c_uint = 0;
    u.d = a;
    e = (u.u64_0 >> 52 as libc::c_int & 0x7ff as libc::c_int as libc::c_ulonglong)
        as libc::c_uint;
    if e < 1023 as libc::c_int as libc::c_uint {
        if e == (1023 as libc::c_int - 1 as libc::c_int) as libc::c_uint
            && u.u64_0 != 0xbfe0000000000000 as libc::c_ulonglong
        {
            u
                .u64_0 = u.u64_0 & (1 as libc::c_int as uint64_t) << 63 as libc::c_int
                | (1023 as libc::c_int as uint64_t) << 52 as libc::c_int;
        } else {
            u.u64_0 &= (1 as libc::c_int as uint64_t) << 63 as libc::c_int;
        }
    } else if e < (1023 as libc::c_int + 52 as libc::c_int) as libc::c_uint {
        s = (u.u64_0 >> 63 as libc::c_int) as libc::c_uint;
        one = (1 as libc::c_int as uint64_t)
            << (52 as libc::c_int as libc::c_uint)
                .wrapping_sub(e.wrapping_sub(1023 as libc::c_int as libc::c_uint));
        frac_mask = one.wrapping_sub(1 as libc::c_int as libc::c_ulonglong);
        u
            .u64_0 = (u.u64_0 as libc::c_ulonglong)
            .wrapping_add((one >> 1 as libc::c_int).wrapping_sub(s as libc::c_ulonglong))
            as uint64_t as uint64_t;
        u.u64_0 &= !frac_mask;
    }
    return u.d;
}
unsafe extern "C" fn js_math_hypot(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut r: libc::c_double = 0.;
    let mut a: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    r = 0 as libc::c_int as libc::c_double;
    if argc > 0 as libc::c_int {
        if JS_ToFloat64(ctx, &mut r, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if argc == 1 as libc::c_int {
            r = fabs(r);
        } else {
            i = 1 as libc::c_int;
            while i < argc {
                if JS_ToFloat64(ctx, &mut a, *argv.offset(i as isize)) != 0 {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                r = hypot(r, a);
                i += 1;
            }
        }
    }
    return JS_NewFloat64(ctx, r);
}
unsafe extern "C" fn js_math_fround(mut a: libc::c_double) -> libc::c_double {
    return a as libc::c_float as libc::c_double;
}
unsafe extern "C" fn js_math_imul(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    if JS_ToInt32(ctx, &mut a, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32(ctx, &mut b, *argv.offset(1 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewInt32(ctx, a * b);
}
unsafe extern "C" fn js_math_clz32(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut a: uint32_t = 0;
    let mut r: uint32_t = 0;
    if JS_ToUint32(ctx, &mut a, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if a == 0 as libc::c_int as libc::c_uint {
        r = 32 as libc::c_int as uint32_t;
    } else {
        r = clz32(a) as uint32_t;
    }
    return JS_NewInt32(ctx, r as int32_t);
}
unsafe extern "C" fn xorshift64star(mut pstate: *mut uint64_t) -> uint64_t {
    let mut x: uint64_t = 0;
    x = *pstate;
    x ^= x >> 12 as libc::c_int;
    x ^= x << 25 as libc::c_int;
    x ^= x >> 27 as libc::c_int;
    *pstate = x;
    return x.wrapping_mul(0x2545f4914f6cdd1d as libc::c_longlong as libc::c_ulonglong);
}
unsafe extern "C" fn js_random_init(mut ctx: *mut JSContext) {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    gettimeofday(&mut tv, 0 as *mut libc::c_void);
    (*ctx)
        .random_state = (tv.tv_sec * 1000000 as libc::c_int as libc::c_longlong
        + tv.tv_usec) as uint64_t;
    if (*ctx).random_state == 0 as libc::c_int as libc::c_ulonglong {
        (*ctx).random_state = 1 as libc::c_int as uint64_t;
    }
}
unsafe extern "C" fn js_math_random(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
    let mut v: uint64_t = 0;
    v = xorshift64star(&mut (*ctx).random_state);
    u
        .u64_0 = (0x3ff as libc::c_int as uint64_t) << 52 as libc::c_int
        | v >> 12 as libc::c_int;
    return __JS_NewFloat64(ctx, u.d - 1.0f64);
}
static mut js_math_funcs: [JSCFunctionListEntry; 44] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"min\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_math_min_max
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"max\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_math_min_max
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"abs\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    fabs
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"floor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    floor
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"ceil\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    ceil
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"round\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    js_math_round
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sqrt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    sqrt
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"acos\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    acos
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"asin\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    asin
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"atan\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    atan
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"atan2\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f_f: Some(
                                    atan2
                                        as unsafe extern "C" fn(
                                            libc::c_double,
                                            libc::c_double,
                                        ) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"cos\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    cos
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"exp\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    exp
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"log\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    log
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"pow\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f_f: Some(
                                    js_pow
                                        as unsafe extern "C" fn(
                                            libc::c_double,
                                            libc::c_double,
                                        ) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sin\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    sin
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"tan\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    tan
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"trunc\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    trunc
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sign\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    js_math_sign
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"cosh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    cosh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sinh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    sinh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"tanh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    tanh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"acosh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    acosh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"asinh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    asinh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"atanh\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    atanh
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"expm1\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    expm1
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"log1p\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    log1p
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"log2\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    log2
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"log10\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    log10
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"cbrt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    cbrt
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"hypot\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_math_hypot
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"random\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_math_random
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fround\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_f_f as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                f_f: Some(
                                    js_math_fround
                                        as unsafe extern "C" fn(libc::c_double) -> libc::c_double,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"imul\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_math_imul
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"clz32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_math_clz32
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Math\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"E\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 2.718281828459045f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"LN10\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 2.302585092994046f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"LN2\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 0.6931471805599453f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"LOG2E\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 1.4426950408889634f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"LOG10E\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 0.4342944819032518f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"PI\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 3.141592653589793f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"SQRT1_2\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 0.7071067811865476f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"SQRT2\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 1.4142135623730951f64,
                },
            };
            init
        },
    ]
};
static mut js_math_obj: [JSCFunctionListEntry; 1] = [JSCFunctionListEntry {
    name: 0 as *const libc::c_char,
    prop_flags: 0,
    def_type: 0,
    magic: 0,
    u: C2RustUnnamed_22 {
        func: C2RustUnnamed_25 {
            length: 0,
            cproto: 0,
            cfunc: JSCFunctionType { generic: None },
        },
    },
}; 1];
unsafe extern "C" fn js___date_clock(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut d: int64_t = 0;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    gettimeofday(&mut tv, 0 as *mut libc::c_void);
    d = tv.tv_sec * 1000000 as libc::c_int as libc::c_longlong + tv.tv_usec;
    return JS_NewInt64(ctx, d);
}
unsafe extern "C" fn getTimezoneOffset(mut time: int64_t) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_regexp_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut re: *mut JSRegExp = &mut (*p).u.regexp;
    JS_FreeValueRT(
        rt,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*re).bytecode as uintptr_t as libc::c_ulonglong,
    );
    JS_FreeValueRT(
        rt,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*re).pattern as uintptr_t as libc::c_ulonglong,
    );
}
unsafe extern "C" fn js_compile_regexp(
    mut ctx: *mut JSContext,
    mut pattern: JSValue,
    mut flags: JSValue,
) -> JSValue {
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut re_flags: libc::c_int = 0;
    let mut mask: libc::c_int = 0;
    let mut re_bytecode_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut i: size_t = 0;
    let mut len: size_t = 0;
    let mut re_bytecode_len: libc::c_int = 0;
    let mut ret: JSValue = 0;
    let mut error_msg: [libc::c_char; 64] = [0; 64];
    re_flags = 0 as libc::c_int;
    if JS_IsUndefined(flags) == 0 {
        str = JS_ToCStringLen(ctx, &mut len, flags);
        if str.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i = 0 as libc::c_int as size_t;
        while i < len {
            's_131: {
                let mut current_block_13: u64;
                match *str.offset(i as isize) as libc::c_int {
                    103 => {
                        mask = (1 as libc::c_int) << 0 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    105 => {
                        mask = (1 as libc::c_int) << 1 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    109 => {
                        mask = (1 as libc::c_int) << 2 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    115 => {
                        mask = (1 as libc::c_int) << 3 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    117 => {
                        mask = (1 as libc::c_int) << 4 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    121 => {
                        mask = (1 as libc::c_int) << 5 as libc::c_int;
                        current_block_13 = 15089075282327824602;
                    }
                    _ => {
                        current_block_13 = 14434253808855938679;
                    }
                }
                match current_block_13 {
                    15089075282327824602 => {
                        if !(re_flags & mask != 0 as libc::c_int) {
                            re_flags |= mask;
                            break 's_131;
                        }
                    }
                    _ => {}
                }
                JS_FreeCString(ctx, str);
                return JS_ThrowSyntaxError(
                    ctx,
                    b"invalid regular expression flags\0" as *const u8
                        as *const libc::c_char,
                );
            }
            i = i.wrapping_add(1);
        }
        JS_FreeCString(ctx, str);
    }
    str = JS_ToCStringLen2(
        ctx,
        &mut len,
        pattern,
        (re_flags & (1 as libc::c_int) << 4 as libc::c_int == 0) as libc::c_int,
    );
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    re_bytecode_buf = lre_compile(
        &mut re_bytecode_len,
        error_msg.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        str,
        len,
        re_flags,
        ctx as *mut libc::c_void,
    );
    JS_FreeCString(ctx, str);
    if re_bytecode_buf.is_null() {
        JS_ThrowSyntaxError(
            ctx,
            b"%s\0" as *const u8 as *const libc::c_char,
            error_msg.as_mut_ptr(),
        );
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = js_new_string8(ctx, re_bytecode_buf, re_bytecode_len);
    js_free(ctx, re_bytecode_buf as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn js_regexp_constructor_internal(
    mut ctx: *mut JSContext,
    mut ctor: JSValue,
    mut pattern: JSValue,
    mut bc: JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut re: *mut JSRegExp = 0 as *mut JSRegExp;
    if (bc >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int
        || (pattern >> 32 as libc::c_int) as libc::c_int != JS_TAG_STRING as libc::c_int
    {
        JS_ThrowTypeError(ctx, b"string expected\0" as *const u8 as *const libc::c_char);
    } else {
        obj = js_create_from_ctor(ctx, ctor, JS_CLASS_REGEXP as libc::c_int);
        if !(JS_IsException(obj) != 0) {
            p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            re = &mut (*p).u.regexp;
            let ref mut fresh656 = (*re).pattern;
            *fresh656 = pattern as intptr_t as *mut libc::c_void as *mut JSString;
            let ref mut fresh657 = (*re).bytecode;
            *fresh657 = bc as intptr_t as *mut libc::c_void as *mut JSString;
            JS_DefinePropertyValue(
                ctx,
                obj,
                JS_ATOM_lastIndex as libc::c_int as JSAtom,
                JS_NewInt32(ctx, 0 as libc::c_int),
                (1 as libc::c_int) << 1 as libc::c_int,
            );
            return obj;
        }
    }
    JS_FreeValue(ctx, bc);
    JS_FreeValue(ctx, pattern);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_get_regexp(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut throw_error: BOOL,
) -> *mut JSRegExp {
    if (obj >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_REGEXP as libc::c_int
        {
            return &mut (*p).u.regexp;
        }
    }
    if throw_error != 0 {
        JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP as libc::c_int);
    }
    return 0 as *mut JSRegExp;
}
unsafe extern "C" fn js_is_regexp(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut m: JSValue = 0;
    if JS_IsObject(obj) == 0 {
        return FALSE as libc::c_int;
    }
    m = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_match as libc::c_int as JSAtom);
    if JS_IsException(m) != 0 {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(m) == 0 {
        return JS_ToBoolFree(ctx, m);
    }
    return (js_get_regexp(ctx, obj, FALSE as libc::c_int)
        != 0 as *mut libc::c_void as *mut JSRegExp) as libc::c_int;
}
unsafe extern "C" fn js_regexp_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut pattern: JSValue = 0;
    let mut flags: JSValue = 0;
    let mut bc: JSValue = 0;
    let mut val: JSValue = 0;
    let mut pat: JSValue = 0;
    let mut flags1: JSValue = 0;
    let mut re: *mut JSRegExp = 0 as *mut JSRegExp;
    let mut pat_is_regexp: libc::c_int = 0;
    pat = *argv.offset(0 as libc::c_int as isize);
    flags1 = *argv.offset(1 as libc::c_int as isize);
    pat_is_regexp = js_is_regexp(ctx, pat);
    if pat_is_regexp < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsUndefined(new_target) != 0 {
        new_target = JS_GetActiveFunction(ctx);
        if pat_is_regexp != 0 && JS_IsUndefined(flags1) != 0 {
            let mut ctor: JSValue = 0;
            let mut res: BOOL = 0;
            ctor = JS_GetProperty(
                ctx,
                pat,
                JS_ATOM_constructor as libc::c_int as JSAtom,
            );
            if JS_IsException(ctor) != 0 {
                return ctor;
            }
            res = js_same_value(ctx, ctor, new_target);
            JS_FreeValue(ctx, ctor);
            if res != 0 {
                return JS_DupValue(ctx, pat);
            }
        }
    }
    re = js_get_regexp(ctx, pat, FALSE as libc::c_int);
    if !re.is_null() {
        pattern = JS_DupValue(
            ctx,
            (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*re).pattern as uintptr_t as libc::c_ulonglong,
        );
        if JS_IsUndefined(flags1) != 0 {
            bc = JS_DupValue(
                ctx,
                (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                    | (*re).bytecode as uintptr_t as libc::c_ulonglong,
            );
            current_block = 3393639170440764147;
        } else {
            flags = JS_ToString(ctx, flags1);
            if JS_IsException(flags) != 0 {
                current_block = 9096757917069992730;
            } else {
                current_block = 1345366029464561491;
            }
        }
    } else {
        flags = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        if pat_is_regexp != 0 {
            pattern = JS_GetProperty(ctx, pat, JS_ATOM_source as libc::c_int as JSAtom);
            if JS_IsException(pattern) != 0 {
                current_block = 9096757917069992730;
            } else if JS_IsUndefined(flags1) != 0 {
                flags = JS_GetProperty(ctx, pat, JS_ATOM_flags as libc::c_int as JSAtom);
                if JS_IsException(flags) != 0 {
                    current_block = 9096757917069992730;
                } else {
                    current_block = 7746103178988627676;
                }
            } else {
                flags = JS_DupValue(ctx, flags1);
                current_block = 7746103178988627676;
            }
        } else {
            pattern = JS_DupValue(ctx, pat);
            flags = JS_DupValue(ctx, flags1);
            current_block = 7746103178988627676;
        }
        match current_block {
            9096757917069992730 => {}
            _ => {
                if JS_IsUndefined(pattern) != 0 {
                    pattern = JS_AtomToString(
                        ctx,
                        JS_ATOM_empty_string as libc::c_int as JSAtom,
                    );
                    current_block = 1345366029464561491;
                } else {
                    val = pattern;
                    pattern = JS_ToString(ctx, val);
                    JS_FreeValue(ctx, val);
                    if JS_IsException(pattern) != 0 {
                        current_block = 9096757917069992730;
                    } else {
                        current_block = 1345366029464561491;
                    }
                }
            }
        }
    }
    match current_block {
        1345366029464561491 => {
            bc = js_compile_regexp(ctx, pattern, flags);
            if JS_IsException(bc) != 0 {
                current_block = 9096757917069992730;
            } else {
                JS_FreeValue(ctx, flags);
                current_block = 3393639170440764147;
            }
        }
        _ => {}
    }
    match current_block {
        3393639170440764147 => {
            return js_regexp_constructor_internal(ctx, new_target, pattern, bc);
        }
        _ => {
            JS_FreeValue(ctx, pattern);
            JS_FreeValue(ctx, flags);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    };
}
unsafe extern "C" fn js_regexp_compile(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut re1: *mut JSRegExp = 0 as *mut JSRegExp;
    let mut re: *mut JSRegExp = 0 as *mut JSRegExp;
    let mut pattern1: JSValue = 0;
    let mut flags1: JSValue = 0;
    let mut bc: JSValue = 0;
    let mut pattern: JSValue = 0;
    re = js_get_regexp(ctx, this_val, TRUE as libc::c_int);
    if re.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    pattern1 = *argv.offset(0 as libc::c_int as isize);
    flags1 = *argv.offset(1 as libc::c_int as isize);
    re1 = js_get_regexp(ctx, pattern1, FALSE as libc::c_int);
    if !re1.is_null() {
        if JS_IsUndefined(flags1) == 0 {
            return JS_ThrowTypeError(
                ctx,
                b"flags must be undefined\0" as *const u8 as *const libc::c_char,
            );
        }
        pattern = JS_DupValue(
            ctx,
            (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*re1).pattern as uintptr_t as libc::c_ulonglong,
        );
        bc = JS_DupValue(
            ctx,
            (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*re1).bytecode as uintptr_t as libc::c_ulonglong,
        );
    } else {
        bc = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        if JS_IsUndefined(pattern1) != 0 {
            pattern = JS_AtomToString(
                ctx,
                JS_ATOM_empty_string as libc::c_int as JSAtom,
            );
        } else {
            pattern = JS_ToString(ctx, pattern1);
        }
        if JS_IsException(pattern) != 0 {
            current_block = 14263084902310470070;
        } else {
            bc = js_compile_regexp(ctx, pattern, flags1);
            if JS_IsException(bc) != 0 {
                current_block = 14263084902310470070;
            } else {
                current_block = 6057473163062296781;
            }
        }
        match current_block {
            6057473163062296781 => {}
            _ => {
                JS_FreeValue(ctx, pattern);
                JS_FreeValue(ctx, bc);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    JS_FreeValue(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*re).pattern as uintptr_t as libc::c_ulonglong,
    );
    JS_FreeValue(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*re).bytecode as uintptr_t as libc::c_ulonglong,
    );
    let ref mut fresh658 = (*re).pattern;
    *fresh658 = pattern as intptr_t as *mut libc::c_void as *mut JSString;
    let ref mut fresh659 = (*re).bytecode;
    *fresh659 = bc as intptr_t as *mut libc::c_void as *mut JSString;
    if JS_SetProperty(
        ctx,
        this_val,
        JS_ATOM_lastIndex as libc::c_int as JSAtom,
        JS_NewInt32(ctx, 0 as libc::c_int),
    ) < 0 as libc::c_int
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn js_regexp_get_source(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut re: *mut JSRegExp = 0 as *mut JSRegExp;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut bra: libc::c_int = 0;
    if (this_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if !(js_same_value(
        ctx,
        this_val,
        *((*ctx).class_proto).offset(JS_CLASS_REGEXP as libc::c_int as isize),
    ) != 0)
    {
        re = js_get_regexp(ctx, this_val, TRUE as libc::c_int);
        if re.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        p = (*re).pattern;
        if !((*p).len() as libc::c_int == 0 as libc::c_int) {
            string_buffer_init2(
                ctx,
                b,
                (*p).len() as libc::c_int,
                (*p).is_wide_char() as libc::c_int,
            );
            bra = 0 as libc::c_int;
            i = 0 as libc::c_int;
            n = (*p).len() as libc::c_int;
            while i < n {
                c2 = -(1 as libc::c_int);
                let fresh660 = i;
                i = i + 1;
                c = string_get(p, fresh660);
                match c {
                    92 => {
                        if i < n {
                            let fresh661 = i;
                            i = i + 1;
                            c2 = string_get(p, fresh661);
                        }
                    }
                    93 => {
                        bra = 0 as libc::c_int;
                    }
                    91 => {
                        if bra == 0 {
                            if i < n && string_get(p, i) == ']' as i32 {
                                let fresh662 = i;
                                i = i + 1;
                                c2 = string_get(p, fresh662);
                            }
                            bra = 1 as libc::c_int;
                        }
                    }
                    10 => {
                        c = '\\' as i32;
                        c2 = 'n' as i32;
                    }
                    13 => {
                        c = '\\' as i32;
                        c2 = 'r' as i32;
                    }
                    47 => {
                        if bra == 0 {
                            c = '\\' as i32;
                            c2 = '/' as i32;
                        }
                    }
                    _ => {}
                }
                string_buffer_putc16(b, c as uint32_t);
                if c2 >= 0 as libc::c_int {
                    string_buffer_putc16(b, c2 as uint32_t);
                }
            }
            return string_buffer_end(b);
        }
    }
    return JS_NewString(ctx, b"(?:)\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn js_regexp_get_flag(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut mask: libc::c_int,
) -> JSValue {
    let mut re: *mut JSRegExp = 0 as *mut JSRegExp;
    let mut flags: libc::c_int = 0;
    if (this_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    re = js_get_regexp(ctx, this_val, FALSE as libc::c_int);
    if re.is_null() {
        if js_same_value(
            ctx,
            this_val,
            *((*ctx).class_proto).offset(JS_CLASS_REGEXP as libc::c_int as isize),
        ) != 0
        {
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong
        } else {
            return JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP as libc::c_int)
        }
    }
    flags = lre_get_flags(((*(*re).bytecode).u.str8).as_mut_ptr());
    return JS_NewBool(ctx, (flags & mask != 0 as libc::c_int) as libc::c_int);
}
unsafe extern "C" fn js_regexp_get_flags(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut str: [libc::c_char; 8] = [0; 8];
    let mut p: *mut libc::c_char = str.as_mut_ptr();
    let mut res: libc::c_int = 0;
    if (this_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    res = JS_ToBoolFree(
        ctx,
        JS_GetProperty(ctx, this_val, JS_ATOM_global as libc::c_int as JSAtom),
    );
    if !(res < 0 as libc::c_int) {
        if res != 0 {
            let fresh663 = p;
            p = p.offset(1);
            *fresh663 = 'g' as i32 as libc::c_char;
        }
        res = JS_ToBoolFree(
            ctx,
            JS_GetPropertyStr(
                ctx,
                this_val,
                b"ignoreCase\0" as *const u8 as *const libc::c_char,
            ),
        );
        if !(res < 0 as libc::c_int) {
            if res != 0 {
                let fresh664 = p;
                p = p.offset(1);
                *fresh664 = 'i' as i32 as libc::c_char;
            }
            res = JS_ToBoolFree(
                ctx,
                JS_GetPropertyStr(
                    ctx,
                    this_val,
                    b"multiline\0" as *const u8 as *const libc::c_char,
                ),
            );
            if !(res < 0 as libc::c_int) {
                if res != 0 {
                    let fresh665 = p;
                    p = p.offset(1);
                    *fresh665 = 'm' as i32 as libc::c_char;
                }
                res = JS_ToBoolFree(
                    ctx,
                    JS_GetPropertyStr(
                        ctx,
                        this_val,
                        b"dotAll\0" as *const u8 as *const libc::c_char,
                    ),
                );
                if !(res < 0 as libc::c_int) {
                    if res != 0 {
                        let fresh666 = p;
                        p = p.offset(1);
                        *fresh666 = 's' as i32 as libc::c_char;
                    }
                    res = JS_ToBoolFree(
                        ctx,
                        JS_GetProperty(
                            ctx,
                            this_val,
                            JS_ATOM_unicode as libc::c_int as JSAtom,
                        ),
                    );
                    if !(res < 0 as libc::c_int) {
                        if res != 0 {
                            let fresh667 = p;
                            p = p.offset(1);
                            *fresh667 = 'u' as i32 as libc::c_char;
                        }
                        res = JS_ToBoolFree(
                            ctx,
                            JS_GetPropertyStr(
                                ctx,
                                this_val,
                                b"sticky\0" as *const u8 as *const libc::c_char,
                            ),
                        );
                        if !(res < 0 as libc::c_int) {
                            if res != 0 {
                                let fresh668 = p;
                                p = p.offset(1);
                                *fresh668 = 'y' as i32 as libc::c_char;
                            }
                            return JS_NewStringLen(
                                ctx,
                                str.as_mut_ptr(),
                                p.offset_from(str.as_mut_ptr()) as libc::c_long as size_t,
                            );
                        }
                    }
                }
            }
        }
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_regexp_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut pattern: JSValue = 0;
    let mut flags: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if JS_IsObject(this_val) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    string_buffer_putc8(b, '/' as i32 as uint32_t);
    pattern = JS_GetProperty(ctx, this_val, JS_ATOM_source as libc::c_int as JSAtom);
    if !(string_buffer_concat_value_free(b, pattern) != 0) {
        string_buffer_putc8(b, '/' as i32 as uint32_t);
        flags = JS_GetProperty(ctx, this_val, JS_ATOM_flags as libc::c_int as JSAtom);
        if !(string_buffer_concat_value_free(b, flags) != 0) {
            return string_buffer_end(b);
        }
    }
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn lre_check_stack_overflow(
    mut opaque: *mut libc::c_void,
    mut alloca_size: size_t,
) -> libc::c_int {
    let mut ctx: *mut JSContext = opaque as *mut JSContext;
    return js_check_stack_overflow((*ctx).rt, alloca_size);
}
#[no_mangle]
pub unsafe extern "C" fn lre_realloc(
    mut opaque: *mut libc::c_void,
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    let mut ctx: *mut JSContext = opaque as *mut JSContext;
    return js_realloc_rt((*ctx).rt, ptr, size);
}
unsafe extern "C" fn js_regexp_exec(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut re: *mut JSRegExp = js_get_regexp(ctx, this_val, TRUE as libc::c_int);
    let mut str: *mut JSString = 0 as *mut JSString;
    let mut str_val: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut val: JSValue = 0;
    let mut groups: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut re_bytecode: *mut uint8_t = 0 as *mut uint8_t;
    let mut ret: libc::c_int = 0;
    let mut capture: *mut *mut uint8_t = 0 as *mut *mut uint8_t;
    let mut str_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut capture_count: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut re_flags: libc::c_int = 0;
    let mut last_index: int64_t = 0;
    let mut group_name_ptr: *const libc::c_char = 0 as *const libc::c_char;
    if re.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    str_val = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str_val) != 0 {
        return str_val;
    }
    val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex as libc::c_int as JSAtom);
    if JS_IsException(val) != 0 || JS_ToLengthFree(ctx, &mut last_index, val) != 0 {
        JS_FreeValue(ctx, str_val);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    re_bytecode = ((*(*re).bytecode).u.str8).as_mut_ptr();
    re_flags = lre_get_flags(re_bytecode);
    if re_flags
        & ((1 as libc::c_int) << 0 as libc::c_int
            | (1 as libc::c_int) << 5 as libc::c_int) == 0 as libc::c_int
    {
        last_index = 0 as libc::c_int as int64_t;
    }
    str = str_val as intptr_t as *mut libc::c_void as *mut JSString;
    capture_count = lre_get_capture_count(re_bytecode);
    capture = 0 as *mut *mut uint8_t;
    if capture_count > 0 as libc::c_int {
        capture = js_malloc(
            ctx,
            (::core::mem::size_of::<*mut uint8_t>() as libc::c_ulong)
                .wrapping_mul(capture_count as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong),
        ) as *mut *mut uint8_t;
        if capture.is_null() {
            JS_FreeValue(ctx, str_val);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    shift = (*str).is_wide_char() as libc::c_int;
    str_buf = ((*str).u.str8).as_mut_ptr();
    if last_index > (*str).len() as libc::c_longlong {
        ret = 2 as libc::c_int;
    } else {
        ret = lre_exec(
            capture,
            re_bytecode,
            str_buf,
            last_index as libc::c_int,
            (*str).len() as libc::c_int,
            shift,
            ctx as *mut libc::c_void,
        );
    }
    obj = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if ret != 1 as libc::c_int {
        if ret >= 0 as libc::c_int {
            if ret == 2 as libc::c_int
                || re_flags
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 5 as libc::c_int) != 0
            {
                if JS_SetProperty(
                    ctx,
                    this_val,
                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                    JS_NewInt32(ctx, 0 as libc::c_int),
                ) < 0 as libc::c_int
                {
                    current_block = 15430662215273938114;
                } else {
                    current_block = 6450597802325118133;
                }
            } else {
                current_block = 6450597802325118133;
            }
            match current_block {
                15430662215273938114 => {}
                _ => {
                    JS_FreeValue(ctx, str_val);
                    current_block = 3736434875406665187;
                }
            }
        } else {
            JS_ThrowInternalError(
                ctx,
                b"out of memory in regexp execution\0" as *const u8
                    as *const libc::c_char,
            );
            current_block = 15430662215273938114;
        }
    } else {
        let mut prop_flags: libc::c_int = 0;
        if re_flags
            & ((1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 5 as libc::c_int) != 0
        {
            if JS_SetProperty(
                ctx,
                this_val,
                JS_ATOM_lastIndex as libc::c_int as JSAtom,
                JS_NewInt32(
                    ctx,
                    ((*capture.offset(1 as libc::c_int as isize)).offset_from(str_buf)
                        as libc::c_long >> shift) as int32_t,
                ),
            ) < 0 as libc::c_int
            {
                current_block = 15430662215273938114;
            } else {
                current_block = 9441801433784995173;
            }
        } else {
            current_block = 9441801433784995173;
        }
        match current_block {
            15430662215273938114 => {}
            _ => {
                obj = JS_NewArray(ctx);
                if JS_IsException(obj) != 0 {
                    current_block = 15430662215273938114;
                } else {
                    prop_flags = (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int
                        | (1 as libc::c_int) << 14 as libc::c_int;
                    group_name_ptr = lre_get_groupnames(re_bytecode);
                    if !group_name_ptr.is_null() {
                        groups = JS_NewObjectProto(
                            ctx,
                            (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        );
                        if JS_IsException(groups) != 0 {
                            current_block = 15430662215273938114;
                        } else {
                            current_block = 5892776923941496671;
                        }
                    } else {
                        current_block = 5892776923941496671;
                    }
                    match current_block {
                        15430662215273938114 => {}
                        _ => {
                            i = 0 as libc::c_int;
                            loop {
                                if !(i < capture_count) {
                                    current_block = 13853033528615664019;
                                    break;
                                }
                                let mut start: libc::c_int = 0;
                                let mut end: libc::c_int = 0;
                                let mut val_0: JSValue = 0;
                                if (*capture.offset((2 as libc::c_int * i) as isize))
                                    .is_null()
                                    || (*capture
                                        .offset((2 as libc::c_int * i + 1 as libc::c_int) as isize))
                                        .is_null()
                                {
                                    val_0 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                } else {
                                    start = ((*capture.offset((2 as libc::c_int * i) as isize))
                                        .offset_from(str_buf) as libc::c_long >> shift)
                                        as libc::c_int;
                                    end = ((*capture
                                        .offset((2 as libc::c_int * i + 1 as libc::c_int) as isize))
                                        .offset_from(str_buf) as libc::c_long >> shift)
                                        as libc::c_int;
                                    val_0 = js_sub_string(ctx, str, start, end);
                                    if JS_IsException(val_0) != 0 {
                                        current_block = 15430662215273938114;
                                        break;
                                    }
                                }
                                if !group_name_ptr.is_null() && i > 0 as libc::c_int {
                                    if *group_name_ptr != 0 {
                                        if JS_DefinePropertyValueStr(
                                            ctx,
                                            groups,
                                            group_name_ptr,
                                            JS_DupValue(ctx, val_0),
                                            prop_flags,
                                        ) < 0 as libc::c_int
                                        {
                                            JS_FreeValue(ctx, val_0);
                                            current_block = 15430662215273938114;
                                            break;
                                        }
                                    }
                                    group_name_ptr = group_name_ptr
                                        .offset(
                                            (strlen(group_name_ptr))
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                        );
                                }
                                if JS_DefinePropertyValueUint32(
                                    ctx,
                                    obj,
                                    i as uint32_t,
                                    val_0,
                                    prop_flags,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 15430662215273938114;
                                    break;
                                }
                                i += 1;
                            }
                            match current_block {
                                15430662215273938114 => {}
                                _ => {
                                    if JS_DefinePropertyValue(
                                        ctx,
                                        obj,
                                        JS_ATOM_groups as libc::c_int as JSAtom,
                                        groups,
                                        prop_flags,
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 15430662215273938114;
                                    } else if JS_DefinePropertyValue(
                                        ctx,
                                        obj,
                                        JS_ATOM_index as libc::c_int as JSAtom,
                                        JS_NewInt32(
                                            ctx,
                                            ((*capture.offset(0 as libc::c_int as isize))
                                                .offset_from(str_buf) as libc::c_long >> shift) as int32_t,
                                        ),
                                        prop_flags,
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 15430662215273938114;
                                    } else if JS_DefinePropertyValue(
                                        ctx,
                                        obj,
                                        JS_ATOM_input as libc::c_int as JSAtom,
                                        str_val,
                                        prop_flags,
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 869742251437531643;
                                    } else {
                                        current_block = 3736434875406665187;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        3736434875406665187 => {
            js_free(ctx, capture as *mut libc::c_void);
            return obj;
        }
        15430662215273938114 => {
            JS_FreeValue(ctx, groups);
            JS_FreeValue(ctx, str_val);
        }
        _ => {}
    }
    JS_FreeValue(ctx, obj);
    js_free(ctx, capture as *mut libc::c_void);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_RegExpDelete(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut arg: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut re: *mut JSRegExp = js_get_regexp(ctx, this_val, TRUE as libc::c_int);
    let mut str: *mut JSString = 0 as *mut JSString;
    let mut str_val: JSValue = 0;
    let mut val: JSValue = 0;
    let mut re_bytecode: *mut uint8_t = 0 as *mut uint8_t;
    let mut ret: libc::c_int = 0;
    let mut capture: *mut *mut uint8_t = 0 as *mut *mut uint8_t;
    let mut str_buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut capture_count: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    let mut re_flags: libc::c_int = 0;
    let mut next_src_pos: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut end: libc::c_int = 0;
    let mut last_index: int64_t = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    if re.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    capture = 0 as *mut *mut uint8_t;
    str_val = JS_ToString(ctx, arg);
    if !(JS_IsException(str_val) != 0) {
        str = str_val as intptr_t as *mut libc::c_void as *mut JSString;
        re_bytecode = ((*(*re).bytecode).u.str8).as_mut_ptr();
        re_flags = lre_get_flags(re_bytecode);
        if re_flags
            & ((1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 5 as libc::c_int) == 0 as libc::c_int
        {
            last_index = 0 as libc::c_int as int64_t;
            current_block = 6057473163062296781;
        } else {
            val = JS_GetProperty(
                ctx,
                this_val,
                JS_ATOM_lastIndex as libc::c_int as JSAtom,
            );
            if JS_IsException(val) != 0
                || JS_ToLengthFree(ctx, &mut last_index, val) != 0
            {
                current_block = 7861046860455062086;
            } else {
                current_block = 6057473163062296781;
            }
        }
        match current_block {
            7861046860455062086 => {}
            _ => {
                capture_count = lre_get_capture_count(re_bytecode);
                if capture_count > 0 as libc::c_int {
                    capture = js_malloc(
                        ctx,
                        (::core::mem::size_of::<*mut uint8_t>() as libc::c_ulong)
                            .wrapping_mul(capture_count as libc::c_ulong)
                            .wrapping_mul(2 as libc::c_int as libc::c_ulong),
                    ) as *mut *mut uint8_t;
                    if capture.is_null() {
                        current_block = 7861046860455062086;
                    } else {
                        current_block = 5634871135123216486;
                    }
                } else {
                    current_block = 5634871135123216486;
                }
                match current_block {
                    7861046860455062086 => {}
                    _ => {
                        shift = (*str).is_wide_char() as libc::c_int;
                        str_buf = ((*str).u.str8).as_mut_ptr();
                        next_src_pos = 0 as libc::c_int;
                        loop {
                            if last_index > (*str).len() as libc::c_longlong {
                                current_block = 7018308795614528254;
                                break;
                            }
                            ret = lre_exec(
                                capture,
                                re_bytecode,
                                str_buf,
                                last_index as libc::c_int,
                                (*str).len() as libc::c_int,
                                shift,
                                ctx as *mut libc::c_void,
                            );
                            if ret != 1 as libc::c_int {
                                if ret >= 0 as libc::c_int {
                                    if !(ret == 2 as libc::c_int
                                        || re_flags
                                            & ((1 as libc::c_int) << 0 as libc::c_int
                                                | (1 as libc::c_int) << 5 as libc::c_int) != 0)
                                    {
                                        current_block = 7018308795614528254;
                                        break;
                                    }
                                    if JS_SetProperty(
                                        ctx,
                                        this_val,
                                        JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                        JS_NewInt32(ctx, 0 as libc::c_int),
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 7861046860455062086;
                                        break;
                                    } else {
                                        current_block = 7018308795614528254;
                                        break;
                                    }
                                } else {
                                    JS_ThrowInternalError(
                                        ctx,
                                        b"out of memory in regexp execution\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    current_block = 7861046860455062086;
                                    break;
                                }
                            } else {
                                start = ((*capture.offset(0 as libc::c_int as isize))
                                    .offset_from(str_buf) as libc::c_long >> shift)
                                    as libc::c_int;
                                end = ((*capture.offset(1 as libc::c_int as isize))
                                    .offset_from(str_buf) as libc::c_long >> shift)
                                    as libc::c_int;
                                last_index = end as int64_t;
                                if next_src_pos < start {
                                    if string_buffer_concat(
                                        b,
                                        str,
                                        next_src_pos as uint32_t,
                                        start as uint32_t,
                                    ) != 0
                                    {
                                        current_block = 7861046860455062086;
                                        break;
                                    }
                                }
                                next_src_pos = end;
                                if re_flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                                    if JS_SetProperty(
                                        ctx,
                                        this_val,
                                        JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                        JS_NewInt32(ctx, end),
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 7861046860455062086;
                                        break;
                                    } else {
                                        current_block = 7018308795614528254;
                                        break;
                                    }
                                } else {
                                    if end == start {
                                        if re_flags & (1 as libc::c_int) << 4 as libc::c_int == 0
                                            || end as libc::c_uint >= (*str).len()
                                            || (*str).is_wide_char() == 0
                                        {
                                            end += 1;
                                        } else {
                                            string_getc(str, &mut end);
                                        }
                                    }
                                    last_index = end as int64_t;
                                }
                            }
                        }
                        match current_block {
                            7861046860455062086 => {}
                            _ => {
                                if !(string_buffer_concat(
                                    b,
                                    str,
                                    next_src_pos as uint32_t,
                                    (*str).len(),
                                ) != 0)
                                {
                                    JS_FreeValue(ctx, str_val);
                                    js_free(ctx, capture as *mut libc::c_void);
                                    return string_buffer_end(b);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, str_val);
    js_free(ctx, capture as *mut libc::c_void);
    string_buffer_free(b);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn JS_RegExpExec(
    mut ctx: *mut JSContext,
    mut r: JSValue,
    mut s: JSValue,
) -> JSValue {
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    method = JS_GetProperty(ctx, r, JS_ATOM_exec as libc::c_int as JSAtom);
    if JS_IsException(method) != 0 {
        return method;
    }
    if JS_IsFunction(ctx, method) != 0 {
        ret = JS_CallFree(ctx, method, r, 1 as libc::c_int, &mut s);
        if JS_IsException(ret) != 0 {
            return ret;
        }
        if JS_IsObject(ret) == 0 && JS_IsNull(ret) == 0 {
            JS_FreeValue(ctx, ret);
            return JS_ThrowTypeError(
                ctx,
                b"RegExp exec method must return an object or null\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return ret;
    }
    JS_FreeValue(ctx, method);
    return js_regexp_exec(ctx, r, 1 as libc::c_int, &mut s);
}
unsafe extern "C" fn js_regexp_test(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: BOOL = 0;
    val = JS_RegExpExec(ctx, this_val, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = (JS_IsNull(val) == 0) as libc::c_int;
    JS_FreeValue(ctx, val);
    return JS_NewBool(ctx, ret);
}
unsafe extern "C" fn js_regexp_Symbol_match(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut rx: JSValue = this_val;
    let mut A: JSValue = 0;
    let mut S: JSValue = 0;
    let mut result: JSValue = 0;
    let mut matchStr: JSValue = 0;
    let mut global: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut fullUnicode: libc::c_int = 0;
    let mut isEmpty: libc::c_int = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    if JS_IsObject(rx) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    A = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    result = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    matchStr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    S = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(S) != 0) {
        global = JS_ToBoolFree(
            ctx,
            JS_GetProperty(ctx, rx, JS_ATOM_global as libc::c_int as JSAtom),
        );
        if !(global < 0 as libc::c_int) {
            if global == 0 {
                A = JS_RegExpExec(ctx, rx, S);
                current_block = 9007357115414505193;
            } else {
                fullUnicode = JS_ToBoolFree(
                    ctx,
                    JS_GetProperty(ctx, rx, JS_ATOM_unicode as libc::c_int as JSAtom),
                );
                if fullUnicode < 0 as libc::c_int {
                    current_block = 16598072006681698261;
                } else if JS_SetProperty(
                    ctx,
                    rx,
                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                    JS_NewInt32(ctx, 0 as libc::c_int),
                ) < 0 as libc::c_int
                {
                    current_block = 16598072006681698261;
                } else {
                    A = JS_NewArray(ctx);
                    if JS_IsException(A) != 0 {
                        current_block = 16598072006681698261;
                    } else {
                        n = 0 as libc::c_int;
                        loop {
                            JS_FreeValue(ctx, result);
                            result = JS_RegExpExec(ctx, rx, S);
                            if JS_IsException(result) != 0 {
                                current_block = 16598072006681698261;
                                break;
                            }
                            if JS_IsNull(result) != 0 {
                                current_block = 2873832966593178012;
                                break;
                            }
                            matchStr = JS_ToStringFree(
                                ctx,
                                JS_GetPropertyInt64(
                                    ctx,
                                    result,
                                    0 as libc::c_int as int64_t,
                                ),
                            );
                            if JS_IsException(matchStr) != 0 {
                                current_block = 16598072006681698261;
                                break;
                            }
                            isEmpty = JS_IsEmptyString(matchStr);
                            let fresh669 = n;
                            n = n + 1;
                            if JS_SetPropertyInt64(ctx, A, fresh669 as int64_t, matchStr)
                                < 0 as libc::c_int
                            {
                                current_block = 16598072006681698261;
                                break;
                            }
                            if !(isEmpty != 0) {
                                continue;
                            }
                            let mut thisIndex: int64_t = 0;
                            let mut nextIndex: int64_t = 0;
                            if JS_ToLengthFree(
                                ctx,
                                &mut thisIndex,
                                JS_GetProperty(
                                    ctx,
                                    rx,
                                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                ),
                            ) < 0 as libc::c_int
                            {
                                current_block = 16598072006681698261;
                                break;
                            }
                            p = S as intptr_t as *mut libc::c_void as *mut JSString;
                            nextIndex = string_advance_index(p, thisIndex, fullUnicode);
                            if JS_SetProperty(
                                ctx,
                                rx,
                                JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                JS_NewInt64(ctx, nextIndex),
                            ) < 0 as libc::c_int
                            {
                                current_block = 16598072006681698261;
                                break;
                            }
                        }
                        match current_block {
                            16598072006681698261 => {}
                            _ => {
                                if n == 0 as libc::c_int {
                                    JS_FreeValue(ctx, A);
                                    A = (JS_TAG_NULL as libc::c_int as uint64_t)
                                        << 32 as libc::c_int
                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                }
                                current_block = 9007357115414505193;
                            }
                        }
                    }
                }
            }
            match current_block {
                16598072006681698261 => {}
                _ => {
                    JS_FreeValue(ctx, result);
                    JS_FreeValue(ctx, S);
                    return A;
                }
            }
        }
    }
    JS_FreeValue(ctx, A);
    JS_FreeValue(ctx, result);
    JS_FreeValue(ctx, S);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_regexp_string_iterator_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSRegExpStringIteratorData = (*p).u.regexp_string_iterator_data;
    if !it.is_null() {
        JS_FreeValueRT(rt, (*it).iterating_regexp);
        JS_FreeValueRT(rt, (*it).iterated_string);
        js_free_rt(rt, it as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_regexp_string_iterator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSRegExpStringIteratorData = (*p).u.regexp_string_iterator_data;
    if !it.is_null() {
        JS_MarkValue(rt, (*it).iterating_regexp, mark_func);
        JS_MarkValue(rt, (*it).iterated_string, mark_func);
    }
}
unsafe extern "C" fn js_regexp_string_iterator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut it: *mut JSRegExpStringIteratorData = 0 as *mut JSRegExpStringIteratorData;
    let mut R: JSValue = 0;
    let mut S: JSValue = 0;
    let mut matchStr: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut match_0: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut sp: *mut JSString = 0 as *mut JSString;
    it = JS_GetOpaque2(
        ctx,
        this_val,
        JS_CLASS_REGEXP_STRING_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSRegExpStringIteratorData;
    if !it.is_null() {
        if (*it).done != 0 {
            *pdone = TRUE as libc::c_int;
            return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        R = (*it).iterating_regexp;
        S = (*it).iterated_string;
        match_0 = JS_RegExpExec(ctx, R, S);
        if !(JS_IsException(match_0) != 0) {
            if JS_IsNull(match_0) != 0 {
                (*it).done = TRUE as libc::c_int;
                *pdone = TRUE as libc::c_int;
                return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                if (*it).global != 0 {
                    matchStr = JS_ToStringFree(
                        ctx,
                        JS_GetPropertyInt64(ctx, match_0, 0 as libc::c_int as int64_t),
                    );
                    if JS_IsException(matchStr) != 0 {
                        current_block = 3693554349894293148;
                    } else {
                        if JS_IsEmptyString(matchStr) != 0 {
                            let mut thisIndex: int64_t = 0;
                            let mut nextIndex: int64_t = 0;
                            if JS_ToLengthFree(
                                ctx,
                                &mut thisIndex,
                                JS_GetProperty(
                                    ctx,
                                    R,
                                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                ),
                            ) < 0 as libc::c_int
                            {
                                current_block = 3693554349894293148;
                            } else {
                                sp = S as intptr_t as *mut libc::c_void as *mut JSString;
                                nextIndex = string_advance_index(
                                    sp,
                                    thisIndex,
                                    (*it).unicode,
                                );
                                if JS_SetProperty(
                                    ctx,
                                    R,
                                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                    JS_NewInt64(ctx, nextIndex),
                                ) < 0 as libc::c_int
                                {
                                    current_block = 3693554349894293148;
                                } else {
                                    current_block = 11298138898191919651;
                                }
                            }
                        } else {
                            current_block = 11298138898191919651;
                        }
                        match current_block {
                            3693554349894293148 => {}
                            _ => {
                                JS_FreeValue(ctx, matchStr);
                                current_block = 14818589718467733107;
                            }
                        }
                    }
                } else {
                    (*it).done = TRUE as libc::c_int;
                    current_block = 14818589718467733107;
                }
                match current_block {
                    3693554349894293148 => {}
                    _ => {
                        *pdone = FALSE as libc::c_int;
                        return match_0;
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, match_0);
    JS_FreeValue(ctx, matchStr);
    *pdone = FALSE as libc::c_int;
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_regexp_Symbol_matchAll(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut R: JSValue = this_val;
    let mut S: JSValue = 0;
    let mut C: JSValue = 0;
    let mut flags: JSValue = 0;
    let mut matcher: JSValue = 0;
    let mut iter: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut strp: *mut JSString = 0 as *mut JSString;
    let mut lastIndex: int64_t = 0;
    let mut it: *mut JSRegExpStringIteratorData = 0 as *mut JSRegExpStringIteratorData;
    if JS_IsObject(R) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    C = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    flags = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    matcher = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    iter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    S = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(S) != 0) {
        C = JS_SpeciesConstructor(ctx, R, (*ctx).regexp_ctor);
        if !(JS_IsException(C) != 0) {
            flags = JS_ToStringFree(
                ctx,
                JS_GetProperty(ctx, R, JS_ATOM_flags as libc::c_int as JSAtom),
            );
            if !(JS_IsException(flags) != 0) {
                args[0 as libc::c_int as usize] = R;
                args[1 as libc::c_int as usize] = flags;
                matcher = JS_CallConstructor(
                    ctx,
                    C,
                    2 as libc::c_int,
                    args.as_mut_ptr(),
                );
                if !(JS_IsException(matcher) != 0) {
                    if !(JS_ToLengthFree(
                        ctx,
                        &mut lastIndex,
                        JS_GetProperty(
                            ctx,
                            R,
                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                        ),
                    ) != 0)
                    {
                        if !(JS_SetProperty(
                            ctx,
                            matcher,
                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                            JS_NewInt64(ctx, lastIndex),
                        ) < 0 as libc::c_int)
                        {
                            iter = JS_NewObjectClass(
                                ctx,
                                JS_CLASS_REGEXP_STRING_ITERATOR as libc::c_int,
                            );
                            if !(JS_IsException(iter) != 0) {
                                it = js_malloc(
                                    ctx,
                                    ::core::mem::size_of::<JSRegExpStringIteratorData>()
                                        as libc::c_ulong,
                                ) as *mut JSRegExpStringIteratorData;
                                if !it.is_null() {
                                    (*it).iterating_regexp = matcher;
                                    (*it).iterated_string = S;
                                    strp = flags as intptr_t as *mut libc::c_void
                                        as *mut JSString;
                                    (*it)
                                        .global = (string_indexof_char(
                                        strp,
                                        'g' as i32,
                                        0 as libc::c_int,
                                    ) >= 0 as libc::c_int) as libc::c_int;
                                    (*it)
                                        .unicode = (string_indexof_char(
                                        strp,
                                        'u' as i32,
                                        0 as libc::c_int,
                                    ) >= 0 as libc::c_int) as libc::c_int;
                                    (*it).done = FALSE as libc::c_int;
                                    JS_SetOpaque(iter, it as *mut libc::c_void);
                                    JS_FreeValue(ctx, C);
                                    JS_FreeValue(ctx, flags);
                                    return iter;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, S);
    JS_FreeValue(ctx, C);
    JS_FreeValue(ctx, flags);
    JS_FreeValue(ctx, matcher);
    JS_FreeValue(ctx, iter);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn value_buffer_init(
    mut ctx: *mut JSContext,
    mut b: *mut ValueBuffer,
) -> libc::c_int {
    let ref mut fresh670 = (*b).ctx;
    *fresh670 = ctx;
    (*b).len = 0 as libc::c_int;
    (*b).size = 4 as libc::c_int;
    (*b).error_status = 0 as libc::c_int;
    let ref mut fresh671 = (*b).arr;
    *fresh671 = ((*b).def).as_mut_ptr();
    return 0 as libc::c_int;
}
unsafe extern "C" fn value_buffer_free(mut b: *mut ValueBuffer) {
    while (*b).len > 0 as libc::c_int {
        let ref mut fresh672 = (*b).len;
        *fresh672 -= 1;
        JS_FreeValue((*b).ctx, *((*b).arr).offset(*fresh672 as isize));
    }
    if (*b).arr != ((*b).def).as_mut_ptr() {
        js_free((*b).ctx, (*b).arr as *mut libc::c_void);
    }
    let ref mut fresh673 = (*b).arr;
    *fresh673 = ((*b).def).as_mut_ptr();
    (*b).size = 4 as libc::c_int;
}
unsafe extern "C" fn value_buffer_append(
    mut b: *mut ValueBuffer,
    mut val: JSValue,
) -> libc::c_int {
    if (*b).error_status != 0 {
        return -(1 as libc::c_int);
    }
    if (*b).len >= (*b).size {
        let mut new_size: libc::c_int = (*b).len + ((*b).len >> 1 as libc::c_int)
            + 31 as libc::c_int & !(16 as libc::c_int);
        let mut slack: size_t = 0;
        let mut new_arr: *mut JSValue = 0 as *mut JSValue;
        if (*b).arr == ((*b).def).as_mut_ptr() {
            new_arr = js_realloc2(
                (*b).ctx,
                0 as *mut libc::c_void,
                (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                    .wrapping_mul(new_size as libc::c_ulong),
                &mut slack,
            ) as *mut JSValue;
            if !new_arr.is_null() {
                memcpy(
                    new_arr as *mut libc::c_void,
                    ((*b).def).as_mut_ptr() as *const libc::c_void,
                    ::core::mem::size_of::<[JSValue; 4]>() as libc::c_ulong,
                );
            }
        } else {
            new_arr = js_realloc2(
                (*b).ctx,
                (*b).arr as *mut libc::c_void,
                (::core::mem::size_of::<JSValue>() as libc::c_ulong)
                    .wrapping_mul(new_size as libc::c_ulong),
                &mut slack,
            ) as *mut JSValue;
        }
        if new_arr.is_null() {
            value_buffer_free(b);
            JS_FreeValue((*b).ctx, val);
            (*b).error_status = -(1 as libc::c_int);
            return -(1 as libc::c_int);
        }
        new_size = (new_size as libc::c_ulong)
            .wrapping_add(
                slack.wrapping_div(::core::mem::size_of::<JSValue>() as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
        let ref mut fresh674 = (*b).arr;
        *fresh674 = new_arr;
        (*b).size = new_size;
    }
    let ref mut fresh675 = (*b).len;
    let fresh676 = *fresh675;
    *fresh675 = *fresh675 + 1;
    *((*b).arr).offset(fresh676 as isize) = val;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_is_standard_regexp(
    mut ctx: *mut JSContext,
    mut rx: JSValue,
) -> libc::c_int {
    let mut val: JSValue = 0;
    let mut res: libc::c_int = 0;
    val = JS_GetProperty(ctx, rx, JS_ATOM_constructor as libc::c_int as JSAtom);
    if JS_IsException(val) != 0 {
        return -(1 as libc::c_int);
    }
    res = js_same_value(ctx, val, (*ctx).regexp_ctor);
    JS_FreeValue(ctx, val);
    if res != 0 {
        val = JS_GetProperty(ctx, rx, JS_ATOM_exec as libc::c_int as JSAtom);
        if JS_IsException(val) != 0 {
            return -(1 as libc::c_int);
        }
        res = JS_IsCFunction(
            ctx,
            val,
            Some(
                js_regexp_exec
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            0 as libc::c_int,
        );
        JS_FreeValue(ctx, val);
    }
    return res;
}
unsafe extern "C" fn js_regexp_Symbol_replace(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut rx: JSValue = this_val;
    let mut rep: JSValue = *argv.offset(1 as libc::c_int as isize);
    let mut args: [JSValue; 6] = [0; 6];
    let mut str: JSValue = 0;
    let mut rep_val: JSValue = 0;
    let mut matched: JSValue = 0;
    let mut tab: JSValue = 0;
    let mut rep_str: JSValue = 0;
    let mut namedCaptures: JSValue = 0;
    let mut res: JSValue = 0;
    let mut sp: *mut JSString = 0 as *mut JSString;
    let mut rp: *mut JSString = 0 as *mut JSString;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut v_b: ValueBuffer = ValueBuffer {
        ctx: 0 as *mut JSContext,
        arr: 0 as *mut JSValue,
        def: [0; 4],
        len: 0,
        size: 0,
        error_status: 0,
    };
    let mut results: *mut ValueBuffer = &mut v_b;
    let mut nextSourcePosition: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut functionalReplace: libc::c_int = 0;
    let mut is_global: libc::c_int = 0;
    let mut fullUnicode: libc::c_int = 0;
    let mut nCaptures: uint32_t = 0;
    let mut position: int64_t = 0;
    if JS_IsObject(rx) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    value_buffer_init(ctx, results);
    rep_val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    matched = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    tab = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    rep_str = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    namedCaptures = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        current_block = 5634495352082367803;
    } else {
        sp = str as intptr_t as *mut libc::c_void as *mut JSString;
        rp = 0 as *mut JSString;
        functionalReplace = JS_IsFunction(ctx, rep);
        if functionalReplace == 0 {
            rep_val = JS_ToString(ctx, rep);
            if JS_IsException(rep_val) != 0 {
                current_block = 5634495352082367803;
            } else {
                rp = rep_val as intptr_t as *mut libc::c_void as *mut JSString;
                current_block = 5601891728916014340;
            }
        } else {
            current_block = 5601891728916014340;
        }
        match current_block {
            5634495352082367803 => {}
            _ => {
                fullUnicode = 0 as libc::c_int;
                is_global = JS_ToBoolFree(
                    ctx,
                    JS_GetProperty(ctx, rx, JS_ATOM_global as libc::c_int as JSAtom),
                );
                if is_global < 0 as libc::c_int {
                    current_block = 5634495352082367803;
                } else {
                    if is_global != 0 {
                        fullUnicode = JS_ToBoolFree(
                            ctx,
                            JS_GetProperty(
                                ctx,
                                rx,
                                JS_ATOM_unicode as libc::c_int as JSAtom,
                            ),
                        );
                        if fullUnicode < 0 as libc::c_int {
                            current_block = 5634495352082367803;
                        } else if JS_SetProperty(
                            ctx,
                            rx,
                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                            JS_NewInt32(ctx, 0 as libc::c_int),
                        ) < 0 as libc::c_int
                        {
                            current_block = 5634495352082367803;
                        } else {
                            current_block = 14359455889292382949;
                        }
                    } else {
                        current_block = 14359455889292382949;
                    }
                    match current_block {
                        5634495352082367803 => {}
                        _ => {
                            if !rp.is_null()
                                && (*rp).len() as libc::c_int == 0 as libc::c_int
                                && is_global != 0 && js_is_standard_regexp(ctx, rx) != 0
                            {
                                res = JS_RegExpDelete(ctx, rx, str);
                                current_block = 10273590682397269289;
                            } else {
                                loop {
                                    let mut result: JSValue = 0;
                                    result = JS_RegExpExec(ctx, rx, str);
                                    if JS_IsException(result) != 0 {
                                        current_block = 5634495352082367803;
                                        break;
                                    }
                                    if JS_IsNull(result) != 0 {
                                        current_block = 12497913735442871383;
                                        break;
                                    }
                                    if value_buffer_append(results, result) < 0 as libc::c_int {
                                        current_block = 5634495352082367803;
                                        break;
                                    }
                                    if is_global == 0 {
                                        current_block = 12497913735442871383;
                                        break;
                                    }
                                    JS_FreeValue(ctx, matched);
                                    matched = JS_ToStringFree(
                                        ctx,
                                        JS_GetPropertyInt64(
                                            ctx,
                                            result,
                                            0 as libc::c_int as int64_t,
                                        ),
                                    );
                                    if JS_IsException(matched) != 0 {
                                        current_block = 5634495352082367803;
                                        break;
                                    }
                                    if !(JS_IsEmptyString(matched) != 0) {
                                        continue;
                                    }
                                    let mut thisIndex: int64_t = 0;
                                    let mut nextIndex: int64_t = 0;
                                    if JS_ToLengthFree(
                                        ctx,
                                        &mut thisIndex,
                                        JS_GetProperty(
                                            ctx,
                                            rx,
                                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                        ),
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 5634495352082367803;
                                        break;
                                    }
                                    nextIndex = string_advance_index(
                                        sp,
                                        thisIndex,
                                        fullUnicode,
                                    );
                                    if JS_SetProperty(
                                        ctx,
                                        rx,
                                        JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                        JS_NewInt64(ctx, nextIndex),
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 5634495352082367803;
                                        break;
                                    }
                                }
                                match current_block {
                                    5634495352082367803 => {}
                                    _ => {
                                        nextSourcePosition = 0 as libc::c_int;
                                        j = 0 as libc::c_int;
                                        's_248: loop {
                                            if !(j < (*results).len) {
                                                current_block = 5409161009579131794;
                                                break;
                                            }
                                            let mut result_0: JSValue = 0;
                                            result_0 = *((*results).arr).offset(j as isize);
                                            if js_get_length32(ctx, &mut nCaptures, result_0)
                                                < 0 as libc::c_int
                                            {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            JS_FreeValue(ctx, matched);
                                            matched = JS_ToStringFree(
                                                ctx,
                                                JS_GetPropertyInt64(
                                                    ctx,
                                                    result_0,
                                                    0 as libc::c_int as int64_t,
                                                ),
                                            );
                                            if JS_IsException(matched) != 0 {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            if JS_ToLengthFree(
                                                ctx,
                                                &mut position,
                                                JS_GetProperty(
                                                    ctx,
                                                    result_0,
                                                    JS_ATOM_index as libc::c_int as JSAtom,
                                                ),
                                            ) != 0
                                            {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            if position > (*sp).len() as libc::c_longlong {
                                                position = (*sp).len() as int64_t;
                                            } else if position < 0 as libc::c_int as libc::c_longlong {
                                                position = 0 as libc::c_int as int64_t;
                                            }
                                            JS_FreeValue(ctx, tab);
                                            tab = JS_NewArray(ctx);
                                            if JS_IsException(tab) != 0 {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            if JS_DefinePropertyValueInt64(
                                                ctx,
                                                tab,
                                                0 as libc::c_int as int64_t,
                                                JS_DupValue(ctx, matched),
                                                (1 as libc::c_int) << 0 as libc::c_int
                                                    | (1 as libc::c_int) << 1 as libc::c_int
                                                    | (1 as libc::c_int) << 2 as libc::c_int
                                                    | (1 as libc::c_int) << 14 as libc::c_int,
                                            ) < 0 as libc::c_int
                                            {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            n = 1 as libc::c_int;
                                            while (n as libc::c_uint) < nCaptures {
                                                let mut capN: JSValue = 0;
                                                capN = JS_GetPropertyInt64(ctx, result_0, n as int64_t);
                                                if JS_IsException(capN) != 0 {
                                                    current_block = 5634495352082367803;
                                                    break 's_248;
                                                }
                                                if JS_IsUndefined(capN) == 0 {
                                                    capN = JS_ToStringFree(ctx, capN);
                                                    if JS_IsException(capN) != 0 {
                                                        current_block = 5634495352082367803;
                                                        break 's_248;
                                                    }
                                                }
                                                if JS_DefinePropertyValueInt64(
                                                    ctx,
                                                    tab,
                                                    n as int64_t,
                                                    capN,
                                                    (1 as libc::c_int) << 0 as libc::c_int
                                                        | (1 as libc::c_int) << 1 as libc::c_int
                                                        | (1 as libc::c_int) << 2 as libc::c_int
                                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 5634495352082367803;
                                                    break 's_248;
                                                }
                                                n += 1;
                                            }
                                            JS_FreeValue(ctx, namedCaptures);
                                            namedCaptures = JS_GetProperty(
                                                ctx,
                                                result_0,
                                                JS_ATOM_groups as libc::c_int as JSAtom,
                                            );
                                            if JS_IsException(namedCaptures) != 0 {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            if functionalReplace != 0 {
                                                let fresh677 = n;
                                                n = n + 1;
                                                if JS_DefinePropertyValueInt64(
                                                    ctx,
                                                    tab,
                                                    fresh677 as int64_t,
                                                    JS_NewInt32(ctx, position as int32_t),
                                                    (1 as libc::c_int) << 0 as libc::c_int
                                                        | (1 as libc::c_int) << 1 as libc::c_int
                                                        | (1 as libc::c_int) << 2 as libc::c_int
                                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 5634495352082367803;
                                                    break;
                                                }
                                                let fresh678 = n;
                                                n = n + 1;
                                                if JS_DefinePropertyValueInt64(
                                                    ctx,
                                                    tab,
                                                    fresh678 as int64_t,
                                                    JS_DupValue(ctx, str),
                                                    (1 as libc::c_int) << 0 as libc::c_int
                                                        | (1 as libc::c_int) << 1 as libc::c_int
                                                        | (1 as libc::c_int) << 2 as libc::c_int
                                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 5634495352082367803;
                                                    break;
                                                }
                                                if JS_IsUndefined(namedCaptures) == 0 {
                                                    let fresh679 = n;
                                                    n = n + 1;
                                                    if JS_DefinePropertyValueInt64(
                                                        ctx,
                                                        tab,
                                                        fresh679 as int64_t,
                                                        JS_DupValue(ctx, namedCaptures),
                                                        (1 as libc::c_int) << 0 as libc::c_int
                                                            | (1 as libc::c_int) << 1 as libc::c_int
                                                            | (1 as libc::c_int) << 2 as libc::c_int
                                                            | (1 as libc::c_int) << 14 as libc::c_int,
                                                    ) < 0 as libc::c_int
                                                    {
                                                        current_block = 5634495352082367803;
                                                        break;
                                                    }
                                                }
                                                args[0 as libc::c_int
                                                    as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                    << 32 as libc::c_int
                                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                                args[1 as libc::c_int as usize] = tab;
                                                JS_FreeValue(ctx, rep_str);
                                                rep_str = JS_ToStringFree(
                                                    ctx,
                                                    js_function_apply(
                                                        ctx,
                                                        rep,
                                                        2 as libc::c_int,
                                                        args.as_mut_ptr(),
                                                        0 as libc::c_int,
                                                    ),
                                                );
                                            } else {
                                                let mut namedCaptures1: JSValue = 0;
                                                if JS_IsUndefined(namedCaptures) == 0 {
                                                    namedCaptures1 = JS_ToObject(ctx, namedCaptures);
                                                    if JS_IsException(namedCaptures1) != 0 {
                                                        current_block = 5634495352082367803;
                                                        break;
                                                    }
                                                } else {
                                                    namedCaptures1 = (JS_TAG_UNDEFINED as libc::c_int
                                                        as uint64_t) << 32 as libc::c_int
                                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                                }
                                                args[0 as libc::c_int as usize] = matched;
                                                args[1 as libc::c_int as usize] = str;
                                                args[2 as libc::c_int
                                                    as usize] = JS_NewInt32(ctx, position as int32_t);
                                                args[3 as libc::c_int as usize] = tab;
                                                args[4 as libc::c_int as usize] = namedCaptures1;
                                                args[5 as libc::c_int as usize] = rep_val;
                                                JS_FreeValue(ctx, rep_str);
                                                rep_str = js_string___GetSubstitution(
                                                    ctx,
                                                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                        << 32 as libc::c_int
                                                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                                    6 as libc::c_int,
                                                    args.as_mut_ptr(),
                                                );
                                                JS_FreeValue(ctx, namedCaptures1);
                                            }
                                            if JS_IsException(rep_str) != 0 {
                                                current_block = 5634495352082367803;
                                                break;
                                            }
                                            if position >= nextSourcePosition as libc::c_longlong {
                                                string_buffer_concat(
                                                    b,
                                                    sp,
                                                    nextSourcePosition as uint32_t,
                                                    position as uint32_t,
                                                );
                                                string_buffer_concat_value(b, rep_str);
                                                nextSourcePosition = (position
                                                    + (*(matched as intptr_t as *mut libc::c_void
                                                        as *mut JSString))
                                                        .len() as libc::c_longlong) as libc::c_int;
                                            }
                                            j += 1;
                                        }
                                        match current_block {
                                            5634495352082367803 => {}
                                            _ => {
                                                string_buffer_concat(
                                                    b,
                                                    sp,
                                                    nextSourcePosition as uint32_t,
                                                    (*sp).len(),
                                                );
                                                res = string_buffer_end(b);
                                                current_block = 315623043347432359;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        5634495352082367803 => {
            res = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            current_block = 10273590682397269289;
        }
        _ => {}
    }
    match current_block {
        10273590682397269289 => {
            string_buffer_free(b);
        }
        _ => {}
    }
    value_buffer_free(results);
    JS_FreeValue(ctx, rep_val);
    JS_FreeValue(ctx, matched);
    JS_FreeValue(ctx, tab);
    JS_FreeValue(ctx, rep_str);
    JS_FreeValue(ctx, namedCaptures);
    JS_FreeValue(ctx, str);
    return res;
}
unsafe extern "C" fn js_regexp_Symbol_search(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut rx: JSValue = this_val;
    let mut str: JSValue = 0;
    let mut previousLastIndex: JSValue = 0;
    let mut currentLastIndex: JSValue = 0;
    let mut result: JSValue = 0;
    let mut index: JSValue = 0;
    if JS_IsObject(rx) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    result = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    currentLastIndex = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    previousLastIndex = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if !(JS_IsException(str) != 0) {
        previousLastIndex = JS_GetProperty(
            ctx,
            rx,
            JS_ATOM_lastIndex as libc::c_int as JSAtom,
        );
        if !(JS_IsException(previousLastIndex) != 0) {
            if js_same_value(ctx, previousLastIndex, JS_NewInt32(ctx, 0 as libc::c_int))
                == 0
            {
                if JS_SetProperty(
                    ctx,
                    rx,
                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                    JS_NewInt32(ctx, 0 as libc::c_int),
                ) < 0 as libc::c_int
                {
                    current_block = 7725961750659579936;
                } else {
                    current_block = 1841672684692190573;
                }
            } else {
                current_block = 1841672684692190573;
            }
            match current_block {
                7725961750659579936 => {}
                _ => {
                    result = JS_RegExpExec(ctx, rx, str);
                    if !(JS_IsException(result) != 0) {
                        currentLastIndex = JS_GetProperty(
                            ctx,
                            rx,
                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                        );
                        if !(JS_IsException(currentLastIndex) != 0) {
                            if js_same_value(ctx, currentLastIndex, previousLastIndex)
                                != 0
                            {
                                JS_FreeValue(ctx, previousLastIndex);
                                current_block = 18317007320854588510;
                            } else if JS_SetProperty(
                                ctx,
                                rx,
                                JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                previousLastIndex,
                            ) < 0 as libc::c_int
                            {
                                previousLastIndex = (JS_TAG_UNDEFINED as libc::c_int
                                    as uint64_t) << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                current_block = 7725961750659579936;
                            } else {
                                current_block = 18317007320854588510;
                            }
                            match current_block {
                                7725961750659579936 => {}
                                _ => {
                                    JS_FreeValue(ctx, str);
                                    JS_FreeValue(ctx, currentLastIndex);
                                    if JS_IsNull(result) != 0 {
                                        return JS_NewInt32(ctx, -(1 as libc::c_int))
                                    } else {
                                        index = JS_GetProperty(
                                            ctx,
                                            result,
                                            JS_ATOM_index as libc::c_int as JSAtom,
                                        );
                                        JS_FreeValue(ctx, result);
                                        return index;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, result);
    JS_FreeValue(ctx, str);
    JS_FreeValue(ctx, currentLastIndex);
    JS_FreeValue(ctx, previousLastIndex);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_regexp_Symbol_split(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut rx: JSValue = this_val;
    let mut args: [JSValue; 2] = [0; 2];
    let mut str: JSValue = 0;
    let mut ctor: JSValue = 0;
    let mut splitter: JSValue = 0;
    let mut A: JSValue = 0;
    let mut flags: JSValue = 0;
    let mut z: JSValue = 0;
    let mut sub: JSValue = 0;
    let mut strp: *mut JSString = 0 as *mut JSString;
    let mut lim: uint32_t = 0;
    let mut size: uint32_t = 0;
    let mut p: uint32_t = 0;
    let mut q: uint32_t = 0;
    let mut unicodeMatching: libc::c_int = 0;
    let mut lengthA: int64_t = 0;
    let mut e: int64_t = 0;
    let mut numberOfCaptures: int64_t = 0;
    let mut i: int64_t = 0;
    if JS_IsObject(rx) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    ctor = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    splitter = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    A = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    flags = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    z = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        current_block = 12713661300686792047;
    } else {
        ctor = JS_SpeciesConstructor(ctx, rx, (*ctx).regexp_ctor);
        if JS_IsException(ctor) != 0 {
            current_block = 12713661300686792047;
        } else {
            flags = JS_ToStringFree(
                ctx,
                JS_GetProperty(ctx, rx, JS_ATOM_flags as libc::c_int as JSAtom),
            );
            if JS_IsException(flags) != 0 {
                current_block = 12713661300686792047;
            } else {
                strp = flags as intptr_t as *mut libc::c_void as *mut JSString;
                unicodeMatching = (string_indexof_char(
                    strp,
                    'u' as i32,
                    0 as libc::c_int,
                ) >= 0 as libc::c_int) as libc::c_int;
                if string_indexof_char(strp, 'y' as i32, 0 as libc::c_int)
                    < 0 as libc::c_int
                {
                    flags = JS_ConcatString3(
                        ctx,
                        b"\0" as *const u8 as *const libc::c_char,
                        flags,
                        b"y\0" as *const u8 as *const libc::c_char,
                    );
                    if JS_IsException(flags) != 0 {
                        current_block = 12713661300686792047;
                    } else {
                        current_block = 12147880666119273379;
                    }
                } else {
                    current_block = 12147880666119273379;
                }
                match current_block {
                    12713661300686792047 => {}
                    _ => {
                        args[0 as libc::c_int as usize] = rx;
                        args[1 as libc::c_int as usize] = flags;
                        splitter = JS_CallConstructor(
                            ctx,
                            ctor,
                            2 as libc::c_int,
                            args.as_mut_ptr(),
                        );
                        if JS_IsException(splitter) != 0 {
                            current_block = 12713661300686792047;
                        } else {
                            A = JS_NewArray(ctx);
                            if JS_IsException(A) != 0 {
                                current_block = 12713661300686792047;
                            } else {
                                lengthA = 0 as libc::c_int as int64_t;
                                if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize))
                                    != 0
                                {
                                    lim = 0xffffffff as libc::c_uint;
                                    current_block = 11913429853522160501;
                                } else if JS_ToUint32(
                                    ctx,
                                    &mut lim,
                                    *argv.offset(1 as libc::c_int as isize),
                                ) < 0 as libc::c_int
                                {
                                    current_block = 12713661300686792047;
                                } else if lim == 0 as libc::c_int as libc::c_uint {
                                    current_block = 477886510573148996;
                                } else {
                                    current_block = 11913429853522160501;
                                }
                                match current_block {
                                    12713661300686792047 => {}
                                    477886510573148996 => {}
                                    _ => {
                                        strp = str as intptr_t as *mut libc::c_void
                                            as *mut JSString;
                                        q = 0 as libc::c_int as uint32_t;
                                        p = q;
                                        size = (*strp).len();
                                        if size == 0 as libc::c_int as libc::c_uint {
                                            z = JS_RegExpExec(ctx, splitter, str);
                                            if JS_IsException(z) != 0 {
                                                current_block = 12713661300686792047;
                                            } else if JS_IsNull(z) != 0 {
                                                current_block = 12299192390398119548;
                                            } else {
                                                current_block = 477886510573148996;
                                            }
                                        } else {
                                            's_205: loop {
                                                if !(q < size) {
                                                    current_block = 12299192390398119548;
                                                    break;
                                                }
                                                if JS_SetProperty(
                                                    ctx,
                                                    splitter,
                                                    JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                                    JS_NewInt32(ctx, q as int32_t),
                                                ) < 0 as libc::c_int
                                                {
                                                    current_block = 12713661300686792047;
                                                    break;
                                                }
                                                JS_FreeValue(ctx, z);
                                                z = JS_RegExpExec(ctx, splitter, str);
                                                if JS_IsException(z) != 0 {
                                                    current_block = 12713661300686792047;
                                                    break;
                                                }
                                                if JS_IsNull(z) != 0 {
                                                    q = string_advance_index(
                                                        strp,
                                                        q as int64_t,
                                                        unicodeMatching,
                                                    ) as uint32_t;
                                                } else {
                                                    if JS_ToLengthFree(
                                                        ctx,
                                                        &mut e,
                                                        JS_GetProperty(
                                                            ctx,
                                                            splitter,
                                                            JS_ATOM_lastIndex as libc::c_int as JSAtom,
                                                        ),
                                                    ) != 0
                                                    {
                                                        current_block = 12713661300686792047;
                                                        break;
                                                    }
                                                    if e > size as libc::c_longlong {
                                                        e = size as int64_t;
                                                    }
                                                    if e == p as libc::c_longlong {
                                                        q = string_advance_index(
                                                            strp,
                                                            q as int64_t,
                                                            unicodeMatching,
                                                        ) as uint32_t;
                                                    } else {
                                                        sub = js_sub_string(
                                                            ctx,
                                                            strp,
                                                            p as libc::c_int,
                                                            q as libc::c_int,
                                                        );
                                                        if JS_IsException(sub) != 0 {
                                                            current_block = 12713661300686792047;
                                                            break;
                                                        }
                                                        let fresh680 = lengthA;
                                                        lengthA = lengthA + 1;
                                                        if JS_DefinePropertyValueInt64(
                                                            ctx,
                                                            A,
                                                            fresh680,
                                                            sub,
                                                            (1 as libc::c_int) << 0 as libc::c_int
                                                                | (1 as libc::c_int) << 1 as libc::c_int
                                                                | (1 as libc::c_int) << 2 as libc::c_int
                                                                | (1 as libc::c_int) << 14 as libc::c_int,
                                                        ) < 0 as libc::c_int
                                                        {
                                                            current_block = 12713661300686792047;
                                                            break;
                                                        }
                                                        if lengthA == lim as libc::c_longlong {
                                                            current_block = 477886510573148996;
                                                            break;
                                                        }
                                                        p = e as uint32_t;
                                                        if js_get_length64(ctx, &mut numberOfCaptures, z) != 0 {
                                                            current_block = 12713661300686792047;
                                                            break;
                                                        }
                                                        i = 1 as libc::c_int as int64_t;
                                                        while i < numberOfCaptures {
                                                            sub = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, z, i));
                                                            if JS_IsException(sub) != 0 {
                                                                current_block = 12713661300686792047;
                                                                break 's_205;
                                                            }
                                                            let fresh681 = lengthA;
                                                            lengthA = lengthA + 1;
                                                            if JS_DefinePropertyValueInt64(
                                                                ctx,
                                                                A,
                                                                fresh681,
                                                                sub,
                                                                (1 as libc::c_int) << 0 as libc::c_int
                                                                    | (1 as libc::c_int) << 1 as libc::c_int
                                                                    | (1 as libc::c_int) << 2 as libc::c_int
                                                                    | (1 as libc::c_int) << 14 as libc::c_int,
                                                            ) < 0 as libc::c_int
                                                            {
                                                                current_block = 12713661300686792047;
                                                                break 's_205;
                                                            }
                                                            if lengthA == lim as libc::c_longlong {
                                                                current_block = 477886510573148996;
                                                                break 's_205;
                                                            }
                                                            i += 1;
                                                        }
                                                        q = p;
                                                    }
                                                }
                                            }
                                        }
                                        match current_block {
                                            477886510573148996 => {}
                                            12713661300686792047 => {}
                                            _ => {
                                                if p > size {
                                                    p = size;
                                                }
                                                sub = js_sub_string(
                                                    ctx,
                                                    strp,
                                                    p as libc::c_int,
                                                    size as libc::c_int,
                                                );
                                                if JS_IsException(sub) != 0 {
                                                    current_block = 12713661300686792047;
                                                } else {
                                                    let fresh682 = lengthA;
                                                    lengthA = lengthA + 1;
                                                    if JS_DefinePropertyValueInt64(
                                                        ctx,
                                                        A,
                                                        fresh682,
                                                        sub,
                                                        (1 as libc::c_int) << 0 as libc::c_int
                                                            | (1 as libc::c_int) << 1 as libc::c_int
                                                            | (1 as libc::c_int) << 2 as libc::c_int
                                                            | (1 as libc::c_int) << 14 as libc::c_int,
                                                    ) < 0 as libc::c_int
                                                    {
                                                        current_block = 12713661300686792047;
                                                    } else {
                                                        current_block = 477886510573148996;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        12713661300686792047 => {
            JS_FreeValue(ctx, A);
            A = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    JS_FreeValue(ctx, str);
    JS_FreeValue(ctx, ctor);
    JS_FreeValue(ctx, splitter);
    JS_FreeValue(ctx, flags);
    JS_FreeValue(ctx, z);
    return A;
}
static mut js_regexp_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_regexp_proto_funcs: [JSCFunctionListEntry; 17] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"flags\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_regexp_get_flags
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"source\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_regexp_get_source
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"global\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"ignoreCase\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"multiline\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 4 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"dotAll\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 8 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"unicode\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 16 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sticky\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 32 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_regexp_get_flag
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"exec\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_exec
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"compile\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_compile
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"test\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_test
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.replace]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_Symbol_replace
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.match]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_Symbol_match
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.matchAll]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_Symbol_matchAll
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.search]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_Symbol_search
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.split]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_regexp_Symbol_split
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_regexp_string_iterator_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_regexp_string_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"RegExp String Iterator\0" as *const u8
                        as *const libc::c_char,
                },
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicRegExpCompiler(mut ctx: *mut JSContext) {
    let ref mut fresh683 = (*ctx).compile_regexp;
    *fresh683 = Some(
        js_compile_regexp
            as unsafe extern "C" fn(*mut JSContext, JSValue, JSValue) -> JSValue,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicRegExp(mut ctx: *mut JSContext) {
    let mut obj: JSValue = 0;
    JS_AddIntrinsicRegExpCompiler(ctx);
    *((*ctx).class_proto)
        .offset(JS_CLASS_REGEXP as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_REGEXP as libc::c_int as isize),
        js_regexp_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 17]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"RegExp\0" as *const u8 as *const libc::c_char,
        Some(
            js_regexp_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        2 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_REGEXP as libc::c_int as isize),
    );
    (*ctx).regexp_ctor = JS_DupValue(ctx, obj);
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_regexp_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_REGEXP_STRING_ITERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_REGEXP_STRING_ITERATOR as libc::c_int as isize),
        js_regexp_string_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
}
unsafe extern "C" fn json_parse_expect(
    mut s: *mut JSParseState,
    mut tok: libc::c_int,
) -> libc::c_int {
    if (*s).token.val != tok {
        return js_parse_error(
            s,
            b"expecting '%c'\0" as *const u8 as *const libc::c_char,
            tok,
        );
    }
    return json_next_token(s);
}
unsafe extern "C" fn json_parse_value(mut s: *mut JSParseState) -> JSValue {
    let mut current_block: u64;
    let mut ctx: *mut JSContext = (*s).ctx;
    let mut val: JSValue = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut ret: libc::c_int = 0;
    match (*s).token.val {
        123 => {
            let mut prop_val: JSValue = 0;
            let mut prop_name: JSAtom = 0;
            if json_next_token(s) != 0 {
                current_block = 7671080357183645490;
            } else {
                val = JS_NewObject(ctx);
                if JS_IsException(val) != 0 {
                    current_block = 7671080357183645490;
                } else {
                    if (*s).token.val != '}' as i32 {
                        loop {
                            if (*s).token.val == TOK_STRING as libc::c_int {
                                prop_name = JS_ValueToAtom(ctx, (*s).token.u.str_0.str_0);
                                if prop_name == 0 as libc::c_int as libc::c_uint {
                                    current_block = 7671080357183645490;
                                    break;
                                }
                            } else if (*s).ext_json != 0
                                && (*s).token.val == TOK_IDENT as libc::c_int
                            {
                                prop_name = JS_DupAtom(ctx, (*s).token.u.ident.atom);
                            } else {
                                js_parse_error(
                                    s,
                                    b"expecting property name\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 7671080357183645490;
                                break;
                            }
                            if !(json_next_token(s) != 0) {
                                if !(json_parse_expect(s, ':' as i32) != 0) {
                                    prop_val = json_parse_value(s);
                                    if !(JS_IsException(prop_val) != 0) {
                                        ret = JS_DefinePropertyValue(
                                            ctx,
                                            val,
                                            prop_name,
                                            prop_val,
                                            (1 as libc::c_int) << 0 as libc::c_int
                                                | (1 as libc::c_int) << 1 as libc::c_int
                                                | (1 as libc::c_int) << 2 as libc::c_int,
                                        );
                                        JS_FreeAtom(ctx, prop_name);
                                        if ret < 0 as libc::c_int {
                                            current_block = 7671080357183645490;
                                            break;
                                        }
                                        if (*s).token.val != ',' as i32 {
                                            current_block = 15897653523371991391;
                                            break;
                                        }
                                        if json_next_token(s) != 0 {
                                            current_block = 7671080357183645490;
                                            break;
                                        }
                                        if (*s).ext_json != 0 && (*s).token.val == '}' as i32 {
                                            current_block = 15897653523371991391;
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }
                            }
                            JS_FreeAtom(ctx, prop_name);
                            current_block = 7671080357183645490;
                            break;
                        }
                    } else {
                        current_block = 15897653523371991391;
                    }
                    match current_block {
                        7671080357183645490 => {}
                        _ => {
                            if json_parse_expect(s, '}' as i32) != 0 {
                                current_block = 7671080357183645490;
                            } else {
                                current_block = 17239133558811367971;
                            }
                        }
                    }
                }
            }
        }
        91 => {
            let mut el: JSValue = 0;
            let mut idx: uint32_t = 0;
            if json_next_token(s) != 0 {
                current_block = 7671080357183645490;
            } else {
                val = JS_NewArray(ctx);
                if JS_IsException(val) != 0 {
                    current_block = 7671080357183645490;
                } else {
                    if (*s).token.val != ']' as i32 {
                        idx = 0 as libc::c_int as uint32_t;
                        loop {
                            el = json_parse_value(s);
                            if JS_IsException(el) != 0 {
                                current_block = 7671080357183645490;
                                break;
                            }
                            ret = JS_DefinePropertyValueUint32(
                                ctx,
                                val,
                                idx,
                                el,
                                (1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int
                                    | (1 as libc::c_int) << 2 as libc::c_int,
                            );
                            if ret < 0 as libc::c_int {
                                current_block = 7671080357183645490;
                                break;
                            }
                            if (*s).token.val != ',' as i32 {
                                current_block = 11777552016271000781;
                                break;
                            }
                            if json_next_token(s) != 0 {
                                current_block = 7671080357183645490;
                                break;
                            }
                            idx = idx.wrapping_add(1);
                            if (*s).ext_json != 0 && (*s).token.val == ']' as i32 {
                                current_block = 11777552016271000781;
                                break;
                            }
                        }
                    } else {
                        current_block = 11777552016271000781;
                    }
                    match current_block {
                        7671080357183645490 => {}
                        _ => {
                            if json_parse_expect(s, ']' as i32) != 0 {
                                current_block = 7671080357183645490;
                            } else {
                                current_block = 17239133558811367971;
                            }
                        }
                    }
                }
            }
        }
        -127 => {
            val = JS_DupValue(ctx, (*s).token.u.str_0.str_0);
            if json_next_token(s) != 0 {
                current_block = 7671080357183645490;
            } else {
                current_block = 17239133558811367971;
            }
        }
        -128 => {
            val = (*s).token.u.num.val;
            if json_next_token(s) != 0 {
                current_block = 7671080357183645490;
            } else {
                current_block = 17239133558811367971;
            }
        }
        -125 => {
            if (*s).token.u.ident.atom == JS_ATOM_false as libc::c_int as libc::c_uint
                || (*s).token.u.ident.atom == JS_ATOM_true as libc::c_int as libc::c_uint
            {
                val = JS_NewBool(
                    ctx,
                    ((*s).token.u.ident.atom
                        == JS_ATOM_true as libc::c_int as libc::c_uint) as libc::c_int,
                );
                current_block = 8869332144787829186;
            } else if (*s).token.u.ident.atom
                == JS_ATOM_null as libc::c_int as libc::c_uint
            {
                val = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                current_block = 8869332144787829186;
            } else {
                current_block = 12707246683098196155;
            }
            match current_block {
                12707246683098196155 => {}
                _ => {
                    if json_next_token(s) != 0 {
                        current_block = 7671080357183645490;
                    } else {
                        current_block = 17239133558811367971;
                    }
                }
            }
        }
        _ => {
            current_block = 12707246683098196155;
        }
    }
    match current_block {
        12707246683098196155 => {
            if (*s).token.val == TOK_EOF as libc::c_int {
                js_parse_error(
                    s,
                    b"unexpected end of input\0" as *const u8 as *const libc::c_char,
                );
            } else {
                js_parse_error(
                    s,
                    b"unexpected token: '%.*s'\0" as *const u8 as *const libc::c_char,
                    ((*s).buf_ptr).offset_from((*s).token.ptr) as libc::c_long
                        as libc::c_int,
                    (*s).token.ptr,
                );
            }
        }
        17239133558811367971 => return val,
        _ => {}
    }
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ParseJSON2(
    mut ctx: *mut JSContext,
    mut buf: *const libc::c_char,
    mut buf_len: size_t,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut s1: JSParseState = JSParseState {
        ctx: 0 as *mut JSContext,
        last_line_num: 0,
        line_num: 0,
        filename: 0 as *const libc::c_char,
        token: JSToken {
            val: 0,
            line_num: 0,
            ptr: 0 as *const uint8_t,
            u: C2RustUnnamed_31 {
                str_0: C2RustUnnamed_35 {
                    str_0: 0,
                    sep: 0,
                },
            },
        },
        got_lf: 0,
        last_ptr: 0 as *const uint8_t,
        buf_ptr: 0 as *const uint8_t,
        buf_end: 0 as *const uint8_t,
        cur_func: 0 as *mut JSFunctionDef,
        is_module: 0,
        allow_html_comments: 0,
        ext_json: 0,
    };
    let mut s: *mut JSParseState = &mut s1;
    let mut val: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    js_parse_init(ctx, s, buf, buf_len, filename);
    (*s)
        .ext_json = (flags & (1 as libc::c_int) << 0 as libc::c_int != 0 as libc::c_int)
        as libc::c_int;
    if !(json_next_token(s) != 0) {
        val = json_parse_value(s);
        if !(JS_IsException(val) != 0) {
            if (*s).token.val != TOK_EOF as libc::c_int {
                if js_parse_error(
                    s,
                    b"unexpected data at the end\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    current_block = 13710288707027659960;
                } else {
                    current_block = 8515828400728868193;
                }
            } else {
                current_block = 8515828400728868193;
            }
            match current_block {
                13710288707027659960 => {}
                _ => return val,
            }
        }
    }
    JS_FreeValue(ctx, val);
    free_token(s, &mut (*s).token);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_ParseJSON(
    mut ctx: *mut JSContext,
    mut buf: *const libc::c_char,
    mut buf_len: size_t,
    mut filename: *const libc::c_char,
) -> JSValue {
    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0 as libc::c_int);
}
unsafe extern "C" fn internalize_json_property(
    mut ctx: *mut JSContext,
    mut holder: JSValue,
    mut name: JSAtom,
    mut reviver: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut val: JSValue = 0;
    let mut new_el: JSValue = 0;
    let mut name_val: JSValue = 0;
    let mut res: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut ret: libc::c_int = 0;
    let mut is_array: libc::c_int = 0;
    let mut i: uint32_t = 0;
    let mut len: uint32_t = 0 as libc::c_int as uint32_t;
    let mut prop: JSAtom = 0;
    let mut atoms: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    if js_check_stack_overflow((*ctx).rt, 0 as libc::c_int as size_t) != 0 {
        return JS_ThrowStackOverflow(ctx);
    }
    val = JS_GetProperty(ctx, holder, name);
    if JS_IsException(val) != 0 {
        return val;
    }
    if JS_IsObject(val) != 0 {
        is_array = JS_IsArray(ctx, val);
        if is_array < 0 as libc::c_int {
            current_block = 9836646533837465727;
        } else {
            if is_array != 0 {
                if js_get_length32(ctx, &mut len, val) != 0 {
                    current_block = 9836646533837465727;
                } else {
                    current_block = 15976848397966268834;
                }
            } else {
                ret = JS_GetOwnPropertyNamesInternal(
                    ctx,
                    &mut atoms,
                    &mut len,
                    val as intptr_t as *mut libc::c_void as *mut JSObject,
                    (1 as libc::c_int) << 4 as libc::c_int
                        | (1 as libc::c_int) << 0 as libc::c_int,
                );
                if ret < 0 as libc::c_int {
                    current_block = 9836646533837465727;
                } else {
                    current_block = 15976848397966268834;
                }
            }
            match current_block {
                9836646533837465727 => {}
                _ => {
                    i = 0 as libc::c_int as uint32_t;
                    loop {
                        if !(i < len) {
                            current_block = 7828949454673616476;
                            break;
                        }
                        if is_array != 0 {
                            prop = JS_NewAtomUInt32(ctx, i);
                            if prop == 0 as libc::c_int as libc::c_uint {
                                current_block = 9836646533837465727;
                                break;
                            }
                        } else {
                            prop = JS_DupAtom(ctx, (*atoms.offset(i as isize)).atom);
                        }
                        new_el = internalize_json_property(ctx, val, prop, reviver);
                        if JS_IsException(new_el) != 0 {
                            JS_FreeAtom(ctx, prop);
                            current_block = 9836646533837465727;
                            break;
                        } else {
                            if JS_IsUndefined(new_el) != 0 {
                                ret = JS_DeleteProperty(ctx, val, prop, 0 as libc::c_int);
                            } else {
                                ret = JS_DefinePropertyValue(
                                    ctx,
                                    val,
                                    prop,
                                    new_el,
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int,
                                );
                            }
                            JS_FreeAtom(ctx, prop);
                            if ret < 0 as libc::c_int {
                                current_block = 9836646533837465727;
                                break;
                            }
                            i = i.wrapping_add(1);
                        }
                    }
                }
            }
        }
    } else {
        current_block = 7828949454673616476;
    }
    match current_block {
        7828949454673616476 => {
            js_free_prop_enum(ctx, atoms, len);
            atoms = 0 as *mut JSPropertyEnum;
            name_val = JS_AtomToValue(ctx, name);
            if !(JS_IsException(name_val) != 0) {
                args[0 as libc::c_int as usize] = name_val;
                args[1 as libc::c_int as usize] = val;
                res = JS_Call(ctx, reviver, holder, 2 as libc::c_int, args.as_mut_ptr());
                JS_FreeValue(ctx, name_val);
                JS_FreeValue(ctx, val);
                return res;
            }
        }
        _ => {}
    }
    js_free_prop_enum(ctx, atoms, len);
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_json_parse(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut root: JSValue = 0;
    let mut reviver: JSValue = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: size_t = 0;
    str = JS_ToCStringLen(ctx, &mut len, *argv.offset(0 as libc::c_int as isize));
    if str.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    obj = JS_ParseJSON(ctx, str, len, b"<input>\0" as *const u8 as *const libc::c_char);
    JS_FreeCString(ctx, str);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    if argc > 1 as libc::c_int
        && JS_IsFunction(ctx, *argv.offset(1 as libc::c_int as isize)) != 0
    {
        reviver = *argv.offset(1 as libc::c_int as isize);
        root = JS_NewObject(ctx);
        if JS_IsException(root) != 0 {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if JS_DefinePropertyValue(
            ctx,
            root,
            JS_ATOM_empty_string as libc::c_int as JSAtom,
            obj,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        ) < 0 as libc::c_int
        {
            JS_FreeValue(ctx, root);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        obj = internalize_json_property(
            ctx,
            root,
            JS_ATOM_empty_string as libc::c_int as JSAtom,
            reviver,
        );
        JS_FreeValue(ctx, root);
    }
    return obj;
}
unsafe extern "C" fn JS_ToQuotedStringFree(
    mut ctx: *mut JSContext,
    mut val: JSValue,
) -> JSValue {
    let mut r: JSValue = JS_ToQuotedString(ctx, val);
    JS_FreeValue(ctx, val);
    return r;
}
unsafe extern "C" fn js_json_check(
    mut ctx: *mut JSContext,
    mut jsc: *mut JSONStringifyContext,
    mut holder: JSValue,
    mut val: JSValue,
    mut key: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut v: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    if JS_IsObject(val) != 0 {
        let mut f: JSValue = JS_GetProperty(
            ctx,
            val,
            JS_ATOM_toJSON as libc::c_int as JSAtom,
        );
        if JS_IsException(f) != 0 {
            current_block = 15636603039583107224;
        } else if JS_IsFunction(ctx, f) != 0 {
            v = JS_CallFree(ctx, f, val, 1 as libc::c_int, &mut key);
            JS_FreeValue(ctx, val);
            val = v;
            if JS_IsException(val) != 0 {
                current_block = 15636603039583107224;
            } else {
                current_block = 7746791466490516765;
            }
        } else {
            JS_FreeValue(ctx, f);
            current_block = 7746791466490516765;
        }
    } else {
        current_block = 7746791466490516765;
    }
    match current_block {
        7746791466490516765 => {
            if JS_IsUndefined((*jsc).replacer_func) == 0 {
                args[0 as libc::c_int as usize] = key;
                args[1 as libc::c_int as usize] = val;
                v = JS_Call(
                    ctx,
                    (*jsc).replacer_func,
                    holder,
                    2 as libc::c_int,
                    args.as_mut_ptr(),
                );
                JS_FreeValue(ctx, val);
                val = v;
                if JS_IsException(val) != 0 {
                    current_block = 15636603039583107224;
                } else {
                    current_block = 5689001924483802034;
                }
            } else {
                current_block = 5689001924483802034;
            }
            match current_block {
                15636603039583107224 => {}
                _ => {
                    let mut current_block_10: u64;
                    match JS_VALUE_GET_NORM_TAG(val) {
                        -1 => {
                            if JS_IsFunction(ctx, val) != 0 {
                                current_block_10 = 11307063007268554308;
                            } else {
                                current_block_10 = 3852484604078265000;
                            }
                        }
                        -7 | 0 | 7 | 1 | 2 | 6 => {
                            current_block_10 = 3852484604078265000;
                        }
                        _ => {
                            current_block_10 = 11307063007268554308;
                        }
                    }
                    match current_block_10 {
                        11307063007268554308 => {}
                        _ => return val,
                    }
                    JS_FreeValue(ctx, val);
                    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_json_to_str(
    mut ctx: *mut JSContext,
    mut jsc: *mut JSONStringifyContext,
    mut holder: JSValue,
    mut val: JSValue,
    mut indent: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut indent1: JSValue = 0;
    let mut sep: JSValue = 0;
    let mut sep1: JSValue = 0;
    let mut tab: JSValue = 0;
    let mut v: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut i: int64_t = 0;
    let mut len: int64_t = 0;
    let mut cl: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut has_content: BOOL = 0;
    indent1 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    sep = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    sep1 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    tab = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    prop = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    match JS_VALUE_GET_NORM_TAG(val) {
        -1 => {
            p = val as intptr_t as *mut libc::c_void as *mut JSObject;
            cl = (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int;
            if cl == JS_CLASS_STRING as libc::c_int {
                val = JS_ToStringFree(ctx, val);
                if !(JS_IsException(val) != 0) {
                    val = JS_ToQuotedStringFree(ctx, val);
                    if !(JS_IsException(val) != 0) {
                        return string_buffer_concat_value_free((*jsc).b, val);
                    }
                }
            } else if cl == JS_CLASS_NUMBER as libc::c_int {
                val = JS_ToNumberFree(ctx, val);
                if !(JS_IsException(val) != 0) {
                    return string_buffer_concat_value_free((*jsc).b, val);
                }
            } else {
                if cl == JS_CLASS_BOOLEAN as libc::c_int {
                    ret = string_buffer_concat_value((*jsc).b, (*p).u.object_data);
                    JS_FreeValue(ctx, val);
                    return ret;
                }
                v = js_array_includes(
                    ctx,
                    (*jsc).stack,
                    1 as libc::c_int,
                    &mut val as *mut JSValue,
                );
                if !(JS_IsException(v) != 0) {
                    if JS_ToBoolFree(ctx, v) != 0 {
                        JS_ThrowTypeError(
                            ctx,
                            b"circular reference\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        indent1 = JS_ConcatString(
                            ctx,
                            JS_DupValue(ctx, indent),
                            JS_DupValue(ctx, (*jsc).gap),
                        );
                        if !(JS_IsException(indent1) != 0) {
                            if JS_IsEmptyString((*jsc).gap) == 0 {
                                sep = JS_ConcatString3(
                                    ctx,
                                    b"\n\0" as *const u8 as *const libc::c_char,
                                    JS_DupValue(ctx, indent1),
                                    b"\0" as *const u8 as *const libc::c_char,
                                );
                                if JS_IsException(sep) != 0 {
                                    current_block = 14055139356457136764;
                                } else {
                                    sep1 = JS_NewString(
                                        ctx,
                                        b" \0" as *const u8 as *const libc::c_char,
                                    );
                                    if JS_IsException(sep1) != 0 {
                                        current_block = 14055139356457136764;
                                    } else {
                                        current_block = 7659304154607701039;
                                    }
                                }
                            } else {
                                sep = JS_DupValue(ctx, (*jsc).empty);
                                sep1 = JS_DupValue(ctx, (*jsc).empty);
                                current_block = 7659304154607701039;
                            }
                            match current_block {
                                14055139356457136764 => {}
                                _ => {
                                    v = js_array_push(
                                        ctx,
                                        (*jsc).stack,
                                        1 as libc::c_int,
                                        &mut val as *mut JSValue,
                                        0 as libc::c_int,
                                    );
                                    if !(check_exception_free(ctx, v) != 0) {
                                        ret = JS_IsArray(ctx, val);
                                        if !(ret < 0 as libc::c_int) {
                                            if ret != 0 {
                                                if js_get_length64(ctx, &mut len, val) != 0 {
                                                    current_block = 14055139356457136764;
                                                } else {
                                                    string_buffer_putc8((*jsc).b, '[' as i32 as uint32_t);
                                                    i = 0 as libc::c_int as int64_t;
                                                    loop {
                                                        if !(i < len) {
                                                            current_block = 16203797167131938757;
                                                            break;
                                                        }
                                                        if i > 0 as libc::c_int as libc::c_longlong {
                                                            string_buffer_putc8((*jsc).b, ',' as i32 as uint32_t);
                                                        }
                                                        string_buffer_concat_value((*jsc).b, sep);
                                                        v = JS_GetPropertyInt64(ctx, val, i);
                                                        if JS_IsException(v) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        prop = JS_ToStringFree(ctx, JS_NewInt64(ctx, i));
                                                        if JS_IsException(prop) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        v = js_json_check(ctx, jsc, val, v, prop);
                                                        JS_FreeValue(ctx, prop);
                                                        prop = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                            << 32 as libc::c_int
                                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                                        if JS_IsException(v) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        if JS_IsUndefined(v) != 0 {
                                                            v = (JS_TAG_NULL as libc::c_int as uint64_t)
                                                                << 32 as libc::c_int
                                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                                        }
                                                        if js_json_to_str(ctx, jsc, val, v, indent1) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        i += 1;
                                                    }
                                                    match current_block {
                                                        14055139356457136764 => {}
                                                        _ => {
                                                            if len > 0 as libc::c_int as libc::c_longlong
                                                                && JS_IsEmptyString((*jsc).gap) == 0
                                                            {
                                                                string_buffer_putc8((*jsc).b, '\n' as i32 as uint32_t);
                                                                string_buffer_concat_value((*jsc).b, indent);
                                                            }
                                                            string_buffer_putc8((*jsc).b, ']' as i32 as uint32_t);
                                                            current_block = 1417769144978639029;
                                                        }
                                                    }
                                                }
                                            } else {
                                                if JS_IsUndefined((*jsc).property_list) == 0 {
                                                    tab = JS_DupValue(ctx, (*jsc).property_list);
                                                } else {
                                                    tab = js_object_keys(
                                                        ctx,
                                                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                            << 32 as libc::c_int
                                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                                        1 as libc::c_int,
                                                        &mut val as *mut JSValue,
                                                        JS_ITERATOR_KIND_KEY as libc::c_int,
                                                    );
                                                }
                                                if JS_IsException(tab) != 0 {
                                                    current_block = 14055139356457136764;
                                                } else if js_get_length64(ctx, &mut len, tab) != 0 {
                                                    current_block = 14055139356457136764;
                                                } else {
                                                    string_buffer_putc8((*jsc).b, '{' as i32 as uint32_t);
                                                    has_content = FALSE as libc::c_int;
                                                    i = 0 as libc::c_int as int64_t;
                                                    loop {
                                                        if !(i < len) {
                                                            current_block = 18137396335907573669;
                                                            break;
                                                        }
                                                        JS_FreeValue(ctx, prop);
                                                        prop = JS_GetPropertyInt64(ctx, tab, i);
                                                        if JS_IsException(prop) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        v = JS_GetPropertyValue(ctx, val, JS_DupValue(ctx, prop));
                                                        if JS_IsException(v) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        v = js_json_check(ctx, jsc, val, v, prop);
                                                        if JS_IsException(v) != 0 {
                                                            current_block = 14055139356457136764;
                                                            break;
                                                        }
                                                        if JS_IsUndefined(v) == 0 {
                                                            if has_content != 0 {
                                                                string_buffer_putc8((*jsc).b, ',' as i32 as uint32_t);
                                                            }
                                                            prop = JS_ToQuotedStringFree(ctx, prop);
                                                            if JS_IsException(prop) != 0 {
                                                                JS_FreeValue(ctx, v);
                                                                current_block = 14055139356457136764;
                                                                break;
                                                            } else {
                                                                string_buffer_concat_value((*jsc).b, sep);
                                                                string_buffer_concat_value((*jsc).b, prop);
                                                                string_buffer_putc8((*jsc).b, ':' as i32 as uint32_t);
                                                                string_buffer_concat_value((*jsc).b, sep1);
                                                                if js_json_to_str(ctx, jsc, val, v, indent1) != 0 {
                                                                    current_block = 14055139356457136764;
                                                                    break;
                                                                }
                                                                has_content = TRUE as libc::c_int;
                                                            }
                                                        }
                                                        i += 1;
                                                    }
                                                    match current_block {
                                                        14055139356457136764 => {}
                                                        _ => {
                                                            if has_content != 0
                                                                && (*((*jsc).gap as intptr_t as *mut libc::c_void
                                                                    as *mut JSString))
                                                                    .len() as libc::c_int != 0 as libc::c_int
                                                            {
                                                                string_buffer_putc8((*jsc).b, '\n' as i32 as uint32_t);
                                                                string_buffer_concat_value((*jsc).b, indent);
                                                            }
                                                            string_buffer_putc8((*jsc).b, '}' as i32 as uint32_t);
                                                            current_block = 1417769144978639029;
                                                        }
                                                    }
                                                }
                                            }
                                            match current_block {
                                                14055139356457136764 => {}
                                                _ => {
                                                    if !(check_exception_free(
                                                        ctx,
                                                        js_array_pop(
                                                            ctx,
                                                            (*jsc).stack,
                                                            0 as libc::c_int,
                                                            0 as *mut JSValue,
                                                            0 as libc::c_int,
                                                        ),
                                                    ) != 0)
                                                    {
                                                        JS_FreeValue(ctx, val);
                                                        JS_FreeValue(ctx, tab);
                                                        JS_FreeValue(ctx, sep);
                                                        JS_FreeValue(ctx, sep1);
                                                        JS_FreeValue(ctx, indent1);
                                                        JS_FreeValue(ctx, prop);
                                                        return 0 as libc::c_int;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            current_block = 14055139356457136764;
        }
        -7 => {
            val = JS_ToQuotedStringFree(ctx, val);
            if JS_IsException(val) != 0 {
                current_block = 14055139356457136764;
            } else {
                current_block = 1284028469621175066;
            }
        }
        7 => {
            if isfinite(JS_VALUE_GET_FLOAT64(val)) == 0 {
                val = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            current_block = 1284028469621175066;
        }
        0 | 1 | 2 => {
            current_block = 1284028469621175066;
        }
        _ => {
            JS_FreeValue(ctx, val);
            return 0 as libc::c_int;
        }
    }
    match current_block {
        1284028469621175066 => return string_buffer_concat_value_free((*jsc).b, val),
        _ => {
            JS_FreeValue(ctx, val);
            JS_FreeValue(ctx, tab);
            JS_FreeValue(ctx, sep);
            JS_FreeValue(ctx, sep1);
            JS_FreeValue(ctx, indent1);
            JS_FreeValue(ctx, prop);
            return -(1 as libc::c_int);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn JS_JSONStringify(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut replacer: JSValue,
    mut space0: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut jsc_s: JSONStringifyContext = JSONStringifyContext {
        replacer_func: 0,
        stack: 0,
        property_list: 0,
        gap: 0,
        empty: 0,
        b: 0 as *mut StringBuffer,
    };
    let mut jsc: *mut JSONStringifyContext = &mut jsc_s;
    let mut val: JSValue = 0;
    let mut v: JSValue = 0;
    let mut space: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut wrapper: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut i: int64_t = 0;
    let mut j: int64_t = 0;
    let mut n: int64_t = 0;
    (*jsc)
        .replacer_func = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*jsc)
        .stack = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*jsc)
        .property_list = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    (*jsc)
        .gap = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let ref mut fresh684 = (*jsc).b;
    *fresh684 = &mut b_s;
    (*jsc).empty = JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom);
    ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    wrapper = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    string_buffer_init(ctx, (*jsc).b, 0 as libc::c_int);
    (*jsc).stack = JS_NewArray(ctx);
    if JS_IsException((*jsc).stack) != 0 {
        current_block = 14711433821934969052;
    } else {
        if JS_IsFunction(ctx, replacer) != 0 {
            (*jsc).replacer_func = replacer;
            current_block = 14220266465818359136;
        } else {
            res = JS_IsArray(ctx, replacer);
            if res < 0 as libc::c_int {
                current_block = 14711433821934969052;
            } else if res != 0 {
                (*jsc).property_list = JS_NewArray(ctx);
                if JS_IsException((*jsc).property_list) != 0 {
                    current_block = 14711433821934969052;
                } else if js_get_length64(ctx, &mut n, replacer) != 0 {
                    current_block = 14711433821934969052;
                } else {
                    j = 0 as libc::c_int as int64_t;
                    i = j;
                    loop {
                        if !(i < n) {
                            current_block = 14220266465818359136;
                            break;
                        }
                        let mut present: JSValue = 0;
                        v = JS_GetPropertyInt64(ctx, replacer, i);
                        if JS_IsException(v) != 0 {
                            current_block = 14711433821934969052;
                            break;
                        }
                        if JS_IsObject(v) != 0 {
                            let mut p: *mut JSObject = v as intptr_t as *mut libc::c_void
                                as *mut JSObject;
                            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                                == JS_CLASS_STRING as libc::c_int
                                || (*p).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int == JS_CLASS_NUMBER as libc::c_int
                            {
                                v = JS_ToStringFree(ctx, v);
                                if JS_IsException(v) != 0 {
                                    current_block = 14711433821934969052;
                                    break;
                                }
                                current_block = 14072441030219150333;
                            } else {
                                JS_FreeValue(ctx, v);
                                current_block = 15089075282327824602;
                            }
                        } else if JS_IsNumber(v) != 0 {
                            v = JS_ToStringFree(ctx, v);
                            if JS_IsException(v) != 0 {
                                current_block = 14711433821934969052;
                                break;
                            }
                            current_block = 14072441030219150333;
                        } else if JS_IsString(v) == 0 {
                            JS_FreeValue(ctx, v);
                            current_block = 15089075282327824602;
                        } else {
                            current_block = 14072441030219150333;
                        }
                        match current_block {
                            14072441030219150333 => {
                                present = js_array_includes(
                                    ctx,
                                    (*jsc).property_list,
                                    1 as libc::c_int,
                                    &mut v as *mut JSValue,
                                );
                                if JS_IsException(present) != 0 {
                                    JS_FreeValue(ctx, v);
                                    current_block = 14711433821934969052;
                                    break;
                                } else if JS_ToBoolFree(ctx, present) == 0 {
                                    let fresh685 = j;
                                    j = j + 1;
                                    JS_SetPropertyInt64(ctx, (*jsc).property_list, fresh685, v);
                                } else {
                                    JS_FreeValue(ctx, v);
                                }
                            }
                            _ => {}
                        }
                        i += 1;
                    }
                }
            } else {
                current_block = 14220266465818359136;
            }
        }
        match current_block {
            14711433821934969052 => {}
            _ => {
                space = JS_DupValue(ctx, space0);
                if JS_IsObject(space) != 0 {
                    let mut p_0: *mut JSObject = space as intptr_t as *mut libc::c_void
                        as *mut JSObject;
                    if (*p_0).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                        == JS_CLASS_NUMBER as libc::c_int
                    {
                        space = JS_ToNumberFree(ctx, space);
                    } else if (*p_0).c2rust_unnamed.c2rust_unnamed.class_id
                        as libc::c_int == JS_CLASS_STRING as libc::c_int
                    {
                        space = JS_ToStringFree(ctx, space);
                    }
                    if JS_IsException(space) != 0 {
                        JS_FreeValue(ctx, space);
                        current_block = 14711433821934969052;
                    } else {
                        current_block = 17836213544692497527;
                    }
                } else {
                    current_block = 17836213544692497527;
                }
                match current_block {
                    14711433821934969052 => {}
                    _ => {
                        if JS_IsNumber(space) != 0 {
                            let mut n_0: libc::c_int = 0;
                            if JS_ToInt32Clamp(
                                ctx,
                                &mut n_0,
                                space,
                                0 as libc::c_int,
                                10 as libc::c_int,
                                0 as libc::c_int,
                            ) != 0
                            {
                                current_block = 14711433821934969052;
                            } else {
                                (*jsc)
                                    .gap = JS_NewStringLen(
                                    ctx,
                                    b"          \0" as *const u8 as *const libc::c_char,
                                    n_0 as size_t,
                                );
                                current_block = 129780949503461575;
                            }
                        } else {
                            if JS_IsString(space) != 0 {
                                let mut p_1: *mut JSString = space as intptr_t
                                    as *mut libc::c_void as *mut JSString;
                                (*jsc)
                                    .gap = js_sub_string(
                                    ctx,
                                    p_1,
                                    0 as libc::c_int,
                                    min_int((*p_1).len() as libc::c_int, 10 as libc::c_int),
                                );
                            } else {
                                (*jsc).gap = JS_DupValue(ctx, (*jsc).empty);
                            }
                            current_block = 129780949503461575;
                        }
                        match current_block {
                            14711433821934969052 => {}
                            _ => {
                                JS_FreeValue(ctx, space);
                                if JS_IsException((*jsc).gap) != 0 {
                                    current_block = 14711433821934969052;
                                } else {
                                    wrapper = JS_NewObject(ctx);
                                    if JS_IsException(wrapper) != 0 {
                                        current_block = 14711433821934969052;
                                    } else if JS_DefinePropertyValue(
                                        ctx,
                                        wrapper,
                                        JS_ATOM_empty_string as libc::c_int as JSAtom,
                                        JS_DupValue(ctx, obj),
                                        (1 as libc::c_int) << 0 as libc::c_int
                                            | (1 as libc::c_int) << 1 as libc::c_int
                                            | (1 as libc::c_int) << 2 as libc::c_int,
                                    ) < 0 as libc::c_int
                                    {
                                        current_block = 14711433821934969052;
                                    } else {
                                        val = JS_DupValue(ctx, obj);
                                        val = js_json_check(ctx, jsc, wrapper, val, (*jsc).empty);
                                        if JS_IsException(val) != 0 {
                                            current_block = 14711433821934969052;
                                        } else if JS_IsUndefined(val) != 0 {
                                            ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                            current_block = 16503220431803276304;
                                        } else if js_json_to_str(
                                            ctx,
                                            jsc,
                                            wrapper,
                                            val,
                                            (*jsc).empty,
                                        ) != 0
                                        {
                                            current_block = 14711433821934969052;
                                        } else {
                                            ret = string_buffer_end((*jsc).b);
                                            current_block = 10135409896677097952;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        14711433821934969052 => {
            ret = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            current_block = 16503220431803276304;
        }
        _ => {}
    }
    match current_block {
        16503220431803276304 => {
            string_buffer_free((*jsc).b);
        }
        _ => {}
    }
    JS_FreeValue(ctx, wrapper);
    JS_FreeValue(ctx, (*jsc).empty);
    JS_FreeValue(ctx, (*jsc).gap);
    JS_FreeValue(ctx, (*jsc).property_list);
    JS_FreeValue(ctx, (*jsc).stack);
    return ret;
}
unsafe extern "C" fn js_json_stringify(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_JSONStringify(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        *argv.offset(1 as libc::c_int as isize),
        *argv.offset(2 as libc::c_int as isize),
    );
}
static mut js_json_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"parse\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_json_parse
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"stringify\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_json_stringify
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"JSON\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_json_obj: [JSCFunctionListEntry; 1] = [JSCFunctionListEntry {
    name: 0 as *const libc::c_char,
    prop_flags: 0,
    def_type: 0,
    magic: 0,
    u: C2RustUnnamed_22 {
        func: C2RustUnnamed_25 {
            length: 0,
            cproto: 0,
            cfunc: JSCFunctionType { generic: None },
        },
    },
}; 1];
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicJSON(mut ctx: *mut JSContext) {
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).global_obj,
        js_json_obj.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
}
unsafe extern "C" fn js_reflect_apply(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return js_function_apply(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        max_int(0 as libc::c_int, argc - 1 as libc::c_int),
        argv.offset(1 as libc::c_int as isize),
        2 as libc::c_int,
    );
}
unsafe extern "C" fn js_reflect_construct(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut func: JSValue = 0;
    let mut array_arg: JSValue = 0;
    let mut new_target: JSValue = 0;
    let mut tab: *mut JSValue = 0 as *mut JSValue;
    let mut ret: JSValue = 0;
    let mut len: uint32_t = 0;
    func = *argv.offset(0 as libc::c_int as isize);
    array_arg = *argv.offset(1 as libc::c_int as isize);
    if argc > 2 as libc::c_int {
        new_target = *argv.offset(2 as libc::c_int as isize);
        if JS_IsConstructor(ctx, new_target) == 0 {
            return JS_ThrowTypeError(
                ctx,
                b"not a constructor\0" as *const u8 as *const libc::c_char,
            );
        }
    } else {
        new_target = func;
    }
    tab = build_arg_list(ctx, &mut len, array_arg);
    if tab.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_CallConstructor2(ctx, func, new_target, len as libc::c_int, tab);
    free_arg_list(ctx, tab, len);
    return ret;
}
unsafe extern "C" fn js_reflect_deleteProperty(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    atom = JS_ValueToAtom(ctx, *argv.offset(1 as libc::c_int as isize));
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_DeleteProperty(ctx, obj, atom, 0 as libc::c_int);
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_reflect_get(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut receiver: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: JSValue = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    prop = *argv.offset(1 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if argc > 2 as libc::c_int {
        receiver = *argv.offset(2 as libc::c_int as isize);
    } else {
        receiver = obj;
    }
    atom = JS_ValueToAtom(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_GetPropertyInternal(ctx, obj, atom, receiver, FALSE as libc::c_int);
    JS_FreeAtom(ctx, atom);
    return ret;
}
unsafe extern "C" fn js_reflect_has(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut atom: JSAtom = 0;
    let mut ret: libc::c_int = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    prop = *argv.offset(1 as libc::c_int as isize);
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    atom = JS_ValueToAtom(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_HasProperty(ctx, obj, atom);
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_reflect_set(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut prop: JSValue = 0;
    let mut val: JSValue = 0;
    let mut receiver: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut atom: JSAtom = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    prop = *argv.offset(1 as libc::c_int as isize);
    val = *argv.offset(2 as libc::c_int as isize);
    if argc > 3 as libc::c_int {
        receiver = *argv.offset(3 as libc::c_int as isize);
    } else {
        receiver = obj;
    }
    if (obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    atom = JS_ValueToAtom(ctx, prop);
    if (atom == 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ret = JS_SetPropertyGeneric(
        ctx,
        obj,
        atom,
        JS_DupValue(ctx, val),
        receiver,
        0 as libc::c_int,
    );
    JS_FreeAtom(ctx, atom);
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_reflect_setPrototypeOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ret: libc::c_int = 0;
    ret = JS_SetPrototypeInternal(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        *argv.offset(1 as libc::c_int as isize),
        FALSE as libc::c_int,
    );
    if ret < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_NewBool(ctx, ret)
    };
}
unsafe extern "C" fn js_reflect_ownKeys(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    if (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_OBJECT as libc::c_int
    {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    return JS_GetOwnPropertyNames2(
        ctx,
        *argv.offset(0 as libc::c_int as isize),
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int,
        JS_ITERATOR_KIND_KEY as libc::c_int,
    );
}
static mut js_reflect_funcs: [JSCFunctionListEntry; 14] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"apply\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_apply
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"construct\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_construct
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"defineProperty\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_defineProperty
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"deleteProperty\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_deleteProperty
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"get\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_get
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getOwnPropertyDescriptor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_getOwnPropertyDescriptor
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getPrototypeOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_getPrototypeOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"has\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_has
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isExtensible\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_isExtensible
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"ownKeys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_ownKeys
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"preventExtensions\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_object_preventExtensions
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"set\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setPrototypeOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_reflect_setPrototypeOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Reflect\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_reflect_obj: [JSCFunctionListEntry; 1] = [JSCFunctionListEntry {
    name: 0 as *const libc::c_char,
    prop_flags: 0,
    def_type: 0,
    magic: 0,
    u: C2RustUnnamed_22 {
        func: C2RustUnnamed_25 {
            length: 0,
            cproto: 0,
            cfunc: JSCFunctionType { generic: None },
        },
    },
}; 1];
unsafe extern "C" fn js_proxy_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut s: *mut JSProxyData = JS_GetOpaque(
        val,
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    ) as *mut JSProxyData;
    if !s.is_null() {
        JS_FreeValueRT(rt, (*s).target);
        JS_FreeValueRT(rt, (*s).handler);
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_proxy_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSProxyData = JS_GetOpaque(
        val,
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    ) as *mut JSProxyData;
    if !s.is_null() {
        JS_MarkValue(rt, (*s).target, mark_func);
        JS_MarkValue(rt, (*s).handler, mark_func);
    }
}
unsafe extern "C" fn JS_ThrowTypeErrorRevokedProxy(mut ctx: *mut JSContext) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"revoked proxy\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn get_proxy_method(
    mut ctx: *mut JSContext,
    mut pmethod: *mut JSValue,
    mut obj: JSValue,
    mut name: JSAtom,
) -> *mut JSProxyData {
    let mut s: *mut JSProxyData = JS_GetOpaque(
        obj,
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    ) as *mut JSProxyData;
    let mut method: JSValue = 0;
    if js_check_stack_overflow((*ctx).rt, 0 as libc::c_int as size_t) != 0 {
        JS_ThrowStackOverflow(ctx);
        return 0 as *mut JSProxyData;
    }
    if (*s).is_revoked != 0 {
        JS_ThrowTypeErrorRevokedProxy(ctx);
        return 0 as *mut JSProxyData;
    }
    method = JS_GetProperty(ctx, (*s).handler, name);
    if JS_IsException(method) != 0 {
        return 0 as *mut JSProxyData;
    }
    if JS_IsNull(method) != 0 {
        method = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    *pmethod = method;
    return s;
}
unsafe extern "C" fn js_proxy_getPrototypeOf(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut proto1: JSValue = 0;
    let mut res: libc::c_int = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_getPrototypeOf as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsUndefined(method) != 0 {
        return JS_GetPrototype(ctx, (*s).target);
    }
    ret = JS_CallFree(
        ctx,
        method,
        (*s).handler,
        1 as libc::c_int,
        &mut (*s).target as *mut JSValue,
    );
    if JS_IsException(ret) != 0 {
        return ret;
    }
    if !((ret >> 32 as libc::c_int) as libc::c_int != JS_TAG_NULL as libc::c_int
        && (ret >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
    {
        res = JS_IsExtensible(ctx, (*s).target);
        if res < 0 as libc::c_int {
            JS_FreeValue(ctx, ret);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if res == 0 {
            proto1 = JS_GetPrototype(ctx, (*s).target);
            if JS_IsException(proto1) != 0 {
                JS_FreeValue(ctx, ret);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if proto1 as intptr_t as *mut libc::c_void as *mut JSObject
                != ret as intptr_t as *mut libc::c_void as *mut JSObject
            {
                JS_FreeValue(ctx, proto1);
                current_block = 18396000597731568727;
            } else {
                JS_FreeValue(ctx, proto1);
                current_block = 10043043949733653460;
            }
        } else {
            current_block = 10043043949733653460;
        }
        match current_block {
            18396000597731568727 => {}
            _ => return ret,
        }
    }
    JS_FreeValue(ctx, ret);
    return JS_ThrowTypeError(
        ctx,
        b"proxy: inconsistent prototype\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn js_proxy_setPrototypeOf(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut proto_val: JSValue,
    mut throw_flag: BOOL,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut proto1: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut res: BOOL = 0;
    let mut res2: libc::c_int = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_setPrototypeOf as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_SetPrototypeInternal(ctx, (*s).target, proto_val, throw_flag);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = proto_val;
    ret = JS_CallFree(ctx, method, (*s).handler, 2 as libc::c_int, args.as_mut_ptr());
    if JS_IsException(ret) != 0 {
        return -(1 as libc::c_int);
    }
    res = JS_ToBoolFree(ctx, ret);
    if res == 0 {
        if throw_flag != 0 {
            JS_ThrowTypeError(
                ctx,
                b"proxy: bad prototype\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        } else {
            return FALSE as libc::c_int
        }
    }
    res2 = JS_IsExtensible(ctx, (*s).target);
    if res2 < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if res2 == 0 {
        proto1 = JS_GetPrototype(ctx, (*s).target);
        if JS_IsException(proto1) != 0 {
            return -(1 as libc::c_int);
        }
        if proto_val as intptr_t as *mut libc::c_void as *mut JSObject
            != proto1 as intptr_t as *mut libc::c_void as *mut JSObject
        {
            JS_FreeValue(ctx, proto1);
            JS_ThrowTypeError(
                ctx,
                b"proxy: inconsistent prototype\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        JS_FreeValue(ctx, proto1);
    }
    return TRUE as libc::c_int;
}
unsafe extern "C" fn js_proxy_isExtensible(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut res: BOOL = 0;
    let mut res2: libc::c_int = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_isExtensible as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_IsExtensible(ctx, (*s).target);
    }
    ret = JS_CallFree(
        ctx,
        method,
        (*s).handler,
        1 as libc::c_int,
        &mut (*s).target as *mut JSValue,
    );
    if JS_IsException(ret) != 0 {
        return -(1 as libc::c_int);
    }
    res = JS_ToBoolFree(ctx, ret);
    res2 = JS_IsExtensible(ctx, (*s).target);
    if res2 < 0 as libc::c_int {
        return res2;
    }
    if res != res2 {
        JS_ThrowTypeError(
            ctx,
            b"proxy: inconsistent isExtensible\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    return res;
}
unsafe extern "C" fn js_proxy_preventExtensions(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut res: BOOL = 0;
    let mut res2: libc::c_int = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_preventExtensions as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_PreventExtensions(ctx, (*s).target);
    }
    ret = JS_CallFree(
        ctx,
        method,
        (*s).handler,
        1 as libc::c_int,
        &mut (*s).target as *mut JSValue,
    );
    if JS_IsException(ret) != 0 {
        return -(1 as libc::c_int);
    }
    res = JS_ToBoolFree(ctx, ret);
    if res != 0 {
        res2 = JS_IsExtensible(ctx, (*s).target);
        if res2 < 0 as libc::c_int {
            return res2;
        }
        if res2 != 0 {
            JS_ThrowTypeError(
                ctx,
                b"proxy: inconsistent preventExtensions\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    return res;
}
unsafe extern "C" fn js_proxy_has(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret1: JSValue = 0;
    let mut atom_val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut args: [JSValue; 2] = [0; 2];
    let mut res2: BOOL = 0;
    s = get_proxy_method(ctx, &mut method, obj, JS_ATOM_has as libc::c_int as JSAtom);
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_HasProperty(ctx, (*s).target, atom);
    }
    atom_val = JS_AtomToValue(ctx, atom);
    if JS_IsException(atom_val) != 0 {
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = atom_val;
    ret1 = JS_CallFree(ctx, method, (*s).handler, 2 as libc::c_int, args.as_mut_ptr());
    JS_FreeValue(ctx, atom_val);
    if JS_IsException(ret1) != 0 {
        return -(1 as libc::c_int);
    }
    ret = JS_ToBoolFree(ctx, ret1);
    if ret == 0 {
        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
            flags: 0,
            value: 0,
            getter: 0,
            setter: 0,
        };
        p = (*s).target as intptr_t as *mut libc::c_void as *mut JSObject;
        res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, atom);
        if res < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if res != 0 {
            res2 = (desc.flags & (1 as libc::c_int) << 0 as libc::c_int == 0)
                as libc::c_int;
            js_free_desc(ctx, &mut desc);
            if res2 != 0 || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0 {
                JS_ThrowTypeError(
                    ctx,
                    b"proxy: inconsistent has\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        }
    }
    return ret;
}
unsafe extern "C" fn js_proxy_get(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
    mut receiver: JSValue,
) -> JSValue {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut atom_val: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    s = get_proxy_method(ctx, &mut method, obj, JS_ATOM_get as libc::c_int as JSAtom);
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsUndefined(method) != 0 {
        return JS_GetPropertyInternal(
            ctx,
            (*s).target,
            atom,
            receiver,
            FALSE as libc::c_int,
        );
    }
    atom_val = JS_AtomToValue(ctx, atom);
    if JS_IsException(atom_val) != 0 {
        JS_FreeValue(ctx, method);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = atom_val;
    args[2 as libc::c_int as usize] = receiver;
    ret = JS_CallFree(ctx, method, (*s).handler, 3 as libc::c_int, args.as_mut_ptr());
    JS_FreeValue(ctx, atom_val);
    if JS_IsException(ret) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    res = JS_GetOwnPropertyInternal(
        ctx,
        &mut desc,
        (*s).target as intptr_t as *mut libc::c_void as *mut JSObject,
        atom,
    );
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res != 0 {
        let mut current_block_22: u64;
        if desc.flags
            & ((1 as libc::c_int) << 4 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int) == 0 as libc::c_int
        {
            if js_same_value(ctx, desc.value, ret) == 0 {
                current_block_22 = 5627286933747419601;
            } else {
                current_block_22 = 3437258052017859086;
            }
        } else if desc.flags
            & ((1 as libc::c_int) << 4 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int)
            == (1 as libc::c_int) << 4 as libc::c_int
        {
            if JS_IsUndefined(desc.getter) != 0 && JS_IsUndefined(ret) == 0 {
                current_block_22 = 5627286933747419601;
            } else {
                current_block_22 = 3437258052017859086;
            }
        } else {
            current_block_22 = 3437258052017859086;
        }
        match current_block_22 {
            3437258052017859086 => {}
            _ => {
                js_free_desc(ctx, &mut desc);
                JS_FreeValue(ctx, ret);
                return JS_ThrowTypeError(
                    ctx,
                    b"proxy: inconsistent get\0" as *const u8 as *const libc::c_char,
                );
            }
        }
        js_free_desc(ctx, &mut desc);
    }
    return ret;
}
unsafe extern "C" fn js_proxy_set(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
    mut value: JSValue,
    mut receiver: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret1: JSValue = 0;
    let mut atom_val: JSValue = 0;
    let mut ret: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut args: [JSValue; 4] = [0; 4];
    s = get_proxy_method(ctx, &mut method, obj, JS_ATOM_set as libc::c_int as JSAtom);
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_SetPropertyGeneric(
            ctx,
            (*s).target,
            atom,
            JS_DupValue(ctx, value),
            receiver,
            flags,
        );
    }
    atom_val = JS_AtomToValue(ctx, atom);
    if JS_IsException(atom_val) != 0 {
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = atom_val;
    args[2 as libc::c_int as usize] = value;
    args[3 as libc::c_int as usize] = receiver;
    ret1 = JS_CallFree(ctx, method, (*s).handler, 4 as libc::c_int, args.as_mut_ptr());
    JS_FreeValue(ctx, atom_val);
    if JS_IsException(ret1) != 0 {
        return -(1 as libc::c_int);
    }
    ret = JS_ToBoolFree(ctx, ret1);
    if ret != 0 {
        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
            flags: 0,
            value: 0,
            getter: 0,
            setter: 0,
        };
        res = JS_GetOwnPropertyInternal(
            ctx,
            &mut desc,
            (*s).target as intptr_t as *mut libc::c_void as *mut JSObject,
            atom,
        );
        if res < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if res != 0 {
            let mut current_block_25: u64;
            if desc.flags
                & ((1 as libc::c_int) << 4 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int) == 0 as libc::c_int
            {
                if js_same_value(ctx, desc.value, value) == 0 {
                    current_block_25 = 12727902683391250719;
                } else {
                    current_block_25 = 11932355480408055363;
                }
            } else if desc.flags
                & ((1 as libc::c_int) << 4 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int)
                == (1 as libc::c_int) << 4 as libc::c_int
                && JS_IsUndefined(desc.setter) != 0
            {
                current_block_25 = 12727902683391250719;
            } else {
                current_block_25 = 11932355480408055363;
            }
            match current_block_25 {
                11932355480408055363 => {}
                _ => {
                    js_free_desc(ctx, &mut desc);
                    JS_ThrowTypeError(
                        ctx,
                        b"proxy: inconsistent set\0" as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            }
            js_free_desc(ctx, &mut desc);
        }
    } else if flags & (1 as libc::c_int) << 14 as libc::c_int != 0
        || flags & (1 as libc::c_int) << 15 as libc::c_int != 0
            && is_strict_mode(ctx) != 0
    {
        JS_ThrowTypeError(
            ctx,
            b"proxy: cannot set property\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    return ret;
}
unsafe extern "C" fn js_create_desc(
    mut ctx: *mut JSContext,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut ret: JSValue = 0;
    ret = JS_NewObject(ctx);
    if JS_IsException(ret) != 0 {
        return ret;
    }
    if flags & (1 as libc::c_int) << 11 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_get as libc::c_int as JSAtom,
            JS_DupValue(ctx, getter),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    if flags & (1 as libc::c_int) << 12 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_set as libc::c_int as JSAtom,
            JS_DupValue(ctx, setter),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_value as libc::c_int as JSAtom,
            JS_DupValue(ctx, val),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    if flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_writable as libc::c_int as JSAtom,
            JS_NewBool(
                ctx,
                (flags & (1 as libc::c_int) << 1 as libc::c_int != 0 as libc::c_int)
                    as libc::c_int,
            ),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    if flags & (1 as libc::c_int) << 10 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_enumerable as libc::c_int as JSAtom,
            JS_NewBool(
                ctx,
                (flags & (1 as libc::c_int) << 2 as libc::c_int != 0 as libc::c_int)
                    as libc::c_int,
            ),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    if flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        JS_DefinePropertyValue(
            ctx,
            ret,
            JS_ATOM_configurable as libc::c_int as JSAtom,
            JS_NewBool(
                ctx,
                (flags & (1 as libc::c_int) << 0 as libc::c_int != 0 as libc::c_int)
                    as libc::c_int,
            ),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
    }
    return ret;
}
unsafe extern "C" fn js_proxy_get_own_property(
    mut ctx: *mut JSContext,
    mut pdesc: *mut JSPropertyDescriptor,
    mut obj: JSValue,
    mut prop: JSAtom,
) -> libc::c_int {
    let mut flags1: libc::c_int = 0;
    let mut extensible_target: libc::c_int = 0;
    let mut current_block: u64;
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut trap_result_obj: JSValue = 0;
    let mut prop_val: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut target_desc_ret: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut args: [JSValue; 2] = [0; 2];
    let mut result_desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut target_desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_getOwnPropertyDescriptor as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    p = (*s).target as intptr_t as *mut libc::c_void as *mut JSObject;
    if JS_IsUndefined(method) != 0 {
        return JS_GetOwnPropertyInternal(ctx, pdesc, p, prop);
    }
    prop_val = JS_AtomToValue(ctx, prop);
    if JS_IsException(prop_val) != 0 {
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = prop_val;
    trap_result_obj = JS_CallFree(
        ctx,
        method,
        (*s).handler,
        2 as libc::c_int,
        args.as_mut_ptr(),
    );
    JS_FreeValue(ctx, prop_val);
    if JS_IsException(trap_result_obj) != 0 {
        return -(1 as libc::c_int);
    }
    if JS_IsObject(trap_result_obj) == 0 && JS_IsUndefined(trap_result_obj) == 0 {
        JS_FreeValue(ctx, trap_result_obj);
    } else {
        target_desc_ret = JS_GetOwnPropertyInternal(ctx, &mut target_desc, p, prop);
        if target_desc_ret < 0 as libc::c_int {
            JS_FreeValue(ctx, trap_result_obj);
            return -(1 as libc::c_int);
        }
        if target_desc_ret != 0 {
            js_free_desc(ctx, &mut target_desc);
        }
        if JS_IsUndefined(trap_result_obj) != 0 {
            if target_desc_ret != 0 {
                if target_desc.flags & (1 as libc::c_int) << 0 as libc::c_int == 0
                    || ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
                {
                    current_block = 1082032677273684591;
                } else {
                    current_block = 7205609094909031804;
                }
            } else {
                current_block = 7205609094909031804;
            }
            match current_block {
                1082032677273684591 => {}
                _ => {
                    ret = FALSE as libc::c_int;
                    current_block = 8835654301469918283;
                }
            }
        } else {
            flags1 = 0;
            extensible_target = 0;
            extensible_target = JS_IsExtensible(ctx, (*s).target);
            if extensible_target < 0 as libc::c_int {
                JS_FreeValue(ctx, trap_result_obj);
                return -(1 as libc::c_int);
            }
            res = js_obj_to_desc(ctx, &mut result_desc, trap_result_obj);
            JS_FreeValue(ctx, trap_result_obj);
            if res < 0 as libc::c_int {
                return -(1 as libc::c_int);
            }
            if target_desc_ret != 0 {
                flags1 = result_desc.flags | (1 as libc::c_int) << 8 as libc::c_int
                    | (1 as libc::c_int) << 10 as libc::c_int;
                if result_desc.flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                    flags1
                        |= (1 as libc::c_int) << 11 as libc::c_int
                            | (1 as libc::c_int) << 12 as libc::c_int;
                } else {
                    flags1
                        |= (1 as libc::c_int) << 13 as libc::c_int
                            | (1 as libc::c_int) << 9 as libc::c_int;
                }
                if check_define_prop_flags(target_desc.flags, flags1) == 0 {
                    current_block = 13444887745288837131;
                } else {
                    current_block = 14775119014532381840;
                }
            } else if extensible_target == 0 {
                current_block = 13444887745288837131;
            } else {
                current_block = 14775119014532381840;
            }
            match current_block {
                14775119014532381840 => {
                    if result_desc.flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                        if target_desc_ret == 0
                            || target_desc.flags & (1 as libc::c_int) << 0 as libc::c_int
                                != 0
                        {
                            current_block = 13444887745288837131;
                        } else if result_desc.flags
                            & ((1 as libc::c_int) << 4 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int)
                            == 0 as libc::c_int && target_desc_ret != 0
                            && target_desc.flags & (1 as libc::c_int) << 1 as libc::c_int
                                != 0 as libc::c_int
                        {
                            current_block = 13444887745288837131;
                        } else {
                            current_block = 1854459640724737493;
                        }
                    } else {
                        current_block = 1854459640724737493;
                    }
                    match current_block {
                        13444887745288837131 => {}
                        _ => {
                            ret = TRUE as libc::c_int;
                            if !pdesc.is_null() {
                                *pdesc = result_desc;
                            } else {
                                js_free_desc(ctx, &mut result_desc);
                            }
                            current_block = 8835654301469918283;
                        }
                    }
                }
                _ => {}
            }
            match current_block {
                8835654301469918283 => {}
                _ => {
                    js_free_desc(ctx, &mut result_desc);
                    current_block = 1082032677273684591;
                }
            }
        }
        match current_block {
            1082032677273684591 => {}
            _ => return ret,
        }
    }
    JS_ThrowTypeError(
        ctx,
        b"proxy: inconsistent getOwnPropertyDescriptor\0" as *const u8
            as *const libc::c_char,
    );
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_proxy_define_own_property(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut prop: JSAtom,
    mut val: JSValue,
    mut getter: JSValue,
    mut setter: JSValue,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret1: JSValue = 0;
    let mut prop_val: JSValue = 0;
    let mut desc_val: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut args: [JSValue; 3] = [0; 3];
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut setting_not_configurable: BOOL = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_defineProperty as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_DefineProperty(ctx, (*s).target, prop, val, getter, setter, flags);
    }
    prop_val = JS_AtomToValue(ctx, prop);
    if JS_IsException(prop_val) != 0 {
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    desc_val = js_create_desc(ctx, val, getter, setter, flags);
    if JS_IsException(desc_val) != 0 {
        JS_FreeValue(ctx, prop_val);
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = prop_val;
    args[2 as libc::c_int as usize] = desc_val;
    ret1 = JS_CallFree(ctx, method, (*s).handler, 3 as libc::c_int, args.as_mut_ptr());
    JS_FreeValue(ctx, prop_val);
    JS_FreeValue(ctx, desc_val);
    if JS_IsException(ret1) != 0 {
        return -(1 as libc::c_int);
    }
    ret = JS_ToBoolFree(ctx, ret1);
    if ret == 0 {
        if flags & (1 as libc::c_int) << 14 as libc::c_int != 0 {
            JS_ThrowTypeError(
                ctx,
                b"proxy: defineProperty exception\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        } else {
            return 0 as libc::c_int
        }
    }
    p = (*s).target as intptr_t as *mut libc::c_void as *mut JSObject;
    res = JS_GetOwnPropertyInternal(ctx, &mut desc, p, prop);
    if res < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    setting_not_configurable = (flags
        & ((1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 0 as libc::c_int)
        == (1 as libc::c_int) << 8 as libc::c_int) as libc::c_int;
    if res == 0 {
        if ((*p).c2rust_unnamed.c2rust_unnamed).extensible() == 0
            || setting_not_configurable != 0
        {
            current_block = 6046102561768012752;
        } else {
            current_block = 2116367355679836638;
        }
    } else {
        if check_define_prop_flags(desc.flags, flags) == 0
            || desc.flags & (1 as libc::c_int) << 0 as libc::c_int != 0
                && setting_not_configurable != 0
        {
            current_block = 14808134129964231731;
        } else {
            if flags
                & ((1 as libc::c_int) << 11 as libc::c_int
                    | (1 as libc::c_int) << 12 as libc::c_int) != 0
            {
                if desc.flags
                    & ((1 as libc::c_int) << 4 as libc::c_int
                        | (1 as libc::c_int) << 0 as libc::c_int)
                    == (1 as libc::c_int) << 4 as libc::c_int
                {
                    if flags & (1 as libc::c_int) << 11 as libc::c_int != 0
                        && js_same_value(ctx, getter, desc.getter) == 0
                    {
                        current_block = 14808134129964231731;
                    } else if flags & (1 as libc::c_int) << 12 as libc::c_int != 0
                        && js_same_value(ctx, setter, desc.setter) == 0
                    {
                        current_block = 14808134129964231731;
                    } else {
                        current_block = 10095721787123848864;
                    }
                } else {
                    current_block = 10095721787123848864;
                }
            } else if flags & (1 as libc::c_int) << 13 as libc::c_int != 0 {
                if desc.flags
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int)
                    == (1 as libc::c_int) << 1 as libc::c_int
                    && flags & (1 as libc::c_int) << 1 as libc::c_int == 0
                {
                    current_block = 14808134129964231731;
                } else if desc.flags
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int) == 0 as libc::c_int
                    && js_same_value(ctx, val, desc.value) == 0
                {
                    current_block = 14808134129964231731;
                } else {
                    current_block = 10095721787123848864;
                }
            } else {
                current_block = 10095721787123848864;
            }
            match current_block {
                14808134129964231731 => {}
                _ => {
                    if flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
                        if desc.flags
                            & ((1 as libc::c_int) << 4 as libc::c_int
                                | (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int)
                            == (1 as libc::c_int) << 1 as libc::c_int
                        {
                            current_block = 14808134129964231731;
                        } else {
                            current_block = 2520131295878969859;
                        }
                    } else {
                        current_block = 2520131295878969859;
                    }
                    match current_block {
                        14808134129964231731 => {}
                        _ => {
                            js_free_desc(ctx, &mut desc);
                            current_block = 2116367355679836638;
                        }
                    }
                }
            }
        }
        match current_block {
            2116367355679836638 => {}
            _ => {
                js_free_desc(ctx, &mut desc);
                current_block = 6046102561768012752;
            }
        }
    }
    match current_block {
        2116367355679836638 => return 1 as libc::c_int,
        _ => {
            JS_ThrowTypeError(
                ctx,
                b"proxy: inconsistent defineProperty\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn js_proxy_delete_property(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut atom_val: JSValue = 0;
    let mut res: libc::c_int = 0;
    let mut res2: libc::c_int = 0;
    let mut is_extensible: libc::c_int = 0;
    let mut args: [JSValue; 2] = [0; 2];
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_deleteProperty as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_DeleteProperty(ctx, (*s).target, atom, 0 as libc::c_int);
    }
    atom_val = JS_AtomToValue(ctx, atom);
    if JS_IsException(atom_val) != 0 {
        JS_FreeValue(ctx, method);
        return -(1 as libc::c_int);
    }
    args[0 as libc::c_int as usize] = (*s).target;
    args[1 as libc::c_int as usize] = atom_val;
    ret = JS_CallFree(ctx, method, (*s).handler, 2 as libc::c_int, args.as_mut_ptr());
    JS_FreeValue(ctx, atom_val);
    if JS_IsException(ret) != 0 {
        return -(1 as libc::c_int);
    }
    res = JS_ToBoolFree(ctx, ret);
    if res != 0 {
        let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
            flags: 0,
            value: 0,
            getter: 0,
            setter: 0,
        };
        res2 = JS_GetOwnPropertyInternal(
            ctx,
            &mut desc,
            (*s).target as intptr_t as *mut libc::c_void as *mut JSObject,
            atom,
        );
        if res2 < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        if res2 != 0 {
            's_155: {
                let mut current_block_26: u64;
                if desc.flags & (1 as libc::c_int) << 0 as libc::c_int == 0 {
                    current_block_26 = 12301747958388283457;
                } else {
                    is_extensible = JS_IsExtensible(ctx, (*s).target);
                    if is_extensible < 0 as libc::c_int {
                        current_block_26 = 6959127064677330506;
                    } else if is_extensible == 0 {
                        current_block_26 = 12301747958388283457;
                    } else {
                        js_free_desc(ctx, &mut desc);
                        break 's_155;
                    }
                }
                match current_block_26 {
                    12301747958388283457 => {
                        JS_ThrowTypeError(
                            ctx,
                            b"proxy: inconsistent deleteProperty\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
                js_free_desc(ctx, &mut desc);
                return -(1 as libc::c_int);
            }
        }
    }
    return res;
}
unsafe extern "C" fn find_prop_key(
    mut tab: *const JSPropertyEnum,
    mut n: libc::c_int,
    mut atom: JSAtom,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < n {
        if (*tab.offset(i as isize)).atom == atom {
            return i;
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_proxy_get_own_property_names(
    mut ctx: *mut JSContext,
    mut ptab: *mut *mut JSPropertyEnum,
    mut plen: *mut uint32_t,
    mut obj: JSValue,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut prop_array: JSValue = 0;
    let mut val: JSValue = 0;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut len2: uint32_t = 0;
    let mut tab: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut tab2: *mut JSPropertyEnum = 0 as *mut JSPropertyEnum;
    let mut atom: JSAtom = 0;
    let mut desc: JSPropertyDescriptor = JSPropertyDescriptor {
        flags: 0,
        value: 0,
        getter: 0,
        setter: 0,
    };
    let mut res: libc::c_int = 0;
    let mut is_extensible: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    s = get_proxy_method(
        ctx,
        &mut method,
        obj,
        JS_ATOM_ownKeys as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    if JS_IsUndefined(method) != 0 {
        return JS_GetOwnPropertyNamesInternal(
            ctx,
            ptab,
            plen,
            (*s).target as intptr_t as *mut libc::c_void as *mut JSObject,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int,
        );
    }
    prop_array = JS_CallFree(
        ctx,
        method,
        (*s).handler,
        1 as libc::c_int,
        &mut (*s).target as *mut JSValue,
    );
    if JS_IsException(prop_array) != 0 {
        return -(1 as libc::c_int);
    }
    tab = 0 as *mut JSPropertyEnum;
    len = 0 as libc::c_int as uint32_t;
    tab2 = 0 as *mut JSPropertyEnum;
    len2 = 0 as libc::c_int as uint32_t;
    if !(js_get_length32(ctx, &mut len, prop_array) != 0) {
        if len > 0 as libc::c_int as libc::c_uint {
            tab = js_mallocz(
                ctx,
                (::core::mem::size_of::<JSPropertyEnum>() as libc::c_ulong)
                    .wrapping_mul(len as libc::c_ulong),
            ) as *mut JSPropertyEnum;
            if tab.is_null() {
                current_block = 11079151863293658391;
            } else {
                current_block = 12124785117276362961;
            }
        } else {
            current_block = 12124785117276362961;
        }
        match current_block {
            11079151863293658391 => {}
            _ => {
                i = 0 as libc::c_int as uint32_t;
                loop {
                    if !(i < len) {
                        current_block = 652864300344834934;
                        break;
                    }
                    val = JS_GetPropertyUint32(ctx, prop_array, i);
                    if JS_IsException(val) != 0 {
                        current_block = 11079151863293658391;
                        break;
                    }
                    if JS_IsString(val) == 0 && JS_IsSymbol(val) == 0 {
                        JS_FreeValue(ctx, val);
                        JS_ThrowTypeError(
                            ctx,
                            b"proxy: properties must be strings or symbols\0"
                                as *const u8 as *const libc::c_char,
                        );
                        current_block = 11079151863293658391;
                        break;
                    } else {
                        atom = JS_ValueToAtom(ctx, val);
                        JS_FreeValue(ctx, val);
                        if atom == 0 as libc::c_int as libc::c_uint {
                            current_block = 11079151863293658391;
                            break;
                        }
                        (*tab.offset(i as isize)).atom = atom;
                        (*tab.offset(i as isize)).is_enumerable = FALSE as libc::c_int;
                        i = i.wrapping_add(1);
                    }
                }
                match current_block {
                    11079151863293658391 => {}
                    _ => {
                        i = 1 as libc::c_int as uint32_t;
                        loop {
                            if !(i < len) {
                                current_block = 6417057564578538666;
                                break;
                            }
                            if find_prop_key(
                                tab,
                                i as libc::c_int,
                                (*tab.offset(i as isize)).atom,
                            ) >= 0 as libc::c_int
                            {
                                JS_ThrowTypeError(
                                    ctx,
                                    b"proxy: duplicate property\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 11079151863293658391;
                                break;
                            } else {
                                i = i.wrapping_add(1);
                            }
                        }
                        match current_block {
                            11079151863293658391 => {}
                            _ => {
                                is_extensible = JS_IsExtensible(ctx, (*s).target);
                                if !(is_extensible < 0 as libc::c_int) {
                                    if (*s).is_revoked != 0 {
                                        JS_ThrowTypeErrorRevokedProxy(ctx);
                                    } else if !(JS_GetOwnPropertyNamesInternal(
                                        ctx,
                                        &mut tab2,
                                        &mut len2,
                                        (*s).target as intptr_t as *mut libc::c_void
                                            as *mut JSObject,
                                        (1 as libc::c_int) << 0 as libc::c_int
                                            | (1 as libc::c_int) << 1 as libc::c_int,
                                    ) != 0)
                                    {
                                        i = 0 as libc::c_int as uint32_t;
                                        loop {
                                            if !(i < len2) {
                                                current_block = 4741994311446740739;
                                                break;
                                            }
                                            if (*s).is_revoked != 0 {
                                                JS_ThrowTypeErrorRevokedProxy(ctx);
                                                current_block = 11079151863293658391;
                                                break;
                                            } else {
                                                res = JS_GetOwnPropertyInternal(
                                                    ctx,
                                                    &mut desc,
                                                    (*s).target as intptr_t as *mut libc::c_void
                                                        as *mut JSObject,
                                                    (*tab2.offset(i as isize)).atom,
                                                );
                                                if res < 0 as libc::c_int {
                                                    current_block = 11079151863293658391;
                                                    break;
                                                }
                                                if res != 0 {
                                                    js_free_desc(ctx, &mut desc);
                                                    if desc.flags & (1 as libc::c_int) << 0 as libc::c_int == 0
                                                        || is_extensible == 0
                                                    {
                                                        idx = find_prop_key(
                                                            tab,
                                                            len as libc::c_int,
                                                            (*tab2.offset(i as isize)).atom,
                                                        );
                                                        if idx < 0 as libc::c_int {
                                                            JS_ThrowTypeError(
                                                                ctx,
                                                                b"proxy: target property must be present in proxy ownKeys\0"
                                                                    as *const u8 as *const libc::c_char,
                                                            );
                                                            current_block = 11079151863293658391;
                                                            break;
                                                        } else if is_extensible == 0 {
                                                            (*tab.offset(idx as isize))
                                                                .is_enumerable = TRUE as libc::c_int;
                                                        }
                                                    }
                                                }
                                                i = i.wrapping_add(1);
                                            }
                                        }
                                        match current_block {
                                            11079151863293658391 => {}
                                            _ => {
                                                if is_extensible == 0 {
                                                    i = 0 as libc::c_int as uint32_t;
                                                    loop {
                                                        if !(i < len) {
                                                            current_block = 1874315696050160458;
                                                            break;
                                                        }
                                                        if (*tab.offset(i as isize)).is_enumerable == 0 {
                                                            JS_ThrowTypeError(
                                                                ctx,
                                                                b"proxy: property not present in target were returned by non extensible proxy\0"
                                                                    as *const u8 as *const libc::c_char,
                                                            );
                                                            current_block = 11079151863293658391;
                                                            break;
                                                        } else {
                                                            i = i.wrapping_add(1);
                                                        }
                                                    }
                                                } else {
                                                    current_block = 1874315696050160458;
                                                }
                                                match current_block {
                                                    11079151863293658391 => {}
                                                    _ => {
                                                        js_free_prop_enum(ctx, tab2, len2);
                                                        JS_FreeValue(ctx, prop_array);
                                                        *ptab = tab;
                                                        *plen = len;
                                                        return 0 as libc::c_int;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    js_free_prop_enum(ctx, tab2, len2);
    js_free_prop_enum(ctx, tab, len);
    JS_FreeValue(ctx, prop_array);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn js_proxy_call_constructor(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut arg_array: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    s = get_proxy_method(
        ctx,
        &mut method,
        func_obj,
        JS_ATOM_construct as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsConstructor(ctx, (*s).target) == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"not a constructor\0" as *const u8 as *const libc::c_char,
        );
    }
    if JS_IsUndefined(method) != 0 {
        return JS_CallConstructor2(ctx, (*s).target, new_target, argc, argv);
    }
    arg_array = js_create_array(ctx, argc, argv);
    if JS_IsException(arg_array) != 0 {
        ret = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        args[0 as libc::c_int as usize] = (*s).target;
        args[1 as libc::c_int as usize] = arg_array;
        args[2 as libc::c_int as usize] = new_target;
        ret = JS_Call(ctx, method, (*s).handler, 3 as libc::c_int, args.as_mut_ptr());
        if JS_IsException(ret) == 0
            && (ret >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int
        {
            JS_FreeValue(ctx, ret);
            ret = JS_ThrowTypeErrorNotAnObject(ctx);
        }
    }
    JS_FreeValue(ctx, method);
    JS_FreeValue(ctx, arg_array);
    return ret;
}
unsafe extern "C" fn js_proxy_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    let mut method: JSValue = 0;
    let mut arg_array: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    if flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);
    }
    s = get_proxy_method(
        ctx,
        &mut method,
        func_obj,
        JS_ATOM_apply as libc::c_int as JSAtom,
    );
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (*s).is_func == 0 {
        JS_FreeValue(ctx, method);
        return JS_ThrowTypeError(
            ctx,
            b"not a function\0" as *const u8 as *const libc::c_char,
        );
    }
    if JS_IsUndefined(method) != 0 {
        return JS_Call(ctx, (*s).target, this_obj, argc, argv);
    }
    arg_array = js_create_array(ctx, argc, argv);
    if JS_IsException(arg_array) != 0 {
        ret = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        args[0 as libc::c_int as usize] = (*s).target;
        args[1 as libc::c_int as usize] = this_obj;
        args[2 as libc::c_int as usize] = arg_array;
        ret = JS_Call(ctx, method, (*s).handler, 3 as libc::c_int, args.as_mut_ptr());
    }
    JS_FreeValue(ctx, method);
    JS_FreeValue(ctx, arg_array);
    return ret;
}
unsafe extern "C" fn js_proxy_isArray(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut s: *mut JSProxyData = JS_GetOpaque(
        obj,
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    ) as *mut JSProxyData;
    if s.is_null() {
        return FALSE as libc::c_int;
    }
    if (*s).is_revoked != 0 {
        JS_ThrowTypeErrorRevokedProxy(ctx);
        return -(1 as libc::c_int);
    }
    return JS_IsArray(ctx, (*s).target);
}
static mut js_proxy_exotic_methods: JSClassExoticMethods = unsafe {
    {
        let mut init = JSClassExoticMethods {
            get_own_property: Some(
                js_proxy_get_own_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        *mut JSPropertyDescriptor,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            get_own_property_names: Some(
                js_proxy_get_own_property_names
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        *mut *mut JSPropertyEnum,
                        *mut uint32_t,
                        JSValue,
                    ) -> libc::c_int,
            ),
            delete_property: Some(
                js_proxy_delete_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            define_own_property: Some(
                js_proxy_define_own_property
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                        JSValue,
                        JSValue,
                        JSValue,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            has_property: Some(
                js_proxy_has
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                    ) -> libc::c_int,
            ),
            get_property: Some(
                js_proxy_get
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                        JSValue,
                    ) -> JSValue,
            ),
            set_property: Some(
                js_proxy_set
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        JSAtom,
                        JSValue,
                        JSValue,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn js_proxy_constructor(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut target: JSValue = 0;
    let mut handler: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut s: *mut JSProxyData = 0 as *mut JSProxyData;
    target = *argv.offset(0 as libc::c_int as isize);
    handler = *argv.offset(1 as libc::c_int as isize);
    if (target >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int
        || (handler >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int
    {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    obj = JS_NewObjectProtoClass(
        ctx,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    );
    if JS_IsException(obj) != 0 {
        return obj;
    }
    s = js_malloc(ctx, ::core::mem::size_of::<JSProxyData>() as libc::c_ulong)
        as *mut JSProxyData;
    if s.is_null() {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).target = JS_DupValue(ctx, target);
    (*s).handler = JS_DupValue(ctx, handler);
    (*s).is_func = JS_IsFunction(ctx, target) as uint8_t;
    (*s).is_revoked = FALSE as libc::c_int as uint8_t;
    JS_SetOpaque(obj, s as *mut libc::c_void);
    JS_SetConstructorBit(ctx, obj, JS_IsConstructor(ctx, target));
    return obj;
}
unsafe extern "C" fn js_proxy_revoke(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    let mut s: *mut JSProxyData = JS_GetOpaque(
        *func_data.offset(0 as libc::c_int as isize),
        JS_CLASS_PROXY as libc::c_int as JSClassID,
    ) as *mut JSProxyData;
    if !s.is_null() {
        (*s).is_revoked = TRUE as libc::c_int as uint8_t;
        JS_FreeValue(ctx, *func_data.offset(0 as libc::c_int as isize));
        *func_data
            .offset(
                0 as libc::c_int as isize,
            ) = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_proxy_revoke_constructor(
    mut ctx: *mut JSContext,
    mut proxy_obj: JSValue,
) -> JSValue {
    return JS_NewCFunctionData(
        ctx,
        Some(
            js_proxy_revoke
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        0 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
        &mut proxy_obj,
    );
}
unsafe extern "C" fn js_proxy_revocable(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut proxy_obj: JSValue = 0;
    let mut revoke_obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut obj: JSValue = 0;
    proxy_obj = js_proxy_constructor(
        ctx,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        argc,
        argv,
    );
    if !(JS_IsException(proxy_obj) != 0) {
        revoke_obj = js_proxy_revoke_constructor(ctx, proxy_obj);
        if !(JS_IsException(revoke_obj) != 0) {
            obj = JS_NewObject(ctx);
            if !(JS_IsException(obj) != 0) {
                JS_DefinePropertyValue(
                    ctx,
                    obj,
                    JS_ATOM_proxy as libc::c_int as JSAtom,
                    proxy_obj,
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                );
                JS_DefinePropertyValue(
                    ctx,
                    obj,
                    JS_ATOM_revoke as libc::c_int as JSAtom,
                    revoke_obj,
                    (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int,
                );
                return obj;
            }
        }
    }
    JS_FreeValue(ctx, proxy_obj);
    JS_FreeValue(ctx, revoke_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
static mut js_proxy_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"revocable\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_proxy_revocable
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_proxy_class_def: [JSClassShortDef; 1] = unsafe {
    [
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Object as libc::c_int as JSAtom,
                finalizer: Some(
                    js_proxy_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_proxy_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicProxy(mut ctx: *mut JSContext) {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut obj1: JSValue = 0;
    if JS_IsRegisteredClass(rt, JS_CLASS_PROXY as libc::c_int as JSClassID) == 0 {
        init_class_range(
            rt,
            js_proxy_class_def.as_ptr(),
            JS_CLASS_PROXY as libc::c_int,
            (::core::mem::size_of::<[JSClassShortDef; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<JSClassShortDef>() as libc::c_ulong)
                as libc::c_int,
        );
        let ref mut fresh686 = (*((*rt).class_array)
            .offset(JS_CLASS_PROXY as libc::c_int as isize))
            .exotic;
        *fresh686 = &js_proxy_exotic_methods;
        let ref mut fresh687 = (*((*rt).class_array)
            .offset(JS_CLASS_PROXY as libc::c_int as isize))
            .call;
        *fresh687 = Some(
            js_proxy_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
    }
    obj1 = JS_NewCFunction2(
        ctx,
        Some(
            js_proxy_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        b"Proxy\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        JS_CFUNC_constructor,
        0 as libc::c_int,
    );
    JS_SetConstructorBit(ctx, obj1, TRUE as libc::c_int);
    JS_SetPropertyFunctionList(
        ctx,
        obj1,
        js_proxy_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_DefinePropertyValueStr(
        ctx,
        (*ctx).global_obj,
        b"Proxy\0" as *const u8 as *const libc::c_char,
        obj1,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
}
unsafe extern "C" fn js_symbol_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut p: *mut JSString = 0 as *mut JSString;
    if JS_IsUndefined(new_target) == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"not a constructor\0" as *const u8 as *const libc::c_char,
        );
    }
    if argc == 0 as libc::c_int
        || JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) != 0
    {
        p = 0 as *mut JSString;
    } else {
        str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
        if JS_IsException(str) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        p = str as intptr_t as *mut libc::c_void as *mut JSString;
    }
    return JS_NewSymbol(ctx, p, JS_ATOM_TYPE_SYMBOL as libc::c_int);
}
unsafe extern "C" fn js_thisSymbolValue(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_SYMBOL as libc::c_int {
        return JS_DupValue(ctx, this_val);
    }
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_SYMBOL as libc::c_int
        {
            if ((*p).u.object_data >> 32 as libc::c_int) as libc::c_int
                == JS_TAG_SYMBOL as libc::c_int
            {
                return JS_DupValue(ctx, (*p).u.object_data);
            }
        }
    }
    return JS_ThrowTypeError(ctx, b"not a symbol\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn js_symbol_toString(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    val = js_thisSymbolValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    ret = js_string_constructor(
        ctx,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        1 as libc::c_int,
        &mut val as *mut JSValue,
    );
    JS_FreeValue(ctx, val);
    return ret;
}
unsafe extern "C" fn js_symbol_valueOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return js_thisSymbolValue(ctx, this_val);
}
unsafe extern "C" fn js_symbol_get_description(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut val: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    val = js_thisSymbolValue(ctx, this_val);
    if JS_IsException(val) != 0 {
        return val;
    }
    p = val as intptr_t as *mut libc::c_void as *mut JSAtomStruct;
    if (*p).len() as libc::c_int == 0 as libc::c_int
        && (*p).is_wide_char() as libc::c_int != 0 as libc::c_int
    {
        ret = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        ret = JS_AtomToString(ctx, js_get_atom_index((*ctx).rt, p));
    }
    JS_FreeValue(ctx, val);
    return ret;
}
static mut js_symbol_proto_funcs: [JSCFunctionListEntry; 5] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_symbol_toString
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_symbol_valueOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toPrimitive]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_symbol_valueOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Symbol\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"description\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_symbol_get_description
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_symbol_for(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewSymbol(
        ctx,
        str as intptr_t as *mut libc::c_void as *mut JSString,
        JS_ATOM_TYPE_GLOBAL_SYMBOL as libc::c_int,
    );
}
unsafe extern "C" fn js_symbol_keyFor(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSAtomStruct = 0 as *mut JSAtomStruct;
    if JS_IsSymbol(*argv.offset(0 as libc::c_int as isize)) == 0 {
        return JS_ThrowTypeError(
            ctx,
            b"not a symbol\0" as *const u8 as *const libc::c_char,
        );
    }
    p = *argv.offset(0 as libc::c_int as isize) as intptr_t as *mut libc::c_void
        as *mut JSAtomStruct;
    if (*p).atom_type() as libc::c_int != JS_ATOM_TYPE_GLOBAL_SYMBOL as libc::c_int {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_DupValue(
        ctx,
        (JS_TAG_STRING as libc::c_int as uint64_t) << 32 as libc::c_int
            | p as uintptr_t as libc::c_ulonglong,
    );
}
static mut js_symbol_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"for\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_symbol_for
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keyFor\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_symbol_keyFor
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_map_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    let mut obj: JSValue = 0;
    let mut adder: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut iter: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut arr: JSValue = 0;
    let mut is_set: BOOL = 0;
    let mut is_weak: BOOL = 0;
    is_set = magic & (1 as libc::c_int) << 0 as libc::c_int;
    is_weak = (magic & (1 as libc::c_int) << 1 as libc::c_int != 0 as libc::c_int)
        as libc::c_int;
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_MAP as libc::c_int + magic);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    s = js_mallocz(ctx, ::core::mem::size_of::<JSMapState>() as libc::c_ulong)
        as *mut JSMapState;
    if !s.is_null() {
        init_list_head(&mut (*s).records);
        (*s).is_weak = is_weak;
        JS_SetOpaque(obj, s as *mut libc::c_void);
        (*s).hash_size = 1 as libc::c_int as uint32_t;
        let ref mut fresh688 = (*s).hash_table;
        *fresh688 = js_malloc(
            ctx,
            (::core::mem::size_of::<list_head>() as libc::c_ulong)
                .wrapping_mul((*s).hash_size as libc::c_ulong),
        ) as *mut list_head;
        if !((*s).hash_table).is_null() {
            init_list_head(&mut *((*s).hash_table).offset(0 as libc::c_int as isize));
            (*s).record_count_threshold = 4 as libc::c_int as uint32_t;
            arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if argc > 0 as libc::c_int {
                arr = *argv.offset(0 as libc::c_int as isize);
            }
            if JS_IsUndefined(arr) == 0 && JS_IsNull(arr) == 0 {
                let mut item: JSValue = 0;
                let mut ret: JSValue = 0;
                let mut done: BOOL = 0;
                adder = JS_GetProperty(
                    ctx,
                    obj,
                    (if is_set != 0 {
                        JS_ATOM_add as libc::c_int
                    } else {
                        JS_ATOM_set as libc::c_int
                    }) as JSAtom,
                );
                if JS_IsException(adder) != 0 {
                    current_block = 17287822431366845120;
                } else if JS_IsFunction(ctx, adder) == 0 {
                    JS_ThrowTypeError(
                        ctx,
                        b"set/add is not a function\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 17287822431366845120;
                } else {
                    iter = JS_GetIterator(ctx, arr, FALSE as libc::c_int);
                    if JS_IsException(iter) != 0 {
                        current_block = 17287822431366845120;
                    } else {
                        next_method = JS_GetProperty(
                            ctx,
                            iter,
                            JS_ATOM_next as libc::c_int as JSAtom,
                        );
                        if JS_IsException(next_method) != 0 {
                            current_block = 17287822431366845120;
                        } else {
                            loop {
                                item = JS_IteratorNext(
                                    ctx,
                                    iter,
                                    next_method,
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                    &mut done,
                                );
                                if JS_IsException(item) != 0 {
                                    current_block = 17287822431366845120;
                                    break;
                                }
                                if done != 0 {
                                    JS_FreeValue(ctx, item);
                                    current_block = 6545907279487748450;
                                    break;
                                } else {
                                    if is_set != 0 {
                                        ret = JS_Call(
                                            ctx,
                                            adder,
                                            obj,
                                            1 as libc::c_int,
                                            &mut item as *mut JSValue,
                                        );
                                        if JS_IsException(ret) != 0 {
                                            JS_FreeValue(ctx, item);
                                            current_block = 17287822431366845120;
                                            break;
                                        }
                                    } else {
                                        let mut key: JSValue = 0;
                                        let mut value: JSValue = 0;
                                        let mut args: [JSValue; 2] = [0; 2];
                                        key = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                        value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                        if JS_IsObject(item) == 0 {
                                            JS_ThrowTypeErrorNotAnObject(ctx);
                                            current_block = 9756627877181123998;
                                        } else {
                                            key = JS_GetPropertyUint32(
                                                ctx,
                                                item,
                                                0 as libc::c_int as uint32_t,
                                            );
                                            if JS_IsException(key) != 0 {
                                                current_block = 9756627877181123998;
                                            } else {
                                                value = JS_GetPropertyUint32(
                                                    ctx,
                                                    item,
                                                    1 as libc::c_int as uint32_t,
                                                );
                                                if JS_IsException(value) != 0 {
                                                    current_block = 9756627877181123998;
                                                } else {
                                                    args[0 as libc::c_int as usize] = key;
                                                    args[1 as libc::c_int as usize] = value;
                                                    ret = JS_Call(
                                                        ctx,
                                                        adder,
                                                        obj,
                                                        2 as libc::c_int,
                                                        args.as_mut_ptr(),
                                                    );
                                                    if JS_IsException(ret) != 0 {
                                                        current_block = 9756627877181123998;
                                                    } else {
                                                        JS_FreeValue(ctx, key);
                                                        JS_FreeValue(ctx, value);
                                                        current_block = 5159818223158340697;
                                                    }
                                                }
                                            }
                                        }
                                        match current_block {
                                            5159818223158340697 => {}
                                            _ => {
                                                JS_FreeValue(ctx, item);
                                                JS_FreeValue(ctx, key);
                                                JS_FreeValue(ctx, value);
                                                current_block = 17287822431366845120;
                                                break;
                                            }
                                        }
                                    }
                                    JS_FreeValue(ctx, ret);
                                    JS_FreeValue(ctx, item);
                                }
                            }
                            match current_block {
                                17287822431366845120 => {}
                                _ => {
                                    JS_FreeValue(ctx, next_method);
                                    JS_FreeValue(ctx, iter);
                                    JS_FreeValue(ctx, adder);
                                    current_block = 9437013279121998969;
                                }
                            }
                        }
                    }
                }
            } else {
                current_block = 9437013279121998969;
            }
            match current_block {
                17287822431366845120 => {}
                _ => return obj,
            }
        }
    }
    if JS_IsObject(iter) != 0 {
        JS_IteratorClose(ctx, iter, TRUE as libc::c_int);
    }
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    JS_FreeValue(ctx, adder);
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn map_normalize_key(
    mut ctx: *mut JSContext,
    mut key: JSValue,
) -> JSValue {
    let mut tag: uint32_t = (key >> 32 as libc::c_int) as libc::c_int as uint32_t;
    if tag.wrapping_sub(JS_TAG_FIRST as libc::c_int as libc::c_uint)
        >= (JS_TAG_FLOAT64 as libc::c_int - JS_TAG_FIRST as libc::c_int) as libc::c_uint
        && JS_VALUE_GET_FLOAT64(key) == 0.0f64
    {
        key = JS_NewInt32(ctx, 0 as libc::c_int);
    }
    return key;
}
unsafe extern "C" fn map_hash_key(
    mut ctx: *mut JSContext,
    mut key: JSValue,
) -> uint32_t {
    let mut tag: uint32_t = JS_VALUE_GET_NORM_TAG(key) as uint32_t;
    let mut h: uint32_t = 0;
    let mut d: libc::c_double = 0.;
    let mut u: JSFloat64Union = JSFloat64Union { d: 0. };
    let mut current_block_9: u64;
    match tag {
        1 => {
            h = key as libc::c_int as uint32_t;
            current_block_9 = 4956146061682418353;
        }
        4294967289 => {
            h = hash_string(
                key as intptr_t as *mut libc::c_void as *mut JSString,
                0 as libc::c_int as uint32_t,
            );
            current_block_9 = 4956146061682418353;
        }
        4294967295 | 4294967288 => {
            h = (key as intptr_t as *mut libc::c_void as uintptr_t)
                .wrapping_mul(3163 as libc::c_int as libc::c_uint);
            current_block_9 = 4956146061682418353;
        }
        0 => {
            d = (key as libc::c_int * 3163 as libc::c_int) as libc::c_double;
            current_block_9 = 10137859750898340959;
        }
        7 => {
            d = JS_VALUE_GET_FLOAT64(key);
            if isnan(d) != 0 {
                d = 9999.9999f64;
            }
            current_block_9 = 10137859750898340959;
        }
        _ => {
            h = 0 as libc::c_int as uint32_t;
            current_block_9 = 4956146061682418353;
        }
    }
    match current_block_9 {
        10137859750898340959 => {
            u.d = d;
            h = (u.u32_0[0 as libc::c_int as usize] ^ u.u32_0[1 as libc::c_int as usize])
                .wrapping_mul(3163 as libc::c_int as libc::c_uint);
        }
        _ => {}
    }
    h ^= tag;
    return h;
}
unsafe extern "C" fn map_find_record(
    mut ctx: *mut JSContext,
    mut s: *mut JSMapState,
    mut key: JSValue,
) -> *mut JSMapRecord {
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut h: uint32_t = 0;
    h = map_hash_key(ctx, key)
        & ((*s).hash_size).wrapping_sub(1 as libc::c_int as libc::c_uint);
    el = (*((*s).hash_table).offset(h as isize)).next;
    while el != &mut *((*s).hash_table).offset(h as isize) as *mut list_head {
        mr = (el as *mut uint8_t).offset(-(24 as libc::c_ulong as isize))
            as *mut JSMapRecord;
        if js_same_value_zero(ctx, (*mr).key, key) != 0 {
            return mr;
        }
        el = (*el).next;
    }
    return 0 as *mut JSMapRecord;
}
unsafe extern "C" fn map_hash_resize(mut ctx: *mut JSContext, mut s: *mut JSMapState) {
    let mut new_hash_size: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut h: uint32_t = 0;
    let mut slack: size_t = 0;
    let mut new_hash_table: *mut list_head = 0 as *mut list_head;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    if (*s).hash_size == 1 as libc::c_int as libc::c_uint {
        new_hash_size = 4 as libc::c_int as uint32_t;
    } else {
        new_hash_size = ((*s).hash_size).wrapping_mul(2 as libc::c_int as libc::c_uint);
    }
    new_hash_table = js_realloc2(
        ctx,
        (*s).hash_table as *mut libc::c_void,
        (::core::mem::size_of::<list_head>() as libc::c_ulong)
            .wrapping_mul(new_hash_size as libc::c_ulong),
        &mut slack,
    ) as *mut list_head;
    if new_hash_table.is_null() {
        return;
    }
    new_hash_size = (new_hash_size as libc::c_ulong)
        .wrapping_add(
            slack.wrapping_div(::core::mem::size_of::<list_head>() as libc::c_ulong),
        ) as uint32_t as uint32_t;
    i = 0 as libc::c_int as uint32_t;
    while i < new_hash_size {
        init_list_head(&mut *new_hash_table.offset(i as isize));
        i = i.wrapping_add(1);
    }
    el = (*s).records.next;
    while el != &mut (*s).records as *mut list_head {
        mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
            as *mut JSMapRecord;
        if (*mr).empty == 0 {
            h = map_hash_key(ctx, (*mr).key)
                & new_hash_size.wrapping_sub(1 as libc::c_int as libc::c_uint);
            list_add_tail(&mut (*mr).hash_link, &mut *new_hash_table.offset(h as isize));
        }
        el = (*el).next;
    }
    let ref mut fresh689 = (*s).hash_table;
    *fresh689 = new_hash_table;
    (*s).hash_size = new_hash_size;
    (*s)
        .record_count_threshold = new_hash_size
        .wrapping_mul(2 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn map_add_record(
    mut ctx: *mut JSContext,
    mut s: *mut JSMapState,
    mut key: JSValue,
) -> *mut JSMapRecord {
    let mut h: uint32_t = 0;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    mr = js_malloc(ctx, ::core::mem::size_of::<JSMapRecord>() as libc::c_ulong)
        as *mut JSMapRecord;
    if mr.is_null() {
        return 0 as *mut JSMapRecord;
    }
    (*mr).ref_count = 1 as libc::c_int;
    let ref mut fresh690 = (*mr).map;
    *fresh690 = s;
    (*mr).empty = FALSE as libc::c_int;
    if (*s).is_weak != 0 {
        let mut p: *mut JSObject = key as intptr_t as *mut libc::c_void as *mut JSObject;
        let ref mut fresh691 = (*mr).next_weak_ref;
        *fresh691 = (*p).first_weak_ref;
        let ref mut fresh692 = (*p).first_weak_ref;
        *fresh692 = mr;
    } else {
        JS_DupValue(ctx, key);
    }
    (*mr).key = key;
    h = map_hash_key(ctx, key)
        & ((*s).hash_size).wrapping_sub(1 as libc::c_int as libc::c_uint);
    list_add_tail(&mut (*mr).hash_link, &mut *((*s).hash_table).offset(h as isize));
    list_add_tail(&mut (*mr).link, &mut (*s).records);
    let ref mut fresh693 = (*s).record_count;
    *fresh693 = (*fresh693).wrapping_add(1);
    if (*s).record_count >= (*s).record_count_threshold {
        map_hash_resize(ctx, s);
    }
    return mr;
}
unsafe extern "C" fn delete_weak_ref(mut rt: *mut JSRuntime, mut mr: *mut JSMapRecord) {
    let mut pmr: *mut *mut JSMapRecord = 0 as *mut *mut JSMapRecord;
    let mut mr1: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    p = (*mr).key as intptr_t as *mut libc::c_void as *mut JSObject;
    pmr = &mut (*p).first_weak_ref;
    loop {
        mr1 = *pmr;
        assert((mr1 != 0 as *mut libc::c_void as *mut JSMapRecord) as libc::c_int);
        if mr1 == mr {
            break;
        }
        pmr = &mut (*mr1).next_weak_ref;
    }
    *pmr = (*mr1).next_weak_ref;
}
unsafe extern "C" fn map_delete_record(
    mut rt: *mut JSRuntime,
    mut s: *mut JSMapState,
    mut mr: *mut JSMapRecord,
) {
    if (*mr).empty != 0 {
        return;
    }
    list_del(&mut (*mr).hash_link);
    if (*s).is_weak != 0 {
        delete_weak_ref(rt, mr);
    } else {
        JS_FreeValueRT(rt, (*mr).key);
    }
    JS_FreeValueRT(rt, (*mr).value);
    let ref mut fresh694 = (*mr).ref_count;
    *fresh694 -= 1;
    if *fresh694 == 0 as libc::c_int {
        list_del(&mut (*mr).link);
        js_free_rt(rt, mr as *mut libc::c_void);
    } else {
        (*mr).empty = TRUE as libc::c_int;
        (*mr)
            .key = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        (*mr)
            .value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    let ref mut fresh695 = (*s).record_count;
    *fresh695 = (*fresh695).wrapping_sub(1);
}
unsafe extern "C" fn map_decref_record(
    mut rt: *mut JSRuntime,
    mut mr: *mut JSMapRecord,
) {
    let ref mut fresh696 = (*mr).ref_count;
    *fresh696 -= 1;
    if *fresh696 == 0 as libc::c_int {
        assert((*mr).empty);
        list_del(&mut (*mr).link);
        js_free_rt(rt, mr as *mut libc::c_void);
    }
}
unsafe extern "C" fn reset_weak_ref(mut rt: *mut JSRuntime, mut p: *mut JSObject) {
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut mr_next: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    mr = (*p).first_weak_ref;
    while !mr.is_null() {
        s = (*mr).map;
        assert((*s).is_weak);
        assert(((*mr).empty == 0) as libc::c_int);
        list_del(&mut (*mr).hash_link);
        list_del(&mut (*mr).link);
        mr = (*mr).next_weak_ref;
    }
    mr = (*p).first_weak_ref;
    while !mr.is_null() {
        mr_next = (*mr).next_weak_ref;
        JS_FreeValueRT(rt, (*mr).value);
        js_free_rt(rt, mr as *mut libc::c_void);
        mr = mr_next;
    }
    let ref mut fresh697 = (*p).first_weak_ref;
    *fresh697 = 0 as *mut JSMapRecord;
}
unsafe extern "C" fn js_map_set(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut key: JSValue = 0;
    let mut value: JSValue = 0;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    key = map_normalize_key(ctx, *argv.offset(0 as libc::c_int as isize));
    if (*s).is_weak != 0 && JS_IsObject(key) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if magic & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        value = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    } else {
        value = *argv.offset(1 as libc::c_int as isize);
    }
    mr = map_find_record(ctx, s, key);
    if !mr.is_null() {
        JS_FreeValue(ctx, (*mr).value);
    } else {
        mr = map_add_record(ctx, s, key);
        if mr.is_null() {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    (*mr).value = JS_DupValue(ctx, value);
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn js_map_get(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut key: JSValue = 0;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    key = map_normalize_key(ctx, *argv.offset(0 as libc::c_int as isize));
    mr = map_find_record(ctx, s, key);
    if mr.is_null() {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
    } else {
        return JS_DupValue(ctx, (*mr).value)
    };
}
unsafe extern "C" fn js_map_has(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut key: JSValue = 0;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    key = map_normalize_key(ctx, *argv.offset(0 as libc::c_int as isize));
    mr = map_find_record(ctx, s, key);
    return JS_NewBool(
        ctx,
        (mr != 0 as *mut libc::c_void as *mut JSMapRecord) as libc::c_int,
    );
}
unsafe extern "C" fn js_map_delete(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut key: JSValue = 0;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    key = map_normalize_key(ctx, *argv.offset(0 as libc::c_int as isize));
    mr = map_find_record(ctx, s, key);
    if mr.is_null() {
        return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    map_delete_record((*ctx).rt, s, mr);
    return (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
        | 1 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_map_clear(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    el = (*s).records.next;
    el1 = (*el).next;
    while el != &mut (*s).records as *mut list_head {
        mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
            as *mut JSMapRecord;
        map_delete_record((*ctx).rt, s, mr);
        el = el1;
        el1 = (*el).next;
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_map_get_size(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewUint32(ctx, (*s).record_count);
}
unsafe extern "C" fn js_map_forEach(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut s: *mut JSMapState = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapState;
    let mut func: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    func = *argv.offset(0 as libc::c_int as isize);
    if argc > 1 as libc::c_int {
        this_arg = *argv.offset(1 as libc::c_int as isize);
    } else {
        this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if check_function(ctx, func) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    el = (*s).records.next;
    while el != &mut (*s).records as *mut list_head {
        mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
            as *mut JSMapRecord;
        if (*mr).empty == 0 {
            let ref mut fresh698 = (*mr).ref_count;
            *fresh698 += 1;
            args[1 as libc::c_int as usize] = JS_DupValue(ctx, (*mr).key);
            if magic != 0 {
                args[0 as libc::c_int as usize] = args[1 as libc::c_int as usize];
            } else {
                args[0 as libc::c_int as usize] = JS_DupValue(ctx, (*mr).value);
            }
            args[2 as libc::c_int as usize] = this_val;
            ret = JS_Call(ctx, func, this_arg, 3 as libc::c_int, args.as_mut_ptr());
            JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
            if magic == 0 {
                JS_FreeValue(ctx, args[1 as libc::c_int as usize]);
            }
            el = (*el).next;
            map_decref_record((*ctx).rt, mr);
            if JS_IsException(ret) != 0 {
                return ret;
            }
            JS_FreeValue(ctx, ret);
        } else {
            el = (*el).next;
        }
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_map_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    s = (*p).u.map_state;
    if !s.is_null() {
        el = (*s).records.next;
        el1 = (*el).next;
        while el != &mut (*s).records as *mut list_head {
            mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
                as *mut JSMapRecord;
            if (*mr).empty == 0 {
                if (*s).is_weak != 0 {
                    delete_weak_ref(rt, mr);
                } else {
                    JS_FreeValueRT(rt, (*mr).key);
                }
                JS_FreeValueRT(rt, (*mr).value);
            }
            js_free_rt(rt, mr as *mut libc::c_void);
            el = el1;
            el1 = (*el).next;
        }
        js_free_rt(rt, (*s).hash_table as *mut libc::c_void);
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_map_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    s = (*p).u.map_state;
    if !s.is_null() {
        el = (*s).records.next;
        while el != &mut (*s).records as *mut list_head {
            mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
                as *mut JSMapRecord;
            if (*s).is_weak == 0 {
                JS_MarkValue(rt, (*mr).key, mark_func);
            }
            JS_MarkValue(rt, (*mr).value, mark_func);
            el = (*el).next;
        }
    }
}
unsafe extern "C" fn js_map_iterator_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut it: *mut JSMapIteratorData = 0 as *mut JSMapIteratorData;
    p = val as intptr_t as *mut libc::c_void as *mut JSObject;
    it = (*p).u.map_iterator_data;
    if !it.is_null() {
        if JS_IsLiveObject(rt, (*it).obj) != 0 && !((*it).cur_record).is_null() {
            map_decref_record(rt, (*it).cur_record);
        }
        JS_FreeValueRT(rt, (*it).obj);
        js_free_rt(rt, it as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_map_iterator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut it: *mut JSMapIteratorData = 0 as *mut JSMapIteratorData;
    it = (*p).u.map_iterator_data;
    if !it.is_null() {
        JS_MarkValue(rt, (*it).obj, mark_func);
    }
}
unsafe extern "C" fn js_create_map_iterator(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut kind: JSIteratorKindEnum = JS_ITERATOR_KIND_KEY;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    let mut it: *mut JSMapIteratorData = 0 as *mut JSMapIteratorData;
    let mut enum_obj: JSValue = 0;
    kind = (magic >> 2 as libc::c_int) as JSIteratorKindEnum;
    magic &= 3 as libc::c_int;
    s = JS_GetOpaque2(ctx, this_val, (JS_CLASS_MAP as libc::c_int + magic) as JSClassID)
        as *mut JSMapState;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    enum_obj = JS_NewObjectClass(ctx, JS_CLASS_MAP_ITERATOR as libc::c_int + magic);
    if !(JS_IsException(enum_obj) != 0) {
        it = js_malloc(ctx, ::core::mem::size_of::<JSMapIteratorData>() as libc::c_ulong)
            as *mut JSMapIteratorData;
        if it.is_null() {
            JS_FreeValue(ctx, enum_obj);
        } else {
            (*it).obj = JS_DupValue(ctx, this_val);
            (*it).kind = kind;
            let ref mut fresh699 = (*it).cur_record;
            *fresh699 = 0 as *mut JSMapRecord;
            JS_SetOpaque(enum_obj, it as *mut libc::c_void);
            return enum_obj;
        }
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_map_iterator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut pdone: *mut BOOL,
    mut magic: libc::c_int,
) -> JSValue {
    let mut it: *mut JSMapIteratorData = 0 as *mut JSMapIteratorData;
    let mut s: *mut JSMapState = 0 as *mut JSMapState;
    let mut mr: *mut JSMapRecord = 0 as *mut JSMapRecord;
    let mut el: *mut list_head = 0 as *mut list_head;
    it = JS_GetOpaque2(
        ctx,
        this_val,
        (JS_CLASS_MAP_ITERATOR as libc::c_int + magic) as JSClassID,
    ) as *mut JSMapIteratorData;
    if it.is_null() {
        *pdone = FALSE as libc::c_int;
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if !(JS_IsUndefined((*it).obj) != 0) {
        s = JS_GetOpaque((*it).obj, (JS_CLASS_MAP as libc::c_int + magic) as JSClassID)
            as *mut JSMapState;
        assert((s != 0 as *mut libc::c_void as *mut JSMapState) as libc::c_int);
        if ((*it).cur_record).is_null() {
            el = (*s).records.next;
        } else {
            mr = (*it).cur_record;
            el = (*mr).link.next;
            map_decref_record((*ctx).rt, mr);
        }
        loop {
            if el == &mut (*s).records as *mut list_head {
                let ref mut fresh700 = (*it).cur_record;
                *fresh700 = 0 as *mut JSMapRecord;
                JS_FreeValue(ctx, (*it).obj);
                (*it)
                    .obj = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                break;
            } else {
                mr = (el as *mut uint8_t).offset(-(16 as libc::c_ulong as isize))
                    as *mut JSMapRecord;
                if (*mr).empty == 0 {
                    let ref mut fresh701 = (*mr).ref_count;
                    *fresh701 += 1;
                    let ref mut fresh702 = (*it).cur_record;
                    *fresh702 = mr;
                    *pdone = FALSE as libc::c_int;
                    if (*it).kind as libc::c_uint
                        == JS_ITERATOR_KIND_KEY as libc::c_int as libc::c_uint
                    {
                        return JS_DupValue(ctx, (*mr).key)
                    } else {
                        let mut args: [JSValue; 2] = [0; 2];
                        args[0 as libc::c_int as usize] = (*mr).key;
                        if magic != 0 {
                            args[1 as libc::c_int as usize] = (*mr).key;
                        } else {
                            args[1 as libc::c_int as usize] = (*mr).value;
                        }
                        if (*it).kind as libc::c_uint
                            == JS_ITERATOR_KIND_VALUE as libc::c_int as libc::c_uint
                        {
                            return JS_DupValue(ctx, args[1 as libc::c_int as usize])
                        } else {
                            return js_create_array(
                                ctx,
                                2 as libc::c_int,
                                args.as_mut_ptr(),
                            )
                        }
                    }
                } else {
                    el = (*mr).link.next;
                }
            }
        }
    }
    *pdone = TRUE as libc::c_int;
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
static mut js_map_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_map_proto_funcs: [JSCFunctionListEntry; 12] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"set\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"get\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_get
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"has\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_has
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"delete\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_delete
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"clear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_clear
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"size\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_map_get_size
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"forEach\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_forEach
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"values\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((JS_ITERATOR_KIND_VALUE as libc::c_int) << 2 as libc::c_int
                    | 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_map_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((JS_ITERATOR_KIND_KEY as libc::c_int) << 2 as libc::c_int
                    | 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_map_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"entries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((JS_ITERATOR_KIND_KEY_AND_VALUE as libc::c_int)
                    << 2 as libc::c_int | 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_map_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"entries\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Map\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_map_iterator_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_map_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Map Iterator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_set_proto_funcs: [JSCFunctionListEntry; 11] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"add\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"has\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_has
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"delete\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_delete
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"clear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_clear
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"size\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_map_get_size
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"forEach\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_forEach
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"values\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((JS_ITERATOR_KIND_KEY as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_map_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"values\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"values\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"entries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((JS_ITERATOR_KIND_KEY_AND_VALUE as libc::c_int)
                    << 2 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int)
                    as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_map_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Set\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_set_iterator_proto_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_map_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Set Iterator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_weak_map_proto_funcs: [JSCFunctionListEntry; 5] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"set\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"get\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_get
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"has\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_has
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"delete\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_delete
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"WeakMap\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_weak_set_proto_funcs: [JSCFunctionListEntry; 4] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"add\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"has\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_has
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"delete\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: ((1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_map_delete
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"WeakSet\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_map_proto_funcs_ptr: [*const JSCFunctionListEntry; 6] = unsafe {
    [
        js_map_proto_funcs.as_ptr(),
        js_set_proto_funcs.as_ptr(),
        js_weak_map_proto_funcs.as_ptr(),
        js_weak_set_proto_funcs.as_ptr(),
        js_map_iterator_proto_funcs.as_ptr(),
        js_set_iterator_proto_funcs.as_ptr(),
    ]
};
static mut js_map_proto_funcs_count: [uint8_t; 6] = [0; 6];
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicMapSet(mut ctx: *mut JSContext) {
    let mut i: libc::c_int = 0;
    let mut obj1: JSValue = 0;
    let mut buf: [libc::c_char; 64] = [0; 64];
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut name: *const libc::c_char = JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            (JS_ATOM_Map as libc::c_int + i) as JSAtom,
        );
        *((*ctx).class_proto)
            .offset((JS_CLASS_MAP as libc::c_int + i) as isize) = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(
            ctx,
            *((*ctx).class_proto).offset((JS_CLASS_MAP as libc::c_int + i) as isize),
            js_map_proto_funcs_ptr[i as usize],
            js_map_proto_funcs_count[i as usize] as libc::c_int,
        );
        obj1 = JS_NewCFunctionMagic(
            ctx,
            Some(
                js_map_constructor
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            ),
            name,
            0 as libc::c_int,
            JS_CFUNC_constructor_magic,
            i,
        );
        if i < 2 as libc::c_int {
            JS_SetPropertyFunctionList(
                ctx,
                obj1,
                js_map_funcs.as_ptr(),
                (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
                    ) as libc::c_int,
            );
        }
        JS_NewGlobalCConstructor2(
            ctx,
            obj1,
            name,
            *((*ctx).class_proto).offset((JS_CLASS_MAP as libc::c_int + i) as isize),
        );
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        *((*ctx).class_proto)
            .offset(
                (JS_CLASS_MAP_ITERATOR as libc::c_int + i) as isize,
            ) = JS_NewObjectProto(ctx, (*ctx).iterator_proto);
        JS_SetPropertyFunctionList(
            ctx,
            *((*ctx).class_proto)
                .offset((JS_CLASS_MAP_ITERATOR as libc::c_int + i) as isize),
            js_map_proto_funcs_ptr[(i + 4 as libc::c_int) as usize],
            js_map_proto_funcs_count[(i + 4 as libc::c_int) as usize] as libc::c_int,
        );
        i += 1;
    }
}
static mut js_generator_function_proto_funcs: [JSCFunctionListEntry; 1] = [
    {
        let mut init = JSCFunctionListEntry {
            name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
            prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
            def_type: 3 as libc::c_int as uint8_t,
            magic: 0 as libc::c_int as int16_t,
            u: C2RustUnnamed_22 {
                str_0: b"GeneratorFunction\0" as *const u8 as *const libc::c_char,
            },
        };
        init
    },
];
static mut js_generator_proto_funcs: [JSCFunctionListEntry; 4] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"return\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"throw\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_iterator_next as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                iterator_next: Some(
                                    js_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            *mut BOOL,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Generator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn promise_reaction_data_free(
    mut rt: *mut JSRuntime,
    mut rd: *mut JSPromiseReactionData,
) {
    JS_FreeValueRT(rt, (*rd).resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValueRT(rt, (*rd).resolving_funcs[1 as libc::c_int as usize]);
    JS_FreeValueRT(rt, (*rd).handler);
    js_free_rt(rt, rd as *mut libc::c_void);
}
unsafe extern "C" fn promise_reaction_job(
    mut ctx: *mut JSContext,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut handler: JSValue = 0;
    let mut arg: JSValue = 0;
    let mut func: JSValue = 0;
    let mut res: JSValue = 0;
    let mut res2: JSValue = 0;
    let mut is_reject: BOOL = 0;
    assert((argc == 5 as libc::c_int) as libc::c_int);
    handler = *argv.offset(2 as libc::c_int as isize);
    is_reject = JS_ToBool(ctx, *argv.offset(3 as libc::c_int as isize));
    arg = *argv.offset(4 as libc::c_int as isize);
    if JS_IsUndefined(handler) != 0 {
        if is_reject != 0 {
            res = JS_Throw(ctx, JS_DupValue(ctx, arg));
        } else {
            res = JS_DupValue(ctx, arg);
        }
    } else {
        res = JS_Call(
            ctx,
            handler,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut arg,
        );
    }
    is_reject = JS_IsException(res);
    if is_reject != 0 {
        res = JS_GetException(ctx);
    }
    func = *argv.offset(is_reject as isize);
    if JS_IsUndefined(func) == 0 {
        res2 = JS_Call(
            ctx,
            func,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut res as *mut JSValue,
        );
    } else {
        res2 = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    JS_FreeValue(ctx, res);
    return res2;
}
#[no_mangle]
pub unsafe extern "C" fn JS_SetHostPromiseRejectionTracker(
    mut rt: *mut JSRuntime,
    mut cb: Option::<JSHostPromiseRejectionTracker>,
    mut opaque: *mut libc::c_void,
) {
    let ref mut fresh703 = (*rt).host_promise_rejection_tracker;
    *fresh703 = cb;
    let ref mut fresh704 = (*rt).host_promise_rejection_tracker_opaque;
    *fresh704 = opaque;
}
unsafe extern "C" fn fulfill_or_reject_promise(
    mut ctx: *mut JSContext,
    mut promise: JSValue,
    mut value: JSValue,
    mut is_reject: BOOL,
) {
    let mut s: *mut JSPromiseData = JS_GetOpaque(
        promise,
        JS_CLASS_PROMISE as libc::c_int as JSClassID,
    ) as *mut JSPromiseData;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut rd: *mut JSPromiseReactionData = 0 as *mut JSPromiseReactionData;
    let mut args: [JSValue; 5] = [0; 5];
    if s.is_null()
        || (*s).promise_state as libc::c_uint
            != JS_PROMISE_PENDING as libc::c_int as libc::c_uint
    {
        return;
    }
    set_value(ctx, &mut (*s).promise_result, JS_DupValue(ctx, value));
    (*s)
        .promise_state = (JS_PROMISE_FULFILLED as libc::c_int + is_reject)
        as JSPromiseStateEnum;
    if (*s).promise_state as libc::c_uint
        == JS_PROMISE_REJECTED as libc::c_int as libc::c_uint && (*s).is_handled == 0
    {
        let mut rt: *mut JSRuntime = (*ctx).rt;
        if ((*rt).host_promise_rejection_tracker).is_some() {
            ((*rt).host_promise_rejection_tracker)
                .expect(
                    "non-null function pointer",
                )(
                ctx,
                promise,
                value,
                FALSE as libc::c_int,
                (*rt).host_promise_rejection_tracker_opaque,
            );
        }
    }
    el = (*s).promise_reactions[is_reject as usize].next;
    el1 = (*el).next;
    while el
        != &mut *((*s).promise_reactions).as_mut_ptr().offset(is_reject as isize)
            as *mut list_head
    {
        rd = (el as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
            as *mut JSPromiseReactionData;
        args[0 as libc::c_int
            as usize] = (*rd).resolving_funcs[0 as libc::c_int as usize];
        args[1 as libc::c_int
            as usize] = (*rd).resolving_funcs[1 as libc::c_int as usize];
        args[2 as libc::c_int as usize] = (*rd).handler;
        args[3 as libc::c_int as usize] = JS_NewBool(ctx, is_reject);
        args[4 as libc::c_int as usize] = value;
        JS_EnqueueJob(
            ctx,
            Some(
                promise_reaction_job
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            5 as libc::c_int,
            args.as_mut_ptr(),
        );
        list_del(&mut (*rd).link);
        promise_reaction_data_free((*ctx).rt, rd);
        el = el1;
        el1 = (*el).next;
    }
    el = (*s).promise_reactions[(1 as libc::c_int - is_reject) as usize].next;
    el1 = (*el).next;
    while el
        != &mut *((*s).promise_reactions)
            .as_mut_ptr()
            .offset((1 as libc::c_int - is_reject) as isize) as *mut list_head
    {
        rd = (el as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
            as *mut JSPromiseReactionData;
        list_del(&mut (*rd).link);
        promise_reaction_data_free((*ctx).rt, rd);
        el = el1;
        el1 = (*el).next;
    }
}
unsafe extern "C" fn reject_promise(
    mut ctx: *mut JSContext,
    mut promise: JSValue,
    mut value: JSValue,
) {
    fulfill_or_reject_promise(ctx, promise, value, TRUE as libc::c_int);
}
unsafe extern "C" fn js_promise_resolve_thenable_job(
    mut ctx: *mut JSContext,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut promise: JSValue = 0;
    let mut thenable: JSValue = 0;
    let mut then: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut res: JSValue = 0;
    assert((argc == 3 as libc::c_int) as libc::c_int);
    promise = *argv.offset(0 as libc::c_int as isize);
    thenable = *argv.offset(1 as libc::c_int as isize);
    then = *argv.offset(2 as libc::c_int as isize);
    if js_create_resolving_functions(ctx, args.as_mut_ptr(), promise) < 0 as libc::c_int
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    res = JS_Call(ctx, then, thenable, 2 as libc::c_int, args.as_mut_ptr());
    if JS_IsException(res) != 0 {
        let mut error: JSValue = JS_GetException(ctx);
        res = JS_Call(
            ctx,
            args[1 as libc::c_int as usize],
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut error as *mut JSValue,
        );
        JS_FreeValue(ctx, error);
    }
    JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, args[1 as libc::c_int as usize]);
    return res;
}
unsafe extern "C" fn js_promise_resolve_function_free_resolved(
    mut rt: *mut JSRuntime,
    mut sr: *mut JSPromiseFunctionDataResolved,
) {
    let ref mut fresh705 = (*sr).ref_count;
    *fresh705 -= 1;
    if *fresh705 == 0 as libc::c_int {
        js_free_rt(rt, sr as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_create_resolving_functions(
    mut ctx: *mut JSContext,
    mut resolving_funcs: *mut JSValue,
    mut promise: JSValue,
) -> libc::c_int {
    let mut obj: JSValue = 0;
    let mut s: *mut JSPromiseFunctionData = 0 as *mut JSPromiseFunctionData;
    let mut sr: *mut JSPromiseFunctionDataResolved = 0
        as *mut JSPromiseFunctionDataResolved;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    sr = js_malloc(
        ctx,
        ::core::mem::size_of::<JSPromiseFunctionDataResolved>() as libc::c_ulong,
    ) as *mut JSPromiseFunctionDataResolved;
    if sr.is_null() {
        return -(1 as libc::c_int);
    }
    (*sr).ref_count = 1 as libc::c_int;
    (*sr).already_resolved = FALSE as libc::c_int;
    ret = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        obj = JS_NewObjectProtoClass(
            ctx,
            (*ctx).function_proto,
            (JS_CLASS_PROMISE_RESOLVE_FUNCTION as libc::c_int + i) as JSClassID,
        );
        if !(JS_IsException(obj) != 0) {
            s = js_malloc(
                ctx,
                ::core::mem::size_of::<JSPromiseFunctionData>() as libc::c_ulong,
            ) as *mut JSPromiseFunctionData;
            if s.is_null() {
                JS_FreeValue(ctx, obj);
            } else {
                let ref mut fresh706 = (*sr).ref_count;
                *fresh706 += 1;
                let ref mut fresh707 = (*s).presolved;
                *fresh707 = sr;
                (*s).promise = JS_DupValue(ctx, promise);
                JS_SetOpaque(obj, s as *mut libc::c_void);
                js_function_set_properties(
                    ctx,
                    obj,
                    JS_ATOM_empty_string as libc::c_int as JSAtom,
                    1 as libc::c_int,
                );
                *resolving_funcs.offset(i as isize) = obj;
                i += 1;
                continue;
            }
        }
        if i != 0 as libc::c_int {
            JS_FreeValue(ctx, *resolving_funcs.offset(0 as libc::c_int as isize));
        }
        ret = -(1 as libc::c_int);
        break;
    }
    js_promise_resolve_function_free_resolved((*ctx).rt, sr);
    return ret;
}
unsafe extern "C" fn js_promise_resolve_function_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut s: *mut JSPromiseFunctionData = (*(val as intptr_t as *mut libc::c_void
        as *mut JSObject))
        .u
        .promise_function_data;
    if !s.is_null() {
        js_promise_resolve_function_free_resolved(rt, (*s).presolved);
        JS_FreeValueRT(rt, (*s).promise);
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_promise_resolve_function_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSPromiseFunctionData = (*(val as intptr_t as *mut libc::c_void
        as *mut JSObject))
        .u
        .promise_function_data;
    if !s.is_null() {
        JS_MarkValue(rt, (*s).promise, mark_func);
    }
}
unsafe extern "C" fn js_promise_resolve_function_call(
    mut ctx: *mut JSContext,
    mut func_obj: JSValue,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut flags: libc::c_int,
) -> JSValue {
    let mut error: JSValue = 0;
    let mut current_block: u64;
    let mut p: *mut JSObject = func_obj as intptr_t as *mut libc::c_void
        as *mut JSObject;
    let mut s: *mut JSPromiseFunctionData = 0 as *mut JSPromiseFunctionData;
    let mut resolution: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut then: JSValue = 0;
    let mut is_reject: BOOL = 0;
    s = (*p).u.promise_function_data;
    if s.is_null() || (*(*s).presolved).already_resolved != 0 {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*(*s).presolved).already_resolved = TRUE as libc::c_int;
    is_reject = (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        - JS_CLASS_PROMISE_RESOLVE_FUNCTION as libc::c_int;
    if argc > 0 as libc::c_int {
        resolution = *argv.offset(0 as libc::c_int as isize);
    } else {
        resolution = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if is_reject != 0 || JS_IsObject(resolution) == 0 {
        current_block = 12193147098706409873;
    } else {
        if js_same_value(ctx, resolution, (*s).promise) != 0 {
            JS_ThrowTypeError(
                ctx,
                b"promise self resolution\0" as *const u8 as *const libc::c_char,
            );
            current_block = 17874572867694453584;
        } else {
            then = JS_GetProperty(
                ctx,
                resolution,
                JS_ATOM_then as libc::c_int as JSAtom,
            );
            if JS_IsException(then) != 0 {
                error = 0;
                current_block = 17874572867694453584;
            } else if JS_IsFunction(ctx, then) == 0 {
                JS_FreeValue(ctx, then);
                current_block = 12193147098706409873;
            } else {
                args[0 as libc::c_int as usize] = (*s).promise;
                args[1 as libc::c_int as usize] = resolution;
                args[2 as libc::c_int as usize] = then;
                JS_EnqueueJob(
                    ctx,
                    Some(
                        js_promise_resolve_thenable_job
                            as unsafe extern "C" fn(
                                *mut JSContext,
                                libc::c_int,
                                *mut JSValue,
                            ) -> JSValue,
                    ),
                    3 as libc::c_int,
                    args.as_mut_ptr(),
                );
                JS_FreeValue(ctx, then);
                current_block = 14648156034262866959;
            }
        }
        match current_block {
            14648156034262866959 => {}
            12193147098706409873 => {}
            _ => {
                error = JS_GetException(ctx);
                reject_promise(ctx, (*s).promise, error);
                JS_FreeValue(ctx, error);
                current_block = 14648156034262866959;
            }
        }
    }
    match current_block {
        12193147098706409873 => {
            fulfill_or_reject_promise(ctx, (*s).promise, resolution, is_reject);
        }
        _ => {}
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_promise_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut s: *mut JSPromiseData = JS_GetOpaque(
        val,
        JS_CLASS_PROMISE as libc::c_int as JSClassID,
    ) as *mut JSPromiseData;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut el1: *mut list_head = 0 as *mut list_head;
    let mut i: libc::c_int = 0;
    if s.is_null() {
        return;
    }
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        el = (*s).promise_reactions[i as usize].next;
        el1 = (*el).next;
        while el
            != &mut *((*s).promise_reactions).as_mut_ptr().offset(i as isize)
                as *mut list_head
        {
            let mut rd: *mut JSPromiseReactionData = (el as *mut uint8_t)
                .offset(-(0 as libc::c_ulong as isize)) as *mut JSPromiseReactionData;
            promise_reaction_data_free(rt, rd);
            el = el1;
            el1 = (*el).next;
        }
        i += 1;
    }
    JS_FreeValueRT(rt, (*s).promise_result);
    js_free_rt(rt, s as *mut libc::c_void);
}
unsafe extern "C" fn js_promise_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSPromiseData = JS_GetOpaque(
        val,
        JS_CLASS_PROMISE as libc::c_int as JSClassID,
    ) as *mut JSPromiseData;
    let mut el: *mut list_head = 0 as *mut list_head;
    let mut i: libc::c_int = 0;
    if s.is_null() {
        return;
    }
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        el = (*s).promise_reactions[i as usize].next;
        while el
            != &mut *((*s).promise_reactions).as_mut_ptr().offset(i as isize)
                as *mut list_head
        {
            let mut rd: *mut JSPromiseReactionData = (el as *mut uint8_t)
                .offset(-(0 as libc::c_ulong as isize)) as *mut JSPromiseReactionData;
            JS_MarkValue(
                rt,
                (*rd).resolving_funcs[0 as libc::c_int as usize],
                mark_func,
            );
            JS_MarkValue(
                rt,
                (*rd).resolving_funcs[1 as libc::c_int as usize],
                mark_func,
            );
            JS_MarkValue(rt, (*rd).handler, mark_func);
            el = (*el).next;
        }
        i += 1;
    }
    JS_MarkValue(rt, (*s).promise_result, mark_func);
}
unsafe extern "C" fn js_promise_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut executor: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut s: *mut JSPromiseData = 0 as *mut JSPromiseData;
    let mut args: [JSValue; 2] = [0; 2];
    let mut ret: JSValue = 0;
    let mut i: libc::c_int = 0;
    executor = *argv.offset(0 as libc::c_int as isize);
    if check_function(ctx, executor) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_PROMISE as libc::c_int);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    s = js_mallocz(ctx, ::core::mem::size_of::<JSPromiseData>() as libc::c_ulong)
        as *mut JSPromiseData;
    if !s.is_null() {
        (*s).promise_state = JS_PROMISE_PENDING;
        (*s).is_handled = FALSE as libc::c_int;
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            init_list_head(
                &mut *((*s).promise_reactions).as_mut_ptr().offset(i as isize),
            );
            i += 1;
        }
        (*s)
            .promise_result = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
            << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        JS_SetOpaque(obj, s as *mut libc::c_void);
        if !(js_create_resolving_functions(ctx, args.as_mut_ptr(), obj) != 0) {
            ret = JS_Call(
                ctx,
                executor,
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                2 as libc::c_int,
                args.as_mut_ptr(),
            );
            if JS_IsException(ret) != 0 {
                let mut ret2: JSValue = 0;
                let mut error: JSValue = 0;
                error = JS_GetException(ctx);
                ret2 = JS_Call(
                    ctx,
                    args[1 as libc::c_int as usize],
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    1 as libc::c_int,
                    &mut error as *mut JSValue,
                );
                JS_FreeValue(ctx, error);
                if JS_IsException(ret2) != 0 {
                    JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
                    JS_FreeValue(ctx, args[1 as libc::c_int as usize]);
                    current_block = 2665225419883657929;
                } else {
                    JS_FreeValue(ctx, ret2);
                    current_block = 13472856163611868459;
                }
            } else {
                current_block = 13472856163611868459;
            }
            match current_block {
                2665225419883657929 => {}
                _ => {
                    JS_FreeValue(ctx, ret);
                    JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
                    JS_FreeValue(ctx, args[1 as libc::c_int as usize]);
                    return obj;
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_promise_executor(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        if JS_IsUndefined(*func_data.offset(i as isize)) == 0 {
            return JS_ThrowTypeError(
                ctx,
                b"resolving function already set\0" as *const u8 as *const libc::c_char,
            );
        }
        *func_data.offset(i as isize) = JS_DupValue(ctx, *argv.offset(i as isize));
        i += 1;
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_promise_executor_new(mut ctx: *mut JSContext) -> JSValue {
    let mut func_data: [JSValue; 2] = [0; 2];
    func_data[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    func_data[1 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    return JS_NewCFunctionData(
        ctx,
        Some(
            js_promise_executor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        2 as libc::c_int,
        0 as libc::c_int,
        2 as libc::c_int,
        func_data.as_mut_ptr(),
    );
}
unsafe extern "C" fn js_new_promise_capability(
    mut ctx: *mut JSContext,
    mut resolving_funcs: *mut JSValue,
    mut ctor: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut executor: JSValue = 0;
    let mut result_promise: JSValue = 0;
    let mut s: *mut JSCFunctionDataRecord = 0 as *mut JSCFunctionDataRecord;
    let mut i: libc::c_int = 0;
    executor = js_promise_executor_new(ctx);
    if JS_IsException(executor) != 0 {
        return executor;
    }
    if JS_IsUndefined(ctor) != 0 {
        result_promise = js_promise_constructor(
            ctx,
            ctor,
            1 as libc::c_int,
            &mut executor as *mut JSValue,
        );
    } else {
        result_promise = JS_CallConstructor(
            ctx,
            ctor,
            1 as libc::c_int,
            &mut executor as *mut JSValue,
        );
    }
    if !(JS_IsException(result_promise) != 0) {
        s = JS_GetOpaque(executor, JS_CLASS_C_FUNCTION_DATA as libc::c_int as JSClassID)
            as *mut JSCFunctionDataRecord;
        i = 0 as libc::c_int;
        loop {
            if !(i < 2 as libc::c_int) {
                current_block = 10048703153582371463;
                break;
            }
            if check_function(ctx, *((*s).data).as_mut_ptr().offset(i as isize)) != 0 {
                current_block = 12083388426558232158;
                break;
            }
            i += 1;
        }
        match current_block {
            12083388426558232158 => {}
            _ => {
                i = 0 as libc::c_int;
                while i < 2 as libc::c_int {
                    *resolving_funcs
                        .offset(
                            i as isize,
                        ) = JS_DupValue(
                        ctx,
                        *((*s).data).as_mut_ptr().offset(i as isize),
                    );
                    i += 1;
                }
                JS_FreeValue(ctx, executor);
                return result_promise;
            }
        }
    }
    JS_FreeValue(ctx, executor);
    JS_FreeValue(ctx, result_promise);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewPromiseCapability(
    mut ctx: *mut JSContext,
    mut resolving_funcs: *mut JSValue,
) -> JSValue {
    return js_new_promise_capability(
        ctx,
        resolving_funcs,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
}
unsafe extern "C" fn js_promise_resolve(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut result_promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut ret: JSValue = 0;
    let mut is_reject: BOOL = magic;
    if JS_IsObject(this_val) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if is_reject == 0
        && !(JS_GetOpaque(
            *argv.offset(0 as libc::c_int as isize),
            JS_CLASS_PROMISE as libc::c_int as JSClassID,
        ))
            .is_null()
    {
        let mut ctor: JSValue = 0;
        let mut is_same: BOOL = 0;
        ctor = JS_GetProperty(
            ctx,
            *argv.offset(0 as libc::c_int as isize),
            JS_ATOM_constructor as libc::c_int as JSAtom,
        );
        if JS_IsException(ctor) != 0 {
            return ctor;
        }
        is_same = js_same_value(ctx, ctor, this_val);
        JS_FreeValue(ctx, ctor);
        if is_same != 0 {
            return JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
        }
    }
    result_promise = js_new_promise_capability(
        ctx,
        resolving_funcs.as_mut_ptr(),
        this_val,
    );
    if JS_IsException(result_promise) != 0 {
        return result_promise;
    }
    ret = JS_Call(
        ctx,
        resolving_funcs[is_reject as usize],
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        1 as libc::c_int,
        argv,
    );
    JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
    if JS_IsException(ret) != 0 {
        JS_FreeValue(ctx, result_promise);
        return ret;
    }
    JS_FreeValue(ctx, ret);
    return result_promise;
}
unsafe extern "C" fn remainingElementsCount_add(
    mut ctx: *mut JSContext,
    mut resolve_element_env: JSValue,
    mut addend: libc::c_int,
) -> libc::c_int {
    let mut val: JSValue = 0;
    let mut remainingElementsCount: libc::c_int = 0;
    val = JS_GetPropertyUint32(ctx, resolve_element_env, 0 as libc::c_int as uint32_t);
    if JS_IsException(val) != 0 {
        return -(1 as libc::c_int);
    }
    if JS_ToInt32Free(ctx, &mut remainingElementsCount, val) != 0 {
        return -(1 as libc::c_int);
    }
    remainingElementsCount += addend;
    if JS_SetPropertyUint32(
        ctx,
        resolve_element_env,
        0 as libc::c_int as uint32_t,
        JS_NewInt32(ctx, remainingElementsCount),
    ) < 0 as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    return (remainingElementsCount == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn js_promise_all_resolve_element(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut resolve_type: libc::c_int = magic & 3 as libc::c_int;
    let mut is_reject: libc::c_int = magic & 4 as libc::c_int;
    let mut alreadyCalled: BOOL = JS_ToBool(
        ctx,
        *func_data.offset(0 as libc::c_int as isize),
    );
    let mut values: JSValue = *func_data.offset(2 as libc::c_int as isize);
    let mut resolve: JSValue = *func_data.offset(3 as libc::c_int as isize);
    let mut resolve_element_env: JSValue = *func_data.offset(4 as libc::c_int as isize);
    let mut ret: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut is_zero: libc::c_int = 0;
    let mut index: libc::c_int = 0;
    if JS_ToInt32(ctx, &mut index, *func_data.offset(1 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if alreadyCalled != 0 {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    *func_data.offset(0 as libc::c_int as isize) = JS_NewBool(ctx, TRUE as libc::c_int);
    if resolve_type == 1 as libc::c_int {
        let mut str: JSValue = 0;
        obj = JS_NewObject(ctx);
        if JS_IsException(obj) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        str = JS_NewString(
            ctx,
            if is_reject != 0 {
                b"rejected\0" as *const u8 as *const libc::c_char
            } else {
                b"fulfilled\0" as *const u8 as *const libc::c_char
            },
        );
        if JS_IsException(str) != 0 {
            current_block = 8724805806233473232;
        } else if JS_DefinePropertyValue(
            ctx,
            obj,
            JS_ATOM_status as libc::c_int as JSAtom,
            str,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        ) < 0 as libc::c_int
        {
            current_block = 8724805806233473232;
        } else if JS_DefinePropertyValue(
            ctx,
            obj,
            (if is_reject != 0 {
                JS_ATOM_reason as libc::c_int
            } else {
                JS_ATOM_value as libc::c_int
            }) as JSAtom,
            JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        ) < 0 as libc::c_int
        {
            current_block = 8724805806233473232;
        } else {
            current_block = 4495394744059808450;
        }
        match current_block {
            4495394744059808450 => {}
            _ => {
                JS_FreeValue(ctx, obj);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    } else {
        obj = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
    }
    if JS_DefinePropertyValueUint32(
        ctx,
        values,
        index as uint32_t,
        obj,
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 2 as libc::c_int,
    ) < 0 as libc::c_int
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    is_zero = remainingElementsCount_add(ctx, resolve_element_env, -(1 as libc::c_int));
    if is_zero < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if is_zero != 0 {
        if resolve_type == 2 as libc::c_int {
            let mut error: JSValue = 0;
            error = js_aggregate_error_constructor(ctx, values);
            if JS_IsException(error) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            ret = JS_Call(
                ctx,
                resolve,
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut error as *mut JSValue,
            );
            JS_FreeValue(ctx, error);
        } else {
            ret = JS_Call(
                ctx,
                resolve,
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut values as *mut JSValue,
            );
        }
        if JS_IsException(ret) != 0 {
            return ret;
        }
        JS_FreeValue(ctx, ret);
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_promise_all(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut error: JSValue = 0;
    let mut current_block: u64;
    let mut result_promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut item: JSValue = 0;
    let mut next_promise: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut values: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut resolve_element_env: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut resolve_element: JSValue = 0;
    let mut reject_element: JSValue = 0;
    let mut promise_resolve: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut iter: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut then_args: [JSValue; 2] = [0; 2];
    let mut resolve_element_data: [JSValue; 5] = [0; 5];
    let mut done: BOOL = 0;
    let mut index: libc::c_int = 0;
    let mut is_zero: libc::c_int = 0;
    let mut is_promise_any: libc::c_int = (magic == 2 as libc::c_int) as libc::c_int;
    if JS_IsObject(this_val) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    result_promise = js_new_promise_capability(
        ctx,
        resolving_funcs.as_mut_ptr(),
        this_val,
    );
    if JS_IsException(result_promise) != 0 {
        return result_promise;
    }
    promise_resolve = JS_GetProperty(
        ctx,
        this_val,
        JS_ATOM_resolve as libc::c_int as JSAtom,
    );
    if JS_IsException(promise_resolve) != 0 || check_function(ctx, promise_resolve) != 0
    {
        current_block = 2784147956139494993;
    } else {
        iter = JS_GetIterator(
            ctx,
            *argv.offset(0 as libc::c_int as isize),
            FALSE as libc::c_int,
        );
        if JS_IsException(iter) != 0 {
            error = 0;
            current_block = 2784147956139494993;
        } else {
            next_method = JS_GetProperty(
                ctx,
                iter,
                JS_ATOM_next as libc::c_int as JSAtom,
            );
            if JS_IsException(next_method) != 0 {
                current_block = 2784147956139494993;
            } else {
                values = JS_NewArray(ctx);
                if JS_IsException(values) != 0 {
                    current_block = 2784147956139494993;
                } else {
                    resolve_element_env = JS_NewArray(ctx);
                    if JS_IsException(resolve_element_env) != 0 {
                        current_block = 2784147956139494993;
                    } else if JS_DefinePropertyValueUint32(
                        ctx,
                        resolve_element_env,
                        0 as libc::c_int as uint32_t,
                        JS_NewInt32(ctx, 1 as libc::c_int),
                        (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int,
                    ) < 0 as libc::c_int
                    {
                        current_block = 2784147956139494993;
                    } else {
                        index = 0 as libc::c_int;
                        loop {
                            item = JS_IteratorNext(
                                ctx,
                                iter,
                                next_method,
                                0 as libc::c_int,
                                0 as *mut JSValue,
                                &mut done,
                            );
                            if JS_IsException(item) != 0 {
                                current_block = 2784147956139494993;
                                break;
                            }
                            if done != 0 {
                                current_block = 15594839951440953787;
                                break;
                            }
                            next_promise = JS_Call(
                                ctx,
                                promise_resolve,
                                this_val,
                                1 as libc::c_int,
                                &mut item as *mut JSValue,
                            );
                            JS_FreeValue(ctx, item);
                            if !(JS_IsException(next_promise) != 0) {
                                resolve_element_data[0 as libc::c_int
                                    as usize] = JS_NewBool(ctx, FALSE as libc::c_int);
                                resolve_element_data[1 as libc::c_int
                                    as usize] = JS_NewInt32(ctx, index);
                                resolve_element_data[2 as libc::c_int as usize] = values;
                                resolve_element_data[3 as libc::c_int
                                    as usize] = resolving_funcs[is_promise_any as usize];
                                resolve_element_data[4 as libc::c_int
                                    as usize] = resolve_element_env;
                                resolve_element = JS_NewCFunctionData(
                                    ctx,
                                    Some(
                                        js_promise_all_resolve_element
                                            as unsafe extern "C" fn(
                                                *mut JSContext,
                                                JSValue,
                                                libc::c_int,
                                                *mut JSValue,
                                                libc::c_int,
                                                *mut JSValue,
                                            ) -> JSValue,
                                    ),
                                    1 as libc::c_int,
                                    magic,
                                    5 as libc::c_int,
                                    resolve_element_data.as_mut_ptr(),
                                );
                                if JS_IsException(resolve_element) != 0 {
                                    JS_FreeValue(ctx, next_promise);
                                } else {
                                    if magic == 1 as libc::c_int {
                                        reject_element = JS_NewCFunctionData(
                                            ctx,
                                            Some(
                                                js_promise_all_resolve_element
                                                    as unsafe extern "C" fn(
                                                        *mut JSContext,
                                                        JSValue,
                                                        libc::c_int,
                                                        *mut JSValue,
                                                        libc::c_int,
                                                        *mut JSValue,
                                                    ) -> JSValue,
                                            ),
                                            1 as libc::c_int,
                                            magic | 4 as libc::c_int,
                                            5 as libc::c_int,
                                            resolve_element_data.as_mut_ptr(),
                                        );
                                        if JS_IsException(reject_element) != 0 {
                                            JS_FreeValue(ctx, next_promise);
                                            current_block = 14777598181408934718;
                                        } else {
                                            current_block = 2290177392965769716;
                                        }
                                    } else if magic == 2 as libc::c_int {
                                        if JS_DefinePropertyValueUint32(
                                            ctx,
                                            values,
                                            index as uint32_t,
                                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                            (1 as libc::c_int) << 0 as libc::c_int
                                                | (1 as libc::c_int) << 1 as libc::c_int
                                                | (1 as libc::c_int) << 2 as libc::c_int,
                                        ) < 0 as libc::c_int
                                        {
                                            current_block = 14777598181408934718;
                                        } else {
                                            reject_element = resolve_element;
                                            resolve_element = JS_DupValue(
                                                ctx,
                                                resolving_funcs[0 as libc::c_int as usize],
                                            );
                                            current_block = 2290177392965769716;
                                        }
                                    } else {
                                        reject_element = JS_DupValue(
                                            ctx,
                                            resolving_funcs[1 as libc::c_int as usize],
                                        );
                                        current_block = 2290177392965769716;
                                    }
                                    match current_block {
                                        14777598181408934718 => {}
                                        _ => {
                                            if remainingElementsCount_add(
                                                ctx,
                                                resolve_element_env,
                                                1 as libc::c_int,
                                            ) < 0 as libc::c_int
                                            {
                                                JS_FreeValue(ctx, next_promise);
                                                JS_FreeValue(ctx, resolve_element);
                                                JS_FreeValue(ctx, reject_element);
                                            } else {
                                                then_args[0 as libc::c_int as usize] = resolve_element;
                                                then_args[1 as libc::c_int as usize] = reject_element;
                                                ret = JS_InvokeFree(
                                                    ctx,
                                                    next_promise,
                                                    JS_ATOM_then as libc::c_int as JSAtom,
                                                    2 as libc::c_int,
                                                    then_args.as_mut_ptr(),
                                                );
                                                JS_FreeValue(ctx, resolve_element);
                                                JS_FreeValue(ctx, reject_element);
                                                if !(check_exception_free(ctx, ret) != 0) {
                                                    index += 1;
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            JS_IteratorClose(ctx, iter, TRUE as libc::c_int);
                            current_block = 2784147956139494993;
                            break;
                        }
                        match current_block {
                            2784147956139494993 => {}
                            _ => {
                                is_zero = remainingElementsCount_add(
                                    ctx,
                                    resolve_element_env,
                                    -(1 as libc::c_int),
                                );
                                if is_zero < 0 as libc::c_int {
                                    current_block = 2784147956139494993;
                                } else if is_zero != 0 {
                                    if magic == 2 as libc::c_int {
                                        let mut error_0: JSValue = 0;
                                        error_0 = js_aggregate_error_constructor(ctx, values);
                                        if JS_IsException(error_0) != 0 {
                                            current_block = 2784147956139494993;
                                        } else {
                                            JS_FreeValue(ctx, values);
                                            values = error_0;
                                            current_block = 6367734732029634840;
                                        }
                                    } else {
                                        current_block = 6367734732029634840;
                                    }
                                    match current_block {
                                        2784147956139494993 => {}
                                        _ => {
                                            ret = JS_Call(
                                                ctx,
                                                resolving_funcs[is_promise_any as usize],
                                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                                    << 32 as libc::c_int
                                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                                1 as libc::c_int,
                                                &mut values as *mut JSValue,
                                            );
                                            if check_exception_free(ctx, ret) != 0 {
                                                current_block = 2784147956139494993;
                                            } else {
                                                current_block = 9000796907026120986;
                                            }
                                        }
                                    }
                                } else {
                                    current_block = 9000796907026120986;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        2784147956139494993 => {
            error = JS_GetException(ctx);
            ret = JS_Call(
                ctx,
                resolving_funcs[1 as libc::c_int as usize],
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut error as *mut JSValue,
            );
            JS_FreeValue(ctx, error);
            if JS_IsException(ret) != 0 {
                JS_FreeValue(ctx, result_promise);
                result_promise = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                JS_FreeValue(ctx, ret);
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, promise_resolve);
    JS_FreeValue(ctx, resolve_element_env);
    JS_FreeValue(ctx, values);
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
    return result_promise;
}
unsafe extern "C" fn js_promise_race(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut error: JSValue = 0;
    let mut current_block: u64;
    let mut result_promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut item: JSValue = 0;
    let mut next_promise: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut iter: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut promise_resolve: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut done: BOOL = 0;
    if JS_IsObject(this_val) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    result_promise = js_new_promise_capability(
        ctx,
        resolving_funcs.as_mut_ptr(),
        this_val,
    );
    if JS_IsException(result_promise) != 0 {
        return result_promise;
    }
    promise_resolve = JS_GetProperty(
        ctx,
        this_val,
        JS_ATOM_resolve as libc::c_int as JSAtom,
    );
    if JS_IsException(promise_resolve) != 0 || check_function(ctx, promise_resolve) != 0
    {
        current_block = 7684554680888047239;
    } else {
        iter = JS_GetIterator(
            ctx,
            *argv.offset(0 as libc::c_int as isize),
            FALSE as libc::c_int,
        );
        if JS_IsException(iter) != 0 {
            error = 0;
            current_block = 7684554680888047239;
        } else {
            next_method = JS_GetProperty(
                ctx,
                iter,
                JS_ATOM_next as libc::c_int as JSAtom,
            );
            if JS_IsException(next_method) != 0 {
                current_block = 7684554680888047239;
            } else {
                loop {
                    item = JS_IteratorNext(
                        ctx,
                        iter,
                        next_method,
                        0 as libc::c_int,
                        0 as *mut JSValue,
                        &mut done,
                    );
                    if JS_IsException(item) != 0 {
                        current_block = 7684554680888047239;
                        break;
                    }
                    if done != 0 {
                        current_block = 12121654769918827646;
                        break;
                    }
                    next_promise = JS_Call(
                        ctx,
                        promise_resolve,
                        this_val,
                        1 as libc::c_int,
                        &mut item as *mut JSValue,
                    );
                    JS_FreeValue(ctx, item);
                    if !(JS_IsException(next_promise) != 0) {
                        ret = JS_InvokeFree(
                            ctx,
                            next_promise,
                            JS_ATOM_then as libc::c_int as JSAtom,
                            2 as libc::c_int,
                            resolving_funcs.as_mut_ptr(),
                        );
                        if !(check_exception_free(ctx, ret) != 0) {
                            continue;
                        }
                    }
                    JS_IteratorClose(ctx, iter, TRUE as libc::c_int);
                    current_block = 7684554680888047239;
                    break;
                }
            }
        }
    }
    match current_block {
        7684554680888047239 => {
            error = JS_GetException(ctx);
            ret = JS_Call(
                ctx,
                resolving_funcs[1 as libc::c_int as usize],
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                1 as libc::c_int,
                &mut error as *mut JSValue,
            );
            JS_FreeValue(ctx, error);
            if JS_IsException(ret) != 0 {
                JS_FreeValue(ctx, result_promise);
                result_promise = (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                    << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            } else {
                JS_FreeValue(ctx, ret);
            }
        }
        _ => {}
    }
    JS_FreeValue(ctx, promise_resolve);
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
    return result_promise;
}
unsafe extern "C" fn perform_promise_then(
    mut ctx: *mut JSContext,
    mut promise: JSValue,
    mut resolve_reject: *mut JSValue,
    mut cap_resolving_funcs: *mut JSValue,
) -> libc::c_int {
    let mut s: *mut JSPromiseData = JS_GetOpaque(
        promise,
        JS_CLASS_PROMISE as libc::c_int as JSClassID,
    ) as *mut JSPromiseData;
    let mut rd_array: [*mut JSPromiseReactionData; 2] = [0
        as *mut JSPromiseReactionData; 2];
    let mut rd: *mut JSPromiseReactionData = 0 as *mut JSPromiseReactionData;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    rd_array[0 as libc::c_int as usize] = 0 as *mut JSPromiseReactionData;
    rd_array[1 as libc::c_int as usize] = 0 as *mut JSPromiseReactionData;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        let mut handler: JSValue = 0;
        rd = js_mallocz(
            ctx,
            ::core::mem::size_of::<JSPromiseReactionData>() as libc::c_ulong,
        ) as *mut JSPromiseReactionData;
        if rd.is_null() {
            if i == 1 as libc::c_int {
                promise_reaction_data_free(
                    (*ctx).rt,
                    rd_array[0 as libc::c_int as usize],
                );
            }
            return -(1 as libc::c_int);
        }
        j = 0 as libc::c_int;
        while j < 2 as libc::c_int {
            (*rd)
                .resolving_funcs[j
                as usize] = JS_DupValue(ctx, *cap_resolving_funcs.offset(j as isize));
            j += 1;
        }
        handler = *resolve_reject.offset(i as isize);
        if JS_IsFunction(ctx, handler) == 0 {
            handler = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        (*rd).handler = JS_DupValue(ctx, handler);
        rd_array[i as usize] = rd;
        i += 1;
    }
    if (*s).promise_state as libc::c_uint
        == JS_PROMISE_PENDING as libc::c_int as libc::c_uint
    {
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            list_add_tail(
                &mut (**rd_array.as_mut_ptr().offset(i as isize)).link,
                &mut *((*s).promise_reactions).as_mut_ptr().offset(i as isize),
            );
            i += 1;
        }
    } else {
        let mut args: [JSValue; 5] = [0; 5];
        if (*s).promise_state as libc::c_uint
            == JS_PROMISE_REJECTED as libc::c_int as libc::c_uint && (*s).is_handled == 0
        {
            let mut rt: *mut JSRuntime = (*ctx).rt;
            if ((*rt).host_promise_rejection_tracker).is_some() {
                ((*rt).host_promise_rejection_tracker)
                    .expect(
                        "non-null function pointer",
                    )(
                    ctx,
                    promise,
                    (*s).promise_result,
                    TRUE as libc::c_int,
                    (*rt).host_promise_rejection_tracker_opaque,
                );
            }
        }
        i = ((*s).promise_state as libc::c_uint)
            .wrapping_sub(JS_PROMISE_FULFILLED as libc::c_int as libc::c_uint)
            as libc::c_int;
        rd = rd_array[i as usize];
        args[0 as libc::c_int
            as usize] = (*rd).resolving_funcs[0 as libc::c_int as usize];
        args[1 as libc::c_int
            as usize] = (*rd).resolving_funcs[1 as libc::c_int as usize];
        args[2 as libc::c_int as usize] = (*rd).handler;
        args[3 as libc::c_int as usize] = JS_NewBool(ctx, i);
        args[4 as libc::c_int as usize] = (*s).promise_result;
        JS_EnqueueJob(
            ctx,
            Some(
                promise_reaction_job
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            5 as libc::c_int,
            args.as_mut_ptr(),
        );
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            promise_reaction_data_free((*ctx).rt, rd_array[i as usize]);
            i += 1;
        }
    }
    (*s).is_handled = TRUE as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_promise_then(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut ctor: JSValue = 0;
    let mut result_promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut s: *mut JSPromiseData = 0 as *mut JSPromiseData;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    s = JS_GetOpaque2(ctx, this_val, JS_CLASS_PROMISE as libc::c_int as JSClassID)
        as *mut JSPromiseData;
    if s.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ctor = JS_SpeciesConstructor(
        ctx,
        this_val,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    result_promise = js_new_promise_capability(ctx, resolving_funcs.as_mut_ptr(), ctor);
    JS_FreeValue(ctx, ctor);
    if JS_IsException(result_promise) != 0 {
        return result_promise;
    }
    ret = perform_promise_then(ctx, this_val, argv, resolving_funcs.as_mut_ptr());
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        JS_FreeValue(ctx, resolving_funcs[i as usize]);
        i += 1;
    }
    if ret != 0 {
        JS_FreeValue(ctx, result_promise);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return result_promise;
}
unsafe extern "C" fn js_promise_catch(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut args: [JSValue; 2] = [0; 2];
    args[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    args[1 as libc::c_int as usize] = *argv.offset(0 as libc::c_int as isize);
    return JS_Invoke(
        ctx,
        this_val,
        JS_ATOM_then as libc::c_int as JSAtom,
        2 as libc::c_int,
        args.as_mut_ptr(),
    );
}
unsafe extern "C" fn js_promise_finally_value_thunk(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    return JS_DupValue(ctx, *func_data.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn js_promise_finally_thrower(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    return JS_Throw(ctx, JS_DupValue(ctx, *func_data.offset(0 as libc::c_int as isize)));
}
unsafe extern "C" fn js_promise_then_finally_func(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    let mut ctor: JSValue = *func_data.offset(0 as libc::c_int as isize);
    let mut onFinally: JSValue = *func_data.offset(1 as libc::c_int as isize);
    let mut res: JSValue = 0;
    let mut promise: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut then_func: JSValue = 0;
    res = JS_Call(
        ctx,
        onFinally,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        0 as libc::c_int,
        0 as *mut JSValue,
    );
    if JS_IsException(res) != 0 {
        return res;
    }
    promise = js_promise_resolve(
        ctx,
        ctor,
        1 as libc::c_int,
        &mut res as *mut JSValue,
        0 as libc::c_int,
    );
    JS_FreeValue(ctx, res);
    if JS_IsException(promise) != 0 {
        return promise;
    }
    if magic == 0 as libc::c_int {
        then_func = JS_NewCFunctionData(
            ctx,
            Some(
                js_promise_finally_value_thunk
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            argv,
        );
    } else {
        then_func = JS_NewCFunctionData(
            ctx,
            Some(
                js_promise_finally_thrower
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                        *mut JSValue,
                    ) -> JSValue,
            ),
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            argv,
        );
    }
    if JS_IsException(then_func) != 0 {
        JS_FreeValue(ctx, promise);
        return then_func;
    }
    ret = JS_InvokeFree(
        ctx,
        promise,
        JS_ATOM_then as libc::c_int as JSAtom,
        1 as libc::c_int,
        &mut then_func as *mut JSValue,
    );
    JS_FreeValue(ctx, then_func);
    return ret;
}
unsafe extern "C" fn js_promise_finally(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut onFinally: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut ctor: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut then_funcs: [JSValue; 2] = [0; 2];
    let mut func_data: [JSValue; 2] = [0; 2];
    let mut i: libc::c_int = 0;
    ctor = JS_SpeciesConstructor(
        ctx,
        this_val,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    if JS_IsFunction(ctx, onFinally) == 0 {
        then_funcs[0 as libc::c_int as usize] = JS_DupValue(ctx, onFinally);
        then_funcs[1 as libc::c_int as usize] = JS_DupValue(ctx, onFinally);
    } else {
        func_data[0 as libc::c_int as usize] = ctor;
        func_data[1 as libc::c_int as usize] = onFinally;
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            then_funcs[i
                as usize] = JS_NewCFunctionData(
                ctx,
                Some(
                    js_promise_then_finally_func
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            JSValue,
                            libc::c_int,
                            *mut JSValue,
                            libc::c_int,
                            *mut JSValue,
                        ) -> JSValue,
                ),
                1 as libc::c_int,
                i,
                2 as libc::c_int,
                func_data.as_mut_ptr(),
            );
            if JS_IsException(then_funcs[i as usize]) != 0 {
                if i == 1 as libc::c_int {
                    JS_FreeValue(ctx, then_funcs[0 as libc::c_int as usize]);
                }
                JS_FreeValue(ctx, ctor);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            i += 1;
        }
    }
    JS_FreeValue(ctx, ctor);
    ret = JS_Invoke(
        ctx,
        this_val,
        JS_ATOM_then as libc::c_int as JSAtom,
        2 as libc::c_int,
        then_funcs.as_mut_ptr(),
    );
    JS_FreeValue(ctx, then_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, then_funcs[1 as libc::c_int as usize]);
    return ret;
}
static mut js_promise_funcs: [JSCFunctionListEntry; 7] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"resolve\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_promise_resolve
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reject\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_promise_resolve
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"all\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_promise_all
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"allSettled\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_promise_all
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"any\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_promise_all
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"race\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_promise_race
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_promise_proto_funcs: [JSCFunctionListEntry; 4] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"then\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_promise_then
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"catch\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_promise_catch
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"finally\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_promise_finally
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"Promise\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_async_function_proto_funcs: [JSCFunctionListEntry; 1] = [
    {
        let mut init = JSCFunctionListEntry {
            name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
            prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
            def_type: 3 as libc::c_int as uint8_t,
            magic: 0 as libc::c_int as int16_t,
            u: C2RustUnnamed_22 {
                str_0: b"AsyncFunction\0" as *const u8 as *const libc::c_char,
            },
        };
        init
    },
];
unsafe extern "C" fn js_async_from_sync_iterator_unwrap(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
    mut func_data: *mut JSValue,
) -> JSValue {
    return js_create_iterator_result(
        ctx,
        JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
        JS_ToBool(ctx, *func_data.offset(0 as libc::c_int as isize)),
    );
}
unsafe extern "C" fn js_async_from_sync_iterator_unwrap_func_create(
    mut ctx: *mut JSContext,
    mut done: BOOL,
) -> JSValue {
    let mut func_data: [JSValue; 1] = [0; 1];
    func_data[0 as libc::c_int as usize] = JS_NewBool(ctx, done);
    return JS_NewCFunctionData(
        ctx,
        Some(
            js_async_from_sync_iterator_unwrap
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
        func_data.as_mut_ptr(),
    );
}
static mut js_async_iterator_proto_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.asyncIterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_iterator_proto_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_async_from_sync_iterator_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut s: *mut JSAsyncFromSyncIteratorData = JS_GetOpaque(
        val,
        JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncFromSyncIteratorData;
    if !s.is_null() {
        JS_FreeValueRT(rt, (*s).sync_iter);
        JS_FreeValueRT(rt, (*s).next_method);
        js_free_rt(rt, s as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_async_from_sync_iterator_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut s: *mut JSAsyncFromSyncIteratorData = JS_GetOpaque(
        val,
        JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncFromSyncIteratorData;
    if !s.is_null() {
        JS_MarkValue(rt, (*s).sync_iter, mark_func);
        JS_MarkValue(rt, (*s).next_method, mark_func);
    }
}
unsafe extern "C" fn JS_CreateAsyncFromSyncIterator(
    mut ctx: *mut JSContext,
    mut sync_iter: JSValue,
) -> JSValue {
    let mut async_iter: JSValue = 0;
    let mut next_method: JSValue = 0;
    let mut s: *mut JSAsyncFromSyncIteratorData = 0 as *mut JSAsyncFromSyncIteratorData;
    next_method = JS_GetProperty(ctx, sync_iter, JS_ATOM_next as libc::c_int as JSAtom);
    if JS_IsException(next_method) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    async_iter = JS_NewObjectClass(
        ctx,
        JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int,
    );
    if JS_IsException(async_iter) != 0 {
        JS_FreeValue(ctx, next_method);
        return async_iter;
    }
    s = js_mallocz(
        ctx,
        ::core::mem::size_of::<JSAsyncFromSyncIteratorData>() as libc::c_ulong,
    ) as *mut JSAsyncFromSyncIteratorData;
    if s.is_null() {
        JS_FreeValue(ctx, async_iter);
        JS_FreeValue(ctx, next_method);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    (*s).sync_iter = JS_DupValue(ctx, sync_iter);
    (*s).next_method = next_method;
    JS_SetOpaque(async_iter, s as *mut libc::c_void);
    return async_iter;
}
unsafe extern "C" fn js_async_from_sync_iterator_next(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut res2: JSValue = 0;
    let mut current_block: u64;
    let mut promise: JSValue = 0;
    let mut resolving_funcs: [JSValue; 2] = [0; 2];
    let mut value: JSValue = 0;
    let mut err: JSValue = 0;
    let mut method: JSValue = 0;
    let mut s: *mut JSAsyncFromSyncIteratorData = 0 as *mut JSAsyncFromSyncIteratorData;
    let mut done: libc::c_int = 0;
    let mut is_reject: libc::c_int = 0;
    promise = JS_NewPromiseCapability(ctx, resolving_funcs.as_mut_ptr());
    if JS_IsException(promise) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    s = JS_GetOpaque(
        this_val,
        JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int as JSClassID,
    ) as *mut JSAsyncFromSyncIteratorData;
    if s.is_null() {
        JS_ThrowTypeError(
            ctx,
            b"not an Async-from-Sync Iterator\0" as *const u8 as *const libc::c_char,
        );
        current_block = 1731207776193858062;
    } else {
        if magic == 0 as libc::c_int {
            method = JS_DupValue(ctx, (*s).next_method);
            current_block = 4495394744059808450;
        } else {
            method = JS_GetProperty(
                ctx,
                (*s).sync_iter,
                (if magic == 1 as libc::c_int {
                    JS_ATOM_return as libc::c_int
                } else {
                    JS_ATOM_throw as libc::c_int
                }) as JSAtom,
            );
            if JS_IsException(method) != 0 {
                current_block = 1731207776193858062;
            } else if JS_IsUndefined(method) != 0 || JS_IsNull(method) != 0 {
                if magic == 1 as libc::c_int {
                    err = js_create_iterator_result(
                        ctx,
                        JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
                        TRUE as libc::c_int,
                    );
                    is_reject = 0 as libc::c_int;
                } else {
                    err = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
                    is_reject = 1 as libc::c_int;
                }
                current_block = 4249807907907888097;
            } else {
                current_block = 4495394744059808450;
            }
        }
        match current_block {
            1731207776193858062 => {}
            4249807907907888097 => {}
            _ => {
                value = JS_IteratorNext2(
                    ctx,
                    (*s).sync_iter,
                    method,
                    if argc >= 1 as libc::c_int {
                        1 as libc::c_int
                    } else {
                        0 as libc::c_int
                    },
                    argv,
                    &mut done,
                );
                JS_FreeValue(ctx, method);
                if JS_IsException(value) != 0 {
                    current_block = 1731207776193858062;
                } else {
                    if done == 2 as libc::c_int {
                        let mut obj: JSValue = value;
                        value = JS_IteratorGetCompleteValue(ctx, obj, &mut done);
                        JS_FreeValue(ctx, obj);
                        if JS_IsException(value) != 0 {
                            current_block = 1731207776193858062;
                        } else {
                            current_block = 4775909272756257391;
                        }
                    } else {
                        current_block = 4775909272756257391;
                    }
                    match current_block {
                        1731207776193858062 => {}
                        _ => {
                            if JS_IsException(value) != 0 {
                                res2 = 0;
                            } else {
                                let mut value_wrapper_promise: JSValue = 0;
                                let mut resolve_reject: [JSValue; 2] = [0; 2];
                                let mut res: libc::c_int = 0;
                                value_wrapper_promise = js_promise_resolve(
                                    ctx,
                                    (*ctx).promise_ctor,
                                    1 as libc::c_int,
                                    &mut value as *mut JSValue,
                                    0 as libc::c_int,
                                );
                                if JS_IsException(value_wrapper_promise) != 0 {
                                    JS_FreeValue(ctx, value);
                                } else {
                                    resolve_reject[0 as libc::c_int
                                        as usize] = js_async_from_sync_iterator_unwrap_func_create(
                                        ctx,
                                        done,
                                    );
                                    if JS_IsException(resolve_reject[0 as libc::c_int as usize])
                                        != 0
                                    {
                                        JS_FreeValue(ctx, value_wrapper_promise);
                                        JS_FreeValue(ctx, value);
                                        JS_FreeValue(
                                            ctx,
                                            resolving_funcs[0 as libc::c_int as usize],
                                        );
                                        JS_FreeValue(
                                            ctx,
                                            resolving_funcs[1 as libc::c_int as usize],
                                        );
                                        JS_FreeValue(ctx, promise);
                                        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                    } else {
                                        JS_FreeValue(ctx, value);
                                        resolve_reject[1 as libc::c_int
                                            as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                        res = perform_promise_then(
                                            ctx,
                                            value_wrapper_promise,
                                            resolve_reject.as_mut_ptr(),
                                            resolving_funcs.as_mut_ptr(),
                                        );
                                        JS_FreeValue(
                                            ctx,
                                            resolve_reject[0 as libc::c_int as usize],
                                        );
                                        JS_FreeValue(ctx, value_wrapper_promise);
                                        JS_FreeValue(
                                            ctx,
                                            resolving_funcs[0 as libc::c_int as usize],
                                        );
                                        JS_FreeValue(
                                            ctx,
                                            resolving_funcs[1 as libc::c_int as usize],
                                        );
                                        if res != 0 {
                                            JS_FreeValue(ctx, promise);
                                            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                                                << 32 as libc::c_int
                                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                        }
                                        return promise;
                                    }
                                }
                            }
                            current_block = 1731207776193858062;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        1731207776193858062 => {
            err = JS_GetException(ctx);
            is_reject = 1 as libc::c_int;
        }
        _ => {}
    }
    res2 = JS_Call(
        ctx,
        resolving_funcs[is_reject as usize],
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        1 as libc::c_int,
        &mut err as *mut JSValue,
    );
    JS_FreeValue(ctx, err);
    JS_FreeValue(ctx, res2);
    JS_FreeValue(ctx, resolving_funcs[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, resolving_funcs[1 as libc::c_int as usize]);
    return promise;
}
static mut js_async_from_sync_iterator_proto_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_from_sync_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"return\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_from_sync_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"throw\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_from_sync_iterator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_async_generator_function_proto_funcs: [JSCFunctionListEntry; 1] = [
    {
        let mut init = JSCFunctionListEntry {
            name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
            prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
            def_type: 3 as libc::c_int as uint8_t,
            magic: 0 as libc::c_int as int16_t,
            u: C2RustUnnamed_22 {
                str_0: b"AsyncGeneratorFunction\0" as *const u8 as *const libc::c_char,
            },
        };
        init
    },
];
static mut js_async_generator_proto_funcs: [JSCFunctionListEntry; 4] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"next\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"return\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"throw\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 2 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_async_generator_next
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"AsyncGenerator\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_async_class_def: [JSClassShortDef; 9] = unsafe {
    [
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_Promise as libc::c_int as JSAtom,
                finalizer: Some(
                    js_promise_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_promise_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_PromiseResolveFunction as libc::c_int as JSAtom,
                finalizer: Some(
                    js_promise_resolve_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_promise_resolve_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_PromiseRejectFunction as libc::c_int as JSAtom,
                finalizer: Some(
                    js_promise_resolve_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_promise_resolve_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_AsyncFunction as libc::c_int as JSAtom,
                finalizer: Some(
                    js_bytecode_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_bytecode_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_AsyncFunctionResolve as libc::c_int as JSAtom,
                finalizer: Some(
                    js_async_function_resolve_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_async_function_resolve_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_AsyncFunctionReject as libc::c_int as JSAtom,
                finalizer: Some(
                    js_async_function_resolve_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_async_function_resolve_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_empty_string as libc::c_int as JSAtom,
                finalizer: Some(
                    js_async_from_sync_iterator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_async_from_sync_iterator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_AsyncGeneratorFunction as libc::c_int as JSAtom,
                finalizer: Some(
                    js_bytecode_function_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_bytecode_function_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = JSClassShortDef {
                class_name: JS_ATOM_AsyncGenerator as libc::c_int as JSAtom,
                finalizer: Some(
                    js_async_generator_finalizer
                        as unsafe extern "C" fn(*mut JSRuntime, JSValue) -> (),
                ),
                gc_mark: Some(
                    js_async_generator_mark
                        as unsafe extern "C" fn(
                            *mut JSRuntime,
                            JSValue,
                            Option::<JS_MarkFunc>,
                        ) -> (),
                ),
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicPromise(mut ctx: *mut JSContext) {
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut obj1: JSValue = 0;
    if JS_IsRegisteredClass(rt, JS_CLASS_PROMISE as libc::c_int as JSClassID) == 0 {
        init_class_range(
            rt,
            js_async_class_def.as_ptr(),
            JS_CLASS_PROMISE as libc::c_int,
            (::core::mem::size_of::<[JSClassShortDef; 9]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<JSClassShortDef>() as libc::c_ulong)
                as libc::c_int,
        );
        let ref mut fresh708 = (*((*rt).class_array)
            .offset(JS_CLASS_PROMISE_RESOLVE_FUNCTION as libc::c_int as isize))
            .call;
        *fresh708 = Some(
            js_promise_resolve_function_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
        let ref mut fresh709 = (*((*rt).class_array)
            .offset(JS_CLASS_PROMISE_REJECT_FUNCTION as libc::c_int as isize))
            .call;
        *fresh709 = Some(
            js_promise_resolve_function_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
        let ref mut fresh710 = (*((*rt).class_array)
            .offset(JS_CLASS_ASYNC_FUNCTION as libc::c_int as isize))
            .call;
        *fresh710 = Some(
            js_async_function_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
        let ref mut fresh711 = (*((*rt).class_array)
            .offset(JS_CLASS_ASYNC_FUNCTION_RESOLVE as libc::c_int as isize))
            .call;
        *fresh711 = Some(
            js_async_function_resolve_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
        let ref mut fresh712 = (*((*rt).class_array)
            .offset(JS_CLASS_ASYNC_FUNCTION_REJECT as libc::c_int as isize))
            .call;
        *fresh712 = Some(
            js_async_function_resolve_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
        let ref mut fresh713 = (*((*rt).class_array)
            .offset(JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as isize))
            .call;
        *fresh713 = Some(
            js_async_generator_function_call
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        );
    }
    *((*ctx).class_proto)
        .offset(JS_CLASS_PROMISE as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_PROMISE as libc::c_int as isize),
        js_promise_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 4]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    obj1 = JS_NewCFunction2(
        ctx,
        Some(
            js_promise_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        b"Promise\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor,
        0 as libc::c_int,
    );
    (*ctx).promise_ctor = JS_DupValue(ctx, obj1);
    JS_SetPropertyFunctionList(
        ctx,
        obj1,
        js_promise_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 7]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_NewGlobalCConstructor2(
        ctx,
        obj1,
        b"Promise\0" as *const u8 as *const libc::c_char,
        *((*ctx).class_proto).offset(JS_CLASS_PROMISE as libc::c_int as isize),
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ASYNC_FUNCTION as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).function_proto);
    obj1 = JS_NewCFunction3(
        ctx,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
            >,
            Option::<JSCFunction>,
        >(
            Some(
                js_function_constructor
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            ),
        ),
        b"AsyncFunction\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor_or_func_magic,
        JS_FUNC_ASYNC as libc::c_int,
        (*ctx).function_ctor,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ASYNC_FUNCTION as libc::c_int as isize),
        js_async_function_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetConstructor2(
        ctx,
        obj1,
        *((*ctx).class_proto).offset(JS_CLASS_ASYNC_FUNCTION as libc::c_int as isize),
        0 as libc::c_int,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_FreeValue(ctx, obj1);
    (*ctx).async_iterator_proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).async_iterator_proto,
        js_async_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).async_iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_ASYNC_FROM_SYNC_ITERATOR as libc::c_int as isize),
        js_async_from_sync_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ASYNC_GENERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).async_iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ASYNC_GENERATOR as libc::c_int as isize),
        js_async_generator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 4]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).function_proto);
    obj1 = JS_NewCFunction3(
        ctx,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
            >,
            Option::<JSCFunction>,
        >(
            Some(
                js_function_constructor
                    as unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
            ),
        ),
        b"AsyncGeneratorFunction\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor_or_func_magic,
        JS_FUNC_ASYNC_GENERATOR as libc::c_int,
        (*ctx).function_ctor,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as isize),
        js_async_generator_function_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetConstructor2(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as isize),
        *((*ctx).class_proto).offset(JS_CLASS_ASYNC_GENERATOR as libc::c_int as isize),
        (1 as libc::c_int) << 0 as libc::c_int,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_SetConstructor2(
        ctx,
        obj1,
        *((*ctx).class_proto)
            .offset(JS_CLASS_ASYNC_GENERATOR_FUNCTION as libc::c_int as isize),
        0 as libc::c_int,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_FreeValue(ctx, obj1);
}
unsafe extern "C" fn string_get_hex(
    mut p: *mut JSString,
    mut k: libc::c_int,
    mut n: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0 as libc::c_int;
    let mut h: libc::c_int = 0;
    loop {
        let fresh714 = n;
        n = n - 1;
        if !(fresh714 > 0 as libc::c_int) {
            break;
        }
        let fresh715 = k;
        k = k + 1;
        h = from_hex(string_get(p, fresh715));
        if h < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
        c = c << 4 as libc::c_int | h;
    }
    return c;
}
unsafe extern "C" fn isURIReserved(mut c: libc::c_int) -> libc::c_int {
    return (c < 0x100 as libc::c_int
        && !(memchr(
            b";/?:@&=+$,#\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            c,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        ))
            .is_null()) as libc::c_int;
}
unsafe extern "C" fn js_throw_URIError(
    mut ctx: *mut JSContext,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: va_list = 0 as *mut libc::c_void;
    ap = args.clone();
    JS_ThrowError(ctx, JS_URI_ERROR, fmt, ap);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn hex_decode(
    mut ctx: *mut JSContext,
    mut p: *mut JSString,
    mut k: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    if k >= (*p).len() as libc::c_int || string_get(p, k) != '%' as i32 {
        return js_throw_URIError(
            ctx,
            b"expecting %%\0" as *const u8 as *const libc::c_char,
        );
    }
    if k + 2 as libc::c_int >= (*p).len() as libc::c_int
        || {
            c = string_get_hex(p, k + 1 as libc::c_int, 2 as libc::c_int);
            c < 0 as libc::c_int
        }
    {
        return js_throw_URIError(
            ctx,
            b"expecting hex digit\0" as *const u8 as *const libc::c_char,
        );
    }
    return c;
}
unsafe extern "C" fn js_global_decodeURI(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut isComponent: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut str: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut k: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut c_min: libc::c_int = 0;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        return str;
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    k = 0 as libc::c_int;
    's_35: loop {
        if !(k < (*p).len() as libc::c_int) {
            current_block = 1423531122933789233;
            break;
        }
        c = string_get(p, k);
        if c == '%' as i32 {
            c = hex_decode(ctx, p, k);
            if c < 0 as libc::c_int {
                current_block = 4547124847060847846;
                break;
            }
            k += 3 as libc::c_int;
            if c < 0x80 as libc::c_int {
                if isComponent == 0 && isURIReserved(c) != 0 {
                    c = '%' as i32;
                    k -= 2 as libc::c_int;
                }
            } else {
                if c >= 0xc0 as libc::c_int && c <= 0xdf as libc::c_int {
                    n = 1 as libc::c_int;
                    c_min = 0x80 as libc::c_int;
                    c &= 0x1f as libc::c_int;
                } else if c >= 0xe0 as libc::c_int && c <= 0xef as libc::c_int {
                    n = 2 as libc::c_int;
                    c_min = 0x800 as libc::c_int;
                    c &= 0xf as libc::c_int;
                } else if c >= 0xf0 as libc::c_int && c <= 0xf7 as libc::c_int {
                    n = 3 as libc::c_int;
                    c_min = 0x10000 as libc::c_int;
                    c &= 0x7 as libc::c_int;
                } else {
                    n = 0 as libc::c_int;
                    c_min = 1 as libc::c_int;
                    c = 0 as libc::c_int;
                }
                loop {
                    let fresh716 = n;
                    n = n - 1;
                    if !(fresh716 > 0 as libc::c_int) {
                        break;
                    }
                    c1 = hex_decode(ctx, p, k);
                    if c1 < 0 as libc::c_int {
                        current_block = 4547124847060847846;
                        break 's_35;
                    }
                    k += 3 as libc::c_int;
                    if c1 & 0xc0 as libc::c_int != 0x80 as libc::c_int {
                        c = 0 as libc::c_int;
                        break;
                    } else {
                        c = c << 6 as libc::c_int | c1 & 0x3f as libc::c_int;
                    }
                }
                if c < c_min || c > 0x10ffff as libc::c_int
                    || c >= 0xd800 as libc::c_int && c < 0xe000 as libc::c_int
                {
                    js_throw_URIError(
                        ctx,
                        b"malformed UTF-8\0" as *const u8 as *const libc::c_char,
                    );
                    current_block = 4547124847060847846;
                    break;
                }
            }
        } else {
            k += 1;
        }
        string_buffer_putc(b, c as uint32_t);
    }
    match current_block {
        4547124847060847846 => {
            JS_FreeValue(ctx, str);
            string_buffer_free(b);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {
            JS_FreeValue(ctx, str);
            return string_buffer_end(b);
        }
    };
}
unsafe extern "C" fn isUnescaped(mut c: libc::c_int) -> libc::c_int {
    static mut unescaped_chars: [libc::c_char; 70] = unsafe {
        *::core::mem::transmute::<
            &[u8; 70],
            &[libc::c_char; 70],
        >(b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./\0")
    };
    return (c < 0x100 as libc::c_int
        && !(memchr(
            unescaped_chars.as_ptr() as *const libc::c_void,
            c,
            (::core::mem::size_of::<[libc::c_char; 70]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        ))
            .is_null()) as libc::c_int;
}
unsafe extern "C" fn isURIUnescaped(
    mut c: libc::c_int,
    mut isComponent: libc::c_int,
) -> libc::c_int {
    return (c < 0x100 as libc::c_int
        && (c >= 0x61 as libc::c_int && c <= 0x7a as libc::c_int
            || c >= 0x41 as libc::c_int && c <= 0x5a as libc::c_int
            || c >= 0x30 as libc::c_int && c <= 0x39 as libc::c_int
            || !(memchr(
                b"-_.!~*'()\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                c,
                (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            ))
                .is_null() || isComponent == 0 && isURIReserved(c) != 0)) as libc::c_int;
}
unsafe extern "C" fn encodeURI_hex(
    mut b: *mut StringBuffer,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut buf: [uint8_t; 6] = [0; 6];
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut hex: *const libc::c_char = b"0123456789ABCDEF\0" as *const u8
        as *const libc::c_char;
    let fresh717 = n;
    n = n + 1;
    buf[fresh717 as usize] = '%' as i32 as uint8_t;
    if c >= 256 as libc::c_int {
        let fresh718 = n;
        n = n + 1;
        buf[fresh718 as usize] = 'u' as i32 as uint8_t;
        let fresh719 = n;
        n = n + 1;
        buf[fresh719
            as usize] = *hex
            .offset((c >> 12 as libc::c_int & 15 as libc::c_int) as isize) as uint8_t;
        let fresh720 = n;
        n = n + 1;
        buf[fresh720
            as usize] = *hex.offset((c >> 8 as libc::c_int & 15 as libc::c_int) as isize)
            as uint8_t;
    }
    let fresh721 = n;
    n = n + 1;
    buf[fresh721
        as usize] = *hex.offset((c >> 4 as libc::c_int & 15 as libc::c_int) as isize)
        as uint8_t;
    let fresh722 = n;
    n = n + 1;
    buf[fresh722
        as usize] = *hex.offset((c >> 0 as libc::c_int & 15 as libc::c_int) as isize)
        as uint8_t;
    return string_buffer_write8(b, buf.as_mut_ptr(), n);
}
unsafe extern "C" fn js_global_encodeURI(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut isComponent: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut str: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut k: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut c1: libc::c_int = 0;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    string_buffer_init(ctx, b, (*p).len() as libc::c_int);
    k = 0 as libc::c_int;
    loop {
        if !(k < (*p).len() as libc::c_int) {
            current_block = 7226443171521532240;
            break;
        }
        c = string_get(p, k);
        k += 1;
        if isURIUnescaped(c, isComponent) != 0 {
            string_buffer_putc16(b, c as uint32_t);
        } else if c >= 0xdc00 as libc::c_int && c <= 0xdfff as libc::c_int {
            js_throw_URIError(
                ctx,
                b"invalid character\0" as *const u8 as *const libc::c_char,
            );
            current_block = 10546119066303884174;
            break;
        } else {
            if c >= 0xd800 as libc::c_int && c <= 0xdbff as libc::c_int {
                if k >= (*p).len() as libc::c_int {
                    js_throw_URIError(
                        ctx,
                        b"expecting surrogate pair\0" as *const u8 as *const libc::c_char,
                    );
                    current_block = 10546119066303884174;
                    break;
                } else {
                    c1 = string_get(p, k);
                    k += 1;
                    if c1 < 0xdc00 as libc::c_int || c1 > 0xdfff as libc::c_int {
                        js_throw_URIError(
                            ctx,
                            b"expecting surrogate pair\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 10546119066303884174;
                        break;
                    } else {
                        c = ((c & 0x3ff as libc::c_int) << 10 as libc::c_int
                            | c1 & 0x3ff as libc::c_int) + 0x10000 as libc::c_int;
                    }
                }
            }
            if c < 0x80 as libc::c_int {
                encodeURI_hex(b, c);
            } else {
                if c < 0x800 as libc::c_int {
                    encodeURI_hex(b, c >> 6 as libc::c_int | 0xc0 as libc::c_int);
                } else {
                    if c < 0x10000 as libc::c_int {
                        encodeURI_hex(b, c >> 12 as libc::c_int | 0xe0 as libc::c_int);
                    } else {
                        encodeURI_hex(b, c >> 18 as libc::c_int | 0xf0 as libc::c_int);
                        encodeURI_hex(
                            b,
                            c >> 12 as libc::c_int & 0x3f as libc::c_int
                                | 0x80 as libc::c_int,
                        );
                    }
                    encodeURI_hex(
                        b,
                        c >> 6 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int,
                    );
                }
                encodeURI_hex(b, c & 0x3f as libc::c_int | 0x80 as libc::c_int);
            }
        }
    }
    match current_block {
        10546119066303884174 => {
            JS_FreeValue(ctx, str);
            string_buffer_free(b);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {
            JS_FreeValue(ctx, str);
            return string_buffer_end(b);
        }
    };
}
unsafe extern "C" fn js_global_escape(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        return str;
    }
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    string_buffer_init(ctx, b, (*p).len() as libc::c_int);
    i = 0 as libc::c_int;
    len = (*p).len() as libc::c_int;
    while i < len {
        c = string_get(p, i);
        if isUnescaped(c) != 0 {
            string_buffer_putc16(b, c as uint32_t);
        } else {
            encodeURI_hex(b, c);
        }
        i += 1;
    }
    JS_FreeValue(ctx, str);
    return string_buffer_end(b);
}
unsafe extern "C" fn js_global_unescape(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut str: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    str = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(str) != 0 {
        return str;
    }
    string_buffer_init(ctx, b, 0 as libc::c_int);
    p = str as intptr_t as *mut libc::c_void as *mut JSString;
    i = 0 as libc::c_int;
    len = (*p).len() as libc::c_int;
    while i < len {
        c = string_get(p, i);
        if c == '%' as i32 {
            if i + 6 as libc::c_int <= len
                && string_get(p, i + 1 as libc::c_int) == 'u' as i32
                && {
                    n = string_get_hex(p, i + 2 as libc::c_int, 4 as libc::c_int);
                    n >= 0 as libc::c_int
                }
            {
                c = n;
                i += 6 as libc::c_int - 1 as libc::c_int;
            } else if i + 3 as libc::c_int <= len
                && {
                    n = string_get_hex(p, i + 1 as libc::c_int, 2 as libc::c_int);
                    n >= 0 as libc::c_int
                }
            {
                c = n;
                i += 3 as libc::c_int - 1 as libc::c_int;
            }
        }
        string_buffer_putc16(b, c as uint32_t);
        i += 1;
    }
    JS_FreeValue(ctx, str);
    return string_buffer_end(b);
}
static mut js_global_funcs: [JSCFunctionListEntry; 14] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"parseInt\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_parseInt
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"parseFloat\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_parseFloat
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isNaN\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_global_isNaN
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"isFinite\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_global_isFinite
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"decodeURI\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_global_decodeURI
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"decodeURIComponent\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_global_decodeURI
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"encodeURI\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_global_encodeURI
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"encodeURIComponent\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_global_encodeURI
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"escape\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_global_escape
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"unescape\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_global_unescape
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"Infinity\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 1.0f64 / 0.0f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"NaN\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 6 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    f64_0: 9999.9999f64,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"undefined\0" as *const u8 as *const libc::c_char,
                prop_flags: 0 as libc::c_int as uint8_t,
                def_type: 7 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    i32_0: 0 as libc::c_int,
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"__date_clock\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js___date_clock
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn math_mod(mut a: int64_t, mut b: int64_t) -> int64_t {
    let mut m: int64_t = a % b;
    return m
        + (m < 0 as libc::c_int as libc::c_longlong) as libc::c_int as libc::c_longlong
            * b;
}
unsafe extern "C" fn floor_div(mut a: int64_t, mut b: int64_t) -> int64_t {
    let mut m: int64_t = a % b;
    return (a
        - (m
            + (m < 0 as libc::c_int as libc::c_longlong) as libc::c_int
                as libc::c_longlong * b)) / b;
}
unsafe extern "C" fn JS_ThisTimeValue(
    mut ctx: *mut JSContext,
    mut valp: *mut libc::c_double,
    mut this_val: JSValue,
) -> libc::c_int {
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_DATE as libc::c_int && JS_IsNumber((*p).u.object_data) != 0
        {
            return JS_ToFloat64(ctx, valp, (*p).u.object_data);
        }
    }
    JS_ThrowTypeError(ctx, b"not a Date object\0" as *const u8 as *const libc::c_char);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn JS_SetThisTimeValue(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut v: libc::c_double,
) -> JSValue {
    if (this_val >> 32 as libc::c_int) as libc::c_int == JS_TAG_OBJECT as libc::c_int {
        let mut p: *mut JSObject = this_val as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_DATE as libc::c_int
        {
            JS_FreeValue(ctx, (*p).u.object_data);
            (*p).u.object_data = JS_NewFloat64(ctx, v);
            return JS_DupValue(ctx, (*p).u.object_data);
        }
    }
    return JS_ThrowTypeError(
        ctx,
        b"not a Date object\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn days_from_year(mut y: int64_t) -> int64_t {
    return 365 as libc::c_int as libc::c_longlong
        * (y - 1970 as libc::c_int as libc::c_longlong)
        + floor_div(
            y - 1969 as libc::c_int as libc::c_longlong,
            4 as libc::c_int as int64_t,
        )
        - floor_div(
            y - 1901 as libc::c_int as libc::c_longlong,
            100 as libc::c_int as int64_t,
        )
        + floor_div(
            y - 1601 as libc::c_int as libc::c_longlong,
            400 as libc::c_int as int64_t,
        );
}
unsafe extern "C" fn days_in_year(mut y: int64_t) -> int64_t {
    return (365 as libc::c_int
        + (y % 4 as libc::c_int as libc::c_longlong == 0) as libc::c_int
        - (y % 100 as libc::c_int as libc::c_longlong == 0) as libc::c_int
        + (y % 400 as libc::c_int as libc::c_longlong == 0) as libc::c_int) as int64_t;
}
unsafe extern "C" fn year_from_days(mut days: *mut int64_t) -> int64_t {
    let mut y: int64_t = 0;
    let mut d1: int64_t = 0;
    let mut nd: int64_t = 0;
    let mut d: int64_t = *days;
    y = floor_div(
        d * 10000 as libc::c_int as libc::c_longlong,
        3652425 as libc::c_int as int64_t,
    ) + 1970 as libc::c_int as libc::c_longlong;
    loop {
        d1 = d - days_from_year(y);
        if d1 < 0 as libc::c_int as libc::c_longlong {
            y -= 1;
            d1 += days_in_year(y);
        } else {
            nd = days_in_year(y);
            if d1 < nd {
                break;
            }
            d1 -= nd;
            y += 1;
        }
    }
    *days = d1;
    return y;
}
static mut month_days: [libc::c_int; 12] = [
    31 as libc::c_int,
    28 as libc::c_int,
    31 as libc::c_int,
    30 as libc::c_int,
    31 as libc::c_int,
    30 as libc::c_int,
    31 as libc::c_int,
    31 as libc::c_int,
    30 as libc::c_int,
    31 as libc::c_int,
    30 as libc::c_int,
    31 as libc::c_int,
];
static mut month_names: [libc::c_char; 37] = unsafe {
    *::core::mem::transmute::<
        &[u8; 37],
        &[libc::c_char; 37],
    >(b"JanFebMarAprMayJunJulAugSepOctNovDec\0")
};
static mut day_names: [libc::c_char; 22] = unsafe {
    *::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"SunMonTueWedThuFriSat\0")
};
unsafe extern "C" fn get_date_fields(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut fields: *mut libc::c_double,
    mut is_local: libc::c_int,
    mut force: libc::c_int,
) -> libc::c_int {
    let mut dval: libc::c_double = 0.;
    let mut d: int64_t = 0;
    let mut days: int64_t = 0;
    let mut wd: int64_t = 0;
    let mut y: int64_t = 0;
    let mut i: int64_t = 0;
    let mut md: int64_t = 0;
    let mut h: int64_t = 0;
    let mut m: int64_t = 0;
    let mut s: int64_t = 0;
    let mut ms: int64_t = 0;
    let mut tz: int64_t = 0 as libc::c_int as int64_t;
    if JS_ThisTimeValue(ctx, &mut dval, obj) != 0 {
        return -(1 as libc::c_int);
    }
    if isnan(dval) != 0 {
        if force == 0 {
            return FALSE as libc::c_int;
        }
        d = 0 as libc::c_int as int64_t;
    } else {
        d = dval as int64_t;
        if is_local != 0 {
            tz = -getTimezoneOffset(d) as int64_t;
            d += tz * 60000 as libc::c_int as libc::c_longlong;
        }
    }
    h = math_mod(d, 86400000 as libc::c_int as int64_t);
    days = (d - h) / 86400000 as libc::c_int as libc::c_longlong;
    ms = h % 1000 as libc::c_int as libc::c_longlong;
    h = (h - ms) / 1000 as libc::c_int as libc::c_longlong;
    s = h % 60 as libc::c_int as libc::c_longlong;
    h = (h - s) / 60 as libc::c_int as libc::c_longlong;
    m = h % 60 as libc::c_int as libc::c_longlong;
    h = (h - m) / 60 as libc::c_int as libc::c_longlong;
    wd = math_mod(
        days + 4 as libc::c_int as libc::c_longlong,
        7 as libc::c_int as int64_t,
    );
    y = year_from_days(&mut days);
    i = 0 as libc::c_int as int64_t;
    while i < 11 as libc::c_int as libc::c_longlong {
        md = month_days[i as usize] as int64_t;
        if i == 1 as libc::c_int as libc::c_longlong {
            md += days_in_year(y) - 365 as libc::c_int as libc::c_longlong;
        }
        if days < md {
            break;
        }
        days -= md;
        i += 1;
    }
    *fields.offset(0 as libc::c_int as isize) = y as libc::c_double;
    *fields.offset(1 as libc::c_int as isize) = i as libc::c_double;
    *fields
        .offset(
            2 as libc::c_int as isize,
        ) = (days + 1 as libc::c_int as libc::c_longlong) as libc::c_double;
    *fields.offset(3 as libc::c_int as isize) = h as libc::c_double;
    *fields.offset(4 as libc::c_int as isize) = m as libc::c_double;
    *fields.offset(5 as libc::c_int as isize) = s as libc::c_double;
    *fields.offset(6 as libc::c_int as isize) = ms as libc::c_double;
    *fields.offset(7 as libc::c_int as isize) = wd as libc::c_double;
    *fields.offset(8 as libc::c_int as isize) = tz as libc::c_double;
    return TRUE as libc::c_int;
}
unsafe extern "C" fn time_clip(mut t: libc::c_double) -> libc::c_double {
    if t >= -8.64e15f64 && t <= 8.64e15f64 {
        return trunc(t) + 0.0f64
    } else {
        return 9999.9999f64
    };
}
unsafe extern "C" fn set_date_fields(
    mut fields: *mut libc::c_double,
    mut is_local: libc::c_int,
) -> libc::c_double {
    let mut y: int64_t = 0;
    let mut days: libc::c_double = 0.;
    let mut d: libc::c_double = 0.;
    let mut h: libc::c_double = 0.;
    let mut m1: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut md: libc::c_int = 0;
    m1 = *fields.offset(1 as libc::c_int as isize);
    m = fmod(m1, 12 as libc::c_int as libc::c_double) as libc::c_int;
    if m < 0 as libc::c_int {
        m += 12 as libc::c_int;
    }
    y = (*fields.offset(0 as libc::c_int as isize)
        + floor(m1 / 12 as libc::c_int as libc::c_double)) as int64_t;
    days = days_from_year(y) as libc::c_double;
    i = 0 as libc::c_int;
    while i < m {
        md = month_days[i as usize];
        if i == 1 as libc::c_int {
            md = (md as libc::c_longlong
                + (days_in_year(y) - 365 as libc::c_int as libc::c_longlong))
                as libc::c_int;
        }
        days += md as libc::c_double;
        i += 1;
    }
    days
        += *fields.offset(2 as libc::c_int as isize)
            - 1 as libc::c_int as libc::c_double;
    h = *fields.offset(3 as libc::c_int as isize)
        * 3600000 as libc::c_int as libc::c_double
        + *fields.offset(4 as libc::c_int as isize)
            * 60000 as libc::c_int as libc::c_double
        + *fields.offset(5 as libc::c_int as isize)
            * 1000 as libc::c_int as libc::c_double
        + *fields.offset(6 as libc::c_int as isize);
    d = days * 86400000 as libc::c_int as libc::c_double + h;
    if is_local != 0 {
        d += (getTimezoneOffset(d as int64_t) * 60000 as libc::c_int) as libc::c_double;
    }
    return time_clip(d);
}
unsafe extern "C" fn get_date_field(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut fields: [libc::c_double; 9] = [0.; 9];
    let mut res: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut is_local: libc::c_int = 0;
    is_local = magic & 0xf as libc::c_int;
    n = magic >> 4 as libc::c_int & 0xf as libc::c_int;
    res = get_date_fields(
        ctx,
        this_val,
        fields.as_mut_ptr(),
        is_local,
        0 as libc::c_int,
    );
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res == 0 {
        return (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    }
    if magic & 0x100 as libc::c_int != 0 {
        fields[0 as libc::c_int as usize] -= 1900 as libc::c_int as libc::c_double;
    }
    return JS_NewFloat64(ctx, fields[n as usize]);
}
unsafe extern "C" fn set_date_field(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut fields: [libc::c_double; 9] = [0.; 9];
    let mut res: libc::c_int = 0;
    let mut first_field: libc::c_int = 0;
    let mut end_field: libc::c_int = 0;
    let mut is_local: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    let mut a: libc::c_double = 0.;
    d = 9999.9999f64;
    first_field = magic >> 8 as libc::c_int & 0xf as libc::c_int;
    end_field = magic >> 4 as libc::c_int & 0xf as libc::c_int;
    is_local = magic & 0xf as libc::c_int;
    res = get_date_fields(
        ctx,
        this_val,
        fields.as_mut_ptr(),
        is_local,
        (first_field == 0 as libc::c_int) as libc::c_int,
    );
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res != 0 && argc > 0 as libc::c_int {
        n = end_field - first_field;
        if argc < n {
            n = argc;
        }
        i = 0 as libc::c_int;
        loop {
            if !(i < n) {
                current_block = 15976848397966268834;
                break;
            }
            if JS_ToFloat64(ctx, &mut a, *argv.offset(i as isize)) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if isfinite(a) == 0 {
                current_block = 4591084726433101020;
                break;
            }
            fields[(first_field + i) as usize] = trunc(a);
            i += 1;
        }
        match current_block {
            4591084726433101020 => {}
            _ => {
                d = set_date_fields(fields.as_mut_ptr(), is_local);
            }
        }
    }
    return JS_SetThisTimeValue(ctx, this_val, d);
}
unsafe extern "C" fn get_date_string(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    let mut buf: [libc::c_char; 64] = [0; 64];
    let mut fields: [libc::c_double; 9] = [0.; 9];
    let mut res: libc::c_int = 0;
    let mut fmt: libc::c_int = 0;
    let mut part: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut mon: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut ms: libc::c_int = 0;
    let mut wd: libc::c_int = 0;
    let mut tz: libc::c_int = 0;
    fmt = magic >> 4 as libc::c_int & 0xf as libc::c_int;
    part = magic & 0xf as libc::c_int;
    res = get_date_fields(
        ctx,
        this_val,
        fields.as_mut_ptr(),
        fmt & 1 as libc::c_int,
        0 as libc::c_int,
    );
    if res < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if res == 0 {
        if fmt == 2 as libc::c_int {
            return JS_ThrowRangeError(
                ctx,
                b"Date value is NaN\0" as *const u8 as *const libc::c_char,
            )
        } else {
            return JS_NewString(
                ctx,
                b"Invalid Date\0" as *const u8 as *const libc::c_char,
            )
        }
    }
    y = fields[0 as libc::c_int as usize] as libc::c_int;
    mon = fields[1 as libc::c_int as usize] as libc::c_int;
    d = fields[2 as libc::c_int as usize] as libc::c_int;
    h = fields[3 as libc::c_int as usize] as libc::c_int;
    m = fields[4 as libc::c_int as usize] as libc::c_int;
    s = fields[5 as libc::c_int as usize] as libc::c_int;
    ms = fields[6 as libc::c_int as usize] as libc::c_int;
    wd = fields[7 as libc::c_int as usize] as libc::c_int;
    tz = fields[8 as libc::c_int as usize] as libc::c_int;
    pos = 0 as libc::c_int;
    if part & 1 as libc::c_int != 0 {
        match fmt {
            0 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%.3s, %02d %.3s %0*d \0" as *const u8 as *const libc::c_char,
                        day_names.as_ptr().offset((wd * 3 as libc::c_int) as isize),
                        d,
                        month_names.as_ptr().offset((mon * 3 as libc::c_int) as isize),
                        4 as libc::c_int + (y < 0 as libc::c_int) as libc::c_int,
                        y,
                    );
            }
            1 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%.3s %.3s %02d %0*d\0" as *const u8 as *const libc::c_char,
                        day_names.as_ptr().offset((wd * 3 as libc::c_int) as isize),
                        month_names.as_ptr().offset((mon * 3 as libc::c_int) as isize),
                        d,
                        4 as libc::c_int + (y < 0 as libc::c_int) as libc::c_int,
                        y,
                    );
                if part == 3 as libc::c_int {
                    let fresh723 = pos;
                    pos = pos + 1;
                    buf[fresh723 as usize] = ' ' as i32 as libc::c_char;
                }
            }
            2 => {
                if y >= 0 as libc::c_int && y <= 9999 as libc::c_int {
                    pos
                        += snprintf(
                            buf.as_mut_ptr().offset(pos as isize),
                            (::core::mem::size_of::<[libc::c_char; 64]>()
                                as libc::c_ulong)
                                .wrapping_sub(pos as libc::c_ulong),
                            b"%04d\0" as *const u8 as *const libc::c_char,
                            y,
                        );
                } else {
                    pos
                        += snprintf(
                            buf.as_mut_ptr().offset(pos as isize),
                            (::core::mem::size_of::<[libc::c_char; 64]>()
                                as libc::c_ulong)
                                .wrapping_sub(pos as libc::c_ulong),
                            b"%+07d\0" as *const u8 as *const libc::c_char,
                            y,
                        );
                }
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"-%02d-%02dT\0" as *const u8 as *const libc::c_char,
                        mon + 1 as libc::c_int,
                        d,
                    );
            }
            3 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d/%02d/%0*d\0" as *const u8 as *const libc::c_char,
                        mon + 1 as libc::c_int,
                        d,
                        4 as libc::c_int + (y < 0 as libc::c_int) as libc::c_int,
                        y,
                    );
                if part == 3 as libc::c_int {
                    let fresh724 = pos;
                    pos = pos + 1;
                    buf[fresh724 as usize] = ',' as i32 as libc::c_char;
                    let fresh725 = pos;
                    pos = pos + 1;
                    buf[fresh725 as usize] = ' ' as i32 as libc::c_char;
                }
            }
            _ => {}
        }
    }
    if part & 2 as libc::c_int != 0 {
        match fmt {
            0 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d:%02d:%02d GMT\0" as *const u8 as *const libc::c_char,
                        h,
                        m,
                        s,
                    );
            }
            1 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d:%02d:%02d GMT\0" as *const u8 as *const libc::c_char,
                        h,
                        m,
                        s,
                    );
                if tz < 0 as libc::c_int {
                    let fresh726 = pos;
                    pos = pos + 1;
                    buf[fresh726 as usize] = '-' as i32 as libc::c_char;
                    tz = -tz;
                } else {
                    let fresh727 = pos;
                    pos = pos + 1;
                    buf[fresh727 as usize] = '+' as i32 as libc::c_char;
                }
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d%02d\0" as *const u8 as *const libc::c_char,
                        tz / 60 as libc::c_int,
                        tz % 60 as libc::c_int,
                    );
            }
            2 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d:%02d:%02d.%03dZ\0" as *const u8 as *const libc::c_char,
                        h,
                        m,
                        s,
                        ms,
                    );
            }
            3 => {
                pos
                    += snprintf(
                        buf.as_mut_ptr().offset(pos as isize),
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(pos as libc::c_ulong),
                        b"%02d:%02d:%02d %cM\0" as *const u8 as *const libc::c_char,
                        (h + 1 as libc::c_int) % 12 as libc::c_int - 1 as libc::c_int,
                        m,
                        s,
                        if h < 12 as libc::c_int { 'A' as i32 } else { 'P' as i32 },
                    );
            }
            _ => {}
        }
    }
    return JS_NewStringLen(ctx, buf.as_mut_ptr(), pos as size_t);
}
unsafe extern "C" fn date_now() -> int64_t {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    gettimeofday(&mut tv, 0 as *mut libc::c_void);
    return tv.tv_sec * 1000 as libc::c_int as libc::c_longlong
        + tv.tv_usec / 1000 as libc::c_int as libc::c_longlong;
}
unsafe extern "C" fn js_date_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut rv: JSValue = 0;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut a: libc::c_double = 0.;
    let mut val: libc::c_double = 0.;
    if JS_IsUndefined(new_target) != 0 {
        argc = 0 as libc::c_int;
    }
    n = argc;
    if n == 0 as libc::c_int {
        val = date_now() as libc::c_double;
    } else if n == 1 as libc::c_int {
        let mut v: JSValue = 0;
        let mut dv: JSValue = 0;
        if (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
            == JS_TAG_OBJECT as libc::c_int
        {
            let mut p: *mut JSObject = *argv.offset(0 as libc::c_int as isize)
                as intptr_t as *mut libc::c_void as *mut JSObject;
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                == JS_CLASS_DATE as libc::c_int && JS_IsNumber((*p).u.object_data) != 0
            {
                if JS_ToFloat64(ctx, &mut val, (*p).u.object_data) != 0 {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                val = time_clip(val);
                current_block = 2797844157448739368;
            } else {
                current_block = 9606288038608642794;
            }
        } else {
            current_block = 9606288038608642794;
        }
        match current_block {
            2797844157448739368 => {}
            _ => {
                v = JS_ToPrimitive(
                    ctx,
                    *argv.offset(0 as libc::c_int as isize),
                    2 as libc::c_int,
                );
                if JS_IsString(v) != 0 {
                    dv = js_Date_parse(
                        ctx,
                        (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                        1 as libc::c_int,
                        &mut v as *mut JSValue,
                    );
                    JS_FreeValue(ctx, v);
                    if JS_IsException(dv) != 0 {
                        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                    if JS_ToFloat64Free(ctx, &mut val, dv) != 0 {
                        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                    }
                } else if JS_ToFloat64Free(ctx, &mut val, v) != 0 {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong
                }
                val = time_clip(val);
            }
        }
    } else {
        let mut fields: [libc::c_double; 7] = [
            0 as libc::c_int as libc::c_double,
            0 as libc::c_int as libc::c_double,
            1 as libc::c_int as libc::c_double,
            0 as libc::c_int as libc::c_double,
            0 as libc::c_int as libc::c_double,
            0 as libc::c_int as libc::c_double,
            0 as libc::c_int as libc::c_double,
        ];
        if n > 7 as libc::c_int {
            n = 7 as libc::c_int;
        }
        i = 0 as libc::c_int;
        while i < n {
            if JS_ToFloat64(ctx, &mut a, *argv.offset(i as isize)) != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if isfinite(a) == 0 {
                break;
            }
            fields[i as usize] = trunc(a);
            if i == 0 as libc::c_int
                && fields[0 as libc::c_int as usize]
                    >= 0 as libc::c_int as libc::c_double
                && fields[0 as libc::c_int as usize]
                    < 100 as libc::c_int as libc::c_double
            {
                fields[0 as libc::c_int as usize]
                    += 1900 as libc::c_int as libc::c_double;
            }
            i += 1;
        }
        val = if i == n {
            set_date_fields(fields.as_mut_ptr(), 1 as libc::c_int)
        } else {
            9999.9999f64
        };
    }
    rv = js_create_from_ctor(ctx, new_target, JS_CLASS_DATE as libc::c_int);
    if JS_IsException(rv) == 0 {
        JS_SetObjectData(ctx, rv, JS_NewFloat64(ctx, val));
    }
    if JS_IsException(rv) == 0 && JS_IsUndefined(new_target) != 0 {
        let mut s: JSValue = 0;
        s = get_date_string(
            ctx,
            rv,
            0 as libc::c_int,
            0 as *mut JSValue,
            0x13 as libc::c_int,
        );
        JS_FreeValue(ctx, rv);
        rv = s;
    }
    return rv;
}
unsafe extern "C" fn js_Date_UTC(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut fields: [libc::c_double; 7] = [
        0 as libc::c_int as libc::c_double,
        0 as libc::c_int as libc::c_double,
        1 as libc::c_int as libc::c_double,
        0 as libc::c_int as libc::c_double,
        0 as libc::c_int as libc::c_double,
        0 as libc::c_int as libc::c_double,
        0 as libc::c_int as libc::c_double,
    ];
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut a: libc::c_double = 0.;
    n = argc;
    if n == 0 as libc::c_int {
        return (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            );
    }
    if n > 7 as libc::c_int {
        n = 7 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < n {
        if JS_ToFloat64(ctx, &mut a, *argv.offset(i as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if isfinite(a) == 0 {
            return (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
                .wrapping_sub(
                    ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                        + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
                );
        }
        fields[i as usize] = trunc(a);
        if i == 0 as libc::c_int
            && fields[0 as libc::c_int as usize] >= 0 as libc::c_int as libc::c_double
            && fields[0 as libc::c_int as usize] < 100 as libc::c_int as libc::c_double
        {
            fields[0 as libc::c_int as usize] += 1900 as libc::c_int as libc::c_double;
        }
        i += 1;
    }
    return JS_NewFloat64(ctx, set_date_fields(fields.as_mut_ptr(), 0 as libc::c_int));
}
unsafe extern "C" fn string_skip_spaces(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
) {
    while *pp < (*sp).len() as libc::c_int && string_get(sp, *pp) == ' ' as i32 {
        *pp += 1 as libc::c_int;
    }
}
unsafe extern "C" fn string_skip_non_spaces(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
) {
    while *pp < (*sp).len() as libc::c_int && string_get(sp, *pp) != ' ' as i32 {
        *pp += 1 as libc::c_int;
    }
}
unsafe extern "C" fn string_get_digits(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
    mut pval: *mut int64_t,
) -> libc::c_int {
    let mut v: int64_t = 0 as libc::c_int as int64_t;
    let mut c: libc::c_int = 0;
    let mut p: libc::c_int = *pp;
    let mut p_start: libc::c_int = 0;
    if p >= (*sp).len() as libc::c_int {
        return -(1 as libc::c_int);
    }
    p_start = p;
    while p < (*sp).len() as libc::c_int {
        c = string_get(sp, p);
        if !(c >= '0' as i32 && c <= '9' as i32) {
            if !(p == p_start) {
                break;
            }
            return -(1 as libc::c_int);
        } else {
            v = v * 10 as libc::c_int as libc::c_longlong + c as libc::c_longlong
                - '0' as i32 as libc::c_longlong;
            p += 1;
        }
    }
    *pval = v;
    *pp = p;
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_get_signed_digits(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
    mut pval: *mut int64_t,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut p: libc::c_int = *pp;
    if p >= (*sp).len() as libc::c_int {
        return -(1 as libc::c_int);
    }
    sgn = string_get(sp, p);
    if sgn == '-' as i32 || sgn == '+' as i32 {
        p += 1;
    }
    res = string_get_digits(sp, &mut p, pval);
    if res == 0 as libc::c_int && sgn == '-' as i32 {
        *pval = -*pval;
    }
    *pp = p;
    return res;
}
unsafe extern "C" fn string_get_fixed_width_digits(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
    mut n: libc::c_int,
    mut pval: *mut int64_t,
) -> libc::c_int {
    let mut v: int64_t = 0 as libc::c_int as int64_t;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut p: libc::c_int = *pp;
    i = 0 as libc::c_int;
    while i < n {
        if p >= (*sp).len() as libc::c_int {
            return -(1 as libc::c_int);
        }
        c = string_get(sp, p);
        if !(c >= '0' as i32 && c <= '9' as i32) {
            return -(1 as libc::c_int);
        }
        v = v * 10 as libc::c_int as libc::c_longlong + c as libc::c_longlong
            - '0' as i32 as libc::c_longlong;
        p += 1;
        i += 1;
    }
    *pval = v;
    *pp = p;
    return 0 as libc::c_int;
}
unsafe extern "C" fn string_get_milliseconds(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
    mut pval: *mut int64_t,
) -> libc::c_int {
    let mut mul: libc::c_int = 1000 as libc::c_int;
    let mut ms: libc::c_int = 0 as libc::c_int;
    let mut p: libc::c_int = *pp;
    let mut c: libc::c_int = 0;
    let mut p_start: libc::c_int = 0;
    if p >= (*sp).len() as libc::c_int {
        return -(1 as libc::c_int);
    }
    p_start = p;
    while p < (*sp).len() as libc::c_int {
        c = string_get(sp, p);
        if !(c >= '0' as i32 && c <= '9' as i32) {
            if !(p == p_start) {
                break;
            }
            return -(1 as libc::c_int);
        } else {
            if mul == 1 as libc::c_int && c >= '5' as i32 {
                ms += 1 as libc::c_int;
            }
            mul /= 10 as libc::c_int;
            ms += (c - '0' as i32) * mul;
            p += 1;
        }
    }
    *pval = ms as int64_t;
    *pp = p;
    return 0 as libc::c_int;
}
unsafe extern "C" fn find_abbrev(
    mut sp: *mut JSString,
    mut p: libc::c_int,
    mut list: *const libc::c_char,
    mut count: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    if p + 3 as libc::c_int <= (*sp).len() as libc::c_int {
        n = 0 as libc::c_int;
        while n < count {
            let mut current_block_3: u64;
            i = 0 as libc::c_int;
            loop {
                if !(i < 3 as libc::c_int) {
                    current_block_3 = 11006700562992250127;
                    break;
                }
                if string_get(sp, p + i)
                    != month_names[(n * 3 as libc::c_int + i) as usize] as libc::c_int
                {
                    current_block_3 = 3276175668257526147;
                    break;
                }
                i += 1;
            }
            match current_block_3 {
                3276175668257526147 => {}
                _ => return n,
            }
            n += 1;
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn string_get_month(
    mut sp: *mut JSString,
    mut pp: *mut libc::c_int,
    mut pval: *mut int64_t,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    string_skip_spaces(sp, pp);
    n = find_abbrev(sp, *pp, month_names.as_ptr(), 12 as libc::c_int);
    if n < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    *pval = n as int64_t;
    *pp += 3 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_Date_parse(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut s: JSValue = 0;
    let mut rv: JSValue = 0;
    let mut fields: [int64_t; 7] = [
        0 as libc::c_int as int64_t,
        1 as libc::c_int as int64_t,
        1 as libc::c_int as int64_t,
        0 as libc::c_int as int64_t,
        0 as libc::c_int as int64_t,
        0 as libc::c_int as int64_t,
        0 as libc::c_int as int64_t,
    ];
    let mut fields1: [libc::c_double; 7] = [0.; 7];
    let mut tz: int64_t = 0;
    let mut hh: int64_t = 0;
    let mut mm: int64_t = 0;
    let mut d: libc::c_double = 0.;
    let mut p: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut sp: *mut JSString = 0 as *mut JSString;
    let mut is_local: BOOL = 0;
    rv = (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
        .wrapping_sub(
            ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int + 1 as libc::c_int)
                as uint64_t) << 32 as libc::c_int,
        );
    s = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
    if JS_IsException(s) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    sp = s as intptr_t as *mut libc::c_void as *mut JSString;
    p = 0 as libc::c_int;
    if p < (*sp).len() as libc::c_int
        && {
            c = string_get(sp, p);
            c >= '0' as i32 && c <= '9' as i32 || c == '+' as i32 || c == '-' as i32
        }
    {
        if string_get_signed_digits(
            sp,
            &mut p,
            &mut *fields.as_mut_ptr().offset(0 as libc::c_int as isize),
        ) != 0
        {
            current_block = 17820698609634942524;
        } else {
            i = 1 as libc::c_int;
            loop {
                if !(i < 7 as libc::c_int) {
                    current_block = 2569451025026770673;
                    break;
                }
                if p >= (*sp).len() as libc::c_int {
                    current_block = 2569451025026770673;
                    break;
                }
                match i {
                    1 | 2 => {
                        c = '-' as i32;
                    }
                    3 => {
                        c = 'T' as i32;
                    }
                    4 | 5 => {
                        c = ':' as i32;
                    }
                    6 => {
                        c = '.' as i32;
                    }
                    _ => {}
                }
                if string_get(sp, p) != c {
                    current_block = 2569451025026770673;
                    break;
                }
                p += 1;
                if i == 6 as libc::c_int {
                    if string_get_milliseconds(
                        sp,
                        &mut p,
                        &mut *fields.as_mut_ptr().offset(i as isize),
                    ) != 0
                    {
                        current_block = 17820698609634942524;
                        break;
                    }
                } else if string_get_digits(
                    sp,
                    &mut p,
                    &mut *fields.as_mut_ptr().offset(i as isize),
                ) != 0
                {
                    current_block = 17820698609634942524;
                    break;
                }
                i += 1;
            }
            match current_block {
                17820698609634942524 => {}
                _ => {
                    is_local = (i > 3 as libc::c_int) as libc::c_int;
                    fields[1 as libc::c_int as usize]
                        -= 1 as libc::c_int as libc::c_longlong;
                    tz = 0 as libc::c_int as int64_t;
                    if p < (*sp).len() as libc::c_int {
                        sgn = string_get(sp, p);
                        if sgn == '+' as i32 || sgn == '-' as i32 {
                            p += 1;
                            l = (*sp).len() as libc::c_int - p;
                            if l != 4 as libc::c_int && l != 5 as libc::c_int {
                                current_block = 17820698609634942524;
                            } else if string_get_fixed_width_digits(
                                sp,
                                &mut p,
                                2 as libc::c_int,
                                &mut hh,
                            ) != 0
                            {
                                current_block = 17820698609634942524;
                            } else {
                                if l == 5 as libc::c_int {
                                    if string_get(sp, p) != ':' as i32 {
                                        current_block = 17820698609634942524;
                                    } else {
                                        p += 1;
                                        current_block = 721385680381463314;
                                    }
                                } else {
                                    current_block = 721385680381463314;
                                }
                                match current_block {
                                    17820698609634942524 => {}
                                    _ => {
                                        if string_get_fixed_width_digits(
                                            sp,
                                            &mut p,
                                            2 as libc::c_int,
                                            &mut mm,
                                        ) != 0
                                        {
                                            current_block = 17820698609634942524;
                                        } else {
                                            tz = hh * 60 as libc::c_int as libc::c_longlong + mm;
                                            if sgn == '-' as i32 {
                                                tz = -tz;
                                            }
                                            is_local = FALSE as libc::c_int;
                                            current_block = 8151474771948790331;
                                        }
                                    }
                                }
                            }
                        } else if sgn == 'Z' as i32 {
                            p += 1;
                            is_local = FALSE as libc::c_int;
                            current_block = 8151474771948790331;
                        } else {
                            current_block = 17820698609634942524;
                        }
                        match current_block {
                            17820698609634942524 => {}
                            _ => {
                                if p != (*sp).len() as libc::c_int {
                                    current_block = 17820698609634942524;
                                } else {
                                    current_block = 17769492591016358583;
                                }
                            }
                        }
                    } else {
                        current_block = 17769492591016358583;
                    }
                }
            }
        }
    } else {
        string_skip_non_spaces(sp, &mut p);
        string_skip_spaces(sp, &mut p);
        if p >= (*sp).len() as libc::c_int {
            current_block = 17820698609634942524;
        } else {
            c = string_get(sp, p);
            if c >= '0' as i32 && c <= '9' as i32 {
                if string_get_digits(
                    sp,
                    &mut p,
                    &mut *fields.as_mut_ptr().offset(2 as libc::c_int as isize),
                ) != 0
                {
                    current_block = 17820698609634942524;
                } else if string_get_month(
                    sp,
                    &mut p,
                    &mut *fields.as_mut_ptr().offset(1 as libc::c_int as isize),
                ) != 0
                {
                    current_block = 17820698609634942524;
                } else {
                    current_block = 13660591889533726445;
                }
            } else if string_get_month(
                sp,
                &mut p,
                &mut *fields.as_mut_ptr().offset(1 as libc::c_int as isize),
            ) != 0
            {
                current_block = 17820698609634942524;
            } else {
                string_skip_spaces(sp, &mut p);
                if string_get_digits(
                    sp,
                    &mut p,
                    &mut *fields.as_mut_ptr().offset(2 as libc::c_int as isize),
                ) != 0
                {
                    current_block = 17820698609634942524;
                } else {
                    current_block = 13660591889533726445;
                }
            }
            match current_block {
                17820698609634942524 => {}
                _ => {
                    string_skip_spaces(sp, &mut p);
                    if string_get_signed_digits(
                        sp,
                        &mut p,
                        &mut *fields.as_mut_ptr().offset(0 as libc::c_int as isize),
                    ) != 0
                    {
                        current_block = 17820698609634942524;
                    } else {
                        string_skip_spaces(sp, &mut p);
                        i = 0 as libc::c_int;
                        loop {
                            if !(i < 3 as libc::c_int) {
                                current_block = 726525485109251713;
                                break;
                            }
                            if i == 1 as libc::c_int || i == 2 as libc::c_int {
                                if p >= (*sp).len() as libc::c_int {
                                    current_block = 17820698609634942524;
                                    break;
                                }
                                if string_get(sp, p) != ':' as i32 {
                                    current_block = 17820698609634942524;
                                    break;
                                }
                                p += 1;
                            }
                            if string_get_digits(
                                sp,
                                &mut p,
                                &mut *fields
                                    .as_mut_ptr()
                                    .offset((3 as libc::c_int + i) as isize),
                            ) != 0
                            {
                                current_block = 17820698609634942524;
                                break;
                            }
                            i += 1;
                        }
                        match current_block {
                            17820698609634942524 => {}
                            _ => {
                                is_local = FALSE as libc::c_int;
                                tz = 0 as libc::c_int as int64_t;
                                tz = 0 as libc::c_int as int64_t;
                                loop {
                                    if !(p < (*sp).len() as libc::c_int) {
                                        current_block = 17769492591016358583;
                                        break;
                                    }
                                    sgn = string_get(sp, p);
                                    if sgn == '+' as i32 || sgn == '-' as i32 {
                                        p += 1;
                                        if string_get_fixed_width_digits(
                                            sp,
                                            &mut p,
                                            2 as libc::c_int,
                                            &mut hh,
                                        ) != 0
                                        {
                                            current_block = 17820698609634942524;
                                            break;
                                        }
                                        if string_get_fixed_width_digits(
                                            sp,
                                            &mut p,
                                            2 as libc::c_int,
                                            &mut mm,
                                        ) != 0
                                        {
                                            current_block = 17820698609634942524;
                                            break;
                                        }
                                        tz = hh * 60 as libc::c_int as libc::c_longlong + mm;
                                        if sgn == '-' as i32 {
                                            tz = -tz;
                                        }
                                        current_block = 17769492591016358583;
                                        break;
                                    } else {
                                        p += 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        17769492591016358583 => {
            i = 0 as libc::c_int;
            while i < 7 as libc::c_int {
                fields1[i as usize] = fields[i as usize] as libc::c_double;
                i += 1;
            }
            d = set_date_fields(fields1.as_mut_ptr(), is_local)
                - (tz * 60000 as libc::c_int as libc::c_longlong) as libc::c_double;
            rv = JS_NewFloat64(ctx, d);
        }
        _ => {}
    }
    JS_FreeValue(ctx, s);
    return rv;
}
unsafe extern "C" fn js_Date_now(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_NewInt64(ctx, date_now());
}
unsafe extern "C" fn js_date_Symbol_toPrimitive(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = this_val;
    let mut hint: JSAtom = 0 as libc::c_int as JSAtom;
    let mut hint_num: libc::c_int = 0;
    if JS_IsObject(obj) == 0 {
        return JS_ThrowTypeErrorNotAnObject(ctx);
    }
    if JS_IsString(*argv.offset(0 as libc::c_int as isize)) != 0 {
        hint = JS_ValueToAtom(ctx, *argv.offset(0 as libc::c_int as isize));
        if hint == 0 as libc::c_int as libc::c_uint {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        JS_FreeAtom(ctx, hint);
    }
    match hint {
        70 => {
            hint_num = 1 as libc::c_int;
        }
        72 | 22 => {
            hint_num = 0 as libc::c_int;
        }
        _ => {
            return JS_ThrowTypeError(
                ctx,
                b"invalid hint\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return JS_ToPrimitive(ctx, obj, hint_num | (1 as libc::c_int) << 4 as libc::c_int);
}
unsafe extern "C" fn js_date_getTimezoneOffset(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut v: libc::c_double = 0.;
    if JS_ThisTimeValue(ctx, &mut v, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if isnan(v) != 0 {
        return (0x7ff8000000000000 as libc::c_longlong as libc::c_ulonglong)
            .wrapping_sub(
                ((0x7ff80000 as libc::c_int - JS_TAG_FIRST as libc::c_int
                    + 1 as libc::c_int) as uint64_t) << 32 as libc::c_int,
            )
    } else {
        return JS_NewInt64(ctx, getTimezoneOffset(trunc(v) as int64_t) as int64_t)
    };
}
unsafe extern "C" fn js_date_getTime(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut v: libc::c_double = 0.;
    if JS_ThisTimeValue(ctx, &mut v, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewFloat64(ctx, v);
}
unsafe extern "C" fn js_date_setTime(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut v: libc::c_double = 0.;
    if JS_ThisTimeValue(ctx, &mut v, this_val) != 0
        || JS_ToFloat64(ctx, &mut v, *argv.offset(0 as libc::c_int as isize)) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_SetThisTimeValue(ctx, this_val, time_clip(v));
}
unsafe extern "C" fn js_date_setYear(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut y: libc::c_double = 0.;
    let mut args: [JSValue; 1] = [0; 1];
    if JS_ThisTimeValue(ctx, &mut y, this_val) != 0
        || JS_ToFloat64(ctx, &mut y, *argv.offset(0 as libc::c_int as isize)) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    y = y;
    if isfinite(y) != 0 {
        y = trunc(y);
        if y >= 0 as libc::c_int as libc::c_double
            && y < 100 as libc::c_int as libc::c_double
        {
            y += 1900 as libc::c_int as libc::c_double;
        }
    }
    args[0 as libc::c_int as usize] = JS_NewFloat64(ctx, y);
    return set_date_field(
        ctx,
        this_val,
        1 as libc::c_int,
        args.as_mut_ptr(),
        0x11 as libc::c_int,
    );
}
unsafe extern "C" fn js_date_toJSON(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut obj: JSValue = 0;
    let mut tv: JSValue = 0;
    let mut method: JSValue = 0;
    let mut rv: JSValue = 0;
    let mut d: libc::c_double = 0.;
    rv = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    tv = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    obj = JS_ToObject(ctx, this_val);
    tv = JS_ToPrimitive(ctx, obj, 1 as libc::c_int);
    if !(JS_IsException(tv) != 0) {
        if JS_IsNumber(tv) != 0 {
            if JS_ToFloat64(ctx, &mut d, tv) < 0 as libc::c_int {
                current_block = 10823485730815279281;
            } else if isfinite(d) == 0 {
                rv = (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                current_block = 10823485730815279281;
            } else {
                current_block = 11650488183268122163;
            }
        } else {
            current_block = 11650488183268122163;
        }
        match current_block {
            10823485730815279281 => {}
            _ => {
                method = JS_GetPropertyStr(
                    ctx,
                    obj,
                    b"toISOString\0" as *const u8 as *const libc::c_char,
                );
                if !(JS_IsException(method) != 0) {
                    if JS_IsFunction(ctx, method) == 0 {
                        JS_ThrowTypeError(
                            ctx,
                            b"object needs toISOString method\0" as *const u8
                                as *const libc::c_char,
                        );
                        JS_FreeValue(ctx, method);
                    } else {
                        rv = JS_CallFree(
                            ctx,
                            method,
                            obj,
                            0 as libc::c_int,
                            0 as *mut JSValue,
                        );
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    JS_FreeValue(ctx, tv);
    return rv;
}
static mut js_date_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"now\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_Date_now
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"parse\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_Date_parse
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"UTC\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 7 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_Date_UTC
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_date_proto_funcs: [JSCFunctionListEntry; 47] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"valueOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_getTime
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x13 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toPrimitive]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_Symbol_toPrimitive
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toUTCString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x3 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toGMTString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"toUTCString\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toISOString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x23 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toDateString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x11 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toTimeString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x12 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x33 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleDateString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x31 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleTimeString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x32 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_string
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getTimezoneOffset\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_getTimezoneOffset
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getTime\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_getTime
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x101 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getFullYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCFullYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getMonth\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x11 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCMonth\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x10 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getDate\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x21 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCDate\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x20 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getHours\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x31 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCHours\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x30 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getMinutes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x41 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCMinutes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x40 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getSeconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x51 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCSeconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x50 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getMilliseconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x61 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCMilliseconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x60 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getDay\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x71 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUTCDay\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x70 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    get_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setTime\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_setTime
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setMilliseconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x671 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCMilliseconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x670 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setSeconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x571 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCSeconds\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x570 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setMinutes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x471 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCMinutes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x470 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setHours\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x371 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 4 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCHours\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x370 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 4 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setDate\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x231 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCDate\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x230 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setMonth\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x131 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCMonth\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x130 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_setYear
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setFullYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x31 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUTCFullYear\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0x30 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 3 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    set_date_field
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toJSON\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_date_toJSON
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicDate(mut ctx: *mut JSContext) {
    let mut obj: JSValue = 0;
    *((*ctx).class_proto)
        .offset(JS_CLASS_DATE as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_DATE as libc::c_int as isize),
        js_date_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 47]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"Date\0" as *const u8 as *const libc::c_char,
        Some(
            js_date_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        7 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_DATE as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_date_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicEval(mut ctx: *mut JSContext) {
    let ref mut fresh728 = (*ctx).eval_internal;
    *fresh728 = Some(
        __JS_EvalInternal
            as unsafe extern "C" fn(
                *mut JSContext,
                JSValue,
                *const libc::c_char,
                size_t,
                *const libc::c_char,
                libc::c_int,
                libc::c_int,
            ) -> JSValue,
    );
}
static mut native_error_name: [*const libc::c_char; 8] = [
    b"EvalError\0" as *const u8 as *const libc::c_char,
    b"RangeError\0" as *const u8 as *const libc::c_char,
    b"ReferenceError\0" as *const u8 as *const libc::c_char,
    b"SyntaxError\0" as *const u8 as *const libc::c_char,
    b"TypeError\0" as *const u8 as *const libc::c_char,
    b"URIError\0" as *const u8 as *const libc::c_char,
    b"InternalError\0" as *const u8 as *const libc::c_char,
    b"AggregateError\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn JS_AddIntrinsicBasicObjects(mut ctx: *mut JSContext) {
    let mut proto: JSValue = 0;
    let mut i: libc::c_int = 0;
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_OBJECT as libc::c_int as isize,
        ) = JS_NewObjectProto(
        ctx,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    (*ctx)
        .function_proto = JS_NewCFunction3(
        ctx,
        Some(
            js_function_proto
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        b"\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
        JS_CFUNC_generic,
        0 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_BYTECODE_FUNCTION as libc::c_int as isize,
        ) = JS_DupValue(ctx, (*ctx).function_proto);
    *((*ctx).class_proto)
        .offset(JS_CLASS_ERROR as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ERROR as libc::c_int as isize),
        js_error_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < JS_NATIVE_ERROR_COUNT as libc::c_int {
        proto = JS_NewObjectProto(
            ctx,
            *((*ctx).class_proto).offset(JS_CLASS_ERROR as libc::c_int as isize),
        );
        JS_DefinePropertyValue(
            ctx,
            proto,
            JS_ATOM_name as libc::c_int as JSAtom,
            JS_NewAtomString(ctx, native_error_name[i as usize]),
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        JS_DefinePropertyValue(
            ctx,
            proto,
            JS_ATOM_message as libc::c_int as JSAtom,
            JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom),
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        (*ctx).native_error_proto[i as usize] = proto;
        i += 1;
    }
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ARRAY as libc::c_int as isize,
        ) = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_ARRAY as libc::c_int as JSClassID,
    );
    let ref mut fresh729 = (*ctx).array_shape;
    *fresh729 = js_new_shape2(
        ctx,
        get_proto_obj(
            *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
        ),
        4 as libc::c_int,
        1 as libc::c_int,
    );
    add_shape_property(
        ctx,
        &mut (*ctx).array_shape,
        0 as *mut JSObject,
        JS_ATOM_length as libc::c_int as JSAtom,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicBaseObjects(mut ctx: *mut JSContext) {
    let mut i: libc::c_int = 0;
    let mut obj: JSValue = 0;
    let mut number_obj: JSValue = 0;
    let mut obj1: JSValue = 0;
    (*ctx)
        .throw_type_error = JS_NewCFunction(
        ctx,
        Some(
            js_throw_type_error
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        0 as *const libc::c_char,
        0 as libc::c_int,
    );
    obj1 = JS_NewCFunction(
        ctx,
        Some(
            js_function_proto_caller
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        0 as *const libc::c_char,
        0 as libc::c_int,
    );
    JS_DefineProperty(
        ctx,
        (*ctx).function_proto,
        JS_ATOM_caller as libc::c_int as JSAtom,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        obj1,
        (*ctx).throw_type_error,
        (1 as libc::c_int) << 11 as libc::c_int | (1 as libc::c_int) << 12 as libc::c_int
            | (1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_DefineProperty(
        ctx,
        (*ctx).function_proto,
        JS_ATOM_arguments as libc::c_int as JSAtom,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        obj1,
        (*ctx).throw_type_error,
        (1 as libc::c_int) << 11 as libc::c_int | (1 as libc::c_int) << 12 as libc::c_int
            | (1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_FreeValue(ctx, obj1);
    JS_FreeValue(
        ctx,
        js_object_seal(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            1 as libc::c_int,
            &mut (*ctx).throw_type_error as *mut JSValue,
            1 as libc::c_int,
        ),
    );
    (*ctx).global_obj = JS_NewObject(ctx);
    (*ctx)
        .global_var_obj = JS_NewObjectProto(
        ctx,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"Object\0" as *const u8 as *const libc::c_char,
        Some(
            js_object_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_object_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 23]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        js_object_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 11]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).function_proto,
        js_function_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 7]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    (*ctx)
        .function_ctor = JS_NewCFunctionMagic(
        ctx,
        Some(
            js_function_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        ),
        b"Function\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor_or_func_magic,
        JS_FUNC_NORMAL as libc::c_int,
    );
    JS_NewGlobalCConstructor2(
        ctx,
        JS_DupValue(ctx, (*ctx).function_ctor),
        b"Function\0" as *const u8 as *const libc::c_char,
        (*ctx).function_proto,
    );
    obj1 = JS_NewCFunctionMagic(
        ctx,
        Some(
            js_error_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        ),
        b"Error\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor_or_func_magic,
        -(1 as libc::c_int),
    );
    JS_NewGlobalCConstructor2(
        ctx,
        obj1,
        b"Error\0" as *const u8 as *const libc::c_char,
        *((*ctx).class_proto).offset(JS_CLASS_ERROR as libc::c_int as isize),
    );
    i = 0 as libc::c_int;
    while i < JS_NATIVE_ERROR_COUNT as libc::c_int {
        let mut func_obj: JSValue = 0;
        let mut n_args: libc::c_int = 0;
        n_args = 1 as libc::c_int
            + (i == JS_AGGREGATE_ERROR as libc::c_int) as libc::c_int;
        func_obj = JS_NewCFunction3(
            ctx,
            ::core::mem::transmute::<
                Option::<
                    unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
                >,
                Option::<JSCFunction>,
            >(
                Some(
                    js_error_constructor
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            JSValue,
                            libc::c_int,
                            *mut JSValue,
                            libc::c_int,
                        ) -> JSValue,
                ),
            ),
            native_error_name[i as usize],
            n_args,
            JS_CFUNC_constructor_or_func_magic,
            i,
            obj1,
        );
        JS_NewGlobalCConstructor2(
            ctx,
            func_obj,
            native_error_name[i as usize],
            (*ctx).native_error_proto[i as usize],
        );
        i += 1;
    }
    (*ctx).iterator_proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).iterator_proto,
        js_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
        js_array_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 32]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"Array\0" as *const u8 as *const libc::c_char,
        Some(
            js_array_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
    );
    (*ctx).array_ctor = JS_DupValue(ctx, obj);
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_array_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 4]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    let unscopables: [libc::c_char; 74] = *::core::mem::transmute::<
        &[u8; 74],
        &[libc::c_char; 74],
    >(
        b"copyWithin\0entries\0fill\0find\0findIndex\0flat\0flatMap\0includes\0keys\0values\0\0",
    );
    let mut p: *const libc::c_char = unscopables.as_ptr();
    obj1 = JS_NewObjectProto(
        ctx,
        (JS_TAG_NULL as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    p = unscopables.as_ptr();
    while *p != 0 {
        JS_DefinePropertyValueStr(
            ctx,
            obj1,
            p,
            (JS_TAG_BOOL as libc::c_int as uint64_t) << 32 as libc::c_int
                | 1 as libc::c_int as uint32_t as libc::c_ulonglong,
            (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int,
        );
        p = p
            .offset(
                (strlen(p)).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
            );
    }
    JS_DefinePropertyValue(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
        JS_ATOM_Symbol_unscopables as libc::c_int as JSAtom,
        obj1,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*ctx)
        .array_proto_values = JS_GetProperty(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
        JS_ATOM_values as libc::c_int as JSAtom,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_ARRAY_ITERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY_ITERATOR as libc::c_int as isize),
        js_array_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).global_obj,
        js_global_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 14]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_NUMBER as libc::c_int as isize,
        ) = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_NUMBER as libc::c_int as JSClassID,
    );
    JS_SetObjectData(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_NUMBER as libc::c_int as isize),
        JS_NewInt32(ctx, 0 as libc::c_int),
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_NUMBER as libc::c_int as isize),
        js_number_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 6]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    number_obj = JS_NewGlobalCConstructor(
        ctx,
        b"Number\0" as *const u8 as *const libc::c_char,
        Some(
            js_number_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_NUMBER as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        number_obj,
        js_number_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 14]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_BOOLEAN as libc::c_int as isize,
        ) = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_BOOLEAN as libc::c_int as JSClassID,
    );
    JS_SetObjectData(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_BOOLEAN as libc::c_int as isize),
        JS_NewBool(ctx, FALSE as libc::c_int),
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_BOOLEAN as libc::c_int as isize),
        js_boolean_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_NewGlobalCConstructor(
        ctx,
        b"Boolean\0" as *const u8 as *const libc::c_char,
        Some(
            js_boolean_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_BOOLEAN as libc::c_int as isize),
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_STRING as libc::c_int as isize,
        ) = JS_NewObjectProtoClass(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_OBJECT as libc::c_int as isize),
        JS_CLASS_STRING as libc::c_int as JSClassID,
    );
    JS_SetObjectData(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_STRING as libc::c_int as isize),
        JS_AtomToString(ctx, JS_ATOM_empty_string as libc::c_int as JSAtom),
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"String\0" as *const u8 as *const libc::c_char,
        Some(
            js_string_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_STRING as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_string_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_STRING as libc::c_int as isize),
        js_string_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 49]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_STRING_ITERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_STRING_ITERATOR as libc::c_int as isize),
        js_string_iterator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    js_random_init(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).global_obj,
        js_math_obj.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        (*ctx).global_obj,
        js_reflect_obj.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(JS_CLASS_SYMBOL as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_SYMBOL as libc::c_int as isize),
        js_symbol_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 5]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    obj = JS_NewGlobalCConstructor(
        ctx,
        b"Symbol\0" as *const u8 as *const libc::c_char,
        Some(
            js_symbol_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        0 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_SYMBOL as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        obj,
        js_symbol_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    i = JS_ATOM_Symbol_toPrimitive as libc::c_int;
    while i < JS_ATOM_END as libc::c_int {
        let mut buf: [libc::c_char; 64] = [0; 64];
        let mut str: *const libc::c_char = 0 as *const libc::c_char;
        let mut p_0: *const libc::c_char = 0 as *const libc::c_char;
        str = JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            i as JSAtom,
        );
        p_0 = strchr(str, '.' as i32);
        if !p_0.is_null() {
            str = p_0.offset(1 as libc::c_int as isize);
        }
        JS_DefinePropertyValueStr(
            ctx,
            obj,
            str,
            JS_AtomToValue(ctx, i as JSAtom),
            0 as libc::c_int,
        );
        i += 1;
    }
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_GENERATOR as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).iterator_proto);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_GENERATOR as libc::c_int as isize),
        js_generator_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 4]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_GENERATOR_FUNCTION as libc::c_int as isize,
        ) = JS_NewObjectProto(ctx, (*ctx).function_proto);
    obj1 = JS_NewCFunctionMagic(
        ctx,
        Some(
            js_function_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                    libc::c_int,
                ) -> JSValue,
        ),
        b"GeneratorFunction\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        JS_CFUNC_constructor_or_func_magic,
        JS_FUNC_GENERATOR as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_GENERATOR_FUNCTION as libc::c_int as isize),
        js_generator_function_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetConstructor2(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_GENERATOR_FUNCTION as libc::c_int as isize),
        *((*ctx).class_proto).offset(JS_CLASS_GENERATOR as libc::c_int as isize),
        (1 as libc::c_int) << 0 as libc::c_int,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_SetConstructor2(
        ctx,
        obj1,
        *((*ctx).class_proto)
            .offset(JS_CLASS_GENERATOR_FUNCTION as libc::c_int as isize),
        0 as libc::c_int,
        (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_FreeValue(ctx, obj1);
    (*ctx)
        .eval_obj = JS_NewCFunction(
        ctx,
        Some(
            js_global_eval
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        b"eval\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    JS_DefinePropertyValue(
        ctx,
        (*ctx).global_obj,
        JS_ATOM_eval as libc::c_int as JSAtom,
        JS_DupValue(ctx, (*ctx).eval_obj),
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    JS_DefinePropertyValue(
        ctx,
        (*ctx).global_obj,
        JS_ATOM_globalThis as libc::c_int as JSAtom,
        JS_DupValue(ctx, (*ctx).global_obj),
        (1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int,
    );
}
static mut typed_array_size_log2: [uint8_t; 9] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
unsafe extern "C" fn js_array_buffer_constructor3(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut len: uint64_t,
    mut class_id: JSClassID,
    mut buf: *mut uint8_t,
    mut free_func: Option::<JSFreeArrayBufferDataFunc>,
    mut opaque: *mut libc::c_void,
    mut alloc_flag: BOOL,
) -> JSValue {
    let mut current_block: u64;
    let mut rt: *mut JSRuntime = (*ctx).rt;
    let mut obj: JSValue = 0;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    obj = js_create_from_ctor(ctx, new_target, class_id as libc::c_int);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    if len > 0x7fffffff as libc::c_int as libc::c_ulonglong {
        JS_ThrowRangeError(
            ctx,
            b"invalid array buffer length\0" as *const u8 as *const libc::c_char,
        );
    } else {
        abuf = js_malloc(ctx, ::core::mem::size_of::<JSArrayBuffer>() as libc::c_ulong)
            as *mut JSArrayBuffer;
        if !abuf.is_null() {
            (*abuf).byte_length = len as libc::c_int;
            if alloc_flag != 0 {
                if class_id
                    == JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as libc::c_uint
                    && ((*rt).sab_funcs.sab_alloc).is_some()
                {
                    let ref mut fresh730 = (*abuf).data;
                    *fresh730 = ((*rt).sab_funcs.sab_alloc)
                        .expect(
                            "non-null function pointer",
                        )(
                        (*rt).sab_funcs.sab_opaque,
                        max_int(len as libc::c_int, 1 as libc::c_int) as size_t,
                    ) as *mut uint8_t;
                    if ((*abuf).data).is_null() {
                        current_block = 6369931983606118376;
                    } else {
                        memset(
                            (*abuf).data as *mut libc::c_void,
                            0 as libc::c_int,
                            len as libc::c_ulong,
                        );
                        current_block = 1109700713171191020;
                    }
                } else {
                    let ref mut fresh731 = (*abuf).data;
                    *fresh731 = js_mallocz(
                        ctx,
                        max_int(len as libc::c_int, 1 as libc::c_int) as size_t,
                    ) as *mut uint8_t;
                    if ((*abuf).data).is_null() {
                        current_block = 6369931983606118376;
                    } else {
                        current_block = 1109700713171191020;
                    }
                }
            } else {
                if class_id
                    == JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as libc::c_uint
                    && ((*rt).sab_funcs.sab_dup).is_some()
                {
                    ((*rt).sab_funcs.sab_dup)
                        .expect(
                            "non-null function pointer",
                        )((*rt).sab_funcs.sab_opaque, buf as *mut libc::c_void);
                }
                let ref mut fresh732 = (*abuf).data;
                *fresh732 = buf;
                current_block = 1109700713171191020;
            }
            match current_block {
                6369931983606118376 => {}
                _ => {
                    init_list_head(&mut (*abuf).array_list);
                    (*abuf).detached = FALSE as libc::c_int as uint8_t;
                    (*abuf)
                        .shared = (class_id
                        == JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as libc::c_uint)
                        as libc::c_int as uint8_t;
                    let ref mut fresh733 = (*abuf).opaque;
                    *fresh733 = opaque;
                    let ref mut fresh734 = (*abuf).free_func;
                    *fresh734 = free_func;
                    if alloc_flag != 0 && !buf.is_null() {
                        memcpy(
                            (*abuf).data as *mut libc::c_void,
                            buf as *const libc::c_void,
                            len as libc::c_ulong,
                        );
                    }
                    JS_SetOpaque(obj, abuf as *mut libc::c_void);
                    return obj;
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    js_free(ctx, abuf as *mut libc::c_void);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_array_buffer_free(
    mut rt: *mut JSRuntime,
    mut opaque: *mut libc::c_void,
    mut ptr: *mut libc::c_void,
) {
    js_free_rt(rt, ptr);
}
unsafe extern "C" fn js_array_buffer_constructor2(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut len: uint64_t,
    mut class_id: JSClassID,
) -> JSValue {
    return js_array_buffer_constructor3(
        ctx,
        new_target,
        len,
        class_id,
        0 as *mut uint8_t,
        Some(
            js_array_buffer_free
                as unsafe extern "C" fn(
                    *mut JSRuntime,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> (),
        ),
        0 as *mut libc::c_void,
        TRUE as libc::c_int,
    );
}
unsafe extern "C" fn js_array_buffer_constructor1(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut len: uint64_t,
) -> JSValue {
    return js_array_buffer_constructor2(
        ctx,
        new_target,
        len,
        JS_CLASS_ARRAY_BUFFER as libc::c_int as JSClassID,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewArrayBuffer(
    mut ctx: *mut JSContext,
    mut buf: *mut uint8_t,
    mut len: size_t,
    mut free_func: Option::<JSFreeArrayBufferDataFunc>,
    mut opaque: *mut libc::c_void,
    mut is_shared: BOOL,
) -> JSValue {
    return js_array_buffer_constructor3(
        ctx,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        len as uint64_t,
        (if is_shared != 0 {
            JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int
        } else {
            JS_CLASS_ARRAY_BUFFER as libc::c_int
        }) as JSClassID,
        buf,
        free_func,
        opaque,
        FALSE as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn JS_NewArrayBufferCopy(
    mut ctx: *mut JSContext,
    mut buf: *const uint8_t,
    mut len: size_t,
) -> JSValue {
    return js_array_buffer_constructor3(
        ctx,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
        len as uint64_t,
        JS_CLASS_ARRAY_BUFFER as libc::c_int as JSClassID,
        buf as *mut uint8_t,
        Some(
            js_array_buffer_free
                as unsafe extern "C" fn(
                    *mut JSRuntime,
                    *mut libc::c_void,
                    *mut libc::c_void,
                ) -> (),
        ),
        0 as *mut libc::c_void,
        TRUE as libc::c_int,
    );
}
unsafe extern "C" fn js_array_buffer_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut len: uint64_t = 0;
    if JS_ToIndex(ctx, &mut len, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_array_buffer_constructor1(ctx, new_target, len);
}
unsafe extern "C" fn js_shared_array_buffer_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut len: uint64_t = 0;
    if JS_ToIndex(ctx, &mut len, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_array_buffer_constructor2(
        ctx,
        new_target,
        len,
        JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as JSClassID,
    );
}
unsafe extern "C" fn js_array_buffer_finalizer(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut abuf: *mut JSArrayBuffer = (*p).u.array_buffer;
    if !abuf.is_null() {
        if (*abuf).shared as libc::c_int != 0 && ((*rt).sab_funcs.sab_free).is_some() {
            ((*rt).sab_funcs.sab_free)
                .expect(
                    "non-null function pointer",
                )((*rt).sab_funcs.sab_opaque, (*abuf).data as *mut libc::c_void);
        } else if ((*abuf).free_func).is_some() {
            ((*abuf).free_func)
                .expect(
                    "non-null function pointer",
                )(rt, (*abuf).opaque, (*abuf).data as *mut libc::c_void);
        }
        js_free_rt(rt, abuf as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_array_buffer_isView(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut res: BOOL = 0;
    res = FALSE as libc::c_int;
    if (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
        == JS_TAG_OBJECT as libc::c_int
    {
        p = *argv.offset(0 as libc::c_int as isize) as intptr_t as *mut libc::c_void
            as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                <= JS_CLASS_DATAVIEW as libc::c_int
        {
            res = TRUE as libc::c_int;
        }
    }
    return JS_NewBool(ctx, res);
}
static mut js_array_buffer_funcs: [JSCFunctionListEntry; 2] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"isView\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_array_buffer_isView
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn JS_ThrowTypeErrorDetachedArrayBuffer(
    mut ctx: *mut JSContext,
) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"ArrayBuffer is detached\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn js_array_buffer_get_byteLength(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut abuf: *mut JSArrayBuffer = JS_GetOpaque2(
        ctx,
        this_val,
        class_id as JSClassID,
    ) as *mut JSArrayBuffer;
    if abuf.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewUint32(ctx, (*abuf).byte_length as uint32_t);
}
#[no_mangle]
pub unsafe extern "C" fn JS_DetachArrayBuffer(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) {
    let mut abuf: *mut JSArrayBuffer = JS_GetOpaque(
        obj,
        JS_CLASS_ARRAY_BUFFER as libc::c_int as JSClassID,
    ) as *mut JSArrayBuffer;
    let mut el: *mut list_head = 0 as *mut list_head;
    if abuf.is_null() || (*abuf).detached as libc::c_int != 0 {
        return;
    }
    if ((*abuf).free_func).is_some() {
        ((*abuf).free_func)
            .expect(
                "non-null function pointer",
            )((*ctx).rt, (*abuf).opaque, (*abuf).data as *mut libc::c_void);
    }
    let ref mut fresh735 = (*abuf).data;
    *fresh735 = 0 as *mut uint8_t;
    (*abuf).byte_length = 0 as libc::c_int;
    (*abuf).detached = TRUE as libc::c_int as uint8_t;
    el = (*abuf).array_list.next;
    while el != &mut (*abuf).array_list as *mut list_head {
        let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
        let mut p: *mut JSObject = 0 as *mut JSObject;
        ta = (el as *mut uint8_t).offset(-(0 as libc::c_ulong as isize))
            as *mut JSTypedArray;
        p = (*ta).obj;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_DATAVIEW as libc::c_int
        {
            (*p).u.array.count = 0 as libc::c_int as uint32_t;
            let ref mut fresh736 = (*p).u.array.u.ptr;
            *fresh736 = 0 as *mut libc::c_void;
        }
        el = (*el).next;
    }
}
unsafe extern "C" fn js_get_array_buffer(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> *mut JSArrayBuffer {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if !((obj >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int) {
        p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
        if !((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            != JS_CLASS_ARRAY_BUFFER as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                != JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int)
        {
            return (*p).u.array_buffer;
        }
    }
    JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_ARRAY_BUFFER as libc::c_int);
    return 0 as *mut JSArrayBuffer;
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetArrayBuffer(
    mut ctx: *mut JSContext,
    mut psize: *mut size_t,
    mut obj: JSValue,
) -> *mut uint8_t {
    let mut abuf: *mut JSArrayBuffer = js_get_array_buffer(ctx, obj);
    if !abuf.is_null() {
        if (*abuf).detached != 0 {
            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        } else {
            *psize = (*abuf).byte_length as size_t;
            return (*abuf).data;
        }
    }
    *psize = 0 as libc::c_int as size_t;
    return 0 as *mut uint8_t;
}
unsafe extern "C" fn js_array_buffer_slice(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut new_abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut len: int64_t = 0;
    let mut start: int64_t = 0;
    let mut end: int64_t = 0;
    let mut new_len: int64_t = 0;
    let mut ctor: JSValue = 0;
    let mut new_obj: JSValue = 0;
    abuf = JS_GetOpaque2(ctx, this_val, class_id as JSClassID) as *mut JSArrayBuffer;
    if abuf.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (*abuf).detached != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    len = (*abuf).byte_length as int64_t;
    if JS_ToInt64Clamp(
        ctx,
        &mut start,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int as int64_t,
        len,
        len,
    ) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    end = len;
    if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
        if JS_ToInt64Clamp(
            ctx,
            &mut end,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int as int64_t,
            len,
            len,
        ) != 0
        {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    new_len = max_int64(end - start, 0 as libc::c_int as int64_t);
    ctor = JS_SpeciesConstructor(
        ctx,
        this_val,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    if JS_IsUndefined(ctor) != 0 {
        new_obj = js_array_buffer_constructor2(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            new_len as uint64_t,
            class_id as JSClassID,
        );
    } else {
        let mut args: [JSValue; 1] = [0; 1];
        args[0 as libc::c_int as usize] = JS_NewInt64(ctx, new_len);
        new_obj = JS_CallConstructor(ctx, ctor, 1 as libc::c_int, args.as_mut_ptr());
        JS_FreeValue(ctx, ctor);
        JS_FreeValue(ctx, args[0 as libc::c_int as usize]);
    }
    if JS_IsException(new_obj) != 0 {
        return new_obj;
    }
    new_abuf = JS_GetOpaque2(ctx, new_obj, class_id as JSClassID) as *mut JSArrayBuffer;
    if !new_abuf.is_null() {
        if js_same_value(ctx, new_obj, this_val) != 0 {
            JS_ThrowTypeError(
                ctx,
                b"cannot use identical ArrayBuffer\0" as *const u8 as *const libc::c_char,
            );
        } else if (*new_abuf).detached != 0 {
            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        } else if ((*new_abuf).byte_length as libc::c_longlong) < new_len {
            JS_ThrowTypeError(
                ctx,
                b"new ArrayBuffer is too small\0" as *const u8 as *const libc::c_char,
            );
        } else if (*abuf).detached != 0 {
            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        } else {
            memcpy(
                (*new_abuf).data as *mut libc::c_void,
                ((*abuf).data).offset(start as isize) as *const libc::c_void,
                new_len as libc::c_ulong,
            );
            return new_obj;
        }
    }
    JS_FreeValue(ctx, new_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
static mut js_array_buffer_proto_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteLength\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: JS_CLASS_ARRAY_BUFFER as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_array_buffer_get_byteLength
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"slice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_ARRAY_BUFFER as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_buffer_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"ArrayBuffer\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
static mut js_shared_array_buffer_funcs: [JSCFunctionListEntry; 1] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_shared_array_buffer_proto_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteLength\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_array_buffer_get_byteLength
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"slice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_buffer_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"SharedArrayBuffer\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn get_typed_array(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut is_dataview: libc::c_int,
) -> *mut JSObject {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if !((this_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int)
    {
        p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
        if is_dataview != 0 {
            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                != JS_CLASS_DATAVIEW as libc::c_int
            {
                current_block = 15195231945026180563;
            } else {
                current_block = 3276175668257526147;
            }
        } else if !((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                <= JS_CLASS_FLOAT64_ARRAY as libc::c_int)
        {
            current_block = 15195231945026180563;
        } else {
            current_block = 3276175668257526147;
        }
        match current_block {
            15195231945026180563 => {}
            _ => return p,
        }
    }
    JS_ThrowTypeError(
        ctx,
        b"not a %s\0" as *const u8 as *const libc::c_char,
        if is_dataview != 0 {
            b"DataView\0" as *const u8 as *const libc::c_char
        } else {
            b"TypedArray\0" as *const u8 as *const libc::c_char
        },
    );
    return 0 as *mut JSObject;
}
unsafe extern "C" fn typed_array_is_detached(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
) -> BOOL {
    let mut ta: *mut JSTypedArray = (*p).u.typed_array;
    let mut abuf: *mut JSArrayBuffer = (*(*ta).buffer).u.array_buffer;
    return (*abuf).detached as BOOL;
}
unsafe extern "C" fn typed_array_get_length(
    mut ctx: *mut JSContext,
    mut p: *mut JSObject,
) -> uint32_t {
    let mut ta: *mut JSTypedArray = (*p).u.typed_array;
    let mut size_log2: libc::c_int = typed_array_size_log2[((*p)
        .c2rust_unnamed
        .c2rust_unnamed
        .class_id as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
        as libc::c_int;
    return (*ta).length >> size_log2;
}
unsafe extern "C" fn validate_typed_array(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    p = get_typed_array(ctx, this_val, 0 as libc::c_int);
    if p.is_null() {
        return -(1 as libc::c_int);
    }
    if typed_array_is_detached(ctx, p) != 0 {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_typed_array_get_length(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    p = get_typed_array(ctx, this_val, 0 as libc::c_int);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_NewInt32(ctx, (*p).u.array.count as int32_t);
}
unsafe extern "C" fn js_typed_array_get_buffer(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut is_dataview: libc::c_int,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    p = get_typed_array(ctx, this_val, is_dataview);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ta = (*p).u.typed_array;
    return JS_DupValue(
        ctx,
        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*ta).buffer as uintptr_t as libc::c_ulonglong,
    );
}
unsafe extern "C" fn js_typed_array_get_byteLength(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut is_dataview: libc::c_int,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    p = get_typed_array(ctx, this_val, is_dataview);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if typed_array_is_detached(ctx, p) != 0 {
        if is_dataview != 0 {
            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx)
        } else {
            return JS_NewInt32(ctx, 0 as libc::c_int)
        }
    }
    ta = (*p).u.typed_array;
    return JS_NewInt32(ctx, (*ta).length as int32_t);
}
unsafe extern "C" fn js_typed_array_get_byteOffset(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut is_dataview: libc::c_int,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    p = get_typed_array(ctx, this_val, is_dataview);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if typed_array_is_detached(ctx, p) != 0 {
        if is_dataview != 0 {
            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx)
        } else {
            return JS_NewInt32(ctx, 0 as libc::c_int)
        }
    }
    ta = (*p).u.typed_array;
    return JS_NewInt32(ctx, (*ta).offset as int32_t);
}
#[no_mangle]
pub unsafe extern "C" fn JS_GetTypedArrayBuffer(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut pbyte_offset: *mut size_t,
    mut pbyte_length: *mut size_t,
    mut pbytes_per_element: *mut size_t,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    p = get_typed_array(ctx, obj, FALSE as libc::c_int);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if typed_array_is_detached(ctx, p) != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    ta = (*p).u.typed_array;
    if !pbyte_offset.is_null() {
        *pbyte_offset = (*ta).offset as size_t;
    }
    if !pbyte_length.is_null() {
        *pbyte_length = (*ta).length as size_t;
    }
    if !pbytes_per_element.is_null() {
        *pbytes_per_element = ((1 as libc::c_int)
            << typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
                as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
                as libc::c_int) as size_t;
    }
    return JS_DupValue(
        ctx,
        (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
            | (*ta).buffer as uintptr_t as libc::c_ulonglong,
    );
}
unsafe extern "C" fn js_typed_array_get_toStringTag(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    if (this_val >> 32 as libc::c_int) as libc::c_int != JS_TAG_OBJECT as libc::c_int {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
    if !((*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        >= JS_CLASS_UINT8C_ARRAY as libc::c_int
        && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            <= JS_CLASS_FLOAT64_ARRAY as libc::c_int)
    {
        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return JS_AtomToString(
        ctx,
        (*((*(*ctx).rt).class_array)
            .offset((*p).c2rust_unnamed.c2rust_unnamed.class_id as isize))
            .class_name,
    );
}
unsafe extern "C" fn js_typed_array_set_internal(
    mut ctx: *mut JSContext,
    mut dst: JSValue,
    mut src: JSValue,
    mut off: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut src_p: *mut JSObject = 0 as *mut JSObject;
    let mut i: uint32_t = 0;
    let mut src_len: int64_t = 0;
    let mut offset: int64_t = 0;
    let mut val: JSValue = 0;
    let mut src_obj: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    p = get_typed_array(ctx, dst, 0 as libc::c_int);
    if !p.is_null() {
        if !(JS_ToInt64Sat(ctx, &mut offset, off) != 0) {
            if offset < 0 as libc::c_int as libc::c_longlong {
                current_block = 346484238525267279;
            } else {
                if typed_array_is_detached(ctx, p) != 0 {
                    current_block = 911839854170347813;
                } else {
                    src_obj = JS_ToObject(ctx, src);
                    if JS_IsException(src_obj) != 0 {
                        current_block = 15147058484290976772;
                    } else {
                        src_p = src_obj as intptr_t as *mut libc::c_void
                            as *mut JSObject;
                        if (*src_p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
                            && (*src_p).c2rust_unnamed.c2rust_unnamed.class_id
                                as libc::c_int <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
                        {
                            let mut dest_ta: *mut JSTypedArray = (*p).u.typed_array;
                            let mut dest_abuf: *mut JSArrayBuffer = (*(*dest_ta).buffer)
                                .u
                                .array_buffer;
                            let mut src_ta: *mut JSTypedArray = (*src_p).u.typed_array;
                            let mut src_abuf: *mut JSArrayBuffer = (*(*src_ta).buffer)
                                .u
                                .array_buffer;
                            let mut shift: libc::c_int = typed_array_size_log2[((*p)
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .class_id as libc::c_int
                                - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
                                as libc::c_int;
                            if (*src_abuf).detached != 0 {
                                current_block = 911839854170347813;
                            } else {
                                src_len = (*src_p).u.array.count as int64_t;
                                if offset > (*p).u.array.count as libc::c_longlong - src_len
                                {
                                    current_block = 346484238525267279;
                                } else if (*src_p).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int
                                    == (*p).c2rust_unnamed.c2rust_unnamed.class_id
                                        as libc::c_int
                                {
                                    memmove(
                                        ((*dest_abuf).data)
                                            .offset((*dest_ta).offset as isize)
                                            .offset((offset << shift) as isize) as *mut libc::c_void,
                                        ((*src_abuf).data).offset((*src_ta).offset as isize)
                                            as *const libc::c_void,
                                        (src_len << shift) as libc::c_ulong,
                                    );
                                    current_block = 11310416674312052770;
                                } else {
                                    (*dest_abuf).data == (*src_abuf).data;
                                    current_block = 11459959175219260272;
                                }
                            }
                        } else if js_get_length64(ctx, &mut src_len, src_obj) != 0 {
                            current_block = 15147058484290976772;
                        } else if offset
                            > (*p).u.array.count as libc::c_longlong - src_len
                        {
                            current_block = 346484238525267279;
                        } else {
                            current_block = 11459959175219260272;
                        }
                        match current_block {
                            911839854170347813 => {}
                            346484238525267279 => {}
                            15147058484290976772 => {}
                            _ => {
                                match current_block {
                                    11459959175219260272 => {
                                        i = 0 as libc::c_int as uint32_t;
                                        loop {
                                            if !((i as libc::c_longlong) < src_len) {
                                                current_block = 11310416674312052770;
                                                break;
                                            }
                                            val = JS_GetPropertyUint32(ctx, src_obj, i);
                                            if JS_IsException(val) != 0 {
                                                current_block = 15147058484290976772;
                                                break;
                                            }
                                            if JS_SetPropertyUint32(
                                                ctx,
                                                dst,
                                                (offset + i as libc::c_longlong) as uint32_t,
                                                val,
                                            ) < 0 as libc::c_int
                                            {
                                                current_block = 15147058484290976772;
                                                break;
                                            }
                                            i = i.wrapping_add(1);
                                        }
                                    }
                                    _ => {}
                                }
                                match current_block {
                                    15147058484290976772 => {}
                                    _ => {
                                        JS_FreeValue(ctx, src_obj);
                                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                            << 32 as libc::c_int
                                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                                    }
                                }
                            }
                        }
                    }
                }
                match current_block {
                    15147058484290976772 => {}
                    346484238525267279 => {}
                    _ => {
                        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
                        current_block = 15147058484290976772;
                    }
                }
            }
            match current_block {
                15147058484290976772 => {}
                _ => {
                    JS_ThrowRangeError(
                        ctx,
                        b"invalid array length\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
    }
    JS_FreeValue(ctx, src_obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_set(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut offset: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if argc > 1 as libc::c_int {
        offset = *argv.offset(1 as libc::c_int as isize);
    }
    return js_typed_array_set_internal(
        ctx,
        this_val,
        *argv.offset(0 as libc::c_int as isize),
        offset,
    );
}
unsafe extern "C" fn js_create_typed_array_iterator(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut magic: libc::c_int,
) -> JSValue {
    if validate_typed_array(ctx, this_val) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return js_create_array_iterator(ctx, this_val, argc, argv, magic);
}
unsafe extern "C" fn js_typed_array_get_length_internal(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
) -> libc::c_int {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    p = get_typed_array(ctx, obj, 0 as libc::c_int);
    if p.is_null() {
        return -(1 as libc::c_int);
    }
    if typed_array_is_detached(ctx, p) != 0 {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        return -(1 as libc::c_int);
    }
    return (*p).u.array.count as libc::c_int;
}
unsafe extern "C" fn js_typed_array_create(
    mut ctx: *mut JSContext,
    mut ctor: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut ret: JSValue = 0;
    let mut new_len: libc::c_int = 0;
    let mut len: int64_t = 0;
    ret = JS_CallConstructor(ctx, ctor, argc, argv);
    if JS_IsException(ret) != 0 {
        return ret;
    }
    new_len = js_typed_array_get_length_internal(ctx, ret);
    if !(new_len < 0 as libc::c_int) {
        if argc == 1 as libc::c_int {
            if JS_ToLengthFree(
                ctx,
                &mut len,
                JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
            ) != 0
            {
                current_block = 11413149684448299320;
            } else if (new_len as libc::c_longlong) < len {
                JS_ThrowTypeError(
                    ctx,
                    b"TypedArray length is too small\0" as *const u8
                        as *const libc::c_char,
                );
                current_block = 11413149684448299320;
            } else {
                current_block = 2979737022853876585;
            }
        } else {
            current_block = 2979737022853876585;
        }
        match current_block {
            11413149684448299320 => {}
            _ => return ret,
        }
    }
    JS_FreeValue(ctx, ret);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array___speciesCreate(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut ctor: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut argc1: libc::c_int = 0;
    obj = *argv.offset(0 as libc::c_int as isize);
    p = get_typed_array(ctx, obj, 0 as libc::c_int);
    if p.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    ctor = JS_SpeciesConstructor(
        ctx,
        obj,
        (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
    );
    if JS_IsException(ctor) != 0 {
        return ctor;
    }
    argc1 = max_int(argc - 1 as libc::c_int, 0 as libc::c_int);
    if JS_IsUndefined(ctor) != 0 {
        ret = js_typed_array_constructor(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            argc1,
            argv.offset(1 as libc::c_int as isize),
            (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int,
        );
    } else {
        ret = js_typed_array_create(
            ctx,
            ctor,
            argc1,
            argv.offset(1 as libc::c_int as isize),
        );
        JS_FreeValue(ctx, ctor);
    }
    return ret;
}
unsafe extern "C" fn js_typed_array_from(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut items: JSValue = *argv.offset(0 as libc::c_int as isize);
    let mut mapfn: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut args: [JSValue; 2] = [0; 2];
    let mut stack: [JSValue; 2] = [0; 2];
    let mut iter: JSValue = 0;
    let mut arr: JSValue = 0;
    let mut r: JSValue = 0;
    let mut v: JSValue = 0;
    let mut v2: JSValue = 0;
    let mut k: int64_t = 0;
    let mut len: int64_t = 0;
    let mut done: libc::c_int = 0;
    let mut mapping: libc::c_int = 0;
    mapping = FALSE as libc::c_int;
    mapfn = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    r = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    stack[0 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    stack[1 as libc::c_int
        as usize] = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    if argc > 1 as libc::c_int {
        mapfn = *argv.offset(1 as libc::c_int as isize);
        if JS_IsUndefined(mapfn) == 0 {
            if check_function(ctx, mapfn) != 0 {
                current_block = 13421693927056412477;
            } else {
                mapping = 1 as libc::c_int;
                if argc > 2 as libc::c_int {
                    this_arg = *argv.offset(2 as libc::c_int as isize);
                }
                current_block = 5143058163439228106;
            }
        } else {
            current_block = 5143058163439228106;
        }
    } else {
        current_block = 5143058163439228106;
    }
    match current_block {
        5143058163439228106 => {
            iter = JS_GetProperty(
                ctx,
                items,
                JS_ATOM_Symbol_iterator as libc::c_int as JSAtom,
            );
            if JS_IsException(iter) != 0 {
                current_block = 13421693927056412477;
            } else {
                if JS_IsUndefined(iter) == 0 {
                    JS_FreeValue(ctx, iter);
                    arr = JS_NewArray(ctx);
                    if JS_IsException(arr) != 0 {
                        current_block = 13421693927056412477;
                    } else {
                        stack[0 as libc::c_int as usize] = JS_DupValue(ctx, items);
                        if js_for_of_start(
                            ctx,
                            &mut *stack.as_mut_ptr().offset(1 as libc::c_int as isize),
                            FALSE as libc::c_int,
                        ) != 0
                        {
                            current_block = 13421693927056412477;
                        } else {
                            k = 0 as libc::c_int as int64_t;
                            loop {
                                v = JS_IteratorNext(
                                    ctx,
                                    stack[0 as libc::c_int as usize],
                                    stack[1 as libc::c_int as usize],
                                    0 as libc::c_int,
                                    0 as *mut JSValue,
                                    &mut done,
                                );
                                if JS_IsException(v) != 0 {
                                    current_block = 6876706530050647148;
                                    break;
                                }
                                if done != 0 {
                                    current_block = 2873832966593178012;
                                    break;
                                }
                                if JS_DefinePropertyValueInt64(
                                    ctx,
                                    arr,
                                    k,
                                    v,
                                    (1 as libc::c_int) << 0 as libc::c_int
                                        | (1 as libc::c_int) << 1 as libc::c_int
                                        | (1 as libc::c_int) << 2 as libc::c_int
                                        | (1 as libc::c_int) << 14 as libc::c_int,
                                ) < 0 as libc::c_int
                                {
                                    current_block = 6876706530050647148;
                                    break;
                                }
                                k += 1;
                            }
                            match current_block {
                                2873832966593178012 => {}
                                _ => {
                                    if JS_IsUndefined(stack[0 as libc::c_int as usize]) == 0 {
                                        JS_IteratorClose(
                                            ctx,
                                            stack[0 as libc::c_int as usize],
                                            TRUE as libc::c_int,
                                        );
                                    }
                                    current_block = 13421693927056412477;
                                }
                            }
                        }
                    }
                } else {
                    arr = JS_ToObject(ctx, items);
                    if JS_IsException(arr) != 0 {
                        current_block = 13421693927056412477;
                    } else {
                        current_block = 2873832966593178012;
                    }
                }
                match current_block {
                    13421693927056412477 => {}
                    _ => {
                        if js_get_length64(ctx, &mut len, arr) < 0 as libc::c_int {
                            current_block = 13421693927056412477;
                        } else {
                            v = JS_NewInt64(ctx, len);
                            args[0 as libc::c_int as usize] = v;
                            r = js_typed_array_create(
                                ctx,
                                this_val,
                                1 as libc::c_int,
                                args.as_mut_ptr(),
                            );
                            JS_FreeValue(ctx, v);
                            if JS_IsException(r) != 0 {
                                current_block = 13421693927056412477;
                            } else {
                                k = 0 as libc::c_int as int64_t;
                                loop {
                                    if !(k < len) {
                                        current_block = 8966315123586702380;
                                        break;
                                    }
                                    v = JS_GetPropertyInt64(ctx, arr, k);
                                    if JS_IsException(v) != 0 {
                                        current_block = 13421693927056412477;
                                        break;
                                    }
                                    if mapping != 0 {
                                        args[0 as libc::c_int as usize] = v;
                                        args[1 as libc::c_int
                                            as usize] = JS_NewInt32(ctx, k as int32_t);
                                        v2 = JS_Call(
                                            ctx,
                                            mapfn,
                                            this_arg,
                                            2 as libc::c_int,
                                            args.as_mut_ptr(),
                                        );
                                        JS_FreeValue(ctx, v);
                                        v = v2;
                                        if JS_IsException(v) != 0 {
                                            current_block = 13421693927056412477;
                                            break;
                                        }
                                    }
                                    if JS_SetPropertyInt64(ctx, r, k, v) < 0 as libc::c_int {
                                        current_block = 13421693927056412477;
                                        break;
                                    }
                                    k += 1;
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        13421693927056412477 => {
            JS_FreeValue(ctx, r);
            r = (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        _ => {}
    }
    JS_FreeValue(ctx, arr);
    JS_FreeValue(ctx, stack[0 as libc::c_int as usize]);
    JS_FreeValue(ctx, stack[1 as libc::c_int as usize]);
    return r;
}
unsafe extern "C" fn js_typed_array_of(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut obj: JSValue = 0;
    let mut args: [JSValue; 1] = [0; 1];
    let mut i: libc::c_int = 0;
    args[0 as libc::c_int as usize] = JS_NewInt32(ctx, argc);
    obj = js_typed_array_create(ctx, this_val, 1 as libc::c_int, args.as_mut_ptr());
    if JS_IsException(obj) != 0 {
        return obj;
    }
    i = 0 as libc::c_int;
    while i < argc {
        if JS_SetPropertyUint32(
            ctx,
            obj,
            i as uint32_t,
            JS_DupValue(ctx, *argv.offset(i as isize)),
        ) < 0 as libc::c_int
        {
            JS_FreeValue(ctx, obj);
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        i += 1;
    }
    return obj;
}
unsafe extern "C" fn js_typed_array_copyWithin(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    let mut to: libc::c_int = 0;
    let mut from: libc::c_int = 0;
    let mut final_0: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32Clamp(
        ctx,
        &mut to,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        len,
        len,
    ) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_ToInt32Clamp(
        ctx,
        &mut from,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        len,
        len,
    ) != 0
    {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    final_0 = len;
    if argc > 2 as libc::c_int
        && JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) == 0
    {
        if JS_ToInt32Clamp(
            ctx,
            &mut final_0,
            *argv.offset(2 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0
        {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    count = min_int(final_0 - from, len - to);
    if count > 0 as libc::c_int {
        p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
        if typed_array_is_detached(ctx, p) != 0 {
            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        }
        shift = typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
            as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
            as libc::c_int;
        memmove(
            ((*p).u.array.u.uint8_ptr).offset((to << shift) as isize)
                as *mut libc::c_void,
            ((*p).u.array.u.uint8_ptr).offset((from << shift) as isize)
                as *const libc::c_void,
            (count << shift) as libc::c_ulong,
        );
    }
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn js_typed_array_fill(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut final_0: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    let mut v64: uint64_t = 0;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
    if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        == JS_CLASS_UINT8C_ARRAY as libc::c_int
    {
        let mut v: int32_t = 0;
        if JS_ToUint8ClampFree(
            ctx,
            &mut v,
            JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize)),
        ) != 0
        {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        v64 = v as uint64_t;
    } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
        <= JS_CLASS_UINT32_ARRAY as libc::c_int
    {
        let mut v_0: uint32_t = 0;
        if JS_ToUint32(ctx, &mut v_0, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        v64 = v_0 as uint64_t;
    } else {
        let mut d: libc::c_double = 0.;
        if JS_ToFloat64(ctx, &mut d, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_FLOAT32_ARRAY as libc::c_int
        {
            let mut u: C2RustUnnamed_30 = C2RustUnnamed_30 { f: 0. };
            u.f = d as libc::c_float;
            v64 = u.u32_0 as uint64_t;
        } else {
            let mut u_0: JSFloat64Union = JSFloat64Union { d: 0. };
            u_0.d = d;
            v64 = u_0.u64_0;
        }
    }
    k = 0 as libc::c_int;
    if argc > 1 as libc::c_int {
        if JS_ToInt32Clamp(
            ctx,
            &mut k,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0
        {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    final_0 = len;
    if argc > 2 as libc::c_int
        && JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) == 0
    {
        if JS_ToInt32Clamp(
            ctx,
            &mut final_0,
            *argv.offset(2 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0
        {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if typed_array_is_detached(ctx, p) != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    shift = typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
        as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize] as libc::c_int;
    match shift {
        0 => {
            if k < final_0 {
                memset(
                    ((*p).u.array.u.uint8_ptr).offset(k as isize) as *mut libc::c_void,
                    v64 as libc::c_int,
                    (final_0 - k) as libc::c_ulong,
                );
            }
        }
        1 => {
            while k < final_0 {
                *((*p).u.array.u.uint16_ptr).offset(k as isize) = v64 as uint16_t;
                k += 1;
            }
        }
        2 => {
            while k < final_0 {
                *((*p).u.array.u.uint32_ptr).offset(k as isize) = v64 as uint32_t;
                k += 1;
            }
        }
        3 => {
            while k < final_0 {
                *((*p).u.array.u.uint64_ptr).offset(k as isize) = v64;
                k += 1;
            }
        }
        _ => {
            abort();
        }
    }
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn js_typed_array_find(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut findIndex: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut func: JSValue = 0;
    let mut this_arg: JSValue = 0;
    let mut args: [JSValue; 3] = [0; 3];
    let mut val: JSValue = 0;
    let mut index_val: JSValue = 0;
    let mut res: JSValue = 0;
    let mut len: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    val = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if !(len < 0 as libc::c_int) {
        func = *argv.offset(0 as libc::c_int as isize);
        if !(check_function(ctx, func) != 0) {
            this_arg = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            if argc > 1 as libc::c_int {
                this_arg = *argv.offset(1 as libc::c_int as isize);
            }
            k = 0 as libc::c_int;
            loop {
                if !(k < len) {
                    current_block = 7056779235015430508;
                    break;
                }
                index_val = JS_NewInt32(ctx, k);
                val = JS_GetPropertyValue(ctx, this_val, index_val);
                if JS_IsException(val) != 0 {
                    current_block = 7288234912738095595;
                    break;
                }
                args[0 as libc::c_int as usize] = val;
                args[1 as libc::c_int as usize] = index_val;
                args[2 as libc::c_int as usize] = this_val;
                res = JS_Call(ctx, func, this_arg, 3 as libc::c_int, args.as_mut_ptr());
                if JS_IsException(res) != 0 {
                    current_block = 7288234912738095595;
                    break;
                }
                if JS_ToBoolFree(ctx, res) != 0 {
                    if findIndex != 0 {
                        JS_FreeValue(ctx, val);
                        return index_val;
                    } else {
                        return val
                    }
                }
                JS_FreeValue(ctx, val);
                k += 1;
            }
            match current_block {
                7288234912738095595 => {}
                _ => {
                    if findIndex != 0 {
                        return JS_NewInt32(ctx, -(1 as libc::c_int))
                    } else {
                        return (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                            << 32 as libc::c_int
                            | 0 as libc::c_int as uint32_t as libc::c_ulonglong
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, val);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_indexOf(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut special: libc::c_int,
) -> JSValue {
    let mut pv_0: *const uint16_t = 0 as *const uint16_t;
    let mut v_0: uint16_t = 0;
    let mut pv: *const uint8_t = 0 as *const uint8_t;
    let mut pp: *const uint8_t = 0 as *const uint8_t;
    let mut v: uint16_t = 0;
    let mut pv_1: *const uint32_t = 0 as *const uint32_t;
    let mut v_1: uint32_t = 0;
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut is_int: libc::c_int = 0;
    let mut is_bigint: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut stop: libc::c_int = 0;
    let mut inc: libc::c_int = 0;
    let mut res: libc::c_int = -(1 as libc::c_int);
    let mut v64: int64_t = 0;
    let mut d: libc::c_double = 0.;
    let mut f: libc::c_float = 0.;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if !(len < 0 as libc::c_int) {
        if len == 0 as libc::c_int {
            current_block = 3831284441789609621;
        } else {
            if special == 1 as libc::c_int {
                k = len - 1 as libc::c_int;
                if argc > 1 as libc::c_int {
                    if JS_ToFloat64(ctx, &mut d, *argv.offset(1 as libc::c_int as isize))
                        != 0
                    {
                        current_block = 3028142392167073672;
                    } else if isnan(d) != 0 {
                        k = 0 as libc::c_int;
                        current_block = 11042950489265723346;
                    } else if d >= 0 as libc::c_int as libc::c_double {
                        if d < k as libc::c_double {
                            k = d as libc::c_int;
                        }
                        current_block = 11042950489265723346;
                    } else {
                        d += len as libc::c_double;
                        if d < 0 as libc::c_int as libc::c_double {
                            current_block = 3831284441789609621;
                        } else {
                            k = d as libc::c_int;
                            current_block = 11042950489265723346;
                        }
                    }
                } else {
                    current_block = 11042950489265723346;
                }
                match current_block {
                    3028142392167073672 => {}
                    3831284441789609621 => {}
                    _ => {
                        stop = -(1 as libc::c_int);
                        inc = -(1 as libc::c_int);
                        current_block = 17788412896529399552;
                    }
                }
            } else {
                k = 0 as libc::c_int;
                if argc > 1 as libc::c_int {
                    if JS_ToInt32Clamp(
                        ctx,
                        &mut k,
                        *argv.offset(1 as libc::c_int as isize),
                        0 as libc::c_int,
                        len,
                        len,
                    ) != 0
                    {
                        current_block = 3028142392167073672;
                    } else {
                        current_block = 15345278821338558188;
                    }
                } else {
                    current_block = 15345278821338558188;
                }
                match current_block {
                    3028142392167073672 => {}
                    _ => {
                        stop = len;
                        inc = 1 as libc::c_int;
                        current_block = 17788412896529399552;
                    }
                }
            }
            match current_block {
                3028142392167073672 => {}
                3831284441789609621 => {}
                _ => {
                    p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
                    if typed_array_is_detached(ctx, p) != 0 {
                        if special == -(1 as libc::c_int)
                            && JS_IsUndefined(*argv.offset(0 as libc::c_int as isize))
                                != 0 && len > 0 as libc::c_int
                        {
                            res = 0 as libc::c_int;
                        }
                    } else {
                        is_bigint = 0 as libc::c_int;
                        is_int = 0 as libc::c_int;
                        v64 = 0 as libc::c_int as int64_t;
                        tag = JS_VALUE_GET_NORM_TAG(
                            *argv.offset(0 as libc::c_int as isize),
                        );
                        if tag == JS_TAG_INT as libc::c_int {
                            is_int = 1 as libc::c_int;
                            v64 = *argv.offset(0 as libc::c_int as isize) as libc::c_int
                                as int64_t;
                            d = v64 as libc::c_double;
                            current_block = 14775119014532381840;
                        } else if tag == JS_TAG_FLOAT64 as libc::c_int {
                            d = JS_VALUE_GET_FLOAT64(
                                *argv.offset(0 as libc::c_int as isize),
                            );
                            v64 = d as int64_t;
                            is_int = (v64 as libc::c_double == d) as libc::c_int;
                            current_block = 14775119014532381840;
                        } else {
                            current_block = 3831284441789609621;
                        }
                        match current_block {
                            3831284441789609621 => {}
                            _ => {
                                match (*p).c2rust_unnamed.c2rust_unnamed.class_id
                                    as libc::c_int
                                {
                                    22 => {
                                        current_block = 6566153704931017518;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    21 | 23 => {
                                        current_block = 16989991835829368619;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    24 => {
                                        current_block = 16810842749744364298;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    25 => {
                                        current_block = 3465946700934137799;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    26 => {
                                        current_block = 618387217014894856;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    27 => {
                                        current_block = 16033091480162995995;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    28 => {
                                        current_block = 5973339896079976200;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    29 => {
                                        current_block = 2777758207713918955;
                                        match current_block {
                                            618387217014894856 => {
                                                if is_int != 0 && v64 as int32_t as libc::c_longlong == v64
                                                {
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            3465946700934137799 => {
                                                if is_int != 0 && v64 as uint16_t as libc::c_longlong == v64
                                                {
                                                    pv_0 = 0 as *const uint16_t;
                                                    v_0 = 0;
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16989991835829368619 => {
                                                if is_int != 0 && v64 as uint8_t as libc::c_longlong == v64
                                                {
                                                    pv = 0 as *const uint8_t;
                                                    pp = 0 as *const uint8_t;
                                                    v = 0;
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            5973339896079976200 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_2: *const libc::c_float = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .float_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_2.offset(k as isize) as libc::c_double) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        f = d as libc::c_float;
                                                        if f as libc::c_double == d {
                                                            let mut pv_3: *const libc::c_float = (*p)
                                                                .u
                                                                .array
                                                                .u
                                                                .float_ptr;
                                                            while k != stop {
                                                                if *pv_3.offset(k as isize) == f {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            2777758207713918955 => {
                                                if is_bigint != 0 {
                                                    current_block = 3831284441789609621;
                                                } else {
                                                    if isnan(d) != 0 {
                                                        let mut pv_4: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        if !(special != -(1 as libc::c_int)) {
                                                            while k != stop {
                                                                if isnan(*pv_4.offset(k as isize)) != 0 {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        let mut pv_5: *const libc::c_double = (*p)
                                                            .u
                                                            .array
                                                            .u
                                                            .double_ptr;
                                                        while k != stop {
                                                            if *pv_5.offset(k as isize) == d {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            6566153704931017518 => {
                                                if is_int != 0 && v64 as int8_t as libc::c_longlong == v64 {
                                                    current_block = 14449071695088723134;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            16810842749744364298 => {
                                                if is_int != 0 && v64 as int16_t as libc::c_longlong == v64
                                                {
                                                    current_block = 14830638058799530230;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                            _ => {
                                                if is_int != 0 && v64 as uint32_t as libc::c_longlong == v64
                                                {
                                                    pv_1 = 0 as *const uint32_t;
                                                    v_1 = 0;
                                                    current_block = 10616250463266316517;
                                                } else {
                                                    current_block = 3831284441789609621;
                                                }
                                            }
                                        }
                                        match current_block {
                                            3831284441789609621 => {}
                                            _ => {
                                                match current_block {
                                                    10616250463266316517 => {
                                                        pv_1 = (*p).u.array.u.uint32_ptr;
                                                        v_1 = v64 as uint32_t;
                                                        while k != stop {
                                                            if *pv_1.offset(k as isize) == v_1 {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                    14449071695088723134 => {
                                                        pv = (*p).u.array.u.uint8_ptr;
                                                        v = v64 as uint16_t;
                                                        if inc > 0 as libc::c_int {
                                                            pp = memchr(
                                                                pv.offset(k as isize) as *const libc::c_void,
                                                                v as libc::c_int,
                                                                (len - k) as libc::c_ulong,
                                                            ) as *const uint8_t;
                                                            if !pp.is_null() {
                                                                res = pp.offset_from(pv) as libc::c_long as libc::c_int;
                                                            }
                                                        } else {
                                                            while k != stop {
                                                                if *pv.offset(k as isize) as libc::c_int == v as libc::c_int
                                                                {
                                                                    res = k;
                                                                    break;
                                                                } else {
                                                                    k += inc;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {
                                                        pv_0 = (*p).u.array.u.uint16_ptr;
                                                        v_0 = v64 as uint16_t;
                                                        while k != stop {
                                                            if *pv_0.offset(k as isize) as libc::c_int
                                                                == v_0 as libc::c_int
                                                            {
                                                                res = k;
                                                                break;
                                                            } else {
                                                                k += inc;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    current_block = 3831284441789609621;
                }
            }
        }
        match current_block {
            3028142392167073672 => {}
            _ => {
                if special == -(1 as libc::c_int) {
                    return JS_NewBool(ctx, (res >= 0 as libc::c_int) as libc::c_int)
                } else {
                    return JS_NewInt32(ctx, res)
                }
            }
        }
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_join(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut toLocaleString: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut sep: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut el: JSValue = 0;
    let mut b_s: StringBuffer = StringBuffer {
        ctx: 0 as *mut JSContext,
        str_0: 0 as *mut JSString,
        len: 0,
        size: 0,
        is_wide_char: 0,
        error_status: 0,
    };
    let mut b: *mut StringBuffer = &mut b_s;
    let mut p: *mut JSString = 0 as *mut JSString;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    n = js_typed_array_get_length_internal(ctx, this_val);
    if !(n < 0 as libc::c_int) {
        c = ',' as i32;
        if toLocaleString == 0 && argc > 0 as libc::c_int
            && JS_IsUndefined(*argv.offset(0 as libc::c_int as isize)) == 0
        {
            sep = JS_ToString(ctx, *argv.offset(0 as libc::c_int as isize));
            if JS_IsException(sep) != 0 {
                current_block = 5859378378120059144;
            } else {
                p = sep as intptr_t as *mut libc::c_void as *mut JSString;
                if (*p).len() as libc::c_int == 1 as libc::c_int
                    && (*p).is_wide_char() == 0
                {
                    c = (*p).u.str8[0 as libc::c_int as usize] as libc::c_int;
                } else {
                    c = -(1 as libc::c_int);
                }
                current_block = 1856101646708284338;
            }
        } else {
            current_block = 1856101646708284338;
        }
        match current_block {
            5859378378120059144 => {}
            _ => {
                string_buffer_init(ctx, b, 0 as libc::c_int);
                i = 0 as libc::c_int;
                loop {
                    if !(i < n) {
                        current_block = 11932355480408055363;
                        break;
                    }
                    if i > 0 as libc::c_int {
                        if c >= 0 as libc::c_int {
                            if string_buffer_putc8(b, c as uint32_t) != 0 {
                                current_block = 322959191903446656;
                                break;
                            }
                        } else if string_buffer_concat(
                            b,
                            p,
                            0 as libc::c_int as uint32_t,
                            (*p).len(),
                        ) != 0
                        {
                            current_block = 322959191903446656;
                            break;
                        }
                    }
                    el = JS_GetPropertyUint32(ctx, this_val, i as uint32_t);
                    if JS_IsNull(el) == 0 && JS_IsUndefined(el) == 0 {
                        if JS_IsException(el) != 0 {
                            current_block = 322959191903446656;
                            break;
                        }
                        if toLocaleString != 0 {
                            el = JS_ToLocaleStringFree(ctx, el);
                        }
                        if string_buffer_concat_value_free(b, el) != 0 {
                            current_block = 322959191903446656;
                            break;
                        }
                    }
                    i += 1;
                }
                match current_block {
                    322959191903446656 => {
                        string_buffer_free(b);
                        JS_FreeValue(ctx, sep);
                    }
                    _ => {
                        JS_FreeValue(ctx, sep);
                        return string_buffer_end(b);
                    }
                }
            }
        }
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_reverse(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if len > 0 as libc::c_int {
        p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
        match typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
            as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
            as libc::c_int
        {
            0 => {
                let mut p1: *mut uint8_t = (*p).u.array.u.uint8_ptr;
                let mut p2: *mut uint8_t = p1
                    .offset(len as isize)
                    .offset(-(1 as libc::c_int as isize));
                while p1 < p2 {
                    let mut v: uint8_t = *p1;
                    let fresh737 = p1;
                    p1 = p1.offset(1);
                    *fresh737 = *p2;
                    let fresh738 = p2;
                    p2 = p2.offset(-1);
                    *fresh738 = v;
                }
            }
            1 => {
                let mut p1_0: *mut uint16_t = (*p).u.array.u.uint16_ptr;
                let mut p2_0: *mut uint16_t = p1_0
                    .offset(len as isize)
                    .offset(-(1 as libc::c_int as isize));
                while p1_0 < p2_0 {
                    let mut v_0: uint16_t = *p1_0;
                    let fresh739 = p1_0;
                    p1_0 = p1_0.offset(1);
                    *fresh739 = *p2_0;
                    let fresh740 = p2_0;
                    p2_0 = p2_0.offset(-1);
                    *fresh740 = v_0;
                }
            }
            2 => {
                let mut p1_1: *mut uint32_t = (*p).u.array.u.uint32_ptr;
                let mut p2_1: *mut uint32_t = p1_1
                    .offset(len as isize)
                    .offset(-(1 as libc::c_int as isize));
                while p1_1 < p2_1 {
                    let mut v_1: uint32_t = *p1_1;
                    let fresh741 = p1_1;
                    p1_1 = p1_1.offset(1);
                    *fresh741 = *p2_1;
                    let fresh742 = p2_1;
                    p2_1 = p2_1.offset(-1);
                    *fresh742 = v_1;
                }
            }
            3 => {
                let mut p1_2: *mut uint64_t = (*p).u.array.u.uint64_ptr;
                let mut p2_2: *mut uint64_t = p1_2
                    .offset(len as isize)
                    .offset(-(1 as libc::c_int as isize));
                while p1_2 < p2_2 {
                    let mut v_2: uint64_t = *p1_2;
                    let fresh743 = p1_2;
                    p1_2 = p1_2.offset(1);
                    *fresh743 = *p2_2;
                    let fresh744 = p2_2;
                    p2_2 = p2_2.offset(-1);
                    *fresh744 = v_2;
                }
            }
            _ => {
                abort();
            }
        }
    }
    return JS_DupValue(ctx, this_val);
}
unsafe extern "C" fn js_typed_array_slice(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut args: [JSValue; 2] = [0; 2];
    let mut arr: JSValue = 0;
    let mut val: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut p1: *mut JSObject = 0 as *mut JSObject;
    let mut n: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut final_0: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    arr = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    len = js_typed_array_get_length_internal(ctx, this_val);
    if !(len < 0 as libc::c_int) {
        if !(JS_ToInt32Clamp(
            ctx,
            &mut start,
            *argv.offset(0 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0)
        {
            final_0 = len;
            if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
                if JS_ToInt32Clamp(
                    ctx,
                    &mut final_0,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                    len,
                    len,
                ) != 0
                {
                    current_block = 10369570240015093188;
                } else {
                    current_block = 3640593987805443782;
                }
            } else {
                current_block = 3640593987805443782;
            }
            match current_block {
                10369570240015093188 => {}
                _ => {
                    count = max_int(final_0 - start, 0 as libc::c_int);
                    p = get_typed_array(ctx, this_val, 0 as libc::c_int);
                    if !p.is_null() {
                        shift = typed_array_size_log2[((*p)
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .class_id as libc::c_int
                            - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
                            as libc::c_int;
                        args[0 as libc::c_int as usize] = this_val;
                        args[1 as libc::c_int as usize] = JS_NewInt32(ctx, count);
                        arr = js_typed_array___speciesCreate(
                            ctx,
                            (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                << 32 as libc::c_int
                                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                            2 as libc::c_int,
                            args.as_mut_ptr(),
                        );
                        if !(JS_IsException(arr) != 0) {
                            if count > 0 as libc::c_int {
                                if validate_typed_array(ctx, this_val) != 0
                                    || validate_typed_array(ctx, arr) != 0
                                {
                                    current_block = 10369570240015093188;
                                } else {
                                    p1 = get_typed_array(ctx, arr, 0 as libc::c_int);
                                    if !p1.is_null()
                                        && (*p).c2rust_unnamed.c2rust_unnamed.class_id
                                            as libc::c_int
                                            == (*p1).c2rust_unnamed.c2rust_unnamed.class_id
                                                as libc::c_int
                                        && typed_array_get_length(ctx, p1) >= count as libc::c_uint
                                        && typed_array_get_length(ctx, p)
                                            >= (start + count) as libc::c_uint
                                    {
                                        memcpy(
                                            (*p1).u.array.u.uint8_ptr as *mut libc::c_void,
                                            ((*p).u.array.u.uint8_ptr).offset((start << shift) as isize)
                                                as *const libc::c_void,
                                            (count << shift) as libc::c_ulong,
                                        );
                                        current_block = 7205609094909031804;
                                    } else {
                                        n = 0 as libc::c_int;
                                        loop {
                                            if !(n < count) {
                                                current_block = 7205609094909031804;
                                                break;
                                            }
                                            val = JS_GetPropertyValue(
                                                ctx,
                                                this_val,
                                                JS_NewInt32(ctx, start + n),
                                            );
                                            if JS_IsException(val) != 0 {
                                                current_block = 10369570240015093188;
                                                break;
                                            }
                                            if JS_SetPropertyValue(
                                                ctx,
                                                arr,
                                                JS_NewInt32(ctx, n),
                                                val,
                                                (1 as libc::c_int) << 14 as libc::c_int,
                                            ) < 0 as libc::c_int
                                            {
                                                current_block = 10369570240015093188;
                                                break;
                                            }
                                            n += 1;
                                        }
                                    }
                                }
                            } else {
                                current_block = 7205609094909031804;
                            }
                            match current_block {
                                10369570240015093188 => {}
                                _ => return arr,
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, arr);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_subarray(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut args: [JSValue; 4] = [0; 4];
    let mut arr: JSValue = 0;
    let mut byteOffset: JSValue = 0;
    let mut ta_buffer: JSValue = 0;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut final_0: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    let mut offset: libc::c_int = 0;
    p = get_typed_array(ctx, this_val, 0 as libc::c_int);
    if !p.is_null() {
        len = (*p).u.array.count as libc::c_int;
        if !(JS_ToInt32Clamp(
            ctx,
            &mut start,
            *argv.offset(0 as libc::c_int as isize),
            0 as libc::c_int,
            len,
            len,
        ) != 0)
        {
            final_0 = len;
            if JS_IsUndefined(*argv.offset(1 as libc::c_int as isize)) == 0 {
                if JS_ToInt32Clamp(
                    ctx,
                    &mut final_0,
                    *argv.offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                    len,
                    len,
                ) != 0
                {
                    current_block = 15771654167791431907;
                } else {
                    current_block = 3640593987805443782;
                }
            } else {
                current_block = 3640593987805443782;
            }
            match current_block {
                15771654167791431907 => {}
                _ => {
                    count = max_int(final_0 - start, 0 as libc::c_int);
                    byteOffset = js_typed_array_get_byteOffset(
                        ctx,
                        this_val,
                        0 as libc::c_int,
                    );
                    if !(JS_IsException(byteOffset) != 0) {
                        shift = typed_array_size_log2[((*p)
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .class_id as libc::c_int
                            - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
                            as libc::c_int;
                        offset = byteOffset as libc::c_int + (start << shift);
                        JS_FreeValue(ctx, byteOffset);
                        ta_buffer = js_typed_array_get_buffer(
                            ctx,
                            this_val,
                            0 as libc::c_int,
                        );
                        if !(JS_IsException(ta_buffer) != 0) {
                            args[0 as libc::c_int as usize] = this_val;
                            args[1 as libc::c_int as usize] = ta_buffer;
                            args[2 as libc::c_int as usize] = JS_NewInt32(ctx, offset);
                            args[3 as libc::c_int as usize] = JS_NewInt32(ctx, count);
                            arr = js_typed_array___speciesCreate(
                                ctx,
                                (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
                                    << 32 as libc::c_int
                                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                                4 as libc::c_int,
                                args.as_mut_ptr(),
                            );
                            JS_FreeValue(ctx, ta_buffer);
                            return arr;
                        }
                    }
                }
            }
        }
    }
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_cmp_doubles(
    mut x: libc::c_double,
    mut y: libc::c_double,
) -> libc::c_int {
    if isnan(x) != 0 {
        return if isnan(y) != 0 { 0 as libc::c_int } else { 1 as libc::c_int };
    }
    if isnan(y) != 0 {
        return -(1 as libc::c_int);
    }
    if x < y {
        return -(1 as libc::c_int);
    }
    if x > y {
        return 1 as libc::c_int;
    }
    if x != 0 as libc::c_int as libc::c_double {
        return 0 as libc::c_int;
    }
    if signbit(x) != 0 {
        return if signbit(y) != 0 { 0 as libc::c_int } else { -(1 as libc::c_int) }
    } else {
        return if signbit(y) != 0 { 1 as libc::c_int } else { 0 as libc::c_int }
    };
}
unsafe extern "C" fn js_TA_cmp_int8(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return *(a as *const int8_t) as libc::c_int - *(b as *const int8_t) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_uint8(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return *(a as *const uint8_t) as libc::c_int - *(b as *const uint8_t) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_int16(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return *(a as *const int16_t) as libc::c_int - *(b as *const int16_t) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_uint16(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return *(a as *const uint16_t) as libc::c_int
        - *(b as *const uint16_t) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_int32(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut x: int32_t = *(a as *const int32_t);
    let mut y: int32_t = *(b as *const int32_t);
    return (y < x) as libc::c_int - (y > x) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_uint32(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut x: uint32_t = *(a as *const uint32_t);
    let mut y: uint32_t = *(b as *const uint32_t);
    return (y < x) as libc::c_int - (y > x) as libc::c_int;
}
unsafe extern "C" fn js_TA_cmp_float32(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return js_cmp_doubles(
        *(a as *const libc::c_float) as libc::c_double,
        *(b as *const libc::c_float) as libc::c_double,
    );
}
unsafe extern "C" fn js_TA_cmp_float64(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    return js_cmp_doubles(*(a as *const libc::c_double), *(b as *const libc::c_double));
}
unsafe extern "C" fn js_TA_get_int8(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewInt32(ctx, *(a as *const int8_t) as int32_t);
}
unsafe extern "C" fn js_TA_get_uint8(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewInt32(ctx, *(a as *const uint8_t) as int32_t);
}
unsafe extern "C" fn js_TA_get_int16(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewInt32(ctx, *(a as *const int16_t) as int32_t);
}
unsafe extern "C" fn js_TA_get_uint16(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewInt32(ctx, *(a as *const uint16_t) as int32_t);
}
unsafe extern "C" fn js_TA_get_int32(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewInt32(ctx, *(a as *const int32_t));
}
unsafe extern "C" fn js_TA_get_uint32(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return JS_NewUint32(ctx, *(a as *const uint32_t));
}
unsafe extern "C" fn js_TA_get_float32(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return __JS_NewFloat64(ctx, *(a as *const libc::c_float) as libc::c_double);
}
unsafe extern "C" fn js_TA_get_float64(
    mut ctx: *mut JSContext,
    mut a: *const libc::c_void,
) -> JSValue {
    return __JS_NewFloat64(ctx, *(a as *const libc::c_double));
}
unsafe extern "C" fn js_TA_cmp_generic(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    mut opaque: *mut libc::c_void,
) -> libc::c_int {
    let mut current_block: u64;
    let mut psc: *mut TA_sort_context = opaque as *mut TA_sort_context;
    let mut ctx: *mut JSContext = (*psc).ctx;
    let mut a_idx: uint32_t = 0;
    let mut b_idx: uint32_t = 0;
    let mut argv: [JSValue; 2] = [0; 2];
    let mut res: JSValue = 0;
    let mut cmp: libc::c_int = 0;
    cmp = 0 as libc::c_int;
    if (*psc).exception == 0 {
        a_idx = *(a as *mut uint32_t);
        b_idx = *(b as *mut uint32_t);
        argv[0 as libc::c_int
            as usize] = ((*psc).getfun)
            .expect(
                "non-null function pointer",
            )(
            ctx,
            ((*psc).array_ptr)
                .offset(
                    (a_idx as libc::c_ulong).wrapping_mul((*psc).elt_size as size_t)
                        as isize,
                ) as *const libc::c_void,
        );
        argv[1 as libc::c_int
            as usize] = ((*psc).getfun)
            .expect(
                "non-null function pointer",
            )(
            ctx,
            ((*psc).array_ptr)
                .offset(
                    (b_idx as libc::c_ulong).wrapping_mul((*psc).elt_size as size_t)
                        as isize,
                ) as *const libc::c_void,
        );
        res = JS_Call(
            ctx,
            (*psc).cmp,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            2 as libc::c_int,
            argv.as_mut_ptr(),
        );
        if JS_IsException(res) != 0 {
            (*psc).exception = 1 as libc::c_int;
        } else {
            if (res >> 32 as libc::c_int) as libc::c_int == JS_TAG_INT as libc::c_int {
                let mut val: libc::c_int = res as libc::c_int;
                cmp = (val > 0 as libc::c_int) as libc::c_int
                    - (val < 0 as libc::c_int) as libc::c_int;
                current_block = 11584701595673473500;
            } else {
                let mut val_0: libc::c_double = 0.;
                if JS_ToFloat64Free(ctx, &mut val_0, res) < 0 as libc::c_int {
                    (*psc).exception = 1 as libc::c_int;
                    current_block = 16710063725901008193;
                } else {
                    cmp = (val_0 > 0 as libc::c_int as libc::c_double) as libc::c_int
                        - (val_0 < 0 as libc::c_int as libc::c_double) as libc::c_int;
                    current_block = 11584701595673473500;
                }
            }
            match current_block {
                16710063725901008193 => {}
                _ => {
                    if cmp == 0 as libc::c_int {
                        cmp = (a_idx > b_idx) as libc::c_int
                            - (a_idx < b_idx) as libc::c_int;
                    }
                    if validate_typed_array(ctx, (*psc).arr) < 0 as libc::c_int {
                        (*psc).exception = 1 as libc::c_int;
                    }
                }
            }
        }
        JS_FreeValue(ctx, argv[0 as libc::c_int as usize]);
        JS_FreeValue(ctx, argv[1 as libc::c_int as usize]);
    }
    return cmp;
}
unsafe extern "C" fn js_typed_array_sort(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut len: libc::c_int = 0;
    let mut elt_size: size_t = 0;
    let mut tsc: TA_sort_context = TA_sort_context {
        ctx: 0 as *mut JSContext,
        exception: 0,
        arr: 0,
        cmp: 0,
        getfun: None,
        array_ptr: 0 as *mut uint8_t,
        elt_size: 0,
    };
    let mut array_ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut cmpfun: Option::<
        unsafe extern "C" fn(
            *const libc::c_void,
            *const libc::c_void,
            *mut libc::c_void,
        ) -> libc::c_int,
    > = None;
    tsc.ctx = ctx;
    tsc.exception = 0 as libc::c_int;
    tsc.arr = this_val;
    tsc.cmp = *argv.offset(0 as libc::c_int as isize);
    len = js_typed_array_get_length_internal(ctx, this_val);
    if len < 0 as libc::c_int {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if JS_IsUndefined(tsc.cmp) == 0 && check_function(ctx, tsc.cmp) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if len > 1 as libc::c_int {
        p = this_val as intptr_t as *mut libc::c_void as *mut JSObject;
        match (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int {
            22 => {
                tsc
                    .getfun = Some(
                    js_TA_get_int8
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_int8
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            21 | 23 => {
                tsc
                    .getfun = Some(
                    js_TA_get_uint8
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_uint8
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            24 => {
                tsc
                    .getfun = Some(
                    js_TA_get_int16
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_int16
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            25 => {
                tsc
                    .getfun = Some(
                    js_TA_get_uint16
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_uint16
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            26 => {
                tsc
                    .getfun = Some(
                    js_TA_get_int32
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_int32
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            27 => {
                tsc
                    .getfun = Some(
                    js_TA_get_uint32
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_uint32
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            28 => {
                tsc
                    .getfun = Some(
                    js_TA_get_float32
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_float32
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            29 => {
                tsc
                    .getfun = Some(
                    js_TA_get_float64
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            *const libc::c_void,
                        ) -> JSValue,
                );
                cmpfun = Some(
                    js_TA_cmp_float64
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                );
            }
            _ => {
                abort();
            }
        }
        array_ptr = (*p).u.array.u.ptr;
        elt_size = ((1 as libc::c_int)
            << typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
                as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize]
                as libc::c_int) as size_t;
        if JS_IsUndefined(tsc.cmp) == 0 {
            's_397: {
                let mut array_idx: *mut uint32_t = 0 as *mut uint32_t;
                let mut array_tmp: *mut libc::c_void = 0 as *mut libc::c_void;
                let mut i: size_t = 0;
                let mut j: size_t = 0;
                array_idx = js_malloc(
                    ctx,
                    (len as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        ),
                ) as *mut uint32_t;
                if array_idx.is_null() {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                i = 0 as libc::c_int as size_t;
                while i < len as libc::c_ulong {
                    *array_idx.offset(i as isize) = i as uint32_t;
                    i = i.wrapping_add(1);
                }
                tsc.array_ptr = array_ptr as *mut uint8_t;
                tsc.elt_size = elt_size as libc::c_int;
                rqsort(
                    array_idx as *mut libc::c_void,
                    len as size_t,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                    Some(
                        js_TA_cmp_generic
                            as unsafe extern "C" fn(
                                *const libc::c_void,
                                *const libc::c_void,
                                *mut libc::c_void,
                            ) -> libc::c_int,
                    ),
                    &mut tsc as *mut TA_sort_context as *mut libc::c_void,
                );
                if !(tsc.exception != 0) {
                    array_tmp = js_malloc(
                        ctx,
                        (len as libc::c_ulong).wrapping_mul(elt_size),
                    );
                    if !array_tmp.is_null() {
                        memcpy(
                            array_tmp,
                            array_ptr,
                            (len as libc::c_ulong).wrapping_mul(elt_size),
                        );
                        match elt_size {
                            1 => {
                                i = 0 as libc::c_int as size_t;
                                while i < len as libc::c_ulong {
                                    j = *array_idx.offset(i as isize) as size_t;
                                    *(array_ptr as *mut uint8_t)
                                        .offset(
                                            i as isize,
                                        ) = *(array_tmp as *mut uint8_t).offset(j as isize);
                                    i = i.wrapping_add(1);
                                }
                            }
                            2 => {
                                i = 0 as libc::c_int as size_t;
                                while i < len as libc::c_ulong {
                                    j = *array_idx.offset(i as isize) as size_t;
                                    *(array_ptr as *mut uint16_t)
                                        .offset(
                                            i as isize,
                                        ) = *(array_tmp as *mut uint16_t).offset(j as isize);
                                    i = i.wrapping_add(1);
                                }
                            }
                            4 => {
                                i = 0 as libc::c_int as size_t;
                                while i < len as libc::c_ulong {
                                    j = *array_idx.offset(i as isize) as size_t;
                                    *(array_ptr as *mut uint32_t)
                                        .offset(
                                            i as isize,
                                        ) = *(array_tmp as *mut uint32_t).offset(j as isize);
                                    i = i.wrapping_add(1);
                                }
                            }
                            8 => {
                                i = 0 as libc::c_int as size_t;
                                while i < len as libc::c_ulong {
                                    j = *array_idx.offset(i as isize) as size_t;
                                    *(array_ptr as *mut uint64_t)
                                        .offset(
                                            i as isize,
                                        ) = *(array_tmp as *mut uint64_t).offset(j as isize);
                                    i = i.wrapping_add(1);
                                }
                            }
                            _ => {
                                abort();
                            }
                        }
                        js_free(ctx, array_tmp);
                        js_free(ctx, array_idx as *mut libc::c_void);
                        break 's_397;
                    }
                }
                js_free(ctx, array_idx as *mut libc::c_void);
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        } else {
            rqsort(
                array_ptr,
                len as size_t,
                elt_size,
                cmpfun,
                &mut tsc as *mut TA_sort_context as *mut libc::c_void,
            );
            if tsc.exception != 0 {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
        }
    }
    return JS_DupValue(ctx, this_val);
}
static mut js_typed_array_base_funcs: [JSCFunctionListEntry; 3] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"from\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_from
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"of\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_of
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.species]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_get_this
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
static mut js_typed_array_base_proto_funcs: [JSCFunctionListEntry; 30] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"length\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_typed_array_get_length
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"buffer\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_buffer
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteLength\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_byteLength
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteOffset\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_byteOffset
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"set\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_set
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"values\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_typed_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.iterator]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 9 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    alias: {
                        let mut init = C2RustUnnamed_23 {
                            name: b"values\0" as *const u8 as *const libc::c_char,
                            base: -(1 as libc::c_int),
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"keys\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_typed_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"entries\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_ITERATOR_KIND_KEY_AND_VALUE as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_create_typed_array_iterator
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 1 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter: Some(
                                    js_typed_array_get_toStringTag
                                        as unsafe extern "C" fn(*mut JSContext, JSValue) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType { setter: None },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"copyWithin\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_copyWithin
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"every\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (0 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"some\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (1 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"forEach\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (2 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"map\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (3 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"filter\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (4 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_every
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reduce\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (0 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_reduce
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reduceRight\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: (1 as libc::c_int | 8 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_array_reduce
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"fill\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_fill
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"find\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_find
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"findIndex\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_find
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"reverse\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_reverse
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"slice\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_slice
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"subarray\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_subarray
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"sort\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic: Some(
                                    js_typed_array_sort
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"join\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_join
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"toLocaleString\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 0 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_join
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"indexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"lastIndexOf\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"includes\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: -(1 as libc::c_int) as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_typed_array_indexOf
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
    ]
};
unsafe extern "C" fn js_typed_array_base_constructor(
    mut ctx: *mut JSContext,
    mut this_val: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    return JS_ThrowTypeError(
        ctx,
        b"cannot be called\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn typed_array_init(
    mut ctx: *mut JSContext,
    mut obj: JSValue,
    mut buffer: JSValue,
    mut offset: uint64_t,
    mut len: uint64_t,
) -> libc::c_int {
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut pbuffer: *mut JSObject = 0 as *mut JSObject;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut size_log2: libc::c_int = 0;
    p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
    size_log2 = typed_array_size_log2[((*p).c2rust_unnamed.c2rust_unnamed.class_id
        as libc::c_int - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize] as libc::c_int;
    ta = js_malloc(ctx, ::core::mem::size_of::<JSTypedArray>() as libc::c_ulong)
        as *mut JSTypedArray;
    if ta.is_null() {
        JS_FreeValue(ctx, buffer);
        return -(1 as libc::c_int);
    }
    pbuffer = buffer as intptr_t as *mut libc::c_void as *mut JSObject;
    abuf = (*pbuffer).u.array_buffer;
    let ref mut fresh745 = (*ta).obj;
    *fresh745 = p;
    let ref mut fresh746 = (*ta).buffer;
    *fresh746 = pbuffer;
    (*ta).offset = offset as uint32_t;
    (*ta).length = (len << size_log2) as uint32_t;
    list_add_tail(&mut (*ta).link, &mut (*abuf).array_list);
    let ref mut fresh747 = (*p).u.typed_array;
    *fresh747 = ta;
    (*p).u.array.count = len as uint32_t;
    let ref mut fresh748 = (*p).u.array.u.ptr;
    *fresh748 = ((*abuf).data).offset(offset as isize) as *mut libc::c_void;
    return 0 as libc::c_int;
}
unsafe extern "C" fn js_array_from_iterator(
    mut ctx: *mut JSContext,
    mut plen: *mut uint32_t,
    mut obj: JSValue,
    mut method: JSValue,
) -> JSValue {
    let mut current_block: u64;
    let mut arr: JSValue = 0;
    let mut iter: JSValue = 0;
    let mut next_method: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut val: JSValue = 0;
    let mut done: BOOL = 0;
    let mut k: uint32_t = 0;
    *plen = 0 as libc::c_int as uint32_t;
    arr = JS_NewArray(ctx);
    if JS_IsException(arr) != 0 {
        return arr;
    }
    iter = JS_GetIterator2(ctx, obj, method);
    if !(JS_IsException(iter) != 0) {
        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next as libc::c_int as JSAtom);
        if !(JS_IsException(next_method) != 0) {
            k = 0 as libc::c_int as uint32_t;
            loop {
                val = JS_IteratorNext(
                    ctx,
                    iter,
                    next_method,
                    0 as libc::c_int,
                    0 as *mut JSValue,
                    &mut done,
                );
                if JS_IsException(val) != 0 {
                    current_block = 18295666387725681211;
                    break;
                }
                if done != 0 {
                    JS_FreeValue(ctx, val);
                    current_block = 5948590327928692120;
                    break;
                } else {
                    if JS_CreateDataPropertyUint32(
                        ctx,
                        arr,
                        k as int64_t,
                        val,
                        (1 as libc::c_int) << 14 as libc::c_int,
                    ) < 0 as libc::c_int
                    {
                        current_block = 18295666387725681211;
                        break;
                    }
                    k = k.wrapping_add(1);
                }
            }
            match current_block {
                18295666387725681211 => {}
                _ => {
                    JS_FreeValue(ctx, next_method);
                    JS_FreeValue(ctx, iter);
                    *plen = k;
                    return arr;
                }
            }
        }
    }
    JS_FreeValue(ctx, next_method);
    JS_FreeValue(ctx, iter);
    JS_FreeValue(ctx, arr);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_constructor_obj(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut obj: JSValue,
    mut classid: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut iter: JSValue = 0;
    let mut ret: JSValue = 0;
    let mut arr: JSValue = (JS_TAG_UNDEFINED as libc::c_int as uint64_t)
        << 32 as libc::c_int | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    let mut val: JSValue = 0;
    let mut buffer: JSValue = 0;
    let mut i: uint32_t = 0;
    let mut size_log2: libc::c_int = 0;
    let mut len: int64_t = 0;
    size_log2 = typed_array_size_log2[(classid - JS_CLASS_UINT8C_ARRAY as libc::c_int)
        as usize] as libc::c_int;
    ret = js_create_from_ctor(ctx, new_target, classid);
    if JS_IsException(ret) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    iter = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator as libc::c_int as JSAtom);
    if !(JS_IsException(iter) != 0) {
        if JS_IsUndefined(iter) == 0 && JS_IsNull(iter) == 0 {
            let mut len1: uint32_t = 0;
            arr = js_array_from_iterator(ctx, &mut len1, obj, iter);
            JS_FreeValue(ctx, iter);
            if JS_IsException(arr) != 0 {
                current_block = 15201273715869830213;
            } else {
                len = len1 as int64_t;
                current_block = 1054647088692577877;
            }
        } else if js_get_length64(ctx, &mut len, obj) != 0 {
            current_block = 15201273715869830213;
        } else {
            arr = JS_DupValue(ctx, obj);
            current_block = 1054647088692577877;
        }
        match current_block {
            15201273715869830213 => {}
            _ => {
                buffer = js_array_buffer_constructor1(
                    ctx,
                    (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
                    (len << size_log2) as uint64_t,
                );
                if !(JS_IsException(buffer) != 0) {
                    if !(typed_array_init(
                        ctx,
                        ret,
                        buffer,
                        0 as libc::c_int as uint64_t,
                        len as uint64_t,
                    ) != 0)
                    {
                        i = 0 as libc::c_int as uint32_t;
                        loop {
                            if !((i as libc::c_longlong) < len) {
                                current_block = 9828876828309294594;
                                break;
                            }
                            val = JS_GetPropertyUint32(ctx, arr, i);
                            if JS_IsException(val) != 0 {
                                current_block = 15201273715869830213;
                                break;
                            }
                            if JS_SetPropertyUint32(ctx, ret, i, val) < 0 as libc::c_int
                            {
                                current_block = 15201273715869830213;
                                break;
                            }
                            i = i.wrapping_add(1);
                        }
                        match current_block {
                            15201273715869830213 => {}
                            _ => {
                                JS_FreeValue(ctx, arr);
                                return ret;
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, arr);
    JS_FreeValue(ctx, ret);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_constructor_ta(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut src_obj: JSValue,
    mut classid: libc::c_int,
) -> JSValue {
    let mut current_block: u64;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    let mut src_buffer: *mut JSObject = 0 as *mut JSObject;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    let mut ctor: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut buffer: JSValue = 0;
    let mut len: uint32_t = 0;
    let mut i: uint32_t = 0;
    let mut size_log2: libc::c_int = 0;
    let mut src_abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    obj = js_create_from_ctor(ctx, new_target, classid);
    if JS_IsException(obj) != 0 {
        return obj;
    }
    p = src_obj as intptr_t as *mut libc::c_void as *mut JSObject;
    if typed_array_is_detached(ctx, p) != 0 {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
        ta = (*p).u.typed_array;
        len = (*p).u.array.count;
        src_buffer = (*ta).buffer;
        src_abuf = (*src_buffer).u.array_buffer;
        if (*src_abuf).shared == 0 {
            ctor = JS_SpeciesConstructor(
                ctx,
                (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                    | src_buffer as uintptr_t as libc::c_ulonglong,
                (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            );
            if JS_IsException(ctor) != 0 {
                current_block = 16430069707838437962;
            } else {
                current_block = 8457315219000651999;
            }
        } else {
            ctor = (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            current_block = 8457315219000651999;
        }
        match current_block {
            16430069707838437962 => {}
            _ => {
                size_log2 = typed_array_size_log2[(classid
                    - JS_CLASS_UINT8C_ARRAY as libc::c_int) as usize] as libc::c_int;
                buffer = js_array_buffer_constructor1(
                    ctx,
                    ctor,
                    (len as uint64_t) << size_log2,
                );
                JS_FreeValue(ctx, ctor);
                if !(JS_IsException(buffer) != 0) {
                    if typed_array_is_detached(ctx, p) != 0 {
                        JS_FreeValue(ctx, buffer);
                        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
                    } else {
                        abuf = JS_GetOpaque(
                            buffer,
                            JS_CLASS_ARRAY_BUFFER as libc::c_int as JSClassID,
                        ) as *mut JSArrayBuffer;
                        if !(typed_array_init(
                            ctx,
                            obj,
                            buffer,
                            0 as libc::c_int as uint64_t,
                            len as uint64_t,
                        ) != 0)
                        {
                            if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                                == classid
                            {
                                memcpy(
                                    (*abuf).data as *mut libc::c_void,
                                    ((*src_abuf).data).offset((*ta).offset as isize)
                                        as *const libc::c_void,
                                    (*abuf).byte_length as libc::c_ulong,
                                );
                                current_block = 11048769245176032998;
                            } else {
                                i = 0 as libc::c_int as uint32_t;
                                loop {
                                    if !(i < len) {
                                        current_block = 11048769245176032998;
                                        break;
                                    }
                                    let mut val: JSValue = 0;
                                    val = JS_GetPropertyUint32(ctx, src_obj, i);
                                    if JS_IsException(val) != 0 {
                                        current_block = 16430069707838437962;
                                        break;
                                    }
                                    if JS_SetPropertyUint32(ctx, obj, i, val) < 0 as libc::c_int
                                    {
                                        current_block = 16430069707838437962;
                                        break;
                                    }
                                    i = i.wrapping_add(1);
                                }
                            }
                            match current_block {
                                16430069707838437962 => {}
                                _ => return obj,
                            }
                        }
                    }
                }
            }
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_typed_array_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut classid: libc::c_int,
) -> JSValue {
    let mut buffer: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut size_log2: libc::c_int = 0;
    let mut len: uint64_t = 0;
    let mut offset: uint64_t = 0;
    size_log2 = typed_array_size_log2[(classid - JS_CLASS_UINT8C_ARRAY as libc::c_int)
        as usize] as libc::c_int;
    if (*argv.offset(0 as libc::c_int as isize) >> 32 as libc::c_int) as libc::c_int
        != JS_TAG_OBJECT as libc::c_int
    {
        if JS_ToIndex(ctx, &mut len, *argv.offset(0 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        buffer = js_array_buffer_constructor1(
            ctx,
            (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong,
            len << size_log2,
        );
        if JS_IsException(buffer) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        offset = 0 as libc::c_int as uint64_t;
    } else {
        let mut p: *mut JSObject = *argv.offset(0 as libc::c_int as isize) as intptr_t
            as *mut libc::c_void as *mut JSObject;
        if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            == JS_CLASS_ARRAY_BUFFER as libc::c_int
            || (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                == JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int
        {
            abuf = (*p).u.array_buffer;
            if JS_ToIndex(ctx, &mut offset, *argv.offset(1 as libc::c_int as isize)) != 0
            {
                return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                    | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
            }
            if (*abuf).detached != 0 {
                return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
            }
            if offset
                & (((1 as libc::c_int) << size_log2) - 1 as libc::c_int)
                    as libc::c_ulonglong != 0 as libc::c_int as libc::c_ulonglong
                || offset > (*abuf).byte_length as libc::c_ulonglong
            {
                return JS_ThrowRangeError(
                    ctx,
                    b"invalid offset\0" as *const u8 as *const libc::c_char,
                );
            }
            let mut current_block_20: u64;
            if JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) != 0 {
                if (*abuf).byte_length
                    & ((1 as libc::c_int) << size_log2) - 1 as libc::c_int
                    != 0 as libc::c_int
                {
                    current_block_20 = 9505594024024250863;
                } else {
                    len = ((*abuf).byte_length as libc::c_ulonglong).wrapping_sub(offset)
                        >> size_log2;
                    current_block_20 = 4068382217303356765;
                }
            } else {
                if JS_ToIndex(ctx, &mut len, *argv.offset(2 as libc::c_int as isize))
                    != 0
                {
                    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t)
                        << 32 as libc::c_int
                        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
                }
                if (*abuf).detached != 0 {
                    return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
                }
                if offset.wrapping_add(len << size_log2)
                    > (*abuf).byte_length as libc::c_ulonglong
                {
                    current_block_20 = 9505594024024250863;
                } else {
                    current_block_20 = 4068382217303356765;
                }
            }
            match current_block_20 {
                4068382217303356765 => {}
                _ => {
                    return JS_ThrowRangeError(
                        ctx,
                        b"invalid length\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            buffer = JS_DupValue(ctx, *argv.offset(0 as libc::c_int as isize));
        } else if (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
            >= JS_CLASS_UINT8C_ARRAY as libc::c_int
            && (*p).c2rust_unnamed.c2rust_unnamed.class_id as libc::c_int
                <= JS_CLASS_FLOAT64_ARRAY as libc::c_int
        {
            return js_typed_array_constructor_ta(
                ctx,
                new_target,
                *argv.offset(0 as libc::c_int as isize),
                classid,
            )
        } else {
            return js_typed_array_constructor_obj(
                ctx,
                new_target,
                *argv.offset(0 as libc::c_int as isize),
                classid,
            )
        }
    }
    obj = js_create_from_ctor(ctx, new_target, classid);
    if JS_IsException(obj) != 0 {
        JS_FreeValue(ctx, buffer);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if typed_array_init(ctx, obj, buffer, offset, len) != 0 {
        JS_FreeValue(ctx, obj);
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    return obj;
}
unsafe extern "C" fn js_typed_array_finalizer(mut rt: *mut JSRuntime, mut val: JSValue) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut ta: *mut JSTypedArray = (*p).u.typed_array;
    if !ta.is_null() {
        if JS_IsLiveObject(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*ta).buffer as uintptr_t as libc::c_ulonglong,
        ) != 0
        {
            list_del(&mut (*ta).link);
        }
        JS_FreeValueRT(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*ta).buffer as uintptr_t as libc::c_ulonglong,
        );
        js_free_rt(rt, ta as *mut libc::c_void);
    }
}
unsafe extern "C" fn js_typed_array_mark(
    mut rt: *mut JSRuntime,
    mut val: JSValue,
    mut mark_func: Option::<JS_MarkFunc>,
) {
    let mut p: *mut JSObject = val as intptr_t as *mut libc::c_void as *mut JSObject;
    let mut ta: *mut JSTypedArray = (*p).u.typed_array;
    if !ta.is_null() {
        JS_MarkValue(
            rt,
            (JS_TAG_OBJECT as libc::c_int as uint64_t) << 32 as libc::c_int
                | (*ta).buffer as uintptr_t as libc::c_ulonglong,
            mark_func,
        );
    }
}
unsafe extern "C" fn js_dataview_constructor(
    mut ctx: *mut JSContext,
    mut new_target: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
) -> JSValue {
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut offset: uint64_t = 0;
    let mut len: uint32_t = 0;
    let mut buffer: JSValue = 0;
    let mut obj: JSValue = 0;
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    let mut p: *mut JSObject = 0 as *mut JSObject;
    buffer = *argv.offset(0 as libc::c_int as isize);
    abuf = js_get_array_buffer(ctx, buffer);
    if abuf.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    offset = 0 as libc::c_int as uint64_t;
    if argc > 1 as libc::c_int {
        if JS_ToIndex(ctx, &mut offset, *argv.offset(1 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    }
    if (*abuf).detached != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    if offset > (*abuf).byte_length as libc::c_ulonglong {
        return JS_ThrowRangeError(
            ctx,
            b"invalid byteOffset\0" as *const u8 as *const libc::c_char,
        );
    }
    len = ((*abuf).byte_length as libc::c_ulonglong).wrapping_sub(offset) as uint32_t;
    if argc > 2 as libc::c_int
        && JS_IsUndefined(*argv.offset(2 as libc::c_int as isize)) == 0
    {
        let mut l: uint64_t = 0;
        if JS_ToIndex(ctx, &mut l, *argv.offset(2 as libc::c_int as isize)) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if l > len as libc::c_ulonglong {
            return JS_ThrowRangeError(
                ctx,
                b"invalid byteLength\0" as *const u8 as *const libc::c_char,
            );
        }
        len = l as uint32_t;
    }
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_DATAVIEW as libc::c_int);
    if JS_IsException(obj) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    if (*abuf).detached != 0 {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
        ta = js_malloc(ctx, ::core::mem::size_of::<JSTypedArray>() as libc::c_ulong)
            as *mut JSTypedArray;
        if !ta.is_null() {
            p = obj as intptr_t as *mut libc::c_void as *mut JSObject;
            let ref mut fresh749 = (*ta).obj;
            *fresh749 = p;
            let ref mut fresh750 = (*ta).buffer;
            *fresh750 = JS_DupValue(ctx, buffer) as intptr_t as *mut libc::c_void
                as *mut JSObject;
            (*ta).offset = offset as uint32_t;
            (*ta).length = len;
            list_add_tail(&mut (*ta).link, &mut (*abuf).array_list);
            let ref mut fresh751 = (*p).u.typed_array;
            *fresh751 = ta;
            return obj;
        }
    }
    JS_FreeValue(ctx, obj);
    return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
unsafe extern "C" fn js_dataview_getValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut is_swap: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut ptr: *mut uint8_t = 0 as *mut uint8_t;
    let mut v: uint32_t = 0;
    let mut pos: uint64_t = 0;
    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW as libc::c_int as JSClassID)
        as *mut JSTypedArray;
    if ta.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    size = (1 as libc::c_int)
        << typed_array_size_log2[(class_id - JS_CLASS_UINT8C_ARRAY as libc::c_int)
            as usize] as libc::c_int;
    if JS_ToIndex(ctx, &mut pos, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    is_swap = FALSE as libc::c_int;
    if argc > 1 as libc::c_int {
        is_swap = JS_ToBool(ctx, *argv.offset(1 as libc::c_int as isize));
    }
    is_swap ^= 1 as libc::c_int;
    abuf = (*(*ta).buffer).u.array_buffer;
    if (*abuf).detached != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    if pos.wrapping_add(size as libc::c_ulonglong) > (*ta).length as libc::c_ulonglong {
        return JS_ThrowRangeError(
            ctx,
            b"out of bound\0" as *const u8 as *const libc::c_char,
        );
    }
    ptr = ((*abuf).data).offset((*ta).offset as isize).offset(pos as isize);
    match class_id {
        22 => return JS_NewInt32(ctx, *(ptr as *mut int8_t) as int32_t),
        23 => return JS_NewInt32(ctx, *ptr as int32_t),
        24 => {
            v = get_u16(ptr);
            if is_swap != 0 {
                v = bswap16(v as uint16_t) as uint32_t;
            }
            return JS_NewInt32(ctx, v as int16_t as int32_t);
        }
        25 => {
            v = get_u16(ptr);
            if is_swap != 0 {
                v = bswap16(v as uint16_t) as uint32_t;
            }
            return JS_NewInt32(ctx, v as int32_t);
        }
        26 => {
            v = get_u32(ptr);
            if is_swap != 0 {
                v = bswap32(v);
            }
            return JS_NewInt32(ctx, v as int32_t);
        }
        27 => {
            v = get_u32(ptr);
            if is_swap != 0 {
                v = bswap32(v);
            }
            return JS_NewUint32(ctx, v);
        }
        28 => {
            let mut u: C2RustUnnamed_29 = C2RustUnnamed_29 { f: 0. };
            v = get_u32(ptr);
            if is_swap != 0 {
                v = bswap32(v);
            }
            u.i = v;
            return __JS_NewFloat64(ctx, u.f as libc::c_double);
        }
        29 => {
            let mut u_0: C2RustUnnamed_28 = C2RustUnnamed_28 { f: 0. };
            u_0.i = get_u64(ptr);
            if is_swap != 0 {
                u_0.i = bswap64(u_0.i);
            }
            return __JS_NewFloat64(ctx, u_0.f);
        }
        _ => {
            abort();
        }
    };
}
unsafe extern "C" fn js_dataview_setValue(
    mut ctx: *mut JSContext,
    mut this_obj: JSValue,
    mut argc: libc::c_int,
    mut argv: *mut JSValue,
    mut class_id: libc::c_int,
) -> JSValue {
    let mut ta: *mut JSTypedArray = 0 as *mut JSTypedArray;
    let mut abuf: *mut JSArrayBuffer = 0 as *mut JSArrayBuffer;
    let mut is_swap: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut ptr: *mut uint8_t = 0 as *mut uint8_t;
    let mut v64: uint64_t = 0;
    let mut v: uint32_t = 0;
    let mut pos: uint64_t = 0;
    let mut val: JSValue = 0;
    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW as libc::c_int as JSClassID)
        as *mut JSTypedArray;
    if ta.is_null() {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    size = (1 as libc::c_int)
        << typed_array_size_log2[(class_id - JS_CLASS_UINT8C_ARRAY as libc::c_int)
            as usize] as libc::c_int;
    if JS_ToIndex(ctx, &mut pos, *argv.offset(0 as libc::c_int as isize)) != 0 {
        return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
            | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
    }
    val = *argv.offset(1 as libc::c_int as isize);
    v = 0 as libc::c_int as uint32_t;
    v64 = 0 as libc::c_int as uint64_t;
    if class_id <= JS_CLASS_UINT32_ARRAY as libc::c_int {
        if JS_ToUint32(ctx, &mut v, val) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
    } else {
        let mut d: libc::c_double = 0.;
        if JS_ToFloat64(ctx, &mut d, val) != 0 {
            return (JS_TAG_EXCEPTION as libc::c_int as uint64_t) << 32 as libc::c_int
                | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
        }
        if class_id == JS_CLASS_FLOAT32_ARRAY as libc::c_int {
            let mut u: C2RustUnnamed_27 = C2RustUnnamed_27 { f: 0. };
            u.f = d as libc::c_float;
            v = u.i;
        } else {
            let mut u_0: JSFloat64Union = JSFloat64Union { d: 0. };
            u_0.d = d;
            v64 = u_0.u64_0;
        }
    }
    is_swap = FALSE as libc::c_int;
    if argc > 2 as libc::c_int {
        is_swap = JS_ToBool(ctx, *argv.offset(2 as libc::c_int as isize));
    }
    is_swap ^= 1 as libc::c_int;
    abuf = (*(*ta).buffer).u.array_buffer;
    if (*abuf).detached != 0 {
        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    }
    if pos.wrapping_add(size as libc::c_ulonglong) > (*ta).length as libc::c_ulonglong {
        return JS_ThrowRangeError(
            ctx,
            b"out of bound\0" as *const u8 as *const libc::c_char,
        );
    }
    ptr = ((*abuf).data).offset((*ta).offset as isize).offset(pos as isize);
    match class_id {
        22 | 23 => {
            *ptr = v as uint8_t;
        }
        24 | 25 => {
            if is_swap != 0 {
                v = bswap16(v as uint16_t) as uint32_t;
            }
            put_u16(ptr, v as uint16_t);
        }
        26 | 27 | 28 => {
            if is_swap != 0 {
                v = bswap32(v);
            }
            put_u32(ptr, v);
        }
        29 => {
            if is_swap != 0 {
                v64 = bswap64(v64);
            }
            put_u64(ptr, v64);
        }
        _ => {
            abort();
        }
    }
    return (JS_TAG_UNDEFINED as libc::c_int as uint64_t) << 32 as libc::c_int
        | 0 as libc::c_int as uint32_t as libc::c_ulonglong;
}
static mut js_dataview_proto_funcs: [JSCFunctionListEntry; 20] = unsafe {
    [
        {
            let mut init = JSCFunctionListEntry {
                name: b"buffer\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_buffer
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteLength\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_byteLength
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"byteOffset\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 2 as libc::c_int as uint8_t,
                magic: 1 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    getset: {
                        let mut init = C2RustUnnamed_24 {
                            get: JSCFunctionType {
                                getter_magic: Some(
                                    js_typed_array_get_byteOffset
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                            set: JSCFunctionType {
                                setter_magic: None,
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getInt8\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT8_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUint8\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT8_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getInt16\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT16_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUint16\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT16_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getInt32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getUint32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getFloat32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_FLOAT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"getFloat64\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_FLOAT64_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 1 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_getValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setInt8\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT8_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUint8\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT8_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setInt16\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT16_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUint16\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT16_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setInt32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_INT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setUint32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_UINT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setFloat32\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_FLOAT32_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"setFloat64\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 0 as libc::c_int as uint8_t,
                magic: JS_CLASS_FLOAT64_ARRAY as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    func: {
                        let mut init = C2RustUnnamed_25 {
                            length: 2 as libc::c_int as uint8_t,
                            cproto: JS_CFUNC_generic_magic as libc::c_int as uint8_t,
                            cfunc: JSCFunctionType {
                                generic_magic: Some(
                                    js_dataview_setValue
                                        as unsafe extern "C" fn(
                                            *mut JSContext,
                                            JSValue,
                                            libc::c_int,
                                            *mut JSValue,
                                            libc::c_int,
                                        ) -> JSValue,
                                ),
                            },
                        };
                        init
                    },
                },
            };
            init
        },
        {
            let mut init = JSCFunctionListEntry {
                name: b"[Symbol.toStringTag]\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 3 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    str_0: b"DataView\0" as *const u8 as *const libc::c_char,
                },
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn JS_AddIntrinsicTypedArrays(mut ctx: *mut JSContext) {
    let mut typed_array_base_proto: JSValue = 0;
    let mut typed_array_base_func: JSValue = 0;
    let mut array_buffer_func: JSValue = 0;
    let mut shared_array_buffer_func: JSValue = 0;
    let mut i: libc::c_int = 0;
    *((*ctx).class_proto)
        .offset(JS_CLASS_ARRAY_BUFFER as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY_BUFFER as libc::c_int as isize),
        js_array_buffer_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    array_buffer_func = JS_NewGlobalCConstructorOnly(
        ctx,
        b"ArrayBuffer\0" as *const u8 as *const libc::c_char,
        Some(
            js_array_buffer_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY_BUFFER as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        array_buffer_func,
        js_array_buffer_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    *((*ctx).class_proto)
        .offset(
            JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as isize,
        ) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto)
            .offset(JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as isize),
        js_shared_array_buffer_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    shared_array_buffer_func = JS_NewGlobalCConstructorOnly(
        ctx,
        b"SharedArrayBuffer\0" as *const u8 as *const libc::c_char,
        Some(
            js_shared_array_buffer_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto)
            .offset(JS_CLASS_SHARED_ARRAY_BUFFER as libc::c_int as isize),
    );
    JS_SetPropertyFunctionList(
        ctx,
        shared_array_buffer_func,
        js_shared_array_buffer_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 1]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    typed_array_base_proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        typed_array_base_proto,
        js_typed_array_base_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 30]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    let mut obj: JSValue = JS_GetProperty(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_ARRAY as libc::c_int as isize),
        JS_ATOM_toString as libc::c_int as JSAtom,
    );
    JS_DefinePropertyValue(
        ctx,
        typed_array_base_proto,
        JS_ATOM_toString as libc::c_int as JSAtom,
        obj,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    typed_array_base_func = JS_NewCFunction(
        ctx,
        Some(
            js_typed_array_base_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        b"TypedArray\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    );
    JS_SetPropertyFunctionList(
        ctx,
        typed_array_base_func,
        js_typed_array_base_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 3]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);
    i = JS_CLASS_UINT8C_ARRAY as libc::c_int;
    while i
        < JS_CLASS_UINT8C_ARRAY as libc::c_int
            + (JS_CLASS_FLOAT64_ARRAY as libc::c_int
                - JS_CLASS_UINT8C_ARRAY as libc::c_int + 1 as libc::c_int)
    {
        let mut func_obj: JSValue = 0;
        let mut buf: [libc::c_char; 64] = [0; 64];
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        *((*ctx).class_proto)
            .offset(i as isize) = JS_NewObjectProto(ctx, typed_array_base_proto);
        JS_DefinePropertyValueStr(
            ctx,
            *((*ctx).class_proto).offset(i as isize),
            b"BYTES_PER_ELEMENT\0" as *const u8 as *const libc::c_char,
            JS_NewInt32(
                ctx,
                (1 as libc::c_int)
                    << typed_array_size_log2[(i - JS_CLASS_UINT8C_ARRAY as libc::c_int)
                        as usize] as libc::c_int,
            ),
            0 as libc::c_int,
        );
        name = JS_AtomGetStr(
            ctx,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
            (JS_ATOM_Uint8ClampedArray as libc::c_int + i
                - JS_CLASS_UINT8C_ARRAY as libc::c_int) as JSAtom,
        );
        func_obj = JS_NewCFunction3(
            ctx,
            ::core::mem::transmute::<
                Option::<
                    unsafe extern "C" fn(
                        *mut JSContext,
                        JSValue,
                        libc::c_int,
                        *mut JSValue,
                        libc::c_int,
                    ) -> JSValue,
                >,
                Option::<JSCFunction>,
            >(
                Some(
                    js_typed_array_constructor
                        as unsafe extern "C" fn(
                            *mut JSContext,
                            JSValue,
                            libc::c_int,
                            *mut JSValue,
                            libc::c_int,
                        ) -> JSValue,
                ),
            ),
            name,
            3 as libc::c_int,
            JS_CFUNC_constructor_magic,
            i,
            typed_array_base_func,
        );
        JS_NewGlobalCConstructor2(
            ctx,
            func_obj,
            name,
            *((*ctx).class_proto).offset(i as isize),
        );
        JS_DefinePropertyValueStr(
            ctx,
            func_obj,
            b"BYTES_PER_ELEMENT\0" as *const u8 as *const libc::c_char,
            JS_NewInt32(
                ctx,
                (1 as libc::c_int)
                    << typed_array_size_log2[(i - JS_CLASS_UINT8C_ARRAY as libc::c_int)
                        as usize] as libc::c_int,
            ),
            0 as libc::c_int,
        );
        i += 1;
    }
    JS_FreeValue(ctx, typed_array_base_proto);
    JS_FreeValue(ctx, typed_array_base_func);
    *((*ctx).class_proto)
        .offset(JS_CLASS_DATAVIEW as libc::c_int as isize) = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(
        ctx,
        *((*ctx).class_proto).offset(JS_CLASS_DATAVIEW as libc::c_int as isize),
        js_dataview_proto_funcs.as_ptr(),
        (::core::mem::size_of::<[JSCFunctionListEntry; 20]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as libc::c_int,
    );
    JS_NewGlobalCConstructorOnly(
        ctx,
        b"DataView\0" as *const u8 as *const libc::c_char,
        Some(
            js_dataview_constructor
                as unsafe extern "C" fn(
                    *mut JSContext,
                    JSValue,
                    libc::c_int,
                    *mut JSValue,
                ) -> JSValue,
        ),
        1 as libc::c_int,
        *((*ctx).class_proto).offset(JS_CLASS_DATAVIEW as libc::c_int as isize),
    );
}
unsafe extern "C" fn run_static_initializers() {
    js_math_obj = [
        {
            let mut init = JSCFunctionListEntry {
                name: b"Math\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 8 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    prop_list: {
                        let mut init = C2RustUnnamed_21 {
                            tab: js_math_funcs.as_ptr(),
                            len: (::core::mem::size_of::<[JSCFunctionListEntry; 44]>()
                                as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<JSCFunctionListEntry>()
                                        as libc::c_ulong,
                                ) as libc::c_int,
                        };
                        init
                    },
                },
            };
            init
        },
    ];
    js_json_obj = [
        {
            let mut init = JSCFunctionListEntry {
                name: b"JSON\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 8 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    prop_list: {
                        let mut init = C2RustUnnamed_21 {
                            tab: js_json_funcs.as_ptr(),
                            len: (::core::mem::size_of::<[JSCFunctionListEntry; 3]>()
                                as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<JSCFunctionListEntry>()
                                        as libc::c_ulong,
                                ) as libc::c_int,
                        };
                        init
                    },
                },
            };
            init
        },
    ];
    js_reflect_obj = [
        {
            let mut init = JSCFunctionListEntry {
                name: b"Reflect\0" as *const u8 as *const libc::c_char,
                prop_flags: ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as uint8_t,
                def_type: 8 as libc::c_int as uint8_t,
                magic: 0 as libc::c_int as int16_t,
                u: C2RustUnnamed_22 {
                    prop_list: {
                        let mut init = C2RustUnnamed_21 {
                            tab: js_reflect_funcs.as_ptr(),
                            len: (::core::mem::size_of::<[JSCFunctionListEntry; 14]>()
                                as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<JSCFunctionListEntry>()
                                        as libc::c_ulong,
                                ) as libc::c_int,
                        };
                        init
                    },
                },
            };
            init
        },
    ];
    js_map_proto_funcs_count = [
        (::core::mem::size_of::<[JSCFunctionListEntry; 12]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
        (::core::mem::size_of::<[JSCFunctionListEntry; 11]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
        (::core::mem::size_of::<[JSCFunctionListEntry; 5]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
        (::core::mem::size_of::<[JSCFunctionListEntry; 4]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
        (::core::mem::size_of::<[JSCFunctionListEntry; 2]>() as libc::c_ulong)
            .wrapping_div(
                ::core::mem::size_of::<JSCFunctionListEntry>() as libc::c_ulong,
            ) as uint8_t,
    ];
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
